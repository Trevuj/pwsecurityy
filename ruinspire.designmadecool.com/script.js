(() => {
    var e = {
            792: e => {
                "use strict";
                e.exports = function e(t, n) {
                    if (t === n) return !0;
                    if (t && n && "object" == typeof t && "object" == typeof n) {
                        if (t.constructor !== n.constructor) return !1;
                        var i, r, o;
                        if (Array.isArray(t)) {
                            if ((i = t.length) != n.length) return !1;
                            for (r = i; 0 != r--;)
                                if (!e(t[r], n[r])) return !1;
                            return !0
                        }
                        if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
                        if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
                        if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
                        if ((i = (o = Object.keys(t)).length) !== Object.keys(n).length) return !1;
                        for (r = i; 0 != r--;)
                            if (!Object.prototype.hasOwnProperty.call(n, o[r])) return !1;
                        for (r = i; 0 != r--;) {
                            var s = o[r];
                            if (!e(t[s], n[s])) return !1
                        }
                        return !0
                    }
                    return t != t && n != n
                }
            },
            683: (e, t, n) => {
                var i;
                ! function() {
                    "use strict";
                    var r = function() {
                        this.init()
                    };
                    r.prototype = {
                        init: function() {
                            var e = this || o;
                            return e._counter = 1e3, e._html5AudioPool = [], e.html5PoolSize = 10, e._codecs = {}, e._howls = [], e._muted = !1, e._volume = 1, e._canPlayEvent = "canplaythrough", e._navigator = "undefined" != typeof window && window.navigator ? window.navigator : null, e.masterGain = null, e.noAudio = !1, e.usingWebAudio = !0, e.autoSuspend = !0, e.ctx = null, e.autoUnlock = !0, e._setup(), e
                        },
                        volume: function(e) {
                            var t = this || o;
                            if (e = parseFloat(e), t.ctx || d(), void 0 !== e && e >= 0 && e <= 1) {
                                if (t._volume = e, t._muted) return t;
                                t.usingWebAudio && t.masterGain.gain.setValueAtTime(e, o.ctx.currentTime);
                                for (var n = 0; n < t._howls.length; n++)
                                    if (!t._howls[n]._webAudio)
                                        for (var i = t._howls[n]._getSoundIds(), r = 0; r < i.length; r++) {
                                            var s = t._howls[n]._soundById(i[r]);
                                            s && s._node && (s._node.volume = s._volume * e)
                                        }
                                return t
                            }
                            return t._volume
                        },
                        mute: function(e) {
                            var t = this || o;
                            t.ctx || d(), t._muted = e, t.usingWebAudio && t.masterGain.gain.setValueAtTime(e ? 0 : t._volume, o.ctx.currentTime);
                            for (var n = 0; n < t._howls.length; n++)
                                if (!t._howls[n]._webAudio)
                                    for (var i = t._howls[n]._getSoundIds(), r = 0; r < i.length; r++) {
                                        var s = t._howls[n]._soundById(i[r]);
                                        s && s._node && (s._node.muted = !!e || s._muted)
                                    }
                            return t
                        },
                        stop: function() {
                            for (var e = this || o, t = 0; t < e._howls.length; t++) e._howls[t].stop();
                            return e
                        },
                        unload: function() {
                            for (var e = this || o, t = e._howls.length - 1; t >= 0; t--) e._howls[t].unload();
                            return e.usingWebAudio && e.ctx && void 0 !== e.ctx.close && (e.ctx.close(), e.ctx = null, d()), e
                        },
                        codecs: function(e) {
                            return (this || o)._codecs[e.replace(/^x-/, "")]
                        },
                        _setup: function() {
                            var e = this || o;
                            if (e.state = e.ctx && e.ctx.state || "suspended", e._autoSuspend(), !e.usingWebAudio)
                                if ("undefined" != typeof Audio) try {
                                    void 0 === (new Audio).oncanplaythrough && (e._canPlayEvent = "canplay")
                                } catch (t) {
                                    e.noAudio = !0
                                } else e.noAudio = !0;
                            try {
                                (new Audio).muted && (e.noAudio = !0)
                            } catch (e) {}
                            return e.noAudio || e._setupCodecs(), e
                        },
                        _setupCodecs: function() {
                            var e = this || o,
                                t = null;
                            try {
                                t = "undefined" != typeof Audio ? new Audio : null
                            } catch (t) {
                                return e
                            }
                            if (!t || "function" != typeof t.canPlayType) return e;
                            var n = t.canPlayType("audio/mpeg;").replace(/^no$/, ""),
                                i = e._navigator ? e._navigator.userAgent : "",
                                r = i.match(/OPR\/(\d+)/g),
                                s = r && parseInt(r[0].split("/")[1], 10) < 33,
                                a = -1 !== i.indexOf("Safari") && -1 === i.indexOf("Chrome"),
                                l = i.match(/Version\/(.*?) /),
                                c = a && l && parseInt(l[1], 10) < 15;
                            return e._codecs = {
                                mp3: !(s || !n && !t.canPlayType("audio/mp3;").replace(/^no$/, "")),
                                mpeg: !!n,
                                opus: !!t.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
                                ogg: !!t.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
                                oga: !!t.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
                                wav: !!(t.canPlayType('audio/wav; codecs="1"') || t.canPlayType("audio/wav")).replace(/^no$/, ""),
                                aac: !!t.canPlayType("audio/aac;").replace(/^no$/, ""),
                                caf: !!t.canPlayType("audio/x-caf;").replace(/^no$/, ""),
                                m4a: !!(t.canPlayType("audio/x-m4a;") || t.canPlayType("audio/m4a;") || t.canPlayType("audio/aac;")).replace(/^no$/, ""),
                                m4b: !!(t.canPlayType("audio/x-m4b;") || t.canPlayType("audio/m4b;") || t.canPlayType("audio/aac;")).replace(/^no$/, ""),
                                mp4: !!(t.canPlayType("audio/x-mp4;") || t.canPlayType("audio/mp4;") || t.canPlayType("audio/aac;")).replace(/^no$/, ""),
                                weba: !(c || !t.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
                                webm: !(c || !t.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
                                dolby: !!t.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""),
                                flac: !!(t.canPlayType("audio/x-flac;") || t.canPlayType("audio/flac;")).replace(/^no$/, "")
                            }, e
                        },
                        _unlockAudio: function() {
                            var e = this || o;
                            if (!e._audioUnlocked && e.ctx) {
                                e._audioUnlocked = !1, e.autoUnlock = !1, e._mobileUnloaded || 44100 === e.ctx.sampleRate || (e._mobileUnloaded = !0, e.unload()), e._scratchBuffer = e.ctx.createBuffer(1, 1, 22050);
                                var t = function(n) {
                                    for (; e._html5AudioPool.length < e.html5PoolSize;) try {
                                        var i = new Audio;
                                        i._unlocked = !0, e._releaseHtml5Audio(i)
                                    } catch (n) {
                                        e.noAudio = !0;
                                        break
                                    }
                                    for (var r = 0; r < e._howls.length; r++)
                                        if (!e._howls[r]._webAudio)
                                            for (var o = e._howls[r]._getSoundIds(), s = 0; s < o.length; s++) {
                                                var a = e._howls[r]._soundById(o[s]);
                                                a && a._node && !a._node._unlocked && (a._node._unlocked = !0, a._node.load())
                                            }
                                    e._autoResume();
                                    var l = e.ctx.createBufferSource();
                                    l.buffer = e._scratchBuffer, l.connect(e.ctx.destination), void 0 === l.start ? l.noteOn(0) : l.start(0), "function" == typeof e.ctx.resume && e.ctx.resume(), l.onended = function() {
                                        l.disconnect(0), e._audioUnlocked = !0, document.removeEventListener("touchstart", t, !0), document.removeEventListener("touchend", t, !0), document.removeEventListener("click", t, !0), document.removeEventListener("keydown", t, !0);
                                        for (var n = 0; n < e._howls.length; n++) e._howls[n]._emit("unlock")
                                    }
                                };
                                return document.addEventListener("touchstart", t, !0), document.addEventListener("touchend", t, !0), document.addEventListener("click", t, !0), document.addEventListener("keydown", t, !0), e
                            }
                        },
                        _obtainHtml5Audio: function() {
                            var e = this || o;
                            if (e._html5AudioPool.length) return e._html5AudioPool.pop();
                            var t = (new Audio).play();
                            return t && "undefined" != typeof Promise && (t instanceof Promise || "function" == typeof t.then) && t.catch((function() {
                                console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.")
                            })), new Audio
                        },
                        _releaseHtml5Audio: function(e) {
                            var t = this || o;
                            return e._unlocked && t._html5AudioPool.push(e), t
                        },
                        _autoSuspend: function() {
                            var e = this;
                            if (e.autoSuspend && e.ctx && void 0 !== e.ctx.suspend && o.usingWebAudio) {
                                for (var t = 0; t < e._howls.length; t++)
                                    if (e._howls[t]._webAudio)
                                        for (var n = 0; n < e._howls[t]._sounds.length; n++)
                                            if (!e._howls[t]._sounds[n]._paused) return e;
                                return e._suspendTimer && clearTimeout(e._suspendTimer), e._suspendTimer = setTimeout((function() {
                                    if (e.autoSuspend) {
                                        e._suspendTimer = null, e.state = "suspending";
                                        var t = function() {
                                            e.state = "suspended", e._resumeAfterSuspend && (delete e._resumeAfterSuspend, e._autoResume())
                                        };
                                        e.ctx.suspend().then(t, t)
                                    }
                                }), 3e4), e
                            }
                        },
                        _autoResume: function() {
                            var e = this;
                            if (e.ctx && void 0 !== e.ctx.resume && o.usingWebAudio) return "running" === e.state && "interrupted" !== e.ctx.state && e._suspendTimer ? (clearTimeout(e._suspendTimer), e._suspendTimer = null) : "suspended" === e.state || "running" === e.state && "interrupted" === e.ctx.state ? (e.ctx.resume().then((function() {
                                e.state = "running";
                                for (var t = 0; t < e._howls.length; t++) e._howls[t]._emit("resume")
                            })), e._suspendTimer && (clearTimeout(e._suspendTimer), e._suspendTimer = null)) : "suspending" === e.state && (e._resumeAfterSuspend = !0), e
                        }
                    };
                    var o = new r,
                        s = function(e) {
                            e.src && 0 !== e.src.length ? this.init(e) : console.error("An array of source files must be passed with any new Howl.")
                        };
                    s.prototype = {
                        init: function(e) {
                            var t = this;
                            return o.ctx || d(), t._autoplay = e.autoplay || !1, t._format = "string" != typeof e.format ? e.format : [e.format], t._html5 = e.html5 || !1, t._muted = e.mute || !1, t._loop = e.loop || !1, t._pool = e.pool || 5, t._preload = "boolean" != typeof e.preload && "metadata" !== e.preload || e.preload, t._rate = e.rate || 1, t._sprite = e.sprite || {}, t._src = "string" != typeof e.src ? e.src : [e.src], t._volume = void 0 !== e.volume ? e.volume : 1, t._xhr = {
                                method: e.xhr && e.xhr.method ? e.xhr.method : "GET",
                                headers: e.xhr && e.xhr.headers ? e.xhr.headers : null,
                                withCredentials: !(!e.xhr || !e.xhr.withCredentials) && e.xhr.withCredentials
                            }, t._duration = 0, t._state = "unloaded", t._sounds = [], t._endTimers = {}, t._queue = [], t._playLock = !1, t._onend = e.onend ? [{
                                fn: e.onend
                            }] : [], t._onfade = e.onfade ? [{
                                fn: e.onfade
                            }] : [], t._onload = e.onload ? [{
                                fn: e.onload
                            }] : [], t._onloaderror = e.onloaderror ? [{
                                fn: e.onloaderror
                            }] : [], t._onplayerror = e.onplayerror ? [{
                                fn: e.onplayerror
                            }] : [], t._onpause = e.onpause ? [{
                                fn: e.onpause
                            }] : [], t._onplay = e.onplay ? [{
                                fn: e.onplay
                            }] : [], t._onstop = e.onstop ? [{
                                fn: e.onstop
                            }] : [], t._onmute = e.onmute ? [{
                                fn: e.onmute
                            }] : [], t._onvolume = e.onvolume ? [{
                                fn: e.onvolume
                            }] : [], t._onrate = e.onrate ? [{
                                fn: e.onrate
                            }] : [], t._onseek = e.onseek ? [{
                                fn: e.onseek
                            }] : [], t._onunlock = e.onunlock ? [{
                                fn: e.onunlock
                            }] : [], t._onresume = [], t._webAudio = o.usingWebAudio && !t._html5, void 0 !== o.ctx && o.ctx && o.autoUnlock && o._unlockAudio(), o._howls.push(t), t._autoplay && t._queue.push({
                                event: "play",
                                action: function() {
                                    t.play()
                                }
                            }), t._preload && "none" !== t._preload && t.load(), t
                        },
                        load: function() {
                            var e = this,
                                t = null;
                            if (o.noAudio) e._emit("loaderror", null, "No audio support.");
                            else {
                                "string" == typeof e._src && (e._src = [e._src]);
                                for (var n = 0; n < e._src.length; n++) {
                                    var i, r;
                                    if (e._format && e._format[n]) i = e._format[n];
                                    else {
                                        if ("string" != typeof(r = e._src[n])) {
                                            e._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
                                            continue
                                        }(i = /^data:audio\/([^;,]+);/i.exec(r)) || (i = /\.([^.]+)$/.exec(r.split("?", 1)[0])), i && (i = i[1].toLowerCase())
                                    }
                                    if (i || console.warn('No file extension was found. Consider using the "format" property or specify an extension.'), i && o.codecs(i)) {
                                        t = e._src[n];
                                        break
                                    }
                                }
                                if (t) return e._src = t, e._state = "loading", "https:" === window.location.protocol && "http:" === t.slice(0, 5) && (e._html5 = !0, e._webAudio = !1), new a(e), e._webAudio && c(e), e;
                                e._emit("loaderror", null, "No codec support for selected audio sources.")
                            }
                        },
                        play: function(e, t) {
                            var n = this,
                                i = null;
                            if ("number" == typeof e) i = e, e = null;
                            else {
                                if ("string" == typeof e && "loaded" === n._state && !n._sprite[e]) return null;
                                if (void 0 === e && (e = "__default", !n._playLock)) {
                                    for (var r = 0, s = 0; s < n._sounds.length; s++) n._sounds[s]._paused && !n._sounds[s]._ended && (r++, i = n._sounds[s]._id);
                                    1 === r ? e = null : i = null
                                }
                            }
                            var a = i ? n._soundById(i) : n._inactiveSound();
                            if (!a) return null;
                            if (i && !e && (e = a._sprite || "__default"), "loaded" !== n._state) {
                                a._sprite = e, a._ended = !1;
                                var l = a._id;
                                return n._queue.push({
                                    event: "play",
                                    action: function() {
                                        n.play(l)
                                    }
                                }), l
                            }
                            if (i && !a._paused) return t || n._loadQueue("play"), a._id;
                            n._webAudio && o._autoResume();
                            var c = Math.max(0, a._seek > 0 ? a._seek : n._sprite[e][0] / 1e3),
                                A = Math.max(0, (n._sprite[e][0] + n._sprite[e][1]) / 1e3 - c),
                                h = 1e3 * A / Math.abs(a._rate),
                                u = n._sprite[e][0] / 1e3,
                                d = (n._sprite[e][0] + n._sprite[e][1]) / 1e3;
                            a._sprite = e, a._ended = !1;
                            var p = function() {
                                a._paused = !1, a._seek = c, a._start = u, a._stop = d, a._loop = !(!a._loop && !n._sprite[e][2])
                            };
                            if (!(c >= d)) {
                                var g = a._node;
                                if (n._webAudio) {
                                    var f = function() {
                                        n._playLock = !1, p(), n._refreshBuffer(a);
                                        var e = a._muted || n._muted ? 0 : a._volume;
                                        g.gain.setValueAtTime(e, o.ctx.currentTime), a._playStart = o.ctx.currentTime, void 0 === g.bufferSource.start ? a._loop ? g.bufferSource.noteGrainOn(0, c, 86400) : g.bufferSource.noteGrainOn(0, c, A) : a._loop ? g.bufferSource.start(0, c, 86400) : g.bufferSource.start(0, c, A), h !== 1 / 0 && (n._endTimers[a._id] = setTimeout(n._ended.bind(n, a), h)), t || setTimeout((function() {
                                            n._emit("play", a._id), n._loadQueue()
                                        }), 0)
                                    };
                                    "running" === o.state && "interrupted" !== o.ctx.state ? f() : (n._playLock = !0, n.once("resume", f), n._clearTimer(a._id))
                                } else {
                                    var m = function() {
                                        g.currentTime = c, g.muted = a._muted || n._muted || o._muted || g.muted, g.volume = a._volume * o.volume(), g.playbackRate = a._rate;
                                        try {
                                            var i = g.play();
                                            if (i && "undefined" != typeof Promise && (i instanceof Promise || "function" == typeof i.then) ? (n._playLock = !0, p(), i.then((function() {
                                                    n._playLock = !1, g._unlocked = !0, t ? n._loadQueue() : n._emit("play", a._id)
                                                })).catch((function() {
                                                    n._playLock = !1, n._emit("playerror", a._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."), a._ended = !0, a._paused = !0
                                                }))) : t || (n._playLock = !1, p(), n._emit("play", a._id)), g.playbackRate = a._rate, g.paused) return void n._emit("playerror", a._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                                            "__default" !== e || a._loop ? n._endTimers[a._id] = setTimeout(n._ended.bind(n, a), h) : (n._endTimers[a._id] = function() {
                                                n._ended(a), g.removeEventListener("ended", n._endTimers[a._id], !1)
                                            }, g.addEventListener("ended", n._endTimers[a._id], !1))
                                        } catch (e) {
                                            n._emit("playerror", a._id, e)
                                        }
                                    };
                                    "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" === g.src && (g.src = n._src, g.load());
                                    var E = window && window.ejecta || !g.readyState && o._navigator.isCocoonJS;
                                    if (g.readyState >= 3 || E) m();
                                    else {
                                        n._playLock = !0, n._state = "loading";
                                        var C = function() {
                                            n._state = "loaded", m(), g.removeEventListener(o._canPlayEvent, C, !1)
                                        };
                                        g.addEventListener(o._canPlayEvent, C, !1), n._clearTimer(a._id)
                                    }
                                }
                                return a._id
                            }
                            n._ended(a)
                        },
                        pause: function(e) {
                            var t = this;
                            if ("loaded" !== t._state || t._playLock) return t._queue.push({
                                event: "pause",
                                action: function() {
                                    t.pause(e)
                                }
                            }), t;
                            for (var n = t._getSoundIds(e), i = 0; i < n.length; i++) {
                                t._clearTimer(n[i]);
                                var r = t._soundById(n[i]);
                                if (r && !r._paused && (r._seek = t.seek(n[i]), r._rateSeek = 0, r._paused = !0, t._stopFade(n[i]), r._node))
                                    if (t._webAudio) {
                                        if (!r._node.bufferSource) continue;
                                        void 0 === r._node.bufferSource.stop ? r._node.bufferSource.noteOff(0) : r._node.bufferSource.stop(0), t._cleanBuffer(r._node)
                                    } else isNaN(r._node.duration) && r._node.duration !== 1 / 0 || r._node.pause();
                                arguments[1] || t._emit("pause", r ? r._id : null)
                            }
                            return t
                        },
                        stop: function(e, t) {
                            var n = this;
                            if ("loaded" !== n._state || n._playLock) return n._queue.push({
                                event: "stop",
                                action: function() {
                                    n.stop(e)
                                }
                            }), n;
                            for (var i = n._getSoundIds(e), r = 0; r < i.length; r++) {
                                n._clearTimer(i[r]);
                                var o = n._soundById(i[r]);
                                o && (o._seek = o._start || 0, o._rateSeek = 0, o._paused = !0, o._ended = !0, n._stopFade(i[r]), o._node && (n._webAudio ? o._node.bufferSource && (void 0 === o._node.bufferSource.stop ? o._node.bufferSource.noteOff(0) : o._node.bufferSource.stop(0), n._cleanBuffer(o._node)) : isNaN(o._node.duration) && o._node.duration !== 1 / 0 || (o._node.currentTime = o._start || 0, o._node.pause(), o._node.duration === 1 / 0 && n._clearSound(o._node))), t || n._emit("stop", o._id))
                            }
                            return n
                        },
                        mute: function(e, t) {
                            var n = this;
                            if ("loaded" !== n._state || n._playLock) return n._queue.push({
                                event: "mute",
                                action: function() {
                                    n.mute(e, t)
                                }
                            }), n;
                            if (void 0 === t) {
                                if ("boolean" != typeof e) return n._muted;
                                n._muted = e
                            }
                            for (var i = n._getSoundIds(t), r = 0; r < i.length; r++) {
                                var s = n._soundById(i[r]);
                                s && (s._muted = e, s._interval && n._stopFade(s._id), n._webAudio && s._node ? s._node.gain.setValueAtTime(e ? 0 : s._volume, o.ctx.currentTime) : s._node && (s._node.muted = !!o._muted || e), n._emit("mute", s._id))
                            }
                            return n
                        },
                        volume: function() {
                            var e, t, n, i = this,
                                r = arguments;
                            if (0 === r.length) return i._volume;
                            if (1 === r.length || 2 === r.length && void 0 === r[1] ? i._getSoundIds().indexOf(r[0]) >= 0 ? t = parseInt(r[0], 10) : e = parseFloat(r[0]) : r.length >= 2 && (e = parseFloat(r[0]), t = parseInt(r[1], 10)), !(void 0 !== e && e >= 0 && e <= 1)) return (n = t ? i._soundById(t) : i._sounds[0]) ? n._volume : 0;
                            if ("loaded" !== i._state || i._playLock) return i._queue.push({
                                event: "volume",
                                action: function() {
                                    i.volume.apply(i, r)
                                }
                            }), i;
                            void 0 === t && (i._volume = e), t = i._getSoundIds(t);
                            for (var s = 0; s < t.length; s++)(n = i._soundById(t[s])) && (n._volume = e, r[2] || i._stopFade(t[s]), i._webAudio && n._node && !n._muted ? n._node.gain.setValueAtTime(e, o.ctx.currentTime) : n._node && !n._muted && (n._node.volume = e * o.volume()), i._emit("volume", n._id));
                            return i
                        },
                        fade: function(e, t, n, i) {
                            var r = this;
                            if ("loaded" !== r._state || r._playLock) return r._queue.push({
                                event: "fade",
                                action: function() {
                                    r.fade(e, t, n, i)
                                }
                            }), r;
                            e = Math.min(Math.max(0, parseFloat(e)), 1), t = Math.min(Math.max(0, parseFloat(t)), 1), n = parseFloat(n), r.volume(e, i);
                            for (var s = r._getSoundIds(i), a = 0; a < s.length; a++) {
                                var l = r._soundById(s[a]);
                                if (l) {
                                    if (i || r._stopFade(s[a]), r._webAudio && !l._muted) {
                                        var c = o.ctx.currentTime,
                                            A = c + n / 1e3;
                                        l._volume = e, l._node.gain.setValueAtTime(e, c), l._node.gain.linearRampToValueAtTime(t, A)
                                    }
                                    r._startFadeInterval(l, e, t, n, s[a], void 0 === i)
                                }
                            }
                            return r
                        },
                        _startFadeInterval: function(e, t, n, i, r, o) {
                            var s = this,
                                a = t,
                                l = n - t,
                                c = Math.abs(l / .01),
                                A = Math.max(4, c > 0 ? i / c : i),
                                h = Date.now();
                            e._fadeTo = n, e._interval = setInterval((function() {
                                var r = (Date.now() - h) / i;
                                h = Date.now(), a += l * r, a = Math.round(100 * a) / 100, a = l < 0 ? Math.max(n, a) : Math.min(n, a), s._webAudio ? e._volume = a : s.volume(a, e._id, !0), o && (s._volume = a), (n < t && a <= n || n > t && a >= n) && (clearInterval(e._interval), e._interval = null, e._fadeTo = null, s.volume(n, e._id), s._emit("fade", e._id))
                            }), A)
                        },
                        _stopFade: function(e) {
                            var t = this,
                                n = t._soundById(e);
                            return n && n._interval && (t._webAudio && n._node.gain.cancelScheduledValues(o.ctx.currentTime), clearInterval(n._interval), n._interval = null, t.volume(n._fadeTo, e), n._fadeTo = null, t._emit("fade", e)), t
                        },
                        loop: function() {
                            var e, t, n, i = this,
                                r = arguments;
                            if (0 === r.length) return i._loop;
                            if (1 === r.length) {
                                if ("boolean" != typeof r[0]) return !!(n = i._soundById(parseInt(r[0], 10))) && n._loop;
                                e = r[0], i._loop = e
                            } else 2 === r.length && (e = r[0], t = parseInt(r[1], 10));
                            for (var o = i._getSoundIds(t), s = 0; s < o.length; s++)(n = i._soundById(o[s])) && (n._loop = e, i._webAudio && n._node && n._node.bufferSource && (n._node.bufferSource.loop = e, e && (n._node.bufferSource.loopStart = n._start || 0, n._node.bufferSource.loopEnd = n._stop, i.playing(o[s]) && (i.pause(o[s], !0), i.play(o[s], !0)))));
                            return i
                        },
                        rate: function() {
                            var e, t, n, i = this,
                                r = arguments;
                            if (0 === r.length) t = i._sounds[0]._id;
                            else if (1 === r.length) {
                                i._getSoundIds().indexOf(r[0]) >= 0 ? t = parseInt(r[0], 10) : e = parseFloat(r[0])
                            } else 2 === r.length && (e = parseFloat(r[0]), t = parseInt(r[1], 10));
                            if ("number" != typeof e) return (n = i._soundById(t)) ? n._rate : i._rate;
                            if ("loaded" !== i._state || i._playLock) return i._queue.push({
                                event: "rate",
                                action: function() {
                                    i.rate.apply(i, r)
                                }
                            }), i;
                            void 0 === t && (i._rate = e), t = i._getSoundIds(t);
                            for (var s = 0; s < t.length; s++)
                                if (n = i._soundById(t[s])) {
                                    i.playing(t[s]) && (n._rateSeek = i.seek(t[s]), n._playStart = i._webAudio ? o.ctx.currentTime : n._playStart), n._rate = e, i._webAudio && n._node && n._node.bufferSource ? n._node.bufferSource.playbackRate.setValueAtTime(e, o.ctx.currentTime) : n._node && (n._node.playbackRate = e);
                                    var a = i.seek(t[s]),
                                        l = 1e3 * ((i._sprite[n._sprite][0] + i._sprite[n._sprite][1]) / 1e3 - a) / Math.abs(n._rate);
                                    !i._endTimers[t[s]] && n._paused || (i._clearTimer(t[s]), i._endTimers[t[s]] = setTimeout(i._ended.bind(i, n), l)), i._emit("rate", n._id)
                                }
                            return i
                        },
                        seek: function() {
                            var e, t, n = this,
                                i = arguments;
                            if (0 === i.length) n._sounds.length && (t = n._sounds[0]._id);
                            else if (1 === i.length) {
                                n._getSoundIds().indexOf(i[0]) >= 0 ? t = parseInt(i[0], 10) : n._sounds.length && (t = n._sounds[0]._id, e = parseFloat(i[0]))
                            } else 2 === i.length && (e = parseFloat(i[0]), t = parseInt(i[1], 10));
                            if (void 0 === t) return 0;
                            if ("number" == typeof e && ("loaded" !== n._state || n._playLock)) return n._queue.push({
                                event: "seek",
                                action: function() {
                                    n.seek.apply(n, i)
                                }
                            }), n;
                            var r = n._soundById(t);
                            if (r) {
                                if (!("number" == typeof e && e >= 0)) {
                                    if (n._webAudio) {
                                        var s = n.playing(t) ? o.ctx.currentTime - r._playStart : 0,
                                            a = r._rateSeek ? r._rateSeek - r._seek : 0;
                                        return r._seek + (a + s * Math.abs(r._rate))
                                    }
                                    return r._node.currentTime
                                }
                                var l = n.playing(t);
                                l && n.pause(t, !0), r._seek = e, r._ended = !1, n._clearTimer(t), n._webAudio || !r._node || isNaN(r._node.duration) || (r._node.currentTime = e);
                                var c = function() {
                                    l && n.play(t, !0), n._emit("seek", t)
                                };
                                if (l && !n._webAudio) {
                                    var A = function() {
                                        n._playLock ? setTimeout(A, 0) : c()
                                    };
                                    setTimeout(A, 0)
                                } else c()
                            }
                            return n
                        },
                        playing: function(e) {
                            var t = this;
                            if ("number" == typeof e) {
                                var n = t._soundById(e);
                                return !!n && !n._paused
                            }
                            for (var i = 0; i < t._sounds.length; i++)
                                if (!t._sounds[i]._paused) return !0;
                            return !1
                        },
                        duration: function(e) {
                            var t = this,
                                n = t._duration,
                                i = t._soundById(e);
                            return i && (n = t._sprite[i._sprite][1] / 1e3), n
                        },
                        state: function() {
                            return this._state
                        },
                        unload: function() {
                            for (var e = this, t = e._sounds, n = 0; n < t.length; n++) t[n]._paused || e.stop(t[n]._id), e._webAudio || (e._clearSound(t[n]._node), t[n]._node.removeEventListener("error", t[n]._errorFn, !1), t[n]._node.removeEventListener(o._canPlayEvent, t[n]._loadFn, !1), t[n]._node.removeEventListener("ended", t[n]._endFn, !1), o._releaseHtml5Audio(t[n]._node)), delete t[n]._node, e._clearTimer(t[n]._id);
                            var i = o._howls.indexOf(e);
                            i >= 0 && o._howls.splice(i, 1);
                            var r = !0;
                            for (n = 0; n < o._howls.length; n++)
                                if (o._howls[n]._src === e._src || e._src.indexOf(o._howls[n]._src) >= 0) {
                                    r = !1;
                                    break
                                }
                            return l && r && delete l[e._src], o.noAudio = !1, e._state = "unloaded", e._sounds = [], e = null, null
                        },
                        on: function(e, t, n, i) {
                            var r = this["_on" + e];
                            return "function" == typeof t && r.push(i ? {
                                id: n,
                                fn: t,
                                once: i
                            } : {
                                id: n,
                                fn: t
                            }), this
                        },
                        off: function(e, t, n) {
                            var i = this,
                                r = i["_on" + e],
                                o = 0;
                            if ("number" == typeof t && (n = t, t = null), t || n)
                                for (o = 0; o < r.length; o++) {
                                    var s = n === r[o].id;
                                    if (t === r[o].fn && s || !t && s) {
                                        r.splice(o, 1);
                                        break
                                    }
                                } else if (e) i["_on" + e] = [];
                                else {
                                    var a = Object.keys(i);
                                    for (o = 0; o < a.length; o++) 0 === a[o].indexOf("_on") && Array.isArray(i[a[o]]) && (i[a[o]] = [])
                                }
                            return i
                        },
                        once: function(e, t, n) {
                            return this.on(e, t, n, 1), this
                        },
                        _emit: function(e, t, n) {
                            for (var i = this, r = i["_on" + e], o = r.length - 1; o >= 0; o--) r[o].id && r[o].id !== t && "load" !== e || (setTimeout(function(e) {
                                e.call(this, t, n)
                            }.bind(i, r[o].fn), 0), r[o].once && i.off(e, r[o].fn, r[o].id));
                            return i._loadQueue(e), i
                        },
                        _loadQueue: function(e) {
                            var t = this;
                            if (t._queue.length > 0) {
                                var n = t._queue[0];
                                n.event === e && (t._queue.shift(), t._loadQueue()), e || n.action()
                            }
                            return t
                        },
                        _ended: function(e) {
                            var t = this,
                                n = e._sprite;
                            if (!t._webAudio && e._node && !e._node.paused && !e._node.ended && e._node.currentTime < e._stop) return setTimeout(t._ended.bind(t, e), 100), t;
                            var i = !(!e._loop && !t._sprite[n][2]);
                            if (t._emit("end", e._id), !t._webAudio && i && t.stop(e._id, !0).play(e._id), t._webAudio && i) {
                                t._emit("play", e._id), e._seek = e._start || 0, e._rateSeek = 0, e._playStart = o.ctx.currentTime;
                                var r = 1e3 * (e._stop - e._start) / Math.abs(e._rate);
                                t._endTimers[e._id] = setTimeout(t._ended.bind(t, e), r)
                            }
                            return t._webAudio && !i && (e._paused = !0, e._ended = !0, e._seek = e._start || 0, e._rateSeek = 0, t._clearTimer(e._id), t._cleanBuffer(e._node), o._autoSuspend()), t._webAudio || i || t.stop(e._id, !0), t
                        },
                        _clearTimer: function(e) {
                            var t = this;
                            if (t._endTimers[e]) {
                                if ("function" != typeof t._endTimers[e]) clearTimeout(t._endTimers[e]);
                                else {
                                    var n = t._soundById(e);
                                    n && n._node && n._node.removeEventListener("ended", t._endTimers[e], !1)
                                }
                                delete t._endTimers[e]
                            }
                            return t
                        },
                        _soundById: function(e) {
                            for (var t = this, n = 0; n < t._sounds.length; n++)
                                if (e === t._sounds[n]._id) return t._sounds[n];
                            return null
                        },
                        _inactiveSound: function() {
                            var e = this;
                            e._drain();
                            for (var t = 0; t < e._sounds.length; t++)
                                if (e._sounds[t]._ended) return e._sounds[t].reset();
                            return new a(e)
                        },
                        _drain: function() {
                            var e = this,
                                t = e._pool,
                                n = 0,
                                i = 0;
                            if (!(e._sounds.length < t)) {
                                for (i = 0; i < e._sounds.length; i++) e._sounds[i]._ended && n++;
                                for (i = e._sounds.length - 1; i >= 0; i--) {
                                    if (n <= t) return;
                                    e._sounds[i]._ended && (e._webAudio && e._sounds[i]._node && e._sounds[i]._node.disconnect(0), e._sounds.splice(i, 1), n--)
                                }
                            }
                        },
                        _getSoundIds: function(e) {
                            if (void 0 === e) {
                                for (var t = [], n = 0; n < this._sounds.length; n++) t.push(this._sounds[n]._id);
                                return t
                            }
                            return [e]
                        },
                        _refreshBuffer: function(e) {
                            return e._node.bufferSource = o.ctx.createBufferSource(), e._node.bufferSource.buffer = l[this._src], e._panner ? e._node.bufferSource.connect(e._panner) : e._node.bufferSource.connect(e._node), e._node.bufferSource.loop = e._loop, e._loop && (e._node.bufferSource.loopStart = e._start || 0, e._node.bufferSource.loopEnd = e._stop || 0), e._node.bufferSource.playbackRate.setValueAtTime(e._rate, o.ctx.currentTime), this
                        },
                        _cleanBuffer: function(e) {
                            var t = o._navigator && o._navigator.vendor.indexOf("Apple") >= 0;
                            if (!e.bufferSource) return this;
                            if (o._scratchBuffer && e.bufferSource && (e.bufferSource.onended = null, e.bufferSource.disconnect(0), t)) try {
                                e.bufferSource.buffer = o._scratchBuffer
                            } catch (e) {}
                            return e.bufferSource = null, this
                        },
                        _clearSound: function(e) {
                            /MSIE |Trident\//.test(o._navigator && o._navigator.userAgent) || (e.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA")
                        }
                    };
                    var a = function(e) {
                        this._parent = e, this.init()
                    };
                    a.prototype = {
                        init: function() {
                            var e = this,
                                t = e._parent;
                            return e._muted = t._muted, e._loop = t._loop, e._volume = t._volume, e._rate = t._rate, e._seek = 0, e._paused = !0, e._ended = !0, e._sprite = "__default", e._id = ++o._counter, t._sounds.push(e), e.create(), e
                        },
                        create: function() {
                            var e = this,
                                t = e._parent,
                                n = o._muted || e._muted || e._parent._muted ? 0 : e._volume;
                            return t._webAudio ? (e._node = void 0 === o.ctx.createGain ? o.ctx.createGainNode() : o.ctx.createGain(), e._node.gain.setValueAtTime(n, o.ctx.currentTime), e._node.paused = !0, e._node.connect(o.masterGain)) : o.noAudio || (e._node = o._obtainHtml5Audio(), e._errorFn = e._errorListener.bind(e), e._node.addEventListener("error", e._errorFn, !1), e._loadFn = e._loadListener.bind(e), e._node.addEventListener(o._canPlayEvent, e._loadFn, !1), e._endFn = e._endListener.bind(e), e._node.addEventListener("ended", e._endFn, !1), e._node.src = t._src, e._node.preload = !0 === t._preload ? "auto" : t._preload, e._node.volume = n * o.volume(), e._node.load()), e
                        },
                        reset: function() {
                            var e = this,
                                t = e._parent;
                            return e._muted = t._muted, e._loop = t._loop, e._volume = t._volume, e._rate = t._rate, e._seek = 0, e._rateSeek = 0, e._paused = !0, e._ended = !0, e._sprite = "__default", e._id = ++o._counter, e
                        },
                        _errorListener: function() {
                            var e = this;
                            e._parent._emit("loaderror", e._id, e._node.error ? e._node.error.code : 0), e._node.removeEventListener("error", e._errorFn, !1)
                        },
                        _loadListener: function() {
                            var e = this,
                                t = e._parent;
                            t._duration = Math.ceil(10 * e._node.duration) / 10, 0 === Object.keys(t._sprite).length && (t._sprite = {
                                __default: [0, 1e3 * t._duration]
                            }), "loaded" !== t._state && (t._state = "loaded", t._emit("load"), t._loadQueue()), e._node.removeEventListener(o._canPlayEvent, e._loadFn, !1)
                        },
                        _endListener: function() {
                            var e = this,
                                t = e._parent;
                            t._duration === 1 / 0 && (t._duration = Math.ceil(10 * e._node.duration) / 10, t._sprite.__default[1] === 1 / 0 && (t._sprite.__default[1] = 1e3 * t._duration), t._ended(e)), e._node.removeEventListener("ended", e._endFn, !1)
                        }
                    };
                    var l = {},
                        c = function(e) {
                            var t = e._src;
                            if (l[t]) return e._duration = l[t].duration, void u(e);
                            if (/^data:[^;]+;base64,/.test(t)) {
                                for (var n = atob(t.split(",")[1]), i = new Uint8Array(n.length), r = 0; r < n.length; ++r) i[r] = n.charCodeAt(r);
                                h(i.buffer, e)
                            } else {
                                var o = new XMLHttpRequest;
                                o.open(e._xhr.method, t, !0), o.withCredentials = e._xhr.withCredentials, o.responseType = "arraybuffer", e._xhr.headers && Object.keys(e._xhr.headers).forEach((function(t) {
                                    o.setRequestHeader(t, e._xhr.headers[t])
                                })), o.onload = function() {
                                    var t = (o.status + "")[0];
                                    "0" === t || "2" === t || "3" === t ? h(o.response, e) : e._emit("loaderror", null, "Failed loading audio file with status: " + o.status + ".")
                                }, o.onerror = function() {
                                    e._webAudio && (e._html5 = !0, e._webAudio = !1, e._sounds = [], delete l[t], e.load())
                                }, A(o)
                            }
                        },
                        A = function(e) {
                            try {
                                e.send()
                            } catch (t) {
                                e.onerror()
                            }
                        },
                        h = function(e, t) {
                            var n = function() {
                                    t._emit("loaderror", null, "Decoding audio data failed.")
                                },
                                i = function(e) {
                                    e && t._sounds.length > 0 ? (l[t._src] = e, u(t, e)) : n()
                                };
                            "undefined" != typeof Promise && 1 === o.ctx.decodeAudioData.length ? o.ctx.decodeAudioData(e).then(i).catch(n) : o.ctx.decodeAudioData(e, i, n)
                        },
                        u = function(e, t) {
                            t && !e._duration && (e._duration = t.duration), 0 === Object.keys(e._sprite).length && (e._sprite = {
                                __default: [0, 1e3 * e._duration]
                            }), "loaded" !== e._state && (e._state = "loaded", e._emit("load"), e._loadQueue())
                        },
                        d = function() {
                            if (o.usingWebAudio) {
                                try {
                                    "undefined" != typeof AudioContext ? o.ctx = new AudioContext : "undefined" != typeof webkitAudioContext ? o.ctx = new webkitAudioContext : o.usingWebAudio = !1
                                } catch (e) {
                                    o.usingWebAudio = !1
                                }
                                o.ctx || (o.usingWebAudio = !1);
                                var e = /iP(hone|od|ad)/.test(o._navigator && o._navigator.platform),
                                    t = o._navigator && o._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),
                                    n = t ? parseInt(t[1], 10) : null;
                                if (e && n && n < 9) {
                                    var i = /safari/.test(o._navigator && o._navigator.userAgent.toLowerCase());
                                    o._navigator && !i && (o.usingWebAudio = !1)
                                }
                                o.usingWebAudio && (o.masterGain = void 0 === o.ctx.createGain ? o.ctx.createGainNode() : o.ctx.createGain(), o.masterGain.gain.setValueAtTime(o._muted ? 0 : o._volume, o.ctx.currentTime), o.masterGain.connect(o.ctx.destination)), o._setup()
                            }
                        };
                    void 0 === (i = function() {
                        return {
                            Howler: o,
                            Howl: s
                        }
                    }.apply(t, [])) || (e.exports = i), t.Howler = o, t.Howl = s, void 0 !== n.g ? (n.g.HowlerGlobal = r, n.g.Howler = o, n.g.Howl = s, n.g.Sound = a) : "undefined" != typeof window && (window.HowlerGlobal = r, window.Howler = o, window.Howl = s, window.Sound = a)
                }(),
                function() {
                    "use strict";
                    var e;
                    HowlerGlobal.prototype._pos = [0, 0, 0], HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0], HowlerGlobal.prototype.stereo = function(e) {
                        var t = this;
                        if (!t.ctx || !t.ctx.listener) return t;
                        for (var n = t._howls.length - 1; n >= 0; n--) t._howls[n].stereo(e);
                        return t
                    }, HowlerGlobal.prototype.pos = function(e, t, n) {
                        var i = this;
                        return i.ctx && i.ctx.listener ? (t = "number" != typeof t ? i._pos[1] : t, n = "number" != typeof n ? i._pos[2] : n, "number" != typeof e ? i._pos : (i._pos = [e, t, n], void 0 !== i.ctx.listener.positionX ? (i.ctx.listener.positionX.setTargetAtTime(i._pos[0], Howler.ctx.currentTime, .1), i.ctx.listener.positionY.setTargetAtTime(i._pos[1], Howler.ctx.currentTime, .1), i.ctx.listener.positionZ.setTargetAtTime(i._pos[2], Howler.ctx.currentTime, .1)) : i.ctx.listener.setPosition(i._pos[0], i._pos[1], i._pos[2]), i)) : i
                    }, HowlerGlobal.prototype.orientation = function(e, t, n, i, r, o) {
                        var s = this;
                        if (!s.ctx || !s.ctx.listener) return s;
                        var a = s._orientation;
                        return t = "number" != typeof t ? a[1] : t, n = "number" != typeof n ? a[2] : n, i = "number" != typeof i ? a[3] : i, r = "number" != typeof r ? a[4] : r, o = "number" != typeof o ? a[5] : o, "number" != typeof e ? a : (s._orientation = [e, t, n, i, r, o], void 0 !== s.ctx.listener.forwardX ? (s.ctx.listener.forwardX.setTargetAtTime(e, Howler.ctx.currentTime, .1), s.ctx.listener.forwardY.setTargetAtTime(t, Howler.ctx.currentTime, .1), s.ctx.listener.forwardZ.setTargetAtTime(n, Howler.ctx.currentTime, .1), s.ctx.listener.upX.setTargetAtTime(i, Howler.ctx.currentTime, .1), s.ctx.listener.upY.setTargetAtTime(r, Howler.ctx.currentTime, .1), s.ctx.listener.upZ.setTargetAtTime(o, Howler.ctx.currentTime, .1)) : s.ctx.listener.setOrientation(e, t, n, i, r, o), s)
                    }, Howl.prototype.init = (e = Howl.prototype.init, function(t) {
                        var n = this;
                        return n._orientation = t.orientation || [1, 0, 0], n._stereo = t.stereo || null, n._pos = t.pos || null, n._pannerAttr = {
                            coneInnerAngle: void 0 !== t.coneInnerAngle ? t.coneInnerAngle : 360,
                            coneOuterAngle: void 0 !== t.coneOuterAngle ? t.coneOuterAngle : 360,
                            coneOuterGain: void 0 !== t.coneOuterGain ? t.coneOuterGain : 0,
                            distanceModel: void 0 !== t.distanceModel ? t.distanceModel : "inverse",
                            maxDistance: void 0 !== t.maxDistance ? t.maxDistance : 1e4,
                            panningModel: void 0 !== t.panningModel ? t.panningModel : "HRTF",
                            refDistance: void 0 !== t.refDistance ? t.refDistance : 1,
                            rolloffFactor: void 0 !== t.rolloffFactor ? t.rolloffFactor : 1
                        }, n._onstereo = t.onstereo ? [{
                            fn: t.onstereo
                        }] : [], n._onpos = t.onpos ? [{
                            fn: t.onpos
                        }] : [], n._onorientation = t.onorientation ? [{
                            fn: t.onorientation
                        }] : [], e.call(this, t)
                    }), Howl.prototype.stereo = function(e, n) {
                        var i = this;
                        if (!i._webAudio) return i;
                        if ("loaded" !== i._state) return i._queue.push({
                            event: "stereo",
                            action: function() {
                                i.stereo(e, n)
                            }
                        }), i;
                        var r = void 0 === Howler.ctx.createStereoPanner ? "spatial" : "stereo";
                        if (void 0 === n) {
                            if ("number" != typeof e) return i._stereo;
                            i._stereo = e, i._pos = [e, 0, 0]
                        }
                        for (var o = i._getSoundIds(n), s = 0; s < o.length; s++) {
                            var a = i._soundById(o[s]);
                            if (a) {
                                if ("number" != typeof e) return a._stereo;
                                a._stereo = e, a._pos = [e, 0, 0], a._node && (a._pannerAttr.panningModel = "equalpower", a._panner && a._panner.pan || t(a, r), "spatial" === r ? void 0 !== a._panner.positionX ? (a._panner.positionX.setValueAtTime(e, Howler.ctx.currentTime), a._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime), a._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime)) : a._panner.setPosition(e, 0, 0) : a._panner.pan.setValueAtTime(e, Howler.ctx.currentTime)), i._emit("stereo", a._id)
                            }
                        }
                        return i
                    }, Howl.prototype.pos = function(e, n, i, r) {
                        var o = this;
                        if (!o._webAudio) return o;
                        if ("loaded" !== o._state) return o._queue.push({
                            event: "pos",
                            action: function() {
                                o.pos(e, n, i, r)
                            }
                        }), o;
                        if (n = "number" != typeof n ? 0 : n, i = "number" != typeof i ? -.5 : i, void 0 === r) {
                            if ("number" != typeof e) return o._pos;
                            o._pos = [e, n, i]
                        }
                        for (var s = o._getSoundIds(r), a = 0; a < s.length; a++) {
                            var l = o._soundById(s[a]);
                            if (l) {
                                if ("number" != typeof e) return l._pos;
                                l._pos = [e, n, i], l._node && (l._panner && !l._panner.pan || t(l, "spatial"), void 0 !== l._panner.positionX ? (l._panner.positionX.setValueAtTime(e, Howler.ctx.currentTime), l._panner.positionY.setValueAtTime(n, Howler.ctx.currentTime), l._panner.positionZ.setValueAtTime(i, Howler.ctx.currentTime)) : l._panner.setPosition(e, n, i)), o._emit("pos", l._id)
                            }
                        }
                        return o
                    }, Howl.prototype.orientation = function(e, n, i, r) {
                        var o = this;
                        if (!o._webAudio) return o;
                        if ("loaded" !== o._state) return o._queue.push({
                            event: "orientation",
                            action: function() {
                                o.orientation(e, n, i, r)
                            }
                        }), o;
                        if (n = "number" != typeof n ? o._orientation[1] : n, i = "number" != typeof i ? o._orientation[2] : i, void 0 === r) {
                            if ("number" != typeof e) return o._orientation;
                            o._orientation = [e, n, i]
                        }
                        for (var s = o._getSoundIds(r), a = 0; a < s.length; a++) {
                            var l = o._soundById(s[a]);
                            if (l) {
                                if ("number" != typeof e) return l._orientation;
                                l._orientation = [e, n, i], l._node && (l._panner || (l._pos || (l._pos = o._pos || [0, 0, -.5]), t(l, "spatial")), void 0 !== l._panner.orientationX ? (l._panner.orientationX.setValueAtTime(e, Howler.ctx.currentTime), l._panner.orientationY.setValueAtTime(n, Howler.ctx.currentTime), l._panner.orientationZ.setValueAtTime(i, Howler.ctx.currentTime)) : l._panner.setOrientation(e, n, i)), o._emit("orientation", l._id)
                            }
                        }
                        return o
                    }, Howl.prototype.pannerAttr = function() {
                        var e, n, i, r = this,
                            o = arguments;
                        if (!r._webAudio) return r;
                        if (0 === o.length) return r._pannerAttr;
                        if (1 === o.length) {
                            if ("object" != typeof o[0]) return (i = r._soundById(parseInt(o[0], 10))) ? i._pannerAttr : r._pannerAttr;
                            e = o[0], void 0 === n && (e.pannerAttr || (e.pannerAttr = {
                                coneInnerAngle: e.coneInnerAngle,
                                coneOuterAngle: e.coneOuterAngle,
                                coneOuterGain: e.coneOuterGain,
                                distanceModel: e.distanceModel,
                                maxDistance: e.maxDistance,
                                refDistance: e.refDistance,
                                rolloffFactor: e.rolloffFactor,
                                panningModel: e.panningModel
                            }), r._pannerAttr = {
                                coneInnerAngle: void 0 !== e.pannerAttr.coneInnerAngle ? e.pannerAttr.coneInnerAngle : r._coneInnerAngle,
                                coneOuterAngle: void 0 !== e.pannerAttr.coneOuterAngle ? e.pannerAttr.coneOuterAngle : r._coneOuterAngle,
                                coneOuterGain: void 0 !== e.pannerAttr.coneOuterGain ? e.pannerAttr.coneOuterGain : r._coneOuterGain,
                                distanceModel: void 0 !== e.pannerAttr.distanceModel ? e.pannerAttr.distanceModel : r._distanceModel,
                                maxDistance: void 0 !== e.pannerAttr.maxDistance ? e.pannerAttr.maxDistance : r._maxDistance,
                                refDistance: void 0 !== e.pannerAttr.refDistance ? e.pannerAttr.refDistance : r._refDistance,
                                rolloffFactor: void 0 !== e.pannerAttr.rolloffFactor ? e.pannerAttr.rolloffFactor : r._rolloffFactor,
                                panningModel: void 0 !== e.pannerAttr.panningModel ? e.pannerAttr.panningModel : r._panningModel
                            })
                        } else 2 === o.length && (e = o[0], n = parseInt(o[1], 10));
                        for (var s = r._getSoundIds(n), a = 0; a < s.length; a++)
                            if (i = r._soundById(s[a])) {
                                var l = i._pannerAttr;
                                l = {
                                    coneInnerAngle: void 0 !== e.coneInnerAngle ? e.coneInnerAngle : l.coneInnerAngle,
                                    coneOuterAngle: void 0 !== e.coneOuterAngle ? e.coneOuterAngle : l.coneOuterAngle,
                                    coneOuterGain: void 0 !== e.coneOuterGain ? e.coneOuterGain : l.coneOuterGain,
                                    distanceModel: void 0 !== e.distanceModel ? e.distanceModel : l.distanceModel,
                                    maxDistance: void 0 !== e.maxDistance ? e.maxDistance : l.maxDistance,
                                    refDistance: void 0 !== e.refDistance ? e.refDistance : l.refDistance,
                                    rolloffFactor: void 0 !== e.rolloffFactor ? e.rolloffFactor : l.rolloffFactor,
                                    panningModel: void 0 !== e.panningModel ? e.panningModel : l.panningModel
                                };
                                var c = i._panner;
                                c || (i._pos || (i._pos = r._pos || [0, 0, -.5]), t(i, "spatial"), c = i._panner), c.coneInnerAngle = l.coneInnerAngle, c.coneOuterAngle = l.coneOuterAngle, c.coneOuterGain = l.coneOuterGain, c.distanceModel = l.distanceModel, c.maxDistance = l.maxDistance, c.refDistance = l.refDistance, c.rolloffFactor = l.rolloffFactor, c.panningModel = l.panningModel
                            }
                        return r
                    }, Sound.prototype.init = function(e) {
                        return function() {
                            var t = this,
                                n = t._parent;
                            t._orientation = n._orientation, t._stereo = n._stereo, t._pos = n._pos, t._pannerAttr = n._pannerAttr, e.call(this), t._stereo ? n.stereo(t._stereo) : t._pos && n.pos(t._pos[0], t._pos[1], t._pos[2], t._id)
                        }
                    }(Sound.prototype.init), Sound.prototype.reset = function(e) {
                        return function() {
                            var t = this,
                                n = t._parent;
                            return t._orientation = n._orientation, t._stereo = n._stereo, t._pos = n._pos, t._pannerAttr = n._pannerAttr, t._stereo ? n.stereo(t._stereo) : t._pos ? n.pos(t._pos[0], t._pos[1], t._pos[2], t._id) : t._panner && (t._panner.disconnect(0), t._panner = void 0, n._refreshBuffer(t)), e.call(this)
                        }
                    }(Sound.prototype.reset);
                    var t = function(e, t) {
                        "spatial" === (t = t || "spatial") ? (e._panner = Howler.ctx.createPanner(), e._panner.coneInnerAngle = e._pannerAttr.coneInnerAngle, e._panner.coneOuterAngle = e._pannerAttr.coneOuterAngle, e._panner.coneOuterGain = e._pannerAttr.coneOuterGain, e._panner.distanceModel = e._pannerAttr.distanceModel, e._panner.maxDistance = e._pannerAttr.maxDistance, e._panner.refDistance = e._pannerAttr.refDistance, e._panner.rolloffFactor = e._pannerAttr.rolloffFactor, e._panner.panningModel = e._pannerAttr.panningModel, void 0 !== e._panner.positionX ? (e._panner.positionX.setValueAtTime(e._pos[0], Howler.ctx.currentTime), e._panner.positionY.setValueAtTime(e._pos[1], Howler.ctx.currentTime), e._panner.positionZ.setValueAtTime(e._pos[2], Howler.ctx.currentTime)) : e._panner.setPosition(e._pos[0], e._pos[1], e._pos[2]), void 0 !== e._panner.orientationX ? (e._panner.orientationX.setValueAtTime(e._orientation[0], Howler.ctx.currentTime), e._panner.orientationY.setValueAtTime(e._orientation[1], Howler.ctx.currentTime), e._panner.orientationZ.setValueAtTime(e._orientation[2], Howler.ctx.currentTime)) : e._panner.setOrientation(e._orientation[0], e._orientation[1], e._orientation[2])) : (e._panner = Howler.ctx.createStereoPanner(), e._panner.pan.setValueAtTime(e._stereo, Howler.ctx.currentTime)), e._panner.connect(e._node), e._paused || e._parent.pause(e._id, !0).play(e._id, !0)
                    }
                }()
            },
            336: e => {
                var t, n;
                t = [], n = [], e.exports = function(e, i, r) {
                    var o, s, a, l, c, A, h, u;
                    if (e === i) return 0;
                    if (o = e.length, s = i.length, 0 === o) return s;
                    if (0 === s) return o;
                    for (r && (e = e.toLowerCase(), i = i.toLowerCase()), h = 0; h < o;) n[h] = e.charCodeAt(h), t[h] = ++h;
                    for (u = 0; u < s;)
                        for (a = i.charCodeAt(u), l = c = u++, h = -1; ++h < o;) A = a === n[h] ? c : c + 1, c = t[h], t[h] = l = c > l ? A > l ? l + 1 : A : A > c ? c + 1 : A;
                    return l
                }
            },
            722: (e, t, n) => {
                var i = n(336);
                e.exports = function() {
                    var e, t, n, r, o, s = 0,
                        a = arguments[0],
                        l = arguments[1],
                        c = l.length,
                        A = arguments[2];
                    A && (r = A.threshold, o = A.ignoreCase), void 0 === r && (r = 0);
                    for (var h = 0; h < c; ++h)(e = (t = o ? i(a, l[h], !0) : i(a, l[h])) > a.length ? 1 - t / l[h].length : 1 - t / a.length) > s && (s = e, n = l[h]);
                    return s >= r ? n : null
                }
            },
            52: function(e) {
                var t;
                e.exports = ((t = function() {
                    function e(e) {
                        return r.appendChild(e.dom), e
                    }

                    function n(e) {
                        for (var t = 0; t < r.children.length; t++) r.children[t].style.display = t === e ? "block" : "none";
                        i = e
                    }
                    var i = 0,
                        r = document.createElement("div");
                    r.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000", r.addEventListener("click", (function(e) {
                        e.preventDefault(), n(++i % r.children.length)
                    }), !1);
                    var o = (performance || Date).now(),
                        s = o,
                        a = 0,
                        l = e(new t.Panel("FPS", "#0ff", "#002")),
                        c = e(new t.Panel("MS", "#0f0", "#020"));
                    if (self.performance && self.performance.memory) var A = e(new t.Panel("MB", "#f08", "#201"));
                    return n(0), {
                        REVISION: 16,
                        dom: r,
                        addPanel: e,
                        showPanel: n,
                        begin: function() {
                            o = (performance || Date).now()
                        },
                        end: function() {
                            a++;
                            var e = (performance || Date).now();
                            if (c.update(e - o, 200), e > s + 1e3 && (l.update(1e3 * a / (e - s), 100), s = e, a = 0, A)) {
                                var t = performance.memory;
                                A.update(t.usedJSHeapSize / 1048576, t.jsHeapSizeLimit / 1048576)
                            }
                            return e
                        },
                        update: function() {
                            o = this.end()
                        },
                        domElement: r,
                        setMode: n
                    }
                }).Panel = function(e, t, n) {
                    var i = 1 / 0,
                        r = 0,
                        o = Math.round,
                        s = o(window.devicePixelRatio || 1),
                        a = 80 * s,
                        l = 48 * s,
                        c = 3 * s,
                        A = 2 * s,
                        h = 3 * s,
                        u = 15 * s,
                        d = 74 * s,
                        p = 30 * s,
                        g = document.createElement("canvas");
                    g.width = a, g.height = l, g.style.cssText = "width:80px;height:48px";
                    var f = g.getContext("2d");
                    return f.font = "bold " + 9 * s + "px Helvetica,Arial,sans-serif", f.textBaseline = "top", f.fillStyle = n, f.fillRect(0, 0, a, l), f.fillStyle = t, f.fillText(e, c, A), f.fillRect(h, u, d, p), f.fillStyle = n, f.globalAlpha = .9, f.fillRect(h, u, d, p), {
                        dom: g,
                        update: function(l, m) {
                            i = Math.min(i, l), r = Math.max(r, l), f.fillStyle = n, f.globalAlpha = 1, f.fillRect(0, 0, a, u), f.fillStyle = t, f.fillText(o(l) + " " + e + " (" + o(i) + "-" + o(r) + ")", c, A), f.drawImage(g, h + s, u, d - s, p, h, u, d - s, p), f.fillRect(h + d - s, u, s, p), f.fillStyle = n, f.globalAlpha = .9, f.fillRect(h + d - s, u, s, o((1 - l / m) * p))
                        }
                    }
                }, t)
            },
            314: e => {
                e.exports = function() {
                    function e(e, t, n, i) {
                        this.set(e, t, n, i)
                    }
                    return e.prototype.set = function(e, t, n, i) {
                        this._cx = 3 * e, this._bx = 3 * (n - e) - this._cx, this._ax = 1 - this._cx - this._bx, this._cy = 3 * t, this._by = 3 * (i - t) - this._cy, this._ay = 1 - this._cy - this._by
                    }, e.epsilon = 1e-6, e.prototype._sampleCurveX = function(e) {
                        return ((this._ax * e + this._bx) * e + this._cx) * e
                    }, e.prototype._sampleCurveY = function(e) {
                        return ((this._ay * e + this._by) * e + this._cy) * e
                    }, e.prototype._sampleCurveDerivativeX = function(e) {
                        return (3 * this._ax * e + 2 * this._bx) * e + this._cx
                    }, e.prototype._solveCurveX = function(e, t) {
                        var n, i, r, o, s, a;
                        for (r = void 0, o = void 0, s = void 0, a = void 0, n = void 0, i = void 0, s = e, i = 0; i < 8;) {
                            if (a = this._sampleCurveX(s) - e, Math.abs(a) < t) return s;
                            if (n = this._sampleCurveDerivativeX(s), Math.abs(n) < t) break;
                            s -= a / n, i++
                        }
                        if ((s = e) < (r = 0)) return r;
                        if (s > (o = 1)) return o;
                        for (; r < o;) {
                            if (a = this._sampleCurveX(s), Math.abs(a - e) < t) return s;
                            e > a ? r = s : o = s, s = .5 * (o - r) + r
                        }
                        return s
                    }, e.prototype.solve = function(e, t) {
                        return this._sampleCurveY(this._solveCurveX(e, t))
                    }, e.prototype.solveSimple = function(e) {
                        return this._sampleCurveY(this._solveCurveX(e, 1e-6))
                    }, e
                }()
            }
        },
        t = {};

    function n(i) {
        var r = t[i];
        if (void 0 !== r) return r.exports;
        var o = t[i] = {
            exports: {}
        };
        return e[i].call(o.exports, o, o.exports, n), o.exports
    }
    n.n = e => {
        var t = e && e.__esModule ? () => e.default : () => e;
        return n.d(t, {
            a: t
        }), t
    }, n.d = (e, t) => {
        for (var i in t) n.o(t, i) && !n.o(e, i) && Object.defineProperty(e, i, {
            enumerable: !0,
            get: t[i]
        })
    }, n.g = function() {
        if ("object" == typeof globalThis) return globalThis;
        try {
            return this || new Function("return this")()
        } catch (e) {
            if ("object" == typeof window) return window
        }
    }(), n.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), (() => {
        "use strict";
        var e, t;
        ! function(e) {
            e.Default = "default", e.Pointer = "pointer"
        }(e || (e = {})),
        function(e) {
            e.SceneState = "sceneState.json", e.UIState = "uiState.json", e.Index = "index.html", e.Styles = "styles.css", e.Favicon = "favicon.ico", e.MetaImage = "meta-image.jpg", e.ErrorPage = "error-page.html", e.ErrorPageStyles = "error-page-styles.css"
        }(t || (t = {}));
        t.Index, t.Styles, t.SceneState, t.UIState, t.Favicon, t.MetaImage;
        var i, r, o, s, a, l, c, A, h, u, d, p, g, f, m;
        ! function(e) {
            e.WebsitePreviewData = "WEBSITE_PREVIEW_DATA"
        }(i || (i = {})),
        function(e) {
            e[e.Raycast = 1] = "Raycast", e[e.Helpers = 2] = "Helpers", e[e.HelpersRaycast = 3] = "HelpersRaycast"
        }(r || (r = {})),
        function(e) {
            e[e.Low = 512] = "Low", e[e.Normal = 1024] = "Normal", e[e.High = 2048] = "High"
        }(o || (o = {})),
        function(e) {
            e[e.Low = 256] = "Low", e[e.Normal = 512] = "Normal", e[e.High = 1024] = "High"
        }(s || (s = {})),
        function(e) {
            e.Imported = "IMPORTED", e.Scene = "SCENE", e.Mesh = "MESH", e.Group = " GROUP", e.Light = "LIGHT", e.Camera = "CAMERA", e.Water = "Water", e.Html = "HTML"
        }(a || (a = {})),
        function(e) {
            e.Plane = "PLANE", e.Box = "BOX"
        }(l || (l = {})),
        function(e) {
            e.Perspective = "PERSPECTIVE", e.Orthographic = "ORTHOGRAPHIC"
        }(c || (c = {})),
        function(e) {
            e.Directional = "DIRECTIONAL", e.Ambient = "AMBIENT", e.Spot = "SPOT", e.Point = "POINT"
        }(A || (A = {})),
        function(e) {
            e.Unlit = "UNLIT", e.Lit = "LIT"
        }(h || (h = {})),
        function(e) {
            e.Front = "FRONT", e.Back = "BACK", e.Double = "DOUBLE"
        }(u || (u = {})),
        function(e) {
            e.Gltf = "GLTF", e.FBX = "FBX", e.Obj = "OBJ", e.Texture = "TEXTURE", e.VideoTexture = "VIDEO_TEXTURE", e.EXRTexture = "EXR_TEXTURE", e.HDRTexture = "HDR_TEXTURE"
        }(d || (d = {})),
        function(e) {
            e[e.Low = 256] = "Low", e[e.Normal = 512] = "Normal", e[e.High = 1024] = "High"
        }(p || (p = {})),
        function(e) {
            e.Clamp = "Clamp", e.Repeat = "Repeat", e.MirroredRepeat = "MirroredRepeat"
        }(g || (g = {})),
        function(e) {
            e.Absolute = "ABSOLUTE", e.Relative = "RELATIVE"
        }(f || (f = {})),
        function(e) {
            e.Blur = "BLUR", e.DepthOfField = "DOF", e.Bloom = "BLOOM", e.Vignette = "VIGNETTE", e.Pixelation = "PIXELATION", e.HueSaturation = "HUE_SATURATION", e.BrightnessContrast = "BRIGHTNESS_CONTRAST", e.Noise = "NOISE", e.ColorDepth = "COLOR_DEPTH", e.SMAA = "SMAA"
        }(m || (m = {}));
        const E = [m.SMAA, m.Bloom, m.Vignette, m.Pixelation, m.DepthOfField, m.HueSaturation, m.BrightnessContrast, m.Noise, m.ColorDepth];
        const C = function() {
            const e = new Map;
            return E.forEach(((t, n) => {
                e.set(t, n)
            })), e
        }();
        var I, S, v, B, x, y, w, b, Q, U, M, R, T, F, D, k, L, K, P, G, V, O, N, H, q, j, Y, J, W, z, X, Z, _, $, ee, te, ne;
        ! function(e) {
            e.ScrollAnimation = "ScrollAnimation", e.ScrollTransform = "ScrollTransform"
        }(I || (I = {})),
        function(e) {
            e.Rotate2D = "2d", e.Rotate3D = "3d"
        }(S || (S = {})),
        function(e) {
            e.Linear = "linear", e.EaseIn = "easeIn", e.EaseOut = "easeOut", e.EaseInOut = "easeInOut", e.CircIn = "circIn", e.CircOut = "circOut", e.CircInOut = "circInOut", e.BackIn = "backIn", e.BackOut = "backOut", e.BackInOut = "backInOut", e.Anticipate = "anticipate"
        }(v || (v = {})),
        function(e) {
            e.Spring = "spring"
        }(B || (B = {})),
        function(e) {
            e.OnAppear = "appear", e.OnScroll = "scroll", e.ElementInView = "element", e.SectionInView = "section"
        }(x || (x = {})),
        function(e) {
            e.Down = "down", e.Up = "up"
        }(y || (y = {})),
        function(e) {
            e.Top = "top", e.Center = "center", e.Bottom = "bottom"
        }(w || (w = {})),
        function(e) {
            e.Fade = "fade", e.Scale = "scale", e.ScaleBottom = "scale_bottom", e.FlipHorizontal = "flip_horizontal", e.FlipVertical = "flip_vertical", e.SlideTop = "slide_top", e.SlideLeft = "slide_left", e.SlideRight = "slide_right", e.SlideBottom = "slide_bottom", e.Custom = "custom"
        }(b || (b = {})),
        function(e) {
            e.Upload = "upload", e.URL = "url"
        }(Q || (Q = {})),
        function(e) {
            e.Pause = "pause", e.Continue = "continue"
        }(U || (U = {})),
        function(e) {
            e.None = "none", e.PlayPause = "play_pause", e.Waveform = "waveform", e.Speaker = "speaker", e.Custom = "custom"
        }(M || (M = {})),
        function(e) {
            e.Top = "top", e.Right = "right", e.Bottom = "bottom", e.Left = "left"
        }(R || (R = {})),
        function(e) {
            e.Start = "start", e.Center = "center", e.End = "end"
        }(T || (T = {})),
        function(e) {
            e.Auto = "auto", e.Click = "click", e.None = "none"
        }(F || (F = {})),
        function(e) {
            e.UIOverlay = "uiOverlay", e.UIAudio = "uiAudio"
        }(D || (D = {})),
        function(e) {
            e.Play = "play", e.Pause = "pause", e.Stop = "stop", e.TogglePlayPause = "toggle_play_pause", e.TogglePlayStop = "toggle_play_stop"
        }(k || (k = {})),
        function(e) {
            e.Open = "open", e.Close = "close", e.ToggleOpenClose = "toggle_open_close"
        }(L || (L = {})),
        function(e) {
            e.MouseClick = "mouseClick", e.MouseEnter = "mouseEnter", e.MouseLeave = "mouseLeave"
        }(K || (K = {})),
        function(e) {
            e.External = "external", e.Internal = "internal"
        }(P || (P = {})),
        function(e) {
            e.Canvases = "canvases", e.Sections = "sections", e.Links = "links", e.ScrollAnimations = "scrollAnimations", e.Audio = "audio", e.AudioStyle = "audioStyle"
        }(G || (G = {})),
        function(e) {
            e.Interactions = "interactions", e.RelativeOverlays = "relativeOverlays"
        }(V || (V = {})),
        function(e) {
            e.Mobile = "mobile", e.Tablet = "tablet", e.Desktop = "desktop"
        }(O || (O = {})),
        function(e) {
            e.Standard = "standard", e.Smooth = "smooth"
        }(N || (N = {})),
        function(e) {
            e.Objects = "objects", e.Keyframes = "keyframes", e.AnimationLines = "animationLines"
        }(H || (H = {})),
        function(e) {
            e.Standard = "standard", e.Animation = "animation", e.UI = "UI"
        }(q || (q = {})),
        function(e) {
            e.Hdri = "HDRI", e.Audio = "audio", e.Font = "font", e.Image = "image", e.Model3d = "model3d", e.Vector = "vector", e.Video = "video"
        }(j || (j = {})),
        function(e) {
            e.Failed = "failed", e.Pending = "pending", e.Verified = "verified"
        }(Y || (Y = {})),
        function(e) {
            e.Deployed = "deployed", e.Deploying = "deploying", e.Failed = "failed", e.Pending = "pending", e.Undeployed = "undeployed"
        }(J || (J = {})),
        function(e) {
            e.A = "A", e.Cname = "CNAME", e.Txt = "TXT"
        }(W || (W = {})),
        function(e) {
            e.Template = "template", e.User = "user", e.Website = "website"
        }(z || (z = {})),
        function(e) {
            e.Asset = "asset", e.Avatar = "avatar", e.Cover = "cover", e.Favicon = "favicon", e.MetaSocialImage = "metaSocialImage", e.SceneThumbnail = "sceneThumbnail"
        }(X || (X = {})),
        function(e) {
            e.Asc = "asc", e.Desc = "desc"
        }(Z || (Z = {})),
        function(e) {
            e.CreatedAt = "createdAt", e.Random = "random", e.Title = "title", e.UpdatedAt = "updatedAt"
        }(_ || (_ = {})),
        function(e) {
            e.Admin = "admin", e.User = "user"
        }($ || ($ = {})),
        function(e) {
            e.Active = "active", e.Deactivated = "deactivated"
        }(ee || (ee = {})),
        function(e) {
            e.Basic = "basic", e.Pro = "pro", e.Starter = "starter"
        }(te || (te = {})),
        function(e) {
            e.CreatedAt = "createdAt", e.Title = "title", e.UpdatedAt = "updatedAt"
        }(ne || (ne = {}));

        function ie(e) {
            return e.type === m.Bloom
        }

        function re(e) {
            return e.type === m.Vignette
        }

        function oe(e) {
            return e.type === m.Noise
        }

        function se(e) {
            return e.type === m.SMAA
        }

        function ae(e) {
            return e.type === m.DepthOfField
        }

        function le(e) {
            return e.type === m.Pixelation
        }

        function ce(e) {
            return e.type === m.HueSaturation
        }

        function Ae(e) {
            return e.type === m.ColorDepth
        }

        function he(e) {
            return e.type === m.BrightnessContrast
        }

        function ue(e) {
            return e.type === a.Light
        }

        function de(e) {
            return e.type === a.Mesh
        }

        function pe(e) {
            return e.type === a.Scene
        }

        function ge(e) {
            return e.type === a.Imported
        }

        function fe(e) {
            return e.type === a.Water
        }

        function me(e) {
            return (null == e ? void 0 : e.assetType) === d.VideoTexture
        }

        function Ee(e) {
            return e.type === a.Camera
        }

        function Ce(e) {
            return e.cameraType === c.Perspective
        }

        function Ie(e) {
            return e.cameraType === c.Orthographic
        }

        function Se(e) {
            return e.lightType === A.Point
        }

        function ve(e) {
            return e.lightType === A.Directional
        }

        function Be(e) {
            return e.lightType === A.Ambient
        }

        function xe(e) {
            return e.lightType === A.Spot
        }
        const ye = "164",
            we = 1,
            be = 2,
            Qe = 3,
            Ue = 0,
            Me = 1,
            Re = 2,
            Te = 100,
            Fe = 0,
            De = 1,
            ke = 2,
            Le = 0,
            Ke = 1,
            Pe = 2,
            Ge = 3,
            Ve = 4,
            Oe = 5,
            Ne = 6,
            He = 7,
            qe = "attached",
            je = 301,
            Ye = 302,
            Je = 303,
            We = 304,
            ze = 306,
            Xe = 1e3,
            Ze = 1001,
            _e = 1002,
            $e = 1003,
            et = 1004,
            tt = 1005,
            nt = 1006,
            it = 1007,
            rt = 1008,
            ot = 1009,
            st = 1013,
            at = 1014,
            lt = 1015,
            ct = 1016,
            At = 1020,
            ht = 1023,
            ut = 1024,
            dt = 1026,
            pt = 1027,
            gt = 1028,
            ft = 1030,
            mt = 33776,
            Et = 33777,
            Ct = 33778,
            It = 33779,
            St = 35840,
            vt = 35842,
            Bt = 36196,
            xt = 37492,
            yt = 37496,
            wt = 37808,
            bt = 37812,
            Qt = 36492,
            Ut = 2200,
            Mt = 2201,
            Rt = 2300,
            Tt = 2301,
            Ft = 2302,
            Dt = 2400,
            kt = 2401,
            Lt = 2402,
            Kt = 2500,
            Pt = 3200,
            Gt = 3201,
            Vt = "",
            Ot = "srgb",
            Nt = "srgb-linear",
            Ht = "display-p3",
            qt = "display-p3-linear",
            jt = "linear",
            Yt = "srgb",
            Jt = "rec709",
            Wt = "p3",
            zt = 7680,
            Xt = 35044,
            Zt = "300 es",
            _t = 2e3,
            $t = 2001;
        class en {
            addEventListener(e, t) {
                void 0 === this._listeners && (this._listeners = {});
                const n = this._listeners;
                void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t)
            }
            hasEventListener(e, t) {
                if (void 0 === this._listeners) return !1;
                const n = this._listeners;
                return void 0 !== n[e] && -1 !== n[e].indexOf(t)
            }
            removeEventListener(e, t) {
                if (void 0 === this._listeners) return;
                const n = this._listeners[e];
                if (void 0 !== n) {
                    const e = n.indexOf(t); - 1 !== e && n.splice(e, 1)
                }
            }
            dispatchEvent(e) {
                if (void 0 === this._listeners) return;
                const t = this._listeners[e.type];
                if (void 0 !== t) {
                    e.target = this;
                    const n = t.slice(0);
                    for (let t = 0, i = n.length; t < i; t++) n[t].call(this, e);
                    e.target = null
                }
            }
        }
        const tn = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
        let nn = 1234567;
        const rn = Math.PI / 180,
            on = 180 / Math.PI;

        function sn() {
            const e = 4294967295 * Math.random() | 0,
                t = 4294967295 * Math.random() | 0,
                n = 4294967295 * Math.random() | 0,
                i = 4294967295 * Math.random() | 0;
            return (tn[255 & e] + tn[e >> 8 & 255] + tn[e >> 16 & 255] + tn[e >> 24 & 255] + "-" + tn[255 & t] + tn[t >> 8 & 255] + "-" + tn[t >> 16 & 15 | 64] + tn[t >> 24 & 255] + "-" + tn[63 & n | 128] + tn[n >> 8 & 255] + "-" + tn[n >> 16 & 255] + tn[n >> 24 & 255] + tn[255 & i] + tn[i >> 8 & 255] + tn[i >> 16 & 255] + tn[i >> 24 & 255]).toLowerCase()
        }

        function an(e, t, n) {
            return Math.max(t, Math.min(n, e))
        }

        function ln(e, t) {
            return (e % t + t) % t
        }

        function cn(e, t, n) {
            return (1 - n) * e + n * t
        }

        function An(e, t) {
            switch (t.constructor) {
                case Float32Array:
                    return e;
                case Uint32Array:
                    return e / 4294967295;
                case Uint16Array:
                    return e / 65535;
                case Uint8Array:
                    return e / 255;
                case Int32Array:
                    return Math.max(e / 2147483647, -1);
                case Int16Array:
                    return Math.max(e / 32767, -1);
                case Int8Array:
                    return Math.max(e / 127, -1);
                default:
                    throw new Error("Invalid component type.")
            }
        }

        function hn(e, t) {
            switch (t.constructor) {
                case Float32Array:
                    return e;
                case Uint32Array:
                    return Math.round(4294967295 * e);
                case Uint16Array:
                    return Math.round(65535 * e);
                case Uint8Array:
                    return Math.round(255 * e);
                case Int32Array:
                    return Math.round(2147483647 * e);
                case Int16Array:
                    return Math.round(32767 * e);
                case Int8Array:
                    return Math.round(127 * e);
                default:
                    throw new Error("Invalid component type.")
            }
        }
        const un = {
            DEG2RAD: rn,
            RAD2DEG: on,
            generateUUID: sn,
            clamp: an,
            euclideanModulo: ln,
            mapLinear: function(e, t, n, i, r) {
                return i + (e - t) * (r - i) / (n - t)
            },
            inverseLerp: function(e, t, n) {
                return e !== t ? (n - e) / (t - e) : 0
            },
            lerp: cn,
            damp: function(e, t, n, i) {
                return cn(e, t, 1 - Math.exp(-n * i))
            },
            pingpong: function(e, t = 1) {
                return t - Math.abs(ln(e, 2 * t) - t)
            },
            smoothstep: function(e, t, n) {
                return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e)
            },
            smootherstep: function(e, t, n) {
                return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10)
            },
            randInt: function(e, t) {
                return e + Math.floor(Math.random() * (t - e + 1))
            },
            randFloat: function(e, t) {
                return e + Math.random() * (t - e)
            },
            randFloatSpread: function(e) {
                return e * (.5 - Math.random())
            },
            seededRandom: function(e) {
                void 0 !== e && (nn = e);
                let t = nn += 1831565813;
                return t = Math.imul(t ^ t >>> 15, 1 | t), t ^= t + Math.imul(t ^ t >>> 7, 61 | t), ((t ^ t >>> 14) >>> 0) / 4294967296
            },
            degToRad: function(e) {
                return e * rn
            },
            radToDeg: function(e) {
                return e * on
            },
            isPowerOfTwo: function(e) {
                return !(e & e - 1) && 0 !== e
            },
            ceilPowerOfTwo: function(e) {
                return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
            },
            floorPowerOfTwo: function(e) {
                return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
            },
            setQuaternionFromProperEuler: function(e, t, n, i, r) {
                const o = Math.cos,
                    s = Math.sin,
                    a = o(n / 2),
                    l = s(n / 2),
                    c = o((t + i) / 2),
                    A = s((t + i) / 2),
                    h = o((t - i) / 2),
                    u = s((t - i) / 2),
                    d = o((i - t) / 2),
                    p = s((i - t) / 2);
                switch (r) {
                    case "XYX":
                        e.set(a * A, l * h, l * u, a * c);
                        break;
                    case "YZY":
                        e.set(l * u, a * A, l * h, a * c);
                        break;
                    case "ZXZ":
                        e.set(l * h, l * u, a * A, a * c);
                        break;
                    case "XZX":
                        e.set(a * A, l * p, l * d, a * c);
                        break;
                    case "YXY":
                        e.set(l * d, a * A, l * p, a * c);
                        break;
                    case "ZYZ":
                        e.set(l * p, l * d, a * A, a * c);
                        break;
                    default:
                        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
                }
            },
            normalize: hn,
            denormalize: An
        };
        class dn {
            constructor(e = 0, t = 0) {
                dn.prototype.isVector2 = !0, this.x = e, this.y = t
            }
            get width() {
                return this.x
            }
            set width(e) {
                this.x = e
            }
            get height() {
                return this.y
            }
            set height(e) {
                this.y = e
            }
            set(e, t) {
                return this.x = e, this.y = t, this
            }
            setScalar(e) {
                return this.x = e, this.y = e, this
            }
            setX(e) {
                return this.x = e, this
            }
            setY(e) {
                return this.y = e, this
            }
            setComponent(e, t) {
                switch (e) {
                    case 0:
                        this.x = t;
                        break;
                    case 1:
                        this.y = t;
                        break;
                    default:
                        throw new Error("index is out of range: " + e)
                }
                return this
            }
            getComponent(e) {
                switch (e) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    default:
                        throw new Error("index is out of range: " + e)
                }
            }
            clone() {
                return new this.constructor(this.x, this.y)
            }
            copy(e) {
                return this.x = e.x, this.y = e.y, this
            }
            add(e) {
                return this.x += e.x, this.y += e.y, this
            }
            addScalar(e) {
                return this.x += e, this.y += e, this
            }
            addVectors(e, t) {
                return this.x = e.x + t.x, this.y = e.y + t.y, this
            }
            addScaledVector(e, t) {
                return this.x += e.x * t, this.y += e.y * t, this
            }
            sub(e) {
                return this.x -= e.x, this.y -= e.y, this
            }
            subScalar(e) {
                return this.x -= e, this.y -= e, this
            }
            subVectors(e, t) {
                return this.x = e.x - t.x, this.y = e.y - t.y, this
            }
            multiply(e) {
                return this.x *= e.x, this.y *= e.y, this
            }
            multiplyScalar(e) {
                return this.x *= e, this.y *= e, this
            }
            divide(e) {
                return this.x /= e.x, this.y /= e.y, this
            }
            divideScalar(e) {
                return this.multiplyScalar(1 / e)
            }
            applyMatrix3(e) {
                const t = this.x,
                    n = this.y,
                    i = e.elements;
                return this.x = i[0] * t + i[3] * n + i[6], this.y = i[1] * t + i[4] * n + i[7], this
            }
            min(e) {
                return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
            }
            max(e) {
                return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
            }
            clamp(e, t) {
                return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
            }
            clampScalar(e, t) {
                return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this
            }
            clampLength(e, t) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
            }
            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
            }
            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
            }
            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this
            }
            roundToZero() {
                return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this
            }
            negate() {
                return this.x = -this.x, this.y = -this.y, this
            }
            dot(e) {
                return this.x * e.x + this.y * e.y
            }
            cross(e) {
                return this.x * e.y - this.y * e.x
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            angle() {
                return Math.atan2(-this.y, -this.x) + Math.PI
            }
            angleTo(e) {
                const t = Math.sqrt(this.lengthSq() * e.lengthSq());
                if (0 === t) return Math.PI / 2;
                const n = this.dot(e) / t;
                return Math.acos(an(n, -1, 1))
            }
            distanceTo(e) {
                return Math.sqrt(this.distanceToSquared(e))
            }
            distanceToSquared(e) {
                const t = this.x - e.x,
                    n = this.y - e.y;
                return t * t + n * n
            }
            manhattanDistanceTo(e) {
                return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
            }
            setLength(e) {
                return this.normalize().multiplyScalar(e)
            }
            lerp(e, t) {
                return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
            }
            lerpVectors(e, t, n) {
                return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this
            }
            equals(e) {
                return e.x === this.x && e.y === this.y
            }
            fromArray(e, t = 0) {
                return this.x = e[t], this.y = e[t + 1], this
            }
            toArray(e = [], t = 0) {
                return e[t] = this.x, e[t + 1] = this.y, e
            }
            fromBufferAttribute(e, t) {
                return this.x = e.getX(t), this.y = e.getY(t), this
            }
            rotateAround(e, t) {
                const n = Math.cos(t),
                    i = Math.sin(t),
                    r = this.x - e.x,
                    o = this.y - e.y;
                return this.x = r * n - o * i + e.x, this.y = r * i + o * n + e.y, this
            }
            random() {
                return this.x = Math.random(), this.y = Math.random(), this
            }*[Symbol.iterator]() {
                yield this.x, yield this.y
            }
        }
        class pn {
            constructor(e, t, n, i, r, o, s, a, l) {
                pn.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], void 0 !== e && this.set(e, t, n, i, r, o, s, a, l)
            }
            set(e, t, n, i, r, o, s, a, l) {
                const c = this.elements;
                return c[0] = e, c[1] = i, c[2] = s, c[3] = t, c[4] = r, c[5] = a, c[6] = n, c[7] = o, c[8] = l, this
            }
            identity() {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
            }
            copy(e) {
                const t = this.elements,
                    n = e.elements;
                return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this
            }
            extractBasis(e, t, n) {
                return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
            }
            setFromMatrix4(e) {
                const t = e.elements;
                return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
            }
            multiply(e) {
                return this.multiplyMatrices(this, e)
            }
            premultiply(e) {
                return this.multiplyMatrices(e, this)
            }
            multiplyMatrices(e, t) {
                const n = e.elements,
                    i = t.elements,
                    r = this.elements,
                    o = n[0],
                    s = n[3],
                    a = n[6],
                    l = n[1],
                    c = n[4],
                    A = n[7],
                    h = n[2],
                    u = n[5],
                    d = n[8],
                    p = i[0],
                    g = i[3],
                    f = i[6],
                    m = i[1],
                    E = i[4],
                    C = i[7],
                    I = i[2],
                    S = i[5],
                    v = i[8];
                return r[0] = o * p + s * m + a * I, r[3] = o * g + s * E + a * S, r[6] = o * f + s * C + a * v, r[1] = l * p + c * m + A * I, r[4] = l * g + c * E + A * S, r[7] = l * f + c * C + A * v, r[2] = h * p + u * m + d * I, r[5] = h * g + u * E + d * S, r[8] = h * f + u * C + d * v, this
            }
            multiplyScalar(e) {
                const t = this.elements;
                return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
            }
            determinant() {
                const e = this.elements,
                    t = e[0],
                    n = e[1],
                    i = e[2],
                    r = e[3],
                    o = e[4],
                    s = e[5],
                    a = e[6],
                    l = e[7],
                    c = e[8];
                return t * o * c - t * s * l - n * r * c + n * s * a + i * r * l - i * o * a
            }
            invert() {
                const e = this.elements,
                    t = e[0],
                    n = e[1],
                    i = e[2],
                    r = e[3],
                    o = e[4],
                    s = e[5],
                    a = e[6],
                    l = e[7],
                    c = e[8],
                    A = c * o - s * l,
                    h = s * a - c * r,
                    u = l * r - o * a,
                    d = t * A + n * h + i * u;
                if (0 === d) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                const p = 1 / d;
                return e[0] = A * p, e[1] = (i * l - c * n) * p, e[2] = (s * n - i * o) * p, e[3] = h * p, e[4] = (c * t - i * a) * p, e[5] = (i * r - s * t) * p, e[6] = u * p, e[7] = (n * a - l * t) * p, e[8] = (o * t - n * r) * p, this
            }
            transpose() {
                let e;
                const t = this.elements;
                return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
            }
            getNormalMatrix(e) {
                return this.setFromMatrix4(e).invert().transpose()
            }
            transposeIntoArray(e) {
                const t = this.elements;
                return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
            }
            setUvTransform(e, t, n, i, r, o, s) {
                const a = Math.cos(r),
                    l = Math.sin(r);
                return this.set(n * a, n * l, -n * (a * o + l * s) + o + e, -i * l, i * a, -i * (-l * o + a * s) + s + t, 0, 0, 1), this
            }
            scale(e, t) {
                return this.premultiply(gn.makeScale(e, t)), this
            }
            rotate(e) {
                return this.premultiply(gn.makeRotation(-e)), this
            }
            translate(e, t) {
                return this.premultiply(gn.makeTranslation(e, t)), this
            }
            makeTranslation(e, t) {
                return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1), this
            }
            makeRotation(e) {
                const t = Math.cos(e),
                    n = Math.sin(e);
                return this.set(t, -n, 0, n, t, 0, 0, 0, 1), this
            }
            makeScale(e, t) {
                return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this
            }
            equals(e) {
                const t = this.elements,
                    n = e.elements;
                for (let e = 0; e < 9; e++)
                    if (t[e] !== n[e]) return !1;
                return !0
            }
            fromArray(e, t = 0) {
                for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
                return this
            }
            toArray(e = [], t = 0) {
                const n = this.elements;
                return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e
            }
            clone() {
                return (new this.constructor).fromArray(this.elements)
            }
        }
        const gn = new pn;

        function fn(e) {
            for (let t = e.length - 1; t >= 0; --t)
                if (e[t] >= 65535) return !0;
            return !1
        }
        Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array;

        function mn(e) {
            return document.createElementNS("http://www.w3.org/1999/xhtml", e)
        }

        function En() {
            const e = mn("canvas");
            return e.style.display = "block", e
        }
        const Cn = {};

        function In(e) {
            e in Cn || (Cn[e] = !0, console.warn(e))
        }
        const Sn = (new pn).set(.8224621, .177538, 0, .0331941, .9668058, 0, .0170827, .0723974, .9105199),
            vn = (new pn).set(1.2249401, -.2249404, 0, -.0420569, 1.0420571, 0, -.0196376, -.0786361, 1.0982735),
            Bn = {
                [Nt]: {
                    transfer: jt,
                    primaries: Jt,
                    toReference: e => e,
                    fromReference: e => e
                },
                [Ot]: {
                    transfer: Yt,
                    primaries: Jt,
                    toReference: e => e.convertSRGBToLinear(),
                    fromReference: e => e.convertLinearToSRGB()
                },
                [qt]: {
                    transfer: jt,
                    primaries: Wt,
                    toReference: e => e.applyMatrix3(vn),
                    fromReference: e => e.applyMatrix3(Sn)
                },
                [Ht]: {
                    transfer: Yt,
                    primaries: Wt,
                    toReference: e => e.convertSRGBToLinear().applyMatrix3(vn),
                    fromReference: e => e.applyMatrix3(Sn).convertLinearToSRGB()
                }
            },
            xn = new Set([Nt, qt]),
            yn = {
                enabled: !0,
                _workingColorSpace: Nt,
                get workingColorSpace() {
                    return this._workingColorSpace
                },
                set workingColorSpace(e) {
                    if (!xn.has(e)) throw new Error(`Unsupported working color space, "${e}".`);
                    this._workingColorSpace = e
                },
                convert: function(e, t, n) {
                    if (!1 === this.enabled || t === n || !t || !n) return e;
                    const i = Bn[t].toReference;
                    return (0, Bn[n].fromReference)(i(e))
                },
                fromWorkingColorSpace: function(e, t) {
                    return this.convert(e, this._workingColorSpace, t)
                },
                toWorkingColorSpace: function(e, t) {
                    return this.convert(e, t, this._workingColorSpace)
                },
                getPrimaries: function(e) {
                    return Bn[e].primaries
                },
                getTransfer: function(e) {
                    return e === Vt ? jt : Bn[e].transfer
                }
            };

        function wn(e) {
            return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
        }

        function bn(e) {
            return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
        }
        let Qn;
        class Un {
            static getDataURL(e) {
                if (/^data:/i.test(e.src)) return e.src;
                if ("undefined" == typeof HTMLCanvasElement) return e.src;
                let t;
                if (e instanceof HTMLCanvasElement) t = e;
                else {
                    void 0 === Qn && (Qn = mn("canvas")), Qn.width = e.width, Qn.height = e.height;
                    const n = Qn.getContext("2d");
                    e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = Qn
                }
                return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
            }
            static sRGBToLinear(e) {
                if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                    const t = mn("canvas");
                    t.width = e.width, t.height = e.height;
                    const n = t.getContext("2d");
                    n.drawImage(e, 0, 0, e.width, e.height);
                    const i = n.getImageData(0, 0, e.width, e.height),
                        r = i.data;
                    for (let e = 0; e < r.length; e++) r[e] = 255 * wn(r[e] / 255);
                    return n.putImageData(i, 0, 0), t
                }
                if (e.data) {
                    const t = e.data.slice(0);
                    for (let e = 0; e < t.length; e++) t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[e] = Math.floor(255 * wn(t[e] / 255)) : t[e] = wn(t[e]);
                    return {
                        data: t,
                        width: e.width,
                        height: e.height
                    }
                }
                return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e
            }
        }
        let Mn = 0;
        class Rn {
            constructor(e = null) {
                this.isSource = !0, Object.defineProperty(this, "id", {
                    value: Mn++
                }), this.uuid = sn(), this.data = e, this.dataReady = !0, this.version = 0
            }
            set needsUpdate(e) {
                !0 === e && this.version++
            }
            toJSON(e) {
                const t = void 0 === e || "string" == typeof e;
                if (!t && void 0 !== e.images[this.uuid]) return e.images[this.uuid];
                const n = {
                        uuid: this.uuid,
                        url: ""
                    },
                    i = this.data;
                if (null !== i) {
                    let e;
                    if (Array.isArray(i)) {
                        e = [];
                        for (let t = 0, n = i.length; t < n; t++) i[t].isDataTexture ? e.push(Tn(i[t].image)) : e.push(Tn(i[t]))
                    } else e = Tn(i);
                    n.url = e
                }
                return t || (e.images[this.uuid] = n), n
            }
        }

        function Tn(e) {
            return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? Un.getDataURL(e) : e.data ? {
                data: Array.from(e.data),
                width: e.width,
                height: e.height,
                type: e.data.constructor.name
            } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
        }
        let Fn = 0;
        class Dn extends en {
            constructor(e = Dn.DEFAULT_IMAGE, t = Dn.DEFAULT_MAPPING, n = 1001, i = 1001, r = 1006, o = 1008, s = 1023, a = 1009, l = Dn.DEFAULT_ANISOTROPY, c = Vt) {
                super(), this.isTexture = !0, Object.defineProperty(this, "id", {
                    value: Fn++
                }), this.uuid = sn(), this.name = "", this.source = new Rn(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = n, this.wrapT = i, this.magFilter = r, this.minFilter = o, this.anisotropy = l, this.format = s, this.internalFormat = null, this.type = a, this.offset = new dn(0, 0), this.repeat = new dn(1, 1), this.center = new dn(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new pn, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = c, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0
            }
            get image() {
                return this.source.data
            }
            set image(e = null) {
                this.source.data = e
            }
            updateMatrix() {
                this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this
            }
            toJSON(e) {
                const t = void 0 === e || "string" == typeof e;
                if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
                const n = {
                    metadata: {
                        version: 4.6,
                        type: "Texture",
                        generator: "Texture.toJSON"
                    },
                    uuid: this.uuid,
                    name: this.name,
                    image: this.source.toJSON(e).uuid,
                    mapping: this.mapping,
                    channel: this.channel,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    center: [this.center.x, this.center.y],
                    rotation: this.rotation,
                    wrap: [this.wrapS, this.wrapT],
                    format: this.format,
                    internalFormat: this.internalFormat,
                    type: this.type,
                    colorSpace: this.colorSpace,
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY,
                    generateMipmaps: this.generateMipmaps,
                    premultiplyAlpha: this.premultiplyAlpha,
                    unpackAlignment: this.unpackAlignment
                };
                return Object.keys(this.userData).length > 0 && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            transformUv(e) {
                if (300 !== this.mapping) return e;
                if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
                    case Xe:
                        e.x = e.x - Math.floor(e.x);
                        break;
                    case Ze:
                        e.x = e.x < 0 ? 0 : 1;
                        break;
                    case _e:
                        1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
                }
                if (e.y < 0 || e.y > 1) switch (this.wrapT) {
                    case Xe:
                        e.y = e.y - Math.floor(e.y);
                        break;
                    case Ze:
                        e.y = e.y < 0 ? 0 : 1;
                        break;
                    case _e:
                        1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
                }
                return this.flipY && (e.y = 1 - e.y), e
            }
            set needsUpdate(e) {
                !0 === e && (this.version++, this.source.needsUpdate = !0)
            }
            set needsPMREMUpdate(e) {
                !0 === e && this.pmremVersion++
            }
        }
        Dn.DEFAULT_IMAGE = null, Dn.DEFAULT_MAPPING = 300, Dn.DEFAULT_ANISOTROPY = 1;
        class kn {
            constructor(e = 0, t = 0, n = 0, i = 1) {
                kn.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = n, this.w = i
            }
            get width() {
                return this.z
            }
            set width(e) {
                this.z = e
            }
            get height() {
                return this.w
            }
            set height(e) {
                this.w = e
            }
            set(e, t, n, i) {
                return this.x = e, this.y = t, this.z = n, this.w = i, this
            }
            setScalar(e) {
                return this.x = e, this.y = e, this.z = e, this.w = e, this
            }
            setX(e) {
                return this.x = e, this
            }
            setY(e) {
                return this.y = e, this
            }
            setZ(e) {
                return this.z = e, this
            }
            setW(e) {
                return this.w = e, this
            }
            setComponent(e, t) {
                switch (e) {
                    case 0:
                        this.x = t;
                        break;
                    case 1:
                        this.y = t;
                        break;
                    case 2:
                        this.z = t;
                        break;
                    case 3:
                        this.w = t;
                        break;
                    default:
                        throw new Error("index is out of range: " + e)
                }
                return this
            }
            getComponent(e) {
                switch (e) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    case 3:
                        return this.w;
                    default:
                        throw new Error("index is out of range: " + e)
                }
            }
            clone() {
                return new this.constructor(this.x, this.y, this.z, this.w)
            }
            copy(e) {
                return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
            }
            add(e) {
                return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this
            }
            addScalar(e) {
                return this.x += e, this.y += e, this.z += e, this.w += e, this
            }
            addVectors(e, t) {
                return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
            }
            addScaledVector(e, t) {
                return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
            }
            sub(e) {
                return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this
            }
            subScalar(e) {
                return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
            }
            subVectors(e, t) {
                return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
            }
            multiply(e) {
                return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this
            }
            multiplyScalar(e) {
                return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
            }
            applyMatrix4(e) {
                const t = this.x,
                    n = this.y,
                    i = this.z,
                    r = this.w,
                    o = e.elements;
                return this.x = o[0] * t + o[4] * n + o[8] * i + o[12] * r, this.y = o[1] * t + o[5] * n + o[9] * i + o[13] * r, this.z = o[2] * t + o[6] * n + o[10] * i + o[14] * r, this.w = o[3] * t + o[7] * n + o[11] * i + o[15] * r, this
            }
            divideScalar(e) {
                return this.multiplyScalar(1 / e)
            }
            setAxisAngleFromQuaternion(e) {
                this.w = 2 * Math.acos(e.w);
                const t = Math.sqrt(1 - e.w * e.w);
                return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
            }
            setAxisAngleFromRotationMatrix(e) {
                let t, n, i, r;
                const o = .01,
                    s = .1,
                    a = e.elements,
                    l = a[0],
                    c = a[4],
                    A = a[8],
                    h = a[1],
                    u = a[5],
                    d = a[9],
                    p = a[2],
                    g = a[6],
                    f = a[10];
                if (Math.abs(c - h) < o && Math.abs(A - p) < o && Math.abs(d - g) < o) {
                    if (Math.abs(c + h) < s && Math.abs(A + p) < s && Math.abs(d + g) < s && Math.abs(l + u + f - 3) < s) return this.set(1, 0, 0, 0), this;
                    t = Math.PI;
                    const e = (l + 1) / 2,
                        a = (u + 1) / 2,
                        m = (f + 1) / 2,
                        E = (c + h) / 4,
                        C = (A + p) / 4,
                        I = (d + g) / 4;
                    return e > a && e > m ? e < o ? (n = 0, i = .707106781, r = .707106781) : (n = Math.sqrt(e), i = E / n, r = C / n) : a > m ? a < o ? (n = .707106781, i = 0, r = .707106781) : (i = Math.sqrt(a), n = E / i, r = I / i) : m < o ? (n = .707106781, i = .707106781, r = 0) : (r = Math.sqrt(m), n = C / r, i = I / r), this.set(n, i, r, t), this
                }
                let m = Math.sqrt((g - d) * (g - d) + (A - p) * (A - p) + (h - c) * (h - c));
                return Math.abs(m) < .001 && (m = 1), this.x = (g - d) / m, this.y = (A - p) / m, this.z = (h - c) / m, this.w = Math.acos((l + u + f - 1) / 2), this
            }
            min(e) {
                return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
            }
            max(e) {
                return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
            }
            clamp(e, t) {
                return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
            }
            clampScalar(e, t) {
                return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this
            }
            clampLength(e, t) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
            }
            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
            }
            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
            }
            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
            }
            roundToZero() {
                return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this
            }
            negate() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
            }
            dot(e) {
                return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(e) {
                return this.normalize().multiplyScalar(e)
            }
            lerp(e, t) {
                return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
            }
            lerpVectors(e, t, n) {
                return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this
            }
            equals(e) {
                return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
            }
            fromArray(e, t = 0) {
                return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
            }
            toArray(e = [], t = 0) {
                return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
            }
            fromBufferAttribute(e, t) {
                return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
            }
            random() {
                return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
            }*[Symbol.iterator]() {
                yield this.x, yield this.y, yield this.z, yield this.w
            }
        }
        class Ln extends en {
            constructor(e = 1, t = 1, n = {}) {
                super(), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new kn(0, 0, e, t), this.scissorTest = !1, this.viewport = new kn(0, 0, e, t);
                const i = {
                    width: e,
                    height: t,
                    depth: 1
                };
                n = Object.assign({
                    generateMipmaps: !1,
                    internalFormat: null,
                    minFilter: nt,
                    depthBuffer: !0,
                    stencilBuffer: !1,
                    resolveDepthBuffer: !0,
                    resolveStencilBuffer: !0,
                    depthTexture: null,
                    samples: 0,
                    count: 1
                }, n);
                const r = new Dn(i, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace);
                r.flipY = !1, r.generateMipmaps = n.generateMipmaps, r.internalFormat = n.internalFormat, this.textures = [];
                const o = n.count;
                for (let e = 0; e < o; e++) this.textures[e] = r.clone(), this.textures[e].isRenderTargetTexture = !0;
                this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.resolveDepthBuffer = n.resolveDepthBuffer, this.resolveStencilBuffer = n.resolveStencilBuffer, this.depthTexture = n.depthTexture, this.samples = n.samples
            }
            get texture() {
                return this.textures[0]
            }
            set texture(e) {
                this.textures[0] = e
            }
            setSize(e, t, n = 1) {
                if (this.width !== e || this.height !== t || this.depth !== n) {
                    this.width = e, this.height = t, this.depth = n;
                    for (let i = 0, r = this.textures.length; i < r; i++) this.textures[i].image.width = e, this.textures[i].image.height = t, this.textures[i].image.depth = n;
                    this.dispose()
                }
                this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
                for (let t = 0, n = e.textures.length; t < n; t++) this.textures[t] = e.textures[t].clone(), this.textures[t].isRenderTargetTexture = !0;
                const t = Object.assign({}, e.texture.image);
                return this.texture.source = new Rn(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        class Kn extends Ln {
            constructor(e = 1, t = 1, n = {}) {
                super(e, t, n), this.isWebGLRenderTarget = !0
            }
        }
        class Pn extends Dn {
            constructor(e = null, t = 1, n = 1, i = 1) {
                super(null), this.isDataArrayTexture = !0, this.image = {
                    data: e,
                    width: t,
                    height: n,
                    depth: i
                }, this.magFilter = $e, this.minFilter = $e, this.wrapR = Ze, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
            }
        }
        class Gn extends Dn {
            constructor(e = null, t = 1, n = 1, i = 1) {
                super(null), this.isData3DTexture = !0, this.image = {
                    data: e,
                    width: t,
                    height: n,
                    depth: i
                }, this.magFilter = $e, this.minFilter = $e, this.wrapR = Ze, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
            }
        }
        class Vn {
            constructor(e = 0, t = 0, n = 0, i = 1) {
                this.isQuaternion = !0, this._x = e, this._y = t, this._z = n, this._w = i
            }
            static slerpFlat(e, t, n, i, r, o, s) {
                let a = n[i + 0],
                    l = n[i + 1],
                    c = n[i + 2],
                    A = n[i + 3];
                const h = r[o + 0],
                    u = r[o + 1],
                    d = r[o + 2],
                    p = r[o + 3];
                if (0 === s) return e[t + 0] = a, e[t + 1] = l, e[t + 2] = c, void(e[t + 3] = A);
                if (1 === s) return e[t + 0] = h, e[t + 1] = u, e[t + 2] = d, void(e[t + 3] = p);
                if (A !== p || a !== h || l !== u || c !== d) {
                    let e = 1 - s;
                    const t = a * h + l * u + c * d + A * p,
                        n = t >= 0 ? 1 : -1,
                        i = 1 - t * t;
                    if (i > Number.EPSILON) {
                        const r = Math.sqrt(i),
                            o = Math.atan2(r, t * n);
                        e = Math.sin(e * o) / r, s = Math.sin(s * o) / r
                    }
                    const r = s * n;
                    if (a = a * e + h * r, l = l * e + u * r, c = c * e + d * r, A = A * e + p * r, e === 1 - s) {
                        const e = 1 / Math.sqrt(a * a + l * l + c * c + A * A);
                        a *= e, l *= e, c *= e, A *= e
                    }
                }
                e[t] = a, e[t + 1] = l, e[t + 2] = c, e[t + 3] = A
            }
            static multiplyQuaternionsFlat(e, t, n, i, r, o) {
                const s = n[i],
                    a = n[i + 1],
                    l = n[i + 2],
                    c = n[i + 3],
                    A = r[o],
                    h = r[o + 1],
                    u = r[o + 2],
                    d = r[o + 3];
                return e[t] = s * d + c * A + a * u - l * h, e[t + 1] = a * d + c * h + l * A - s * u, e[t + 2] = l * d + c * u + s * h - a * A, e[t + 3] = c * d - s * A - a * h - l * u, e
            }
            get x() {
                return this._x
            }
            set x(e) {
                this._x = e, this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(e) {
                this._y = e, this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(e) {
                this._z = e, this._onChangeCallback()
            }
            get w() {
                return this._w
            }
            set w(e) {
                this._w = e, this._onChangeCallback()
            }
            set(e, t, n, i) {
                return this._x = e, this._y = t, this._z = n, this._w = i, this._onChangeCallback(), this
            }
            clone() {
                return new this.constructor(this._x, this._y, this._z, this._w)
            }
            copy(e) {
                return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this
            }
            setFromEuler(e, t = !0) {
                const n = e._x,
                    i = e._y,
                    r = e._z,
                    o = e._order,
                    s = Math.cos,
                    a = Math.sin,
                    l = s(n / 2),
                    c = s(i / 2),
                    A = s(r / 2),
                    h = a(n / 2),
                    u = a(i / 2),
                    d = a(r / 2);
                switch (o) {
                    case "XYZ":
                        this._x = h * c * A + l * u * d, this._y = l * u * A - h * c * d, this._z = l * c * d + h * u * A, this._w = l * c * A - h * u * d;
                        break;
                    case "YXZ":
                        this._x = h * c * A + l * u * d, this._y = l * u * A - h * c * d, this._z = l * c * d - h * u * A, this._w = l * c * A + h * u * d;
                        break;
                    case "ZXY":
                        this._x = h * c * A - l * u * d, this._y = l * u * A + h * c * d, this._z = l * c * d + h * u * A, this._w = l * c * A - h * u * d;
                        break;
                    case "ZYX":
                        this._x = h * c * A - l * u * d, this._y = l * u * A + h * c * d, this._z = l * c * d - h * u * A, this._w = l * c * A + h * u * d;
                        break;
                    case "YZX":
                        this._x = h * c * A + l * u * d, this._y = l * u * A + h * c * d, this._z = l * c * d - h * u * A, this._w = l * c * A - h * u * d;
                        break;
                    case "XZY":
                        this._x = h * c * A - l * u * d, this._y = l * u * A - h * c * d, this._z = l * c * d + h * u * A, this._w = l * c * A + h * u * d;
                        break;
                    default:
                        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
                }
                return !0 === t && this._onChangeCallback(), this
            }
            setFromAxisAngle(e, t) {
                const n = t / 2,
                    i = Math.sin(n);
                return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(n), this._onChangeCallback(), this
            }
            setFromRotationMatrix(e) {
                const t = e.elements,
                    n = t[0],
                    i = t[4],
                    r = t[8],
                    o = t[1],
                    s = t[5],
                    a = t[9],
                    l = t[2],
                    c = t[6],
                    A = t[10],
                    h = n + s + A;
                if (h > 0) {
                    const e = .5 / Math.sqrt(h + 1);
                    this._w = .25 / e, this._x = (c - a) * e, this._y = (r - l) * e, this._z = (o - i) * e
                } else if (n > s && n > A) {
                    const e = 2 * Math.sqrt(1 + n - s - A);
                    this._w = (c - a) / e, this._x = .25 * e, this._y = (i + o) / e, this._z = (r + l) / e
                } else if (s > A) {
                    const e = 2 * Math.sqrt(1 + s - n - A);
                    this._w = (r - l) / e, this._x = (i + o) / e, this._y = .25 * e, this._z = (a + c) / e
                } else {
                    const e = 2 * Math.sqrt(1 + A - n - s);
                    this._w = (o - i) / e, this._x = (r + l) / e, this._y = (a + c) / e, this._z = .25 * e
                }
                return this._onChangeCallback(), this
            }
            setFromUnitVectors(e, t) {
                let n = e.dot(t) + 1;
                return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize()
            }
            angleTo(e) {
                return 2 * Math.acos(Math.abs(an(this.dot(e), -1, 1)))
            }
            rotateTowards(e, t) {
                const n = this.angleTo(e);
                if (0 === n) return this;
                const i = Math.min(1, t / n);
                return this.slerp(e, i), this
            }
            identity() {
                return this.set(0, 0, 0, 1)
            }
            invert() {
                return this.conjugate()
            }
            conjugate() {
                return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
            }
            dot(e) {
                return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
            }
            lengthSq() {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            }
            length() {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
            }
            normalize() {
                let e = this.length();
                return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this
            }
            multiply(e) {
                return this.multiplyQuaternions(this, e)
            }
            premultiply(e) {
                return this.multiplyQuaternions(e, this)
            }
            multiplyQuaternions(e, t) {
                const n = e._x,
                    i = e._y,
                    r = e._z,
                    o = e._w,
                    s = t._x,
                    a = t._y,
                    l = t._z,
                    c = t._w;
                return this._x = n * c + o * s + i * l - r * a, this._y = i * c + o * a + r * s - n * l, this._z = r * c + o * l + n * a - i * s, this._w = o * c - n * s - i * a - r * l, this._onChangeCallback(), this
            }
            slerp(e, t) {
                if (0 === t) return this;
                if (1 === t) return this.copy(e);
                const n = this._x,
                    i = this._y,
                    r = this._z,
                    o = this._w;
                let s = o * e._w + n * e._x + i * e._y + r * e._z;
                if (s < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, s = -s) : this.copy(e), s >= 1) return this._w = o, this._x = n, this._y = i, this._z = r, this;
                const a = 1 - s * s;
                if (a <= Number.EPSILON) {
                    const e = 1 - t;
                    return this._w = e * o + t * this._w, this._x = e * n + t * this._x, this._y = e * i + t * this._y, this._z = e * r + t * this._z, this.normalize(), this
                }
                const l = Math.sqrt(a),
                    c = Math.atan2(l, s),
                    A = Math.sin((1 - t) * c) / l,
                    h = Math.sin(t * c) / l;
                return this._w = o * A + this._w * h, this._x = n * A + this._x * h, this._y = i * A + this._y * h, this._z = r * A + this._z * h, this._onChangeCallback(), this
            }
            slerpQuaternions(e, t, n) {
                return this.copy(e).slerp(t, n)
            }
            random() {
                const e = 2 * Math.PI * Math.random(),
                    t = 2 * Math.PI * Math.random(),
                    n = Math.random(),
                    i = Math.sqrt(1 - n),
                    r = Math.sqrt(n);
                return this.set(i * Math.sin(e), i * Math.cos(e), r * Math.sin(t), r * Math.cos(t))
            }
            equals(e) {
                return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
            }
            fromArray(e, t = 0) {
                return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this
            }
            toArray(e = [], t = 0) {
                return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
            }
            fromBufferAttribute(e, t) {
                return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this
            }
            toJSON() {
                return this.toArray()
            }
            _onChange(e) {
                return this._onChangeCallback = e, this
            }
            _onChangeCallback() {}*[Symbol.iterator]() {
                yield this._x, yield this._y, yield this._z, yield this._w
            }
        }
        class On {
            constructor(e = 0, t = 0, n = 0) {
                On.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = n
            }
            set(e, t, n) {
                return void 0 === n && (n = this.z), this.x = e, this.y = t, this.z = n, this
            }
            setScalar(e) {
                return this.x = e, this.y = e, this.z = e, this
            }
            setX(e) {
                return this.x = e, this
            }
            setY(e) {
                return this.y = e, this
            }
            setZ(e) {
                return this.z = e, this
            }
            setComponent(e, t) {
                switch (e) {
                    case 0:
                        this.x = t;
                        break;
                    case 1:
                        this.y = t;
                        break;
                    case 2:
                        this.z = t;
                        break;
                    default:
                        throw new Error("index is out of range: " + e)
                }
                return this
            }
            getComponent(e) {
                switch (e) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    default:
                        throw new Error("index is out of range: " + e)
                }
            }
            clone() {
                return new this.constructor(this.x, this.y, this.z)
            }
            copy(e) {
                return this.x = e.x, this.y = e.y, this.z = e.z, this
            }
            add(e) {
                return this.x += e.x, this.y += e.y, this.z += e.z, this
            }
            addScalar(e) {
                return this.x += e, this.y += e, this.z += e, this
            }
            addVectors(e, t) {
                return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
            }
            addScaledVector(e, t) {
                return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
            }
            sub(e) {
                return this.x -= e.x, this.y -= e.y, this.z -= e.z, this
            }
            subScalar(e) {
                return this.x -= e, this.y -= e, this.z -= e, this
            }
            subVectors(e, t) {
                return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
            }
            multiply(e) {
                return this.x *= e.x, this.y *= e.y, this.z *= e.z, this
            }
            multiplyScalar(e) {
                return this.x *= e, this.y *= e, this.z *= e, this
            }
            multiplyVectors(e, t) {
                return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
            }
            applyEuler(e) {
                return this.applyQuaternion(Hn.setFromEuler(e))
            }
            applyAxisAngle(e, t) {
                return this.applyQuaternion(Hn.setFromAxisAngle(e, t))
            }
            applyMatrix3(e) {
                const t = this.x,
                    n = this.y,
                    i = this.z,
                    r = e.elements;
                return this.x = r[0] * t + r[3] * n + r[6] * i, this.y = r[1] * t + r[4] * n + r[7] * i, this.z = r[2] * t + r[5] * n + r[8] * i, this
            }
            applyNormalMatrix(e) {
                return this.applyMatrix3(e).normalize()
            }
            applyMatrix4(e) {
                const t = this.x,
                    n = this.y,
                    i = this.z,
                    r = e.elements,
                    o = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
                return this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * o, this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * o, this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * o, this
            }
            applyQuaternion(e) {
                const t = this.x,
                    n = this.y,
                    i = this.z,
                    r = e.x,
                    o = e.y,
                    s = e.z,
                    a = e.w,
                    l = 2 * (o * i - s * n),
                    c = 2 * (s * t - r * i),
                    A = 2 * (r * n - o * t);
                return this.x = t + a * l + o * A - s * c, this.y = n + a * c + s * l - r * A, this.z = i + a * A + r * c - o * l, this
            }
            project(e) {
                return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
            }
            unproject(e) {
                return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
            }
            transformDirection(e) {
                const t = this.x,
                    n = this.y,
                    i = this.z,
                    r = e.elements;
                return this.x = r[0] * t + r[4] * n + r[8] * i, this.y = r[1] * t + r[5] * n + r[9] * i, this.z = r[2] * t + r[6] * n + r[10] * i, this.normalize()
            }
            divide(e) {
                return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
            }
            divideScalar(e) {
                return this.multiplyScalar(1 / e)
            }
            min(e) {
                return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
            }
            max(e) {
                return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
            }
            clamp(e, t) {
                return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
            }
            clampScalar(e, t) {
                return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this
            }
            clampLength(e, t) {
                const n = this.length();
                return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
            }
            floor() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
            }
            ceil() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
            }
            round() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
            }
            roundToZero() {
                return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this
            }
            negate() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
            }
            dot(e) {
                return this.x * e.x + this.y * e.y + this.z * e.z
            }
            lengthSq() {
                return this.x * this.x + this.y * this.y + this.z * this.z
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
            }
            manhattanLength() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
            }
            normalize() {
                return this.divideScalar(this.length() || 1)
            }
            setLength(e) {
                return this.normalize().multiplyScalar(e)
            }
            lerp(e, t) {
                return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
            }
            lerpVectors(e, t, n) {
                return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this
            }
            cross(e) {
                return this.crossVectors(this, e)
            }
            crossVectors(e, t) {
                const n = e.x,
                    i = e.y,
                    r = e.z,
                    o = t.x,
                    s = t.y,
                    a = t.z;
                return this.x = i * a - r * s, this.y = r * o - n * a, this.z = n * s - i * o, this
            }
            projectOnVector(e) {
                const t = e.lengthSq();
                if (0 === t) return this.set(0, 0, 0);
                const n = e.dot(this) / t;
                return this.copy(e).multiplyScalar(n)
            }
            projectOnPlane(e) {
                return Nn.copy(this).projectOnVector(e), this.sub(Nn)
            }
            reflect(e) {
                return this.sub(Nn.copy(e).multiplyScalar(2 * this.dot(e)))
            }
            angleTo(e) {
                const t = Math.sqrt(this.lengthSq() * e.lengthSq());
                if (0 === t) return Math.PI / 2;
                const n = this.dot(e) / t;
                return Math.acos(an(n, -1, 1))
            }
            distanceTo(e) {
                return Math.sqrt(this.distanceToSquared(e))
            }
            distanceToSquared(e) {
                const t = this.x - e.x,
                    n = this.y - e.y,
                    i = this.z - e.z;
                return t * t + n * n + i * i
            }
            manhattanDistanceTo(e) {
                return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
            }
            setFromSpherical(e) {
                return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
            }
            setFromSphericalCoords(e, t, n) {
                const i = Math.sin(t) * e;
                return this.x = i * Math.sin(n), this.y = Math.cos(t) * e, this.z = i * Math.cos(n), this
            }
            setFromCylindrical(e) {
                return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
            }
            setFromCylindricalCoords(e, t, n) {
                return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this
            }
            setFromMatrixPosition(e) {
                const t = e.elements;
                return this.x = t[12], this.y = t[13], this.z = t[14], this
            }
            setFromMatrixScale(e) {
                const t = this.setFromMatrixColumn(e, 0).length(),
                    n = this.setFromMatrixColumn(e, 1).length(),
                    i = this.setFromMatrixColumn(e, 2).length();
                return this.x = t, this.y = n, this.z = i, this
            }
            setFromMatrixColumn(e, t) {
                return this.fromArray(e.elements, 4 * t)
            }
            setFromMatrix3Column(e, t) {
                return this.fromArray(e.elements, 3 * t)
            }
            setFromEuler(e) {
                return this.x = e._x, this.y = e._y, this.z = e._z, this
            }
            setFromColor(e) {
                return this.x = e.r, this.y = e.g, this.z = e.b, this
            }
            equals(e) {
                return e.x === this.x && e.y === this.y && e.z === this.z
            }
            fromArray(e, t = 0) {
                return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
            }
            toArray(e = [], t = 0) {
                return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
            }
            fromBufferAttribute(e, t) {
                return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
            }
            random() {
                return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
            }
            randomDirection() {
                const e = Math.random() * Math.PI * 2,
                    t = 2 * Math.random() - 1,
                    n = Math.sqrt(1 - t * t);
                return this.x = n * Math.cos(e), this.y = t, this.z = n * Math.sin(e), this
            }*[Symbol.iterator]() {
                yield this.x, yield this.y, yield this.z
            }
        }
        const Nn = new On,
            Hn = new Vn;
        class qn {
            constructor(e = new On(1 / 0, 1 / 0, 1 / 0), t = new On(-1 / 0, -1 / 0, -1 / 0)) {
                this.isBox3 = !0, this.min = e, this.max = t
            }
            set(e, t) {
                return this.min.copy(e), this.max.copy(t), this
            }
            setFromArray(e) {
                this.makeEmpty();
                for (let t = 0, n = e.length; t < n; t += 3) this.expandByPoint(Yn.fromArray(e, t));
                return this
            }
            setFromBufferAttribute(e) {
                this.makeEmpty();
                for (let t = 0, n = e.count; t < n; t++) this.expandByPoint(Yn.fromBufferAttribute(e, t));
                return this
            }
            setFromPoints(e) {
                this.makeEmpty();
                for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
                return this
            }
            setFromCenterAndSize(e, t) {
                const n = Yn.copy(t).multiplyScalar(.5);
                return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
            }
            setFromObject(e, t = !1) {
                return this.makeEmpty(), this.expandByObject(e, t)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                return this.min.copy(e.min), this.max.copy(e.max), this
            }
            makeEmpty() {
                return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
            }
            isEmpty() {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            }
            getCenter(e) {
                return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
            }
            getSize(e) {
                return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
            }
            expandByPoint(e) {
                return this.min.min(e), this.max.max(e), this
            }
            expandByVector(e) {
                return this.min.sub(e), this.max.add(e), this
            }
            expandByScalar(e) {
                return this.min.addScalar(-e), this.max.addScalar(e), this
            }
            expandByObject(e, t = !1) {
                e.updateWorldMatrix(!1, !1);
                const n = e.geometry;
                if (void 0 !== n) {
                    const i = n.getAttribute("position");
                    if (!0 === t && void 0 !== i && !0 !== e.isInstancedMesh)
                        for (let t = 0, n = i.count; t < n; t++) !0 === e.isMesh ? e.getVertexPosition(t, Yn) : Yn.fromBufferAttribute(i, t), Yn.applyMatrix4(e.matrixWorld), this.expandByPoint(Yn);
                    else void 0 !== e.boundingBox ? (null === e.boundingBox && e.computeBoundingBox(), Jn.copy(e.boundingBox)) : (null === n.boundingBox && n.computeBoundingBox(), Jn.copy(n.boundingBox)), Jn.applyMatrix4(e.matrixWorld), this.union(Jn)
                }
                const i = e.children;
                for (let e = 0, n = i.length; e < n; e++) this.expandByObject(i[e], t);
                return this
            }
            containsPoint(e) {
                return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
            }
            containsBox(e) {
                return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
            }
            getParameter(e, t) {
                return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
            }
            intersectsBox(e) {
                return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
            }
            intersectsSphere(e) {
                return this.clampPoint(e.center, Yn), Yn.distanceToSquared(e.center) <= e.radius * e.radius
            }
            intersectsPlane(e) {
                let t, n;
                return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant
            }
            intersectsTriangle(e) {
                if (this.isEmpty()) return !1;
                this.getCenter(ei), ti.subVectors(this.max, ei), Wn.subVectors(e.a, ei), zn.subVectors(e.b, ei), Xn.subVectors(e.c, ei), Zn.subVectors(zn, Wn), _n.subVectors(Xn, zn), $n.subVectors(Wn, Xn);
                let t = [0, -Zn.z, Zn.y, 0, -_n.z, _n.y, 0, -$n.z, $n.y, Zn.z, 0, -Zn.x, _n.z, 0, -_n.x, $n.z, 0, -$n.x, -Zn.y, Zn.x, 0, -_n.y, _n.x, 0, -$n.y, $n.x, 0];
                return !!ri(t, Wn, zn, Xn, ti) && (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!ri(t, Wn, zn, Xn, ti) && (ni.crossVectors(Zn, _n), t = [ni.x, ni.y, ni.z], ri(t, Wn, zn, Xn, ti)))
            }
            clampPoint(e, t) {
                return t.copy(e).clamp(this.min, this.max)
            }
            distanceToPoint(e) {
                return this.clampPoint(e, Yn).distanceTo(e)
            }
            getBoundingSphere(e) {
                return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = .5 * this.getSize(Yn).length()), e
            }
            intersect(e) {
                return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
            }
            union(e) {
                return this.min.min(e.min), this.max.max(e.max), this
            }
            applyMatrix4(e) {
                return this.isEmpty() || (jn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), jn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), jn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), jn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), jn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), jn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), jn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), jn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(jn)), this
            }
            translate(e) {
                return this.min.add(e), this.max.add(e), this
            }
            equals(e) {
                return e.min.equals(this.min) && e.max.equals(this.max)
            }
        }
        const jn = [new On, new On, new On, new On, new On, new On, new On, new On],
            Yn = new On,
            Jn = new qn,
            Wn = new On,
            zn = new On,
            Xn = new On,
            Zn = new On,
            _n = new On,
            $n = new On,
            ei = new On,
            ti = new On,
            ni = new On,
            ii = new On;

        function ri(e, t, n, i, r) {
            for (let o = 0, s = e.length - 3; o <= s; o += 3) {
                ii.fromArray(e, o);
                const s = r.x * Math.abs(ii.x) + r.y * Math.abs(ii.y) + r.z * Math.abs(ii.z),
                    a = t.dot(ii),
                    l = n.dot(ii),
                    c = i.dot(ii);
                if (Math.max(-Math.max(a, l, c), Math.min(a, l, c)) > s) return !1
            }
            return !0
        }
        const oi = new qn,
            si = new On,
            ai = new On;
        class li {
            constructor(e = new On, t = -1) {
                this.isSphere = !0, this.center = e, this.radius = t
            }
            set(e, t) {
                return this.center.copy(e), this.radius = t, this
            }
            setFromPoints(e, t) {
                const n = this.center;
                void 0 !== t ? n.copy(t) : oi.setFromPoints(e).getCenter(n);
                let i = 0;
                for (let t = 0, r = e.length; t < r; t++) i = Math.max(i, n.distanceToSquared(e[t]));
                return this.radius = Math.sqrt(i), this
            }
            copy(e) {
                return this.center.copy(e.center), this.radius = e.radius, this
            }
            isEmpty() {
                return this.radius < 0
            }
            makeEmpty() {
                return this.center.set(0, 0, 0), this.radius = -1, this
            }
            containsPoint(e) {
                return e.distanceToSquared(this.center) <= this.radius * this.radius
            }
            distanceToPoint(e) {
                return e.distanceTo(this.center) - this.radius
            }
            intersectsSphere(e) {
                const t = this.radius + e.radius;
                return e.center.distanceToSquared(this.center) <= t * t
            }
            intersectsBox(e) {
                return e.intersectsSphere(this)
            }
            intersectsPlane(e) {
                return Math.abs(e.distanceToPoint(this.center)) <= this.radius
            }
            clampPoint(e, t) {
                const n = this.center.distanceToSquared(e);
                return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
            }
            getBoundingBox(e) {
                return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e)
            }
            applyMatrix4(e) {
                return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
            }
            translate(e) {
                return this.center.add(e), this
            }
            expandByPoint(e) {
                if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this;
                si.subVectors(e, this.center);
                const t = si.lengthSq();
                if (t > this.radius * this.radius) {
                    const e = Math.sqrt(t),
                        n = .5 * (e - this.radius);
                    this.center.addScaledVector(si, n / e), this.radius += n
                }
                return this
            }
            union(e) {
                return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (!0 === this.center.equals(e.center) ? this.radius = Math.max(this.radius, e.radius) : (ai.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(si.copy(e.center).add(ai)), this.expandByPoint(si.copy(e.center).sub(ai))), this)
            }
            equals(e) {
                return e.center.equals(this.center) && e.radius === this.radius
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const ci = new On,
            Ai = new On,
            hi = new On,
            ui = new On,
            di = new On,
            pi = new On,
            gi = new On;
        class fi {
            constructor(e = new On, t = new On(0, 0, -1)) {
                this.origin = e, this.direction = t
            }
            set(e, t) {
                return this.origin.copy(e), this.direction.copy(t), this
            }
            copy(e) {
                return this.origin.copy(e.origin), this.direction.copy(e.direction), this
            }
            at(e, t) {
                return t.copy(this.origin).addScaledVector(this.direction, e)
            }
            lookAt(e) {
                return this.direction.copy(e).sub(this.origin).normalize(), this
            }
            recast(e) {
                return this.origin.copy(this.at(e, ci)), this
            }
            closestPointToPoint(e, t) {
                t.subVectors(e, this.origin);
                const n = t.dot(this.direction);
                return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n)
            }
            distanceToPoint(e) {
                return Math.sqrt(this.distanceSqToPoint(e))
            }
            distanceSqToPoint(e) {
                const t = ci.subVectors(e, this.origin).dot(this.direction);
                return t < 0 ? this.origin.distanceToSquared(e) : (ci.copy(this.origin).addScaledVector(this.direction, t), ci.distanceToSquared(e))
            }
            distanceSqToSegment(e, t, n, i) {
                Ai.copy(e).add(t).multiplyScalar(.5), hi.copy(t).sub(e).normalize(), ui.copy(this.origin).sub(Ai);
                const r = .5 * e.distanceTo(t),
                    o = -this.direction.dot(hi),
                    s = ui.dot(this.direction),
                    a = -ui.dot(hi),
                    l = ui.lengthSq(),
                    c = Math.abs(1 - o * o);
                let A, h, u, d;
                if (c > 0)
                    if (A = o * a - s, h = o * s - a, d = r * c, A >= 0)
                        if (h >= -d)
                            if (h <= d) {
                                const e = 1 / c;
                                A *= e, h *= e, u = A * (A + o * h + 2 * s) + h * (o * A + h + 2 * a) + l
                            } else h = r, A = Math.max(0, -(o * h + s)), u = -A * A + h * (h + 2 * a) + l;
                else h = -r, A = Math.max(0, -(o * h + s)), u = -A * A + h * (h + 2 * a) + l;
                else h <= -d ? (A = Math.max(0, -(-o * r + s)), h = A > 0 ? -r : Math.min(Math.max(-r, -a), r), u = -A * A + h * (h + 2 * a) + l) : h <= d ? (A = 0, h = Math.min(Math.max(-r, -a), r), u = h * (h + 2 * a) + l) : (A = Math.max(0, -(o * r + s)), h = A > 0 ? r : Math.min(Math.max(-r, -a), r), u = -A * A + h * (h + 2 * a) + l);
                else h = o > 0 ? -r : r, A = Math.max(0, -(o * h + s)), u = -A * A + h * (h + 2 * a) + l;
                return n && n.copy(this.origin).addScaledVector(this.direction, A), i && i.copy(Ai).addScaledVector(hi, h), u
            }
            intersectSphere(e, t) {
                ci.subVectors(e.center, this.origin);
                const n = ci.dot(this.direction),
                    i = ci.dot(ci) - n * n,
                    r = e.radius * e.radius;
                if (i > r) return null;
                const o = Math.sqrt(r - i),
                    s = n - o,
                    a = n + o;
                return a < 0 ? null : s < 0 ? this.at(a, t) : this.at(s, t)
            }
            intersectsSphere(e) {
                return this.distanceSqToPoint(e.center) <= e.radius * e.radius
            }
            distanceToPlane(e) {
                const t = e.normal.dot(this.direction);
                if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
                const n = -(this.origin.dot(e.normal) + e.constant) / t;
                return n >= 0 ? n : null
            }
            intersectPlane(e, t) {
                const n = this.distanceToPlane(e);
                return null === n ? null : this.at(n, t)
            }
            intersectsPlane(e) {
                const t = e.distanceToPoint(this.origin);
                if (0 === t) return !0;
                return e.normal.dot(this.direction) * t < 0
            }
            intersectBox(e, t) {
                let n, i, r, o, s, a;
                const l = 1 / this.direction.x,
                    c = 1 / this.direction.y,
                    A = 1 / this.direction.z,
                    h = this.origin;
                return l >= 0 ? (n = (e.min.x - h.x) * l, i = (e.max.x - h.x) * l) : (n = (e.max.x - h.x) * l, i = (e.min.x - h.x) * l), c >= 0 ? (r = (e.min.y - h.y) * c, o = (e.max.y - h.y) * c) : (r = (e.max.y - h.y) * c, o = (e.min.y - h.y) * c), n > o || r > i ? null : ((r > n || isNaN(n)) && (n = r), (o < i || isNaN(i)) && (i = o), A >= 0 ? (s = (e.min.z - h.z) * A, a = (e.max.z - h.z) * A) : (s = (e.max.z - h.z) * A, a = (e.min.z - h.z) * A), n > a || s > i ? null : ((s > n || n != n) && (n = s), (a < i || i != i) && (i = a), i < 0 ? null : this.at(n >= 0 ? n : i, t)))
            }
            intersectsBox(e) {
                return null !== this.intersectBox(e, ci)
            }
            intersectTriangle(e, t, n, i, r) {
                di.subVectors(t, e), pi.subVectors(n, e), gi.crossVectors(di, pi);
                let o, s = this.direction.dot(gi);
                if (s > 0) {
                    if (i) return null;
                    o = 1
                } else {
                    if (!(s < 0)) return null;
                    o = -1, s = -s
                }
                ui.subVectors(this.origin, e);
                const a = o * this.direction.dot(pi.crossVectors(ui, pi));
                if (a < 0) return null;
                const l = o * this.direction.dot(di.cross(ui));
                if (l < 0) return null;
                if (a + l > s) return null;
                const c = -o * ui.dot(gi);
                return c < 0 ? null : this.at(c / s, r)
            }
            applyMatrix4(e) {
                return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
            }
            equals(e) {
                return e.origin.equals(this.origin) && e.direction.equals(this.direction)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        class mi {
            constructor(e, t, n, i, r, o, s, a, l, c, A, h, u, d, p, g) {
                mi.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], void 0 !== e && this.set(e, t, n, i, r, o, s, a, l, c, A, h, u, d, p, g)
            }
            set(e, t, n, i, r, o, s, a, l, c, A, h, u, d, p, g) {
                const f = this.elements;
                return f[0] = e, f[4] = t, f[8] = n, f[12] = i, f[1] = r, f[5] = o, f[9] = s, f[13] = a, f[2] = l, f[6] = c, f[10] = A, f[14] = h, f[3] = u, f[7] = d, f[11] = p, f[15] = g, this
            }
            identity() {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            }
            clone() {
                return (new mi).fromArray(this.elements)
            }
            copy(e) {
                const t = this.elements,
                    n = e.elements;
                return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this
            }
            copyPosition(e) {
                const t = this.elements,
                    n = e.elements;
                return t[12] = n[12], t[13] = n[13], t[14] = n[14], this
            }
            setFromMatrix3(e) {
                const t = e.elements;
                return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this
            }
            extractBasis(e, t, n) {
                return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
            }
            makeBasis(e, t, n) {
                return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this
            }
            extractRotation(e) {
                const t = this.elements,
                    n = e.elements,
                    i = 1 / Ei.setFromMatrixColumn(e, 0).length(),
                    r = 1 / Ei.setFromMatrixColumn(e, 1).length(),
                    o = 1 / Ei.setFromMatrixColumn(e, 2).length();
                return t[0] = n[0] * i, t[1] = n[1] * i, t[2] = n[2] * i, t[3] = 0, t[4] = n[4] * r, t[5] = n[5] * r, t[6] = n[6] * r, t[7] = 0, t[8] = n[8] * o, t[9] = n[9] * o, t[10] = n[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
            }
            makeRotationFromEuler(e) {
                const t = this.elements,
                    n = e.x,
                    i = e.y,
                    r = e.z,
                    o = Math.cos(n),
                    s = Math.sin(n),
                    a = Math.cos(i),
                    l = Math.sin(i),
                    c = Math.cos(r),
                    A = Math.sin(r);
                if ("XYZ" === e.order) {
                    const e = o * c,
                        n = o * A,
                        i = s * c,
                        r = s * A;
                    t[0] = a * c, t[4] = -a * A, t[8] = l, t[1] = n + i * l, t[5] = e - r * l, t[9] = -s * a, t[2] = r - e * l, t[6] = i + n * l, t[10] = o * a
                } else if ("YXZ" === e.order) {
                    const e = a * c,
                        n = a * A,
                        i = l * c,
                        r = l * A;
                    t[0] = e + r * s, t[4] = i * s - n, t[8] = o * l, t[1] = o * A, t[5] = o * c, t[9] = -s, t[2] = n * s - i, t[6] = r + e * s, t[10] = o * a
                } else if ("ZXY" === e.order) {
                    const e = a * c,
                        n = a * A,
                        i = l * c,
                        r = l * A;
                    t[0] = e - r * s, t[4] = -o * A, t[8] = i + n * s, t[1] = n + i * s, t[5] = o * c, t[9] = r - e * s, t[2] = -o * l, t[6] = s, t[10] = o * a
                } else if ("ZYX" === e.order) {
                    const e = o * c,
                        n = o * A,
                        i = s * c,
                        r = s * A;
                    t[0] = a * c, t[4] = i * l - n, t[8] = e * l + r, t[1] = a * A, t[5] = r * l + e, t[9] = n * l - i, t[2] = -l, t[6] = s * a, t[10] = o * a
                } else if ("YZX" === e.order) {
                    const e = o * a,
                        n = o * l,
                        i = s * a,
                        r = s * l;
                    t[0] = a * c, t[4] = r - e * A, t[8] = i * A + n, t[1] = A, t[5] = o * c, t[9] = -s * c, t[2] = -l * c, t[6] = n * A + i, t[10] = e - r * A
                } else if ("XZY" === e.order) {
                    const e = o * a,
                        n = o * l,
                        i = s * a,
                        r = s * l;
                    t[0] = a * c, t[4] = -A, t[8] = l * c, t[1] = e * A + r, t[5] = o * c, t[9] = n * A - i, t[2] = i * A - n, t[6] = s * c, t[10] = r * A + e
                }
                return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
            }
            makeRotationFromQuaternion(e) {
                return this.compose(Ii, e, Si)
            }
            lookAt(e, t, n) {
                const i = this.elements;
                return xi.subVectors(e, t), 0 === xi.lengthSq() && (xi.z = 1), xi.normalize(), vi.crossVectors(n, xi), 0 === vi.lengthSq() && (1 === Math.abs(n.z) ? xi.x += 1e-4 : xi.z += 1e-4, xi.normalize(), vi.crossVectors(n, xi)), vi.normalize(), Bi.crossVectors(xi, vi), i[0] = vi.x, i[4] = Bi.x, i[8] = xi.x, i[1] = vi.y, i[5] = Bi.y, i[9] = xi.y, i[2] = vi.z, i[6] = Bi.z, i[10] = xi.z, this
            }
            multiply(e) {
                return this.multiplyMatrices(this, e)
            }
            premultiply(e) {
                return this.multiplyMatrices(e, this)
            }
            multiplyMatrices(e, t) {
                const n = e.elements,
                    i = t.elements,
                    r = this.elements,
                    o = n[0],
                    s = n[4],
                    a = n[8],
                    l = n[12],
                    c = n[1],
                    A = n[5],
                    h = n[9],
                    u = n[13],
                    d = n[2],
                    p = n[6],
                    g = n[10],
                    f = n[14],
                    m = n[3],
                    E = n[7],
                    C = n[11],
                    I = n[15],
                    S = i[0],
                    v = i[4],
                    B = i[8],
                    x = i[12],
                    y = i[1],
                    w = i[5],
                    b = i[9],
                    Q = i[13],
                    U = i[2],
                    M = i[6],
                    R = i[10],
                    T = i[14],
                    F = i[3],
                    D = i[7],
                    k = i[11],
                    L = i[15];
                return r[0] = o * S + s * y + a * U + l * F, r[4] = o * v + s * w + a * M + l * D, r[8] = o * B + s * b + a * R + l * k, r[12] = o * x + s * Q + a * T + l * L, r[1] = c * S + A * y + h * U + u * F, r[5] = c * v + A * w + h * M + u * D, r[9] = c * B + A * b + h * R + u * k, r[13] = c * x + A * Q + h * T + u * L, r[2] = d * S + p * y + g * U + f * F, r[6] = d * v + p * w + g * M + f * D, r[10] = d * B + p * b + g * R + f * k, r[14] = d * x + p * Q + g * T + f * L, r[3] = m * S + E * y + C * U + I * F, r[7] = m * v + E * w + C * M + I * D, r[11] = m * B + E * b + C * R + I * k, r[15] = m * x + E * Q + C * T + I * L, this
            }
            multiplyScalar(e) {
                const t = this.elements;
                return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
            }
            determinant() {
                const e = this.elements,
                    t = e[0],
                    n = e[4],
                    i = e[8],
                    r = e[12],
                    o = e[1],
                    s = e[5],
                    a = e[9],
                    l = e[13],
                    c = e[2],
                    A = e[6],
                    h = e[10],
                    u = e[14];
                return e[3] * (+r * a * A - i * l * A - r * s * h + n * l * h + i * s * u - n * a * u) + e[7] * (+t * a * u - t * l * h + r * o * h - i * o * u + i * l * c - r * a * c) + e[11] * (+t * l * A - t * s * u - r * o * A + n * o * u + r * s * c - n * l * c) + e[15] * (-i * s * c - t * a * A + t * s * h + i * o * A - n * o * h + n * a * c)
            }
            transpose() {
                const e = this.elements;
                let t;
                return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
            }
            setPosition(e, t, n) {
                const i = this.elements;
                return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = t, i[14] = n), this
            }
            invert() {
                const e = this.elements,
                    t = e[0],
                    n = e[1],
                    i = e[2],
                    r = e[3],
                    o = e[4],
                    s = e[5],
                    a = e[6],
                    l = e[7],
                    c = e[8],
                    A = e[9],
                    h = e[10],
                    u = e[11],
                    d = e[12],
                    p = e[13],
                    g = e[14],
                    f = e[15],
                    m = A * g * l - p * h * l + p * a * u - s * g * u - A * a * f + s * h * f,
                    E = d * h * l - c * g * l - d * a * u + o * g * u + c * a * f - o * h * f,
                    C = c * p * l - d * A * l + d * s * u - o * p * u - c * s * f + o * A * f,
                    I = d * A * a - c * p * a - d * s * h + o * p * h + c * s * g - o * A * g,
                    S = t * m + n * E + i * C + r * I;
                if (0 === S) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                const v = 1 / S;
                return e[0] = m * v, e[1] = (p * h * r - A * g * r - p * i * u + n * g * u + A * i * f - n * h * f) * v, e[2] = (s * g * r - p * a * r + p * i * l - n * g * l - s * i * f + n * a * f) * v, e[3] = (A * a * r - s * h * r - A * i * l + n * h * l + s * i * u - n * a * u) * v, e[4] = E * v, e[5] = (c * g * r - d * h * r + d * i * u - t * g * u - c * i * f + t * h * f) * v, e[6] = (d * a * r - o * g * r - d * i * l + t * g * l + o * i * f - t * a * f) * v, e[7] = (o * h * r - c * a * r + c * i * l - t * h * l - o * i * u + t * a * u) * v, e[8] = C * v, e[9] = (d * A * r - c * p * r - d * n * u + t * p * u + c * n * f - t * A * f) * v, e[10] = (o * p * r - d * s * r + d * n * l - t * p * l - o * n * f + t * s * f) * v, e[11] = (c * s * r - o * A * r - c * n * l + t * A * l + o * n * u - t * s * u) * v, e[12] = I * v, e[13] = (c * p * i - d * A * i + d * n * h - t * p * h - c * n * g + t * A * g) * v, e[14] = (d * s * i - o * p * i - d * n * a + t * p * a + o * n * g - t * s * g) * v, e[15] = (o * A * i - c * s * i + c * n * a - t * A * a - o * n * h + t * s * h) * v, this
            }
            scale(e) {
                const t = this.elements,
                    n = e.x,
                    i = e.y,
                    r = e.z;
                return t[0] *= n, t[4] *= i, t[8] *= r, t[1] *= n, t[5] *= i, t[9] *= r, t[2] *= n, t[6] *= i, t[10] *= r, t[3] *= n, t[7] *= i, t[11] *= r, this
            }
            getMaxScaleOnAxis() {
                const e = this.elements,
                    t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
                    n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
                    i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
                return Math.sqrt(Math.max(t, n, i))
            }
            makeTranslation(e, t, n) {
                return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this
            }
            makeRotationX(e) {
                const t = Math.cos(e),
                    n = Math.sin(e);
                return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
            }
            makeRotationY(e) {
                const t = Math.cos(e),
                    n = Math.sin(e);
                return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
            }
            makeRotationZ(e) {
                const t = Math.cos(e),
                    n = Math.sin(e);
                return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            }
            makeRotationAxis(e, t) {
                const n = Math.cos(t),
                    i = Math.sin(t),
                    r = 1 - n,
                    o = e.x,
                    s = e.y,
                    a = e.z,
                    l = r * o,
                    c = r * s;
                return this.set(l * o + n, l * s - i * a, l * a + i * s, 0, l * s + i * a, c * s + n, c * a - i * o, 0, l * a - i * s, c * a + i * o, r * a * a + n, 0, 0, 0, 0, 1), this
            }
            makeScale(e, t, n) {
                return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
            }
            makeShear(e, t, n, i, r, o) {
                return this.set(1, n, r, 0, e, 1, o, 0, t, i, 1, 0, 0, 0, 0, 1), this
            }
            compose(e, t, n) {
                const i = this.elements,
                    r = t._x,
                    o = t._y,
                    s = t._z,
                    a = t._w,
                    l = r + r,
                    c = o + o,
                    A = s + s,
                    h = r * l,
                    u = r * c,
                    d = r * A,
                    p = o * c,
                    g = o * A,
                    f = s * A,
                    m = a * l,
                    E = a * c,
                    C = a * A,
                    I = n.x,
                    S = n.y,
                    v = n.z;
                return i[0] = (1 - (p + f)) * I, i[1] = (u + C) * I, i[2] = (d - E) * I, i[3] = 0, i[4] = (u - C) * S, i[5] = (1 - (h + f)) * S, i[6] = (g + m) * S, i[7] = 0, i[8] = (d + E) * v, i[9] = (g - m) * v, i[10] = (1 - (h + p)) * v, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this
            }
            decompose(e, t, n) {
                const i = this.elements;
                let r = Ei.set(i[0], i[1], i[2]).length();
                const o = Ei.set(i[4], i[5], i[6]).length(),
                    s = Ei.set(i[8], i[9], i[10]).length();
                this.determinant() < 0 && (r = -r), e.x = i[12], e.y = i[13], e.z = i[14], Ci.copy(this);
                const a = 1 / r,
                    l = 1 / o,
                    c = 1 / s;
                return Ci.elements[0] *= a, Ci.elements[1] *= a, Ci.elements[2] *= a, Ci.elements[4] *= l, Ci.elements[5] *= l, Ci.elements[6] *= l, Ci.elements[8] *= c, Ci.elements[9] *= c, Ci.elements[10] *= c, t.setFromRotationMatrix(Ci), n.x = r, n.y = o, n.z = s, this
            }
            makePerspective(e, t, n, i, r, o, s = 2e3) {
                const a = this.elements,
                    l = 2 * r / (t - e),
                    c = 2 * r / (n - i),
                    A = (t + e) / (t - e),
                    h = (n + i) / (n - i);
                let u, d;
                if (s === _t) u = -(o + r) / (o - r), d = -2 * o * r / (o - r);
                else {
                    if (s !== $t) throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + s);
                    u = -o / (o - r), d = -o * r / (o - r)
                }
                return a[0] = l, a[4] = 0, a[8] = A, a[12] = 0, a[1] = 0, a[5] = c, a[9] = h, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = u, a[14] = d, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
            }
            makeOrthographic(e, t, n, i, r, o, s = 2e3) {
                const a = this.elements,
                    l = 1 / (t - e),
                    c = 1 / (n - i),
                    A = 1 / (o - r),
                    h = (t + e) * l,
                    u = (n + i) * c;
                let d, p;
                if (s === _t) d = (o + r) * A, p = -2 * A;
                else {
                    if (s !== $t) throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + s);
                    d = r * A, p = -1 * A
                }
                return a[0] = 2 * l, a[4] = 0, a[8] = 0, a[12] = -h, a[1] = 0, a[5] = 2 * c, a[9] = 0, a[13] = -u, a[2] = 0, a[6] = 0, a[10] = p, a[14] = -d, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
            }
            equals(e) {
                const t = this.elements,
                    n = e.elements;
                for (let e = 0; e < 16; e++)
                    if (t[e] !== n[e]) return !1;
                return !0
            }
            fromArray(e, t = 0) {
                for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
                return this
            }
            toArray(e = [], t = 0) {
                const n = this.elements;
                return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e
            }
        }
        const Ei = new On,
            Ci = new mi,
            Ii = new On(0, 0, 0),
            Si = new On(1, 1, 1),
            vi = new On,
            Bi = new On,
            xi = new On,
            yi = new mi,
            wi = new Vn;
        class bi {
            constructor(e = 0, t = 0, n = 0, i = bi.DEFAULT_ORDER) {
                this.isEuler = !0, this._x = e, this._y = t, this._z = n, this._order = i
            }
            get x() {
                return this._x
            }
            set x(e) {
                this._x = e, this._onChangeCallback()
            }
            get y() {
                return this._y
            }
            set y(e) {
                this._y = e, this._onChangeCallback()
            }
            get z() {
                return this._z
            }
            set z(e) {
                this._z = e, this._onChangeCallback()
            }
            get order() {
                return this._order
            }
            set order(e) {
                this._order = e, this._onChangeCallback()
            }
            set(e, t, n, i = this._order) {
                return this._x = e, this._y = t, this._z = n, this._order = i, this._onChangeCallback(), this
            }
            clone() {
                return new this.constructor(this._x, this._y, this._z, this._order)
            }
            copy(e) {
                return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this
            }
            setFromRotationMatrix(e, t = this._order, n = !0) {
                const i = e.elements,
                    r = i[0],
                    o = i[4],
                    s = i[8],
                    a = i[1],
                    l = i[5],
                    c = i[9],
                    A = i[2],
                    h = i[6],
                    u = i[10];
                switch (t) {
                    case "XYZ":
                        this._y = Math.asin(an(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(-c, u), this._z = Math.atan2(-o, r)) : (this._x = Math.atan2(h, l), this._z = 0);
                        break;
                    case "YXZ":
                        this._x = Math.asin(-an(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(s, u), this._z = Math.atan2(a, l)) : (this._y = Math.atan2(-A, r), this._z = 0);
                        break;
                    case "ZXY":
                        this._x = Math.asin(an(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(-A, u), this._z = Math.atan2(-o, l)) : (this._y = 0, this._z = Math.atan2(a, r));
                        break;
                    case "ZYX":
                        this._y = Math.asin(-an(A, -1, 1)), Math.abs(A) < .9999999 ? (this._x = Math.atan2(h, u), this._z = Math.atan2(a, r)) : (this._x = 0, this._z = Math.atan2(-o, l));
                        break;
                    case "YZX":
                        this._z = Math.asin(an(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-A, r)) : (this._x = 0, this._y = Math.atan2(s, u));
                        break;
                    case "XZY":
                        this._z = Math.asin(-an(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(h, l), this._y = Math.atan2(s, r)) : (this._x = Math.atan2(-c, u), this._y = 0);
                        break;
                    default:
                        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
                }
                return this._order = t, !0 === n && this._onChangeCallback(), this
            }
            setFromQuaternion(e, t, n) {
                return yi.makeRotationFromQuaternion(e), this.setFromRotationMatrix(yi, t, n)
            }
            setFromVector3(e, t = this._order) {
                return this.set(e.x, e.y, e.z, t)
            }
            reorder(e) {
                return wi.setFromEuler(this), this.setFromQuaternion(wi, e)
            }
            equals(e) {
                return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
            }
            fromArray(e) {
                return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this._onChangeCallback(), this
            }
            toArray(e = [], t = 0) {
                return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
            }
            _onChange(e) {
                return this._onChangeCallback = e, this
            }
            _onChangeCallback() {}*[Symbol.iterator]() {
                yield this._x, yield this._y, yield this._z, yield this._order
            }
        }
        bi.DEFAULT_ORDER = "XYZ";
        class Qi {
            constructor() {
                this.mask = 1
            }
            set(e) {
                this.mask = 1 << e >>> 0
            }
            enable(e) {
                this.mask |= 1 << e
            }
            enableAll() {
                this.mask = -1
            }
            toggle(e) {
                this.mask ^= 1 << e
            }
            disable(e) {
                this.mask &= ~(1 << e)
            }
            disableAll() {
                this.mask = 0
            }
            test(e) {
                return !!(this.mask & e.mask)
            }
            isEnabled(e) {
                return !!(this.mask & 1 << e)
            }
        }
        let Ui = 0;
        const Mi = new On,
            Ri = new Vn,
            Ti = new mi,
            Fi = new On,
            Di = new On,
            ki = new On,
            Li = new Vn,
            Ki = new On(1, 0, 0),
            Pi = new On(0, 1, 0),
            Gi = new On(0, 0, 1),
            Vi = {
                type: "added"
            },
            Oi = {
                type: "removed"
            },
            Ni = {
                type: "childadded",
                child: null
            },
            Hi = {
                type: "childremoved",
                child: null
            };
        class qi extends en {
            constructor() {
                super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
                    value: Ui++
                }), this.uuid = sn(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = qi.DEFAULT_UP.clone();
                const e = new On,
                    t = new bi,
                    n = new Vn,
                    i = new On(1, 1, 1);
                t._onChange((function() {
                    n.setFromEuler(t, !1)
                })), n._onChange((function() {
                    t.setFromQuaternion(n, void 0, !1)
                })), Object.defineProperties(this, {
                    position: {
                        configurable: !0,
                        enumerable: !0,
                        value: e
                    },
                    rotation: {
                        configurable: !0,
                        enumerable: !0,
                        value: t
                    },
                    quaternion: {
                        configurable: !0,
                        enumerable: !0,
                        value: n
                    },
                    scale: {
                        configurable: !0,
                        enumerable: !0,
                        value: i
                    },
                    modelViewMatrix: {
                        value: new mi
                    },
                    normalMatrix: {
                        value: new pn
                    }
                }), this.matrix = new mi, this.matrixWorld = new mi, this.matrixAutoUpdate = qi.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = qi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new Qi, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
            }
            onBeforeShadow() {}
            onAfterShadow() {}
            onBeforeRender() {}
            onAfterRender() {}
            applyMatrix4(e) {
                this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale)
            }
            applyQuaternion(e) {
                return this.quaternion.premultiply(e), this
            }
            setRotationFromAxisAngle(e, t) {
                this.quaternion.setFromAxisAngle(e, t)
            }
            setRotationFromEuler(e) {
                this.quaternion.setFromEuler(e, !0)
            }
            setRotationFromMatrix(e) {
                this.quaternion.setFromRotationMatrix(e)
            }
            setRotationFromQuaternion(e) {
                this.quaternion.copy(e)
            }
            rotateOnAxis(e, t) {
                return Ri.setFromAxisAngle(e, t), this.quaternion.multiply(Ri), this
            }
            rotateOnWorldAxis(e, t) {
                return Ri.setFromAxisAngle(e, t), this.quaternion.premultiply(Ri), this
            }
            rotateX(e) {
                return this.rotateOnAxis(Ki, e)
            }
            rotateY(e) {
                return this.rotateOnAxis(Pi, e)
            }
            rotateZ(e) {
                return this.rotateOnAxis(Gi, e)
            }
            translateOnAxis(e, t) {
                return Mi.copy(e).applyQuaternion(this.quaternion), this.position.add(Mi.multiplyScalar(t)), this
            }
            translateX(e) {
                return this.translateOnAxis(Ki, e)
            }
            translateY(e) {
                return this.translateOnAxis(Pi, e)
            }
            translateZ(e) {
                return this.translateOnAxis(Gi, e)
            }
            localToWorld(e) {
                return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld)
            }
            worldToLocal(e) {
                return this.updateWorldMatrix(!0, !1), e.applyMatrix4(Ti.copy(this.matrixWorld).invert())
            }
            lookAt(e, t, n) {
                e.isVector3 ? Fi.copy(e) : Fi.set(e, t, n);
                const i = this.parent;
                this.updateWorldMatrix(!0, !1), Di.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Ti.lookAt(Di, Fi, this.up) : Ti.lookAt(Fi, Di, this.up), this.quaternion.setFromRotationMatrix(Ti), i && (Ti.extractRotation(i.matrixWorld), Ri.setFromRotationMatrix(Ti), this.quaternion.premultiply(Ri.invert()))
            }
            add(e) {
                if (arguments.length > 1) {
                    for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
                    return this
                }
                return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(Vi), Ni.child = e, this.dispatchEvent(Ni), Ni.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this)
            }
            remove(e) {
                if (arguments.length > 1) {
                    for (let e = 0; e < arguments.length; e++) this.remove(arguments[e]);
                    return this
                }
                const t = this.children.indexOf(e);
                return -1 !== t && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(Oi), Hi.child = e, this.dispatchEvent(Hi), Hi.child = null), this
            }
            removeFromParent() {
                const e = this.parent;
                return null !== e && e.remove(this), this
            }
            clear() {
                return this.remove(...this.children)
            }
            attach(e) {
                return this.updateWorldMatrix(!0, !1), Ti.copy(this.matrixWorld).invert(), null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), Ti.multiply(e.parent.matrixWorld)), e.applyMatrix4(Ti), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(Vi), Ni.child = e, this.dispatchEvent(Ni), Ni.child = null, this
            }
            getObjectById(e) {
                return this.getObjectByProperty("id", e)
            }
            getObjectByName(e) {
                return this.getObjectByProperty("name", e)
            }
            getObjectByProperty(e, t) {
                if (this[e] === t) return this;
                for (let n = 0, i = this.children.length; n < i; n++) {
                    const i = this.children[n].getObjectByProperty(e, t);
                    if (void 0 !== i) return i
                }
            }
            getObjectsByProperty(e, t, n = []) {
                this[e] === t && n.push(this);
                const i = this.children;
                for (let r = 0, o = i.length; r < o; r++) i[r].getObjectsByProperty(e, t, n);
                return n
            }
            getWorldPosition(e) {
                return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
            }
            getWorldQuaternion(e) {
                return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Di, e, ki), e
            }
            getWorldScale(e) {
                return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Di, Li, e), e
            }
            getWorldDirection(e) {
                this.updateWorldMatrix(!0, !1);
                const t = this.matrixWorld.elements;
                return e.set(t[8], t[9], t[10]).normalize()
            }
            raycast() {}
            traverse(e) {
                e(this);
                const t = this.children;
                for (let n = 0, i = t.length; n < i; n++) t[n].traverse(e)
            }
            traverseVisible(e) {
                if (!1 === this.visible) return;
                e(this);
                const t = this.children;
                for (let n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e)
            }
            traverseAncestors(e) {
                const t = this.parent;
                null !== t && (e(t), t.traverseAncestors(e))
            }
            updateMatrix() {
                this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
            }
            updateMatrixWorld(e) {
                this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
                const t = this.children;
                for (let n = 0, i = t.length; n < i; n++) {
                    const i = t[n];
                    !0 !== i.matrixWorldAutoUpdate && !0 !== e || i.updateMatrixWorld(e)
                }
            }
            updateWorldMatrix(e, t) {
                const n = this.parent;
                if (!0 === e && null !== n && !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === t) {
                    const e = this.children;
                    for (let t = 0, n = e.length; t < n; t++) {
                        const n = e[t];
                        !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!1, !0)
                    }
                }
            }
            toJSON(e) {
                const t = void 0 === e || "string" == typeof e,
                    n = {};
                t && (e = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {},
                    shapes: {},
                    skeletons: {},
                    animations: {},
                    nodes: {}
                }, n.metadata = {
                    version: 4.6,
                    type: "Object",
                    generator: "Object3D.toJSON"
                });
                const i = {};

                function r(t, n) {
                    return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid
                }
                if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), !0 === this.castShadow && (i.castShadow = !0), !0 === this.receiveShadow && (i.receiveShadow = !0), !1 === this.visible && (i.visible = !1), !1 === this.frustumCulled && (i.frustumCulled = !1), 0 !== this.renderOrder && (i.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), i.up = this.up.toArray(), !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (i.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (i.type = "BatchedMesh", i.perObjectFrustumCulled = this.perObjectFrustumCulled, i.sortObjects = this.sortObjects, i.drawRanges = this._drawRanges, i.reservedRanges = this._reservedRanges, i.visibility = this._visibility, i.active = this._active, i.bounds = this._bounds.map((e => ({
                        boxInitialized: e.boxInitialized,
                        boxMin: e.box.min.toArray(),
                        boxMax: e.box.max.toArray(),
                        sphereInitialized: e.sphereInitialized,
                        sphereRadius: e.sphere.radius,
                        sphereCenter: e.sphere.center.toArray()
                    }))), i.maxGeometryCount = this._maxGeometryCount, i.maxVertexCount = this._maxVertexCount, i.maxIndexCount = this._maxIndexCount, i.geometryInitialized = this._geometryInitialized, i.geometryCount = this._geometryCount, i.matricesTexture = this._matricesTexture.toJSON(e), null !== this.boundingSphere && (i.boundingSphere = {
                        center: i.boundingSphere.center.toArray(),
                        radius: i.boundingSphere.radius
                    }), null !== this.boundingBox && (i.boundingBox = {
                        min: i.boundingBox.min.toArray(),
                        max: i.boundingBox.max.toArray()
                    })), this.isScene) this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && !0 !== this.environment.isRenderTargetTexture && (i.environment = this.environment.toJSON(e).uuid);
                else if (this.isMesh || this.isLine || this.isPoints) {
                    i.geometry = r(e.geometries, this.geometry);
                    const t = this.geometry.parameters;
                    if (void 0 !== t && void 0 !== t.shapes) {
                        const n = t.shapes;
                        if (Array.isArray(n))
                            for (let t = 0, i = n.length; t < i; t++) {
                                const i = n[t];
                                r(e.shapes, i)
                            } else r(e.shapes, n)
                    }
                }
                if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (r(e.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), void 0 !== this.material)
                    if (Array.isArray(this.material)) {
                        const t = [];
                        for (let n = 0, i = this.material.length; n < i; n++) t.push(r(e.materials, this.material[n]));
                        i.material = t
                    } else i.material = r(e.materials, this.material);
                if (this.children.length > 0) {
                    i.children = [];
                    for (let t = 0; t < this.children.length; t++) i.children.push(this.children[t].toJSON(e).object)
                }
                if (this.animations.length > 0) {
                    i.animations = [];
                    for (let t = 0; t < this.animations.length; t++) {
                        const n = this.animations[t];
                        i.animations.push(r(e.animations, n))
                    }
                }
                if (t) {
                    const t = o(e.geometries),
                        i = o(e.materials),
                        r = o(e.textures),
                        s = o(e.images),
                        a = o(e.shapes),
                        l = o(e.skeletons),
                        c = o(e.animations),
                        A = o(e.nodes);
                    t.length > 0 && (n.geometries = t), i.length > 0 && (n.materials = i), r.length > 0 && (n.textures = r), s.length > 0 && (n.images = s), a.length > 0 && (n.shapes = a), l.length > 0 && (n.skeletons = l), c.length > 0 && (n.animations = c), A.length > 0 && (n.nodes = A)
                }
                return n.object = i, n;

                function o(e) {
                    const t = [];
                    for (const n in e) {
                        const i = e[n];
                        delete i.metadata, t.push(i)
                    }
                    return t
                }
            }
            clone(e) {
                return (new this.constructor).copy(this, e)
            }
            copy(e, t = !0) {
                if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t)
                    for (let t = 0; t < e.children.length; t++) {
                        const n = e.children[t];
                        this.add(n.clone())
                    }
                return this
            }
        }
        qi.DEFAULT_UP = new On(0, 1, 0), qi.DEFAULT_MATRIX_AUTO_UPDATE = !0, qi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
        const ji = new On,
            Yi = new On,
            Ji = new On,
            Wi = new On,
            zi = new On,
            Xi = new On,
            Zi = new On,
            _i = new On,
            $i = new On,
            er = new On;
        class tr {
            constructor(e = new On, t = new On, n = new On) {
                this.a = e, this.b = t, this.c = n
            }
            static getNormal(e, t, n, i) {
                i.subVectors(n, t), ji.subVectors(e, t), i.cross(ji);
                const r = i.lengthSq();
                return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
            }
            static getBarycoord(e, t, n, i, r) {
                ji.subVectors(i, t), Yi.subVectors(n, t), Ji.subVectors(e, t);
                const o = ji.dot(ji),
                    s = ji.dot(Yi),
                    a = ji.dot(Ji),
                    l = Yi.dot(Yi),
                    c = Yi.dot(Ji),
                    A = o * l - s * s;
                if (0 === A) return r.set(0, 0, 0), null;
                const h = 1 / A,
                    u = (l * a - s * c) * h,
                    d = (o * c - s * a) * h;
                return r.set(1 - u - d, d, u)
            }
            static containsPoint(e, t, n, i) {
                return null !== this.getBarycoord(e, t, n, i, Wi) && (Wi.x >= 0 && Wi.y >= 0 && Wi.x + Wi.y <= 1)
            }
            static getInterpolation(e, t, n, i, r, o, s, a) {
                return null === this.getBarycoord(e, t, n, i, Wi) ? (a.x = 0, a.y = 0, "z" in a && (a.z = 0), "w" in a && (a.w = 0), null) : (a.setScalar(0), a.addScaledVector(r, Wi.x), a.addScaledVector(o, Wi.y), a.addScaledVector(s, Wi.z), a)
            }
            static isFrontFacing(e, t, n, i) {
                return ji.subVectors(n, t), Yi.subVectors(e, t), ji.cross(Yi).dot(i) < 0
            }
            set(e, t, n) {
                return this.a.copy(e), this.b.copy(t), this.c.copy(n), this
            }
            setFromPointsAndIndices(e, t, n, i) {
                return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this
            }
            setFromAttributeAndIndices(e, t, n, i) {
                return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, i), this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
            }
            getArea() {
                return ji.subVectors(this.c, this.b), Yi.subVectors(this.a, this.b), .5 * ji.cross(Yi).length()
            }
            getMidpoint(e) {
                return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            }
            getNormal(e) {
                return tr.getNormal(this.a, this.b, this.c, e)
            }
            getPlane(e) {
                return e.setFromCoplanarPoints(this.a, this.b, this.c)
            }
            getBarycoord(e, t) {
                return tr.getBarycoord(e, this.a, this.b, this.c, t)
            }
            getInterpolation(e, t, n, i, r) {
                return tr.getInterpolation(e, this.a, this.b, this.c, t, n, i, r)
            }
            containsPoint(e) {
                return tr.containsPoint(e, this.a, this.b, this.c)
            }
            isFrontFacing(e) {
                return tr.isFrontFacing(this.a, this.b, this.c, e)
            }
            intersectsBox(e) {
                return e.intersectsTriangle(this)
            }
            closestPointToPoint(e, t) {
                const n = this.a,
                    i = this.b,
                    r = this.c;
                let o, s;
                zi.subVectors(i, n), Xi.subVectors(r, n), _i.subVectors(e, n);
                const a = zi.dot(_i),
                    l = Xi.dot(_i);
                if (a <= 0 && l <= 0) return t.copy(n);
                $i.subVectors(e, i);
                const c = zi.dot($i),
                    A = Xi.dot($i);
                if (c >= 0 && A <= c) return t.copy(i);
                const h = a * A - c * l;
                if (h <= 0 && a >= 0 && c <= 0) return o = a / (a - c), t.copy(n).addScaledVector(zi, o);
                er.subVectors(e, r);
                const u = zi.dot(er),
                    d = Xi.dot(er);
                if (d >= 0 && u <= d) return t.copy(r);
                const p = u * l - a * d;
                if (p <= 0 && l >= 0 && d <= 0) return s = l / (l - d), t.copy(n).addScaledVector(Xi, s);
                const g = c * d - u * A;
                if (g <= 0 && A - c >= 0 && u - d >= 0) return Zi.subVectors(r, i), s = (A - c) / (A - c + (u - d)), t.copy(i).addScaledVector(Zi, s);
                const f = 1 / (g + p + h);
                return o = p * f, s = h * f, t.copy(n).addScaledVector(zi, o).addScaledVector(Xi, s)
            }
            equals(e) {
                return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
            }
        }
        const nr = {
                aliceblue: 15792383,
                antiquewhite: 16444375,
                aqua: 65535,
                aquamarine: 8388564,
                azure: 15794175,
                beige: 16119260,
                bisque: 16770244,
                black: 0,
                blanchedalmond: 16772045,
                blue: 255,
                blueviolet: 9055202,
                brown: 10824234,
                burlywood: 14596231,
                cadetblue: 6266528,
                chartreuse: 8388352,
                chocolate: 13789470,
                coral: 16744272,
                cornflowerblue: 6591981,
                cornsilk: 16775388,
                crimson: 14423100,
                cyan: 65535,
                darkblue: 139,
                darkcyan: 35723,
                darkgoldenrod: 12092939,
                darkgray: 11119017,
                darkgreen: 25600,
                darkgrey: 11119017,
                darkkhaki: 12433259,
                darkmagenta: 9109643,
                darkolivegreen: 5597999,
                darkorange: 16747520,
                darkorchid: 10040012,
                darkred: 9109504,
                darksalmon: 15308410,
                darkseagreen: 9419919,
                darkslateblue: 4734347,
                darkslategray: 3100495,
                darkslategrey: 3100495,
                darkturquoise: 52945,
                darkviolet: 9699539,
                deeppink: 16716947,
                deepskyblue: 49151,
                dimgray: 6908265,
                dimgrey: 6908265,
                dodgerblue: 2003199,
                firebrick: 11674146,
                floralwhite: 16775920,
                forestgreen: 2263842,
                fuchsia: 16711935,
                gainsboro: 14474460,
                ghostwhite: 16316671,
                gold: 16766720,
                goldenrod: 14329120,
                gray: 8421504,
                green: 32768,
                greenyellow: 11403055,
                grey: 8421504,
                honeydew: 15794160,
                hotpink: 16738740,
                indianred: 13458524,
                indigo: 4915330,
                ivory: 16777200,
                khaki: 15787660,
                lavender: 15132410,
                lavenderblush: 16773365,
                lawngreen: 8190976,
                lemonchiffon: 16775885,
                lightblue: 11393254,
                lightcoral: 15761536,
                lightcyan: 14745599,
                lightgoldenrodyellow: 16448210,
                lightgray: 13882323,
                lightgreen: 9498256,
                lightgrey: 13882323,
                lightpink: 16758465,
                lightsalmon: 16752762,
                lightseagreen: 2142890,
                lightskyblue: 8900346,
                lightslategray: 7833753,
                lightslategrey: 7833753,
                lightsteelblue: 11584734,
                lightyellow: 16777184,
                lime: 65280,
                limegreen: 3329330,
                linen: 16445670,
                magenta: 16711935,
                maroon: 8388608,
                mediumaquamarine: 6737322,
                mediumblue: 205,
                mediumorchid: 12211667,
                mediumpurple: 9662683,
                mediumseagreen: 3978097,
                mediumslateblue: 8087790,
                mediumspringgreen: 64154,
                mediumturquoise: 4772300,
                mediumvioletred: 13047173,
                midnightblue: 1644912,
                mintcream: 16121850,
                mistyrose: 16770273,
                moccasin: 16770229,
                navajowhite: 16768685,
                navy: 128,
                oldlace: 16643558,
                olive: 8421376,
                olivedrab: 7048739,
                orange: 16753920,
                orangered: 16729344,
                orchid: 14315734,
                palegoldenrod: 15657130,
                palegreen: 10025880,
                paleturquoise: 11529966,
                palevioletred: 14381203,
                papayawhip: 16773077,
                peachpuff: 16767673,
                peru: 13468991,
                pink: 16761035,
                plum: 14524637,
                powderblue: 11591910,
                purple: 8388736,
                rebeccapurple: 6697881,
                red: 16711680,
                rosybrown: 12357519,
                royalblue: 4286945,
                saddlebrown: 9127187,
                salmon: 16416882,
                sandybrown: 16032864,
                seagreen: 3050327,
                seashell: 16774638,
                sienna: 10506797,
                silver: 12632256,
                skyblue: 8900331,
                slateblue: 6970061,
                slategray: 7372944,
                slategrey: 7372944,
                snow: 16775930,
                springgreen: 65407,
                steelblue: 4620980,
                tan: 13808780,
                teal: 32896,
                thistle: 14204888,
                tomato: 16737095,
                turquoise: 4251856,
                violet: 15631086,
                wheat: 16113331,
                white: 16777215,
                whitesmoke: 16119285,
                yellow: 16776960,
                yellowgreen: 10145074
            },
            ir = {
                h: 0,
                s: 0,
                l: 0
            },
            rr = {
                h: 0,
                s: 0,
                l: 0
            };

        function or(e, t, n) {
            return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e
        }
        class sr {
            constructor(e, t, n) {
                return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, n)
            }
            set(e, t, n) {
                if (void 0 === t && void 0 === n) {
                    const t = e;
                    t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t)
                } else this.setRGB(e, t, n);
                return this
            }
            setScalar(e) {
                return this.r = e, this.g = e, this.b = e, this
            }
            setHex(e, t = Ot) {
                return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, yn.toWorkingColorSpace(this, t), this
            }
            setRGB(e, t, n, i = yn.workingColorSpace) {
                return this.r = e, this.g = t, this.b = n, yn.toWorkingColorSpace(this, i), this
            }
            setHSL(e, t, n, i = yn.workingColorSpace) {
                if (e = ln(e, 1), t = an(t, 0, 1), n = an(n, 0, 1), 0 === t) this.r = this.g = this.b = n;
                else {
                    const i = n <= .5 ? n * (1 + t) : n + t - n * t,
                        r = 2 * n - i;
                    this.r = or(r, i, e + 1 / 3), this.g = or(r, i, e), this.b = or(r, i, e - 1 / 3)
                }
                return yn.toWorkingColorSpace(this, i), this
            }
            setStyle(e, t = Ot) {
                function n(t) {
                    void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
                }
                let i;
                if (i = /^(\w+)\(([^\)]*)\)/.exec(e)) {
                    let r;
                    const o = i[1],
                        s = i[2];
                    switch (o) {
                        case "rgb":
                        case "rgba":
                            if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) return n(r[4]), this.setRGB(Math.min(255, parseInt(r[1], 10)) / 255, Math.min(255, parseInt(r[2], 10)) / 255, Math.min(255, parseInt(r[3], 10)) / 255, t);
                            if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) return n(r[4]), this.setRGB(Math.min(100, parseInt(r[1], 10)) / 100, Math.min(100, parseInt(r[2], 10)) / 100, Math.min(100, parseInt(r[3], 10)) / 100, t);
                            break;
                        case "hsl":
                        case "hsla":
                            if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s)) return n(r[4]), this.setHSL(parseFloat(r[1]) / 360, parseFloat(r[2]) / 100, parseFloat(r[3]) / 100, t);
                            break;
                        default:
                            console.warn("THREE.Color: Unknown color model " + e)
                    }
                } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
                    const n = i[1],
                        r = n.length;
                    if (3 === r) return this.setRGB(parseInt(n.charAt(0), 16) / 15, parseInt(n.charAt(1), 16) / 15, parseInt(n.charAt(2), 16) / 15, t);
                    if (6 === r) return this.setHex(parseInt(n, 16), t);
                    console.warn("THREE.Color: Invalid hex color " + e)
                } else if (e && e.length > 0) return this.setColorName(e, t);
                return this
            }
            setColorName(e, t = Ot) {
                const n = nr[e.toLowerCase()];
                return void 0 !== n ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this
            }
            clone() {
                return new this.constructor(this.r, this.g, this.b)
            }
            copy(e) {
                return this.r = e.r, this.g = e.g, this.b = e.b, this
            }
            copySRGBToLinear(e) {
                return this.r = wn(e.r), this.g = wn(e.g), this.b = wn(e.b), this
            }
            copyLinearToSRGB(e) {
                return this.r = bn(e.r), this.g = bn(e.g), this.b = bn(e.b), this
            }
            convertSRGBToLinear() {
                return this.copySRGBToLinear(this), this
            }
            convertLinearToSRGB() {
                return this.copyLinearToSRGB(this), this
            }
            getHex(e = Ot) {
                return yn.fromWorkingColorSpace(ar.copy(this), e), 65536 * Math.round(an(255 * ar.r, 0, 255)) + 256 * Math.round(an(255 * ar.g, 0, 255)) + Math.round(an(255 * ar.b, 0, 255))
            }
            getHexString(e = Ot) {
                return ("000000" + this.getHex(e).toString(16)).slice(-6)
            }
            getHSL(e, t = yn.workingColorSpace) {
                yn.fromWorkingColorSpace(ar.copy(this), t);
                const n = ar.r,
                    i = ar.g,
                    r = ar.b,
                    o = Math.max(n, i, r),
                    s = Math.min(n, i, r);
                let a, l;
                const c = (s + o) / 2;
                if (s === o) a = 0, l = 0;
                else {
                    const e = o - s;
                    switch (l = c <= .5 ? e / (o + s) : e / (2 - o - s), o) {
                        case n:
                            a = (i - r) / e + (i < r ? 6 : 0);
                            break;
                        case i:
                            a = (r - n) / e + 2;
                            break;
                        case r:
                            a = (n - i) / e + 4
                    }
                    a /= 6
                }
                return e.h = a, e.s = l, e.l = c, e
            }
            getRGB(e, t = yn.workingColorSpace) {
                return yn.fromWorkingColorSpace(ar.copy(this), t), e.r = ar.r, e.g = ar.g, e.b = ar.b, e
            }
            getStyle(e = Ot) {
                yn.fromWorkingColorSpace(ar.copy(this), e);
                const t = ar.r,
                    n = ar.g,
                    i = ar.b;
                return e !== Ot ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(255*t)},${Math.round(255*n)},${Math.round(255*i)})`
            }
            offsetHSL(e, t, n) {
                return this.getHSL(ir), this.setHSL(ir.h + e, ir.s + t, ir.l + n)
            }
            add(e) {
                return this.r += e.r, this.g += e.g, this.b += e.b, this
            }
            addColors(e, t) {
                return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
            }
            addScalar(e) {
                return this.r += e, this.g += e, this.b += e, this
            }
            sub(e) {
                return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
            }
            multiply(e) {
                return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
            }
            multiplyScalar(e) {
                return this.r *= e, this.g *= e, this.b *= e, this
            }
            lerp(e, t) {
                return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
            }
            lerpColors(e, t, n) {
                return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this
            }
            lerpHSL(e, t) {
                this.getHSL(ir), e.getHSL(rr);
                const n = cn(ir.h, rr.h, t),
                    i = cn(ir.s, rr.s, t),
                    r = cn(ir.l, rr.l, t);
                return this.setHSL(n, i, r), this
            }
            setFromVector3(e) {
                return this.r = e.x, this.g = e.y, this.b = e.z, this
            }
            applyMatrix3(e) {
                const t = this.r,
                    n = this.g,
                    i = this.b,
                    r = e.elements;
                return this.r = r[0] * t + r[3] * n + r[6] * i, this.g = r[1] * t + r[4] * n + r[7] * i, this.b = r[2] * t + r[5] * n + r[8] * i, this
            }
            equals(e) {
                return e.r === this.r && e.g === this.g && e.b === this.b
            }
            fromArray(e, t = 0) {
                return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
            }
            toArray(e = [], t = 0) {
                return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
            }
            fromBufferAttribute(e, t) {
                return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this
            }
            toJSON() {
                return this.getHex()
            }*[Symbol.iterator]() {
                yield this.r, yield this.g, yield this.b
            }
        }
        const ar = new sr;
        sr.NAMES = nr;
        let lr = 0;
        class cr extends en {
            constructor() {
                super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
                    value: lr++
                }), this.uuid = sn(), this.name = "", this.type = "Material", this.blending = 1, this.side = Ue, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = Te, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new sr(0, 0, 0), this.blendAlpha = 0, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = zt, this.stencilZFail = zt, this.stencilZPass = zt, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
            }
            get alphaTest() {
                return this._alphaTest
            }
            set alphaTest(e) {
                this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e
            }
            onBuild() {}
            onBeforeRender() {}
            onBeforeCompile() {}
            customProgramCacheKey() {
                return this.onBeforeCompile.toString()
            }
            setValues(e) {
                if (void 0 !== e)
                    for (const t in e) {
                        const n = e[t];
                        if (void 0 === n) {
                            console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
                            continue
                        }
                        const i = this[t];
                        void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n : console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`)
                    }
            }
            toJSON(e) {
                const t = void 0 === e || "string" == typeof e;
                t && (e = {
                    textures: {},
                    images: {}
                });
                const n = {
                    metadata: {
                        version: 4.6,
                        type: "Material",
                        generator: "Material.toJSON"
                    }
                };

                function i(e) {
                    const t = [];
                    for (const n in e) {
                        const i = e[n];
                        delete i.metadata, t.push(i)
                    }
                    return t
                }
                if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), void 0 !== this.sheen && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), void 0 !== this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), void 0 !== this.dispersion && (n.dispersion = this.dispersion), void 0 !== this.iridescence && (n.iridescence = this.iridescence), void 0 !== this.iridescenceIOR && (n.iridescenceIOR = this.iridescenceIOR), void 0 !== this.iridescenceThicknessRange && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), void 0 !== this.anisotropy && (n.anisotropy = this.anisotropy), void 0 !== this.anisotropyRotation && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapRotation && (n.envMapRotation = this.envMapRotation.toArray()), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), void 0 !== this.attenuationDistance && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), this.side !== Ue && (n.side = this.side), !0 === this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = !0), 204 !== this.blendSrc && (n.blendSrc = this.blendSrc), 205 !== this.blendDst && (n.blendDst = this.blendDst), this.blendEquation !== Te && (n.blendEquation = this.blendEquation), null !== this.blendSrcAlpha && (n.blendSrcAlpha = this.blendSrcAlpha), null !== this.blendDstAlpha && (n.blendDstAlpha = this.blendDstAlpha), null !== this.blendEquationAlpha && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), 0 !== this.blendAlpha && (n.blendAlpha = this.blendAlpha), 3 !== this.depthFunc && (n.depthFunc = this.depthFunc), !1 === this.depthTest && (n.depthTest = this.depthTest), !1 === this.depthWrite && (n.depthWrite = this.depthWrite), !1 === this.colorWrite && (n.colorWrite = this.colorWrite), 255 !== this.stencilWriteMask && (n.stencilWriteMask = this.stencilWriteMask), 519 !== this.stencilFunc && (n.stencilFunc = this.stencilFunc), 0 !== this.stencilRef && (n.stencilRef = this.stencilRef), 255 !== this.stencilFuncMask && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== zt && (n.stencilFail = this.stencilFail), this.stencilZFail !== zt && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== zt && (n.stencilZPass = this.stencilZPass), !0 === this.stencilWrite && (n.stencilWrite = this.stencilWrite), void 0 !== this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaHash && (n.alphaHash = !0), !0 === this.alphaToCoverage && (n.alphaToCoverage = !0), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = !0), !0 === this.forceSinglePass && (n.forceSinglePass = !0), !0 === this.wireframe && (n.wireframe = !0), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = !0), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), !1 === this.fog && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData), t) {
                    const t = i(e.textures),
                        r = i(e.images);
                    t.length > 0 && (n.textures = t), r.length > 0 && (n.images = r)
                }
                return n
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
                const t = e.clippingPlanes;
                let n = null;
                if (null !== t) {
                    const e = t.length;
                    n = new Array(e);
                    for (let i = 0; i !== e; ++i) n[i] = t[i].clone()
                }
                return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
            set needsUpdate(e) {
                !0 === e && this.version++
            }
        }
        class Ar extends cr {
            constructor(e) {
                super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new sr(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new bi, this.combine = Fe, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this
            }
        }
        const hr = ur();

        function ur() {
            const e = new ArrayBuffer(4),
                t = new Float32Array(e),
                n = new Uint32Array(e),
                i = new Uint32Array(512),
                r = new Uint32Array(512);
            for (let e = 0; e < 256; ++e) {
                const t = e - 127;
                t < -27 ? (i[e] = 0, i[256 | e] = 32768, r[e] = 24, r[256 | e] = 24) : t < -14 ? (i[e] = 1024 >> -t - 14, i[256 | e] = 1024 >> -t - 14 | 32768, r[e] = -t - 1, r[256 | e] = -t - 1) : t <= 15 ? (i[e] = t + 15 << 10, i[256 | e] = t + 15 << 10 | 32768, r[e] = 13, r[256 | e] = 13) : t < 128 ? (i[e] = 31744, i[256 | e] = 64512, r[e] = 24, r[256 | e] = 24) : (i[e] = 31744, i[256 | e] = 64512, r[e] = 13, r[256 | e] = 13)
            }
            const o = new Uint32Array(2048),
                s = new Uint32Array(64),
                a = new Uint32Array(64);
            for (let e = 1; e < 1024; ++e) {
                let t = e << 13,
                    n = 0;
                for (; !(8388608 & t);) t <<= 1, n -= 8388608;
                t &= -8388609, n += 947912704, o[e] = t | n
            }
            for (let e = 1024; e < 2048; ++e) o[e] = 939524096 + (e - 1024 << 13);
            for (let e = 1; e < 31; ++e) s[e] = e << 23;
            s[31] = 1199570944, s[32] = 2147483648;
            for (let e = 33; e < 63; ++e) s[e] = 2147483648 + (e - 32 << 23);
            s[63] = 3347054592;
            for (let e = 1; e < 64; ++e) 32 !== e && (a[e] = 1024);
            return {
                floatView: t,
                uint32View: n,
                baseTable: i,
                shiftTable: r,
                mantissaTable: o,
                exponentTable: s,
                offsetTable: a
            }
        }

        function dr(e) {
            Math.abs(e) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), e = an(e, -65504, 65504), hr.floatView[0] = e;
            const t = hr.uint32View[0],
                n = t >> 23 & 511;
            return hr.baseTable[n] + ((8388607 & t) >> hr.shiftTable[n])
        }

        function pr(e) {
            const t = e >> 10;
            return hr.uint32View[0] = hr.mantissaTable[hr.offsetTable[t] + (1023 & e)] + hr.exponentTable[t], hr.floatView[0]
        }
        const gr = {
                toHalfFloat: dr,
                fromHalfFloat: pr
            },
            fr = new On,
            mr = new dn;
        class Er {
            constructor(e, t, n = !1) {
                if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = void 0 !== e ? e.length / t : 0, this.normalized = n, this.usage = Xt, this._updateRange = {
                    offset: 0,
                    count: -1
                }, this.updateRanges = [], this.gpuType = lt, this.version = 0
            }
            onUploadCallback() {}
            set needsUpdate(e) {
                !0 === e && this.version++
            }
            get updateRange() {
                return In("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange
            }
            setUsage(e) {
                return this.usage = e, this
            }
            addUpdateRange(e, t) {
                this.updateRanges.push({
                    start: e,
                    count: t
                })
            }
            clearUpdateRanges() {
                this.updateRanges.length = 0
            }
            copy(e) {
                return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this
            }
            copyAt(e, t, n) {
                e *= this.itemSize, n *= t.itemSize;
                for (let i = 0, r = this.itemSize; i < r; i++) this.array[e + i] = t.array[n + i];
                return this
            }
            copyArray(e) {
                return this.array.set(e), this
            }
            applyMatrix3(e) {
                if (2 === this.itemSize)
                    for (let t = 0, n = this.count; t < n; t++) mr.fromBufferAttribute(this, t), mr.applyMatrix3(e), this.setXY(t, mr.x, mr.y);
                else if (3 === this.itemSize)
                    for (let t = 0, n = this.count; t < n; t++) fr.fromBufferAttribute(this, t), fr.applyMatrix3(e), this.setXYZ(t, fr.x, fr.y, fr.z);
                return this
            }
            applyMatrix4(e) {
                for (let t = 0, n = this.count; t < n; t++) fr.fromBufferAttribute(this, t), fr.applyMatrix4(e), this.setXYZ(t, fr.x, fr.y, fr.z);
                return this
            }
            applyNormalMatrix(e) {
                for (let t = 0, n = this.count; t < n; t++) fr.fromBufferAttribute(this, t), fr.applyNormalMatrix(e), this.setXYZ(t, fr.x, fr.y, fr.z);
                return this
            }
            transformDirection(e) {
                for (let t = 0, n = this.count; t < n; t++) fr.fromBufferAttribute(this, t), fr.transformDirection(e), this.setXYZ(t, fr.x, fr.y, fr.z);
                return this
            }
            set(e, t = 0) {
                return this.array.set(e, t), this
            }
            getComponent(e, t) {
                let n = this.array[e * this.itemSize + t];
                return this.normalized && (n = An(n, this.array)), n
            }
            setComponent(e, t, n) {
                return this.normalized && (n = hn(n, this.array)), this.array[e * this.itemSize + t] = n, this
            }
            getX(e) {
                let t = this.array[e * this.itemSize];
                return this.normalized && (t = An(t, this.array)), t
            }
            setX(e, t) {
                return this.normalized && (t = hn(t, this.array)), this.array[e * this.itemSize] = t, this
            }
            getY(e) {
                let t = this.array[e * this.itemSize + 1];
                return this.normalized && (t = An(t, this.array)), t
            }
            setY(e, t) {
                return this.normalized && (t = hn(t, this.array)), this.array[e * this.itemSize + 1] = t, this
            }
            getZ(e) {
                let t = this.array[e * this.itemSize + 2];
                return this.normalized && (t = An(t, this.array)), t
            }
            setZ(e, t) {
                return this.normalized && (t = hn(t, this.array)), this.array[e * this.itemSize + 2] = t, this
            }
            getW(e) {
                let t = this.array[e * this.itemSize + 3];
                return this.normalized && (t = An(t, this.array)), t
            }
            setW(e, t) {
                return this.normalized && (t = hn(t, this.array)), this.array[e * this.itemSize + 3] = t, this
            }
            setXY(e, t, n) {
                return e *= this.itemSize, this.normalized && (t = hn(t, this.array), n = hn(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this
            }
            setXYZ(e, t, n, i) {
                return e *= this.itemSize, this.normalized && (t = hn(t, this.array), n = hn(n, this.array), i = hn(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this
            }
            setXYZW(e, t, n, i, r) {
                return e *= this.itemSize, this.normalized && (t = hn(t, this.array), n = hn(n, this.array), i = hn(i, this.array), r = hn(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this.array[e + 3] = r, this
            }
            onUpload(e) {
                return this.onUploadCallback = e, this
            }
            clone() {
                return new this.constructor(this.array, this.itemSize).copy(this)
            }
            toJSON() {
                const e = {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: Array.from(this.array),
                    normalized: this.normalized
                };
                return "" !== this.name && (e.name = this.name), this.usage !== Xt && (e.usage = this.usage), e
            }
        }
        class Cr extends Er {
            constructor(e, t, n) {
                super(new Uint16Array(e), t, n)
            }
        }
        class Ir extends Er {
            constructor(e, t, n) {
                super(new Uint32Array(e), t, n)
            }
        }
        class Sr extends Er {
            constructor(e, t, n) {
                super(new Float32Array(e), t, n)
            }
        }
        let vr = 0;
        const Br = new mi,
            xr = new qi,
            yr = new On,
            wr = new qn,
            br = new qn,
            Qr = new On;
        class Ur extends en {
            constructor() {
                super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
                    value: vr++
                }), this.uuid = sn(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                    start: 0,
                    count: 1 / 0
                }, this.userData = {}
            }
            getIndex() {
                return this.index
            }
            setIndex(e) {
                return Array.isArray(e) ? this.index = new(fn(e) ? Ir : Cr)(e, 1) : this.index = e, this
            }
            getAttribute(e) {
                return this.attributes[e]
            }
            setAttribute(e, t) {
                return this.attributes[e] = t, this
            }
            deleteAttribute(e) {
                return delete this.attributes[e], this
            }
            hasAttribute(e) {
                return void 0 !== this.attributes[e]
            }
            addGroup(e, t, n = 0) {
                this.groups.push({
                    start: e,
                    count: t,
                    materialIndex: n
                })
            }
            clearGroups() {
                this.groups = []
            }
            setDrawRange(e, t) {
                this.drawRange.start = e, this.drawRange.count = t
            }
            applyMatrix4(e) {
                const t = this.attributes.position;
                void 0 !== t && (t.applyMatrix4(e), t.needsUpdate = !0);
                const n = this.attributes.normal;
                if (void 0 !== n) {
                    const t = (new pn).getNormalMatrix(e);
                    n.applyNormalMatrix(t), n.needsUpdate = !0
                }
                const i = this.attributes.tangent;
                return void 0 !== i && (i.transformDirection(e), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
            }
            applyQuaternion(e) {
                return Br.makeRotationFromQuaternion(e), this.applyMatrix4(Br), this
            }
            rotateX(e) {
                return Br.makeRotationX(e), this.applyMatrix4(Br), this
            }
            rotateY(e) {
                return Br.makeRotationY(e), this.applyMatrix4(Br), this
            }
            rotateZ(e) {
                return Br.makeRotationZ(e), this.applyMatrix4(Br), this
            }
            translate(e, t, n) {
                return Br.makeTranslation(e, t, n), this.applyMatrix4(Br), this
            }
            scale(e, t, n) {
                return Br.makeScale(e, t, n), this.applyMatrix4(Br), this
            }
            lookAt(e) {
                return xr.lookAt(e), xr.updateMatrix(), this.applyMatrix4(xr.matrix), this
            }
            center() {
                return this.computeBoundingBox(), this.boundingBox.getCenter(yr).negate(), this.translate(yr.x, yr.y, yr.z), this
            }
            setFromPoints(e) {
                const t = [];
                for (let n = 0, i = e.length; n < i; n++) {
                    const i = e[n];
                    t.push(i.x, i.y, i.z || 0)
                }
                return this.setAttribute("position", new Sr(t, 3)), this
            }
            computeBoundingBox() {
                null === this.boundingBox && (this.boundingBox = new qn);
                const e = this.attributes.position,
                    t = this.morphAttributes.position;
                if (e && e.isGLBufferAttribute) return console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), void this.boundingBox.set(new On(-1 / 0, -1 / 0, -1 / 0), new On(1 / 0, 1 / 0, 1 / 0));
                if (void 0 !== e) {
                    if (this.boundingBox.setFromBufferAttribute(e), t)
                        for (let e = 0, n = t.length; e < n; e++) {
                            const n = t[e];
                            wr.setFromBufferAttribute(n), this.morphTargetsRelative ? (Qr.addVectors(this.boundingBox.min, wr.min), this.boundingBox.expandByPoint(Qr), Qr.addVectors(this.boundingBox.max, wr.max), this.boundingBox.expandByPoint(Qr)) : (this.boundingBox.expandByPoint(wr.min), this.boundingBox.expandByPoint(wr.max))
                        }
                } else this.boundingBox.makeEmpty();
                (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            }
            computeBoundingSphere() {
                null === this.boundingSphere && (this.boundingSphere = new li);
                const e = this.attributes.position,
                    t = this.morphAttributes.position;
                if (e && e.isGLBufferAttribute) return console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), void this.boundingSphere.set(new On, 1 / 0);
                if (e) {
                    const n = this.boundingSphere.center;
                    if (wr.setFromBufferAttribute(e), t)
                        for (let e = 0, n = t.length; e < n; e++) {
                            const n = t[e];
                            br.setFromBufferAttribute(n), this.morphTargetsRelative ? (Qr.addVectors(wr.min, br.min), wr.expandByPoint(Qr), Qr.addVectors(wr.max, br.max), wr.expandByPoint(Qr)) : (wr.expandByPoint(br.min), wr.expandByPoint(br.max))
                        }
                    wr.getCenter(n);
                    let i = 0;
                    for (let t = 0, r = e.count; t < r; t++) Qr.fromBufferAttribute(e, t), i = Math.max(i, n.distanceToSquared(Qr));
                    if (t)
                        for (let r = 0, o = t.length; r < o; r++) {
                            const o = t[r],
                                s = this.morphTargetsRelative;
                            for (let t = 0, r = o.count; t < r; t++) Qr.fromBufferAttribute(o, t), s && (yr.fromBufferAttribute(e, t), Qr.add(yr)), i = Math.max(i, n.distanceToSquared(Qr))
                        }
                    this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            }
            computeTangents() {
                const e = this.index,
                    t = this.attributes;
                if (null === e || void 0 === t.position || void 0 === t.normal || void 0 === t.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                const n = t.position,
                    i = t.normal,
                    r = t.uv;
                !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new Er(new Float32Array(4 * n.count), 4));
                const o = this.getAttribute("tangent"),
                    s = [],
                    a = [];
                for (let e = 0; e < n.count; e++) s[e] = new On, a[e] = new On;
                const l = new On,
                    c = new On,
                    A = new On,
                    h = new dn,
                    u = new dn,
                    d = new dn,
                    p = new On,
                    g = new On;

                function f(e, t, i) {
                    l.fromBufferAttribute(n, e), c.fromBufferAttribute(n, t), A.fromBufferAttribute(n, i), h.fromBufferAttribute(r, e), u.fromBufferAttribute(r, t), d.fromBufferAttribute(r, i), c.sub(l), A.sub(l), u.sub(h), d.sub(h);
                    const o = 1 / (u.x * d.y - d.x * u.y);
                    isFinite(o) && (p.copy(c).multiplyScalar(d.y).addScaledVector(A, -u.y).multiplyScalar(o), g.copy(A).multiplyScalar(u.x).addScaledVector(c, -d.x).multiplyScalar(o), s[e].add(p), s[t].add(p), s[i].add(p), a[e].add(g), a[t].add(g), a[i].add(g))
                }
                let m = this.groups;
                0 === m.length && (m = [{
                    start: 0,
                    count: e.count
                }]);
                for (let t = 0, n = m.length; t < n; ++t) {
                    const n = m[t],
                        i = n.start;
                    for (let t = i, r = i + n.count; t < r; t += 3) f(e.getX(t + 0), e.getX(t + 1), e.getX(t + 2))
                }
                const E = new On,
                    C = new On,
                    I = new On,
                    S = new On;

                function v(e) {
                    I.fromBufferAttribute(i, e), S.copy(I);
                    const t = s[e];
                    E.copy(t), E.sub(I.multiplyScalar(I.dot(t))).normalize(), C.crossVectors(S, t);
                    const n = C.dot(a[e]) < 0 ? -1 : 1;
                    o.setXYZW(e, E.x, E.y, E.z, n)
                }
                for (let t = 0, n = m.length; t < n; ++t) {
                    const n = m[t],
                        i = n.start;
                    for (let t = i, r = i + n.count; t < r; t += 3) v(e.getX(t + 0)), v(e.getX(t + 1)), v(e.getX(t + 2))
                }
            }
            computeVertexNormals() {
                const e = this.index,
                    t = this.getAttribute("position");
                if (void 0 !== t) {
                    let n = this.getAttribute("normal");
                    if (void 0 === n) n = new Er(new Float32Array(3 * t.count), 3), this.setAttribute("normal", n);
                    else
                        for (let e = 0, t = n.count; e < t; e++) n.setXYZ(e, 0, 0, 0);
                    const i = new On,
                        r = new On,
                        o = new On,
                        s = new On,
                        a = new On,
                        l = new On,
                        c = new On,
                        A = new On;
                    if (e)
                        for (let h = 0, u = e.count; h < u; h += 3) {
                            const u = e.getX(h + 0),
                                d = e.getX(h + 1),
                                p = e.getX(h + 2);
                            i.fromBufferAttribute(t, u), r.fromBufferAttribute(t, d), o.fromBufferAttribute(t, p), c.subVectors(o, r), A.subVectors(i, r), c.cross(A), s.fromBufferAttribute(n, u), a.fromBufferAttribute(n, d), l.fromBufferAttribute(n, p), s.add(c), a.add(c), l.add(c), n.setXYZ(u, s.x, s.y, s.z), n.setXYZ(d, a.x, a.y, a.z), n.setXYZ(p, l.x, l.y, l.z)
                        } else
                            for (let e = 0, s = t.count; e < s; e += 3) i.fromBufferAttribute(t, e + 0), r.fromBufferAttribute(t, e + 1), o.fromBufferAttribute(t, e + 2), c.subVectors(o, r), A.subVectors(i, r), c.cross(A), n.setXYZ(e + 0, c.x, c.y, c.z), n.setXYZ(e + 1, c.x, c.y, c.z), n.setXYZ(e + 2, c.x, c.y, c.z);
                    this.normalizeNormals(), n.needsUpdate = !0
                }
            }
            normalizeNormals() {
                const e = this.attributes.normal;
                for (let t = 0, n = e.count; t < n; t++) Qr.fromBufferAttribute(e, t), Qr.normalize(), e.setXYZ(t, Qr.x, Qr.y, Qr.z)
            }
            toNonIndexed() {
                function e(e, t) {
                    const n = e.array,
                        i = e.itemSize,
                        r = e.normalized,
                        o = new n.constructor(t.length * i);
                    let s = 0,
                        a = 0;
                    for (let r = 0, l = t.length; r < l; r++) {
                        s = e.isInterleavedBufferAttribute ? t[r] * e.data.stride + e.offset : t[r] * i;
                        for (let e = 0; e < i; e++) o[a++] = n[s++]
                    }
                    return new Er(o, i, r)
                }
                if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
                const t = new Ur,
                    n = this.index.array,
                    i = this.attributes;
                for (const r in i) {
                    const o = e(i[r], n);
                    t.setAttribute(r, o)
                }
                const r = this.morphAttributes;
                for (const i in r) {
                    const o = [],
                        s = r[i];
                    for (let t = 0, i = s.length; t < i; t++) {
                        const i = e(s[t], n);
                        o.push(i)
                    }
                    t.morphAttributes[i] = o
                }
                t.morphTargetsRelative = this.morphTargetsRelative;
                const o = this.groups;
                for (let e = 0, n = o.length; e < n; e++) {
                    const n = o[e];
                    t.addGroup(n.start, n.count, n.materialIndex)
                }
                return t
            }
            toJSON() {
                const e = {
                    metadata: {
                        version: 4.6,
                        type: "BufferGeometry",
                        generator: "BufferGeometry.toJSON"
                    }
                };
                if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), void 0 !== this.parameters) {
                    const t = this.parameters;
                    for (const n in t) void 0 !== t[n] && (e[n] = t[n]);
                    return e
                }
                e.data = {
                    attributes: {}
                };
                const t = this.index;
                null !== t && (e.data.index = {
                    type: t.array.constructor.name,
                    array: Array.prototype.slice.call(t.array)
                });
                const n = this.attributes;
                for (const t in n) {
                    const i = n[t];
                    e.data.attributes[t] = i.toJSON(e.data)
                }
                const i = {};
                let r = !1;
                for (const t in this.morphAttributes) {
                    const n = this.morphAttributes[t],
                        o = [];
                    for (let t = 0, i = n.length; t < i; t++) {
                        const i = n[t];
                        o.push(i.toJSON(e.data))
                    }
                    o.length > 0 && (i[t] = o, r = !0)
                }
                r && (e.data.morphAttributes = i, e.data.morphTargetsRelative = this.morphTargetsRelative);
                const o = this.groups;
                o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
                const s = this.boundingSphere;
                return null !== s && (e.data.boundingSphere = {
                    center: s.center.toArray(),
                    radius: s.radius
                }), e
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                const t = {};
                this.name = e.name;
                const n = e.index;
                null !== n && this.setIndex(n.clone(t));
                const i = e.attributes;
                for (const e in i) {
                    const n = i[e];
                    this.setAttribute(e, n.clone(t))
                }
                const r = e.morphAttributes;
                for (const e in r) {
                    const n = [],
                        i = r[e];
                    for (let e = 0, r = i.length; e < r; e++) n.push(i[e].clone(t));
                    this.morphAttributes[e] = n
                }
                this.morphTargetsRelative = e.morphTargetsRelative;
                const o = e.groups;
                for (let e = 0, t = o.length; e < t; e++) {
                    const t = o[e];
                    this.addGroup(t.start, t.count, t.materialIndex)
                }
                const s = e.boundingBox;
                null !== s && (this.boundingBox = s.clone());
                const a = e.boundingSphere;
                return null !== a && (this.boundingSphere = a.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this
            }
            dispose() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }
        const Mr = new mi,
            Rr = new fi,
            Tr = new li,
            Fr = new On,
            Dr = new On,
            kr = new On,
            Lr = new On,
            Kr = new On,
            Pr = new On,
            Gr = new dn,
            Vr = new dn,
            Or = new dn,
            Nr = new On,
            Hr = new On,
            qr = new On,
            jr = new On,
            Yr = new On;
        class Jr extends qi {
            constructor(e = new Ur, t = new Ar) {
                super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets()
            }
            copy(e, t) {
                return super.copy(e, t), void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this
            }
            updateMorphTargets() {
                const e = this.geometry.morphAttributes,
                    t = Object.keys(e);
                if (t.length > 0) {
                    const n = e[t[0]];
                    if (void 0 !== n) {
                        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                        for (let e = 0, t = n.length; e < t; e++) {
                            const t = n[e].name || String(e);
                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = e
                        }
                    }
                }
            }
            getVertexPosition(e, t) {
                const n = this.geometry,
                    i = n.attributes.position,
                    r = n.morphAttributes.position,
                    o = n.morphTargetsRelative;
                t.fromBufferAttribute(i, e);
                const s = this.morphTargetInfluences;
                if (r && s) {
                    Pr.set(0, 0, 0);
                    for (let n = 0, i = r.length; n < i; n++) {
                        const i = s[n],
                            a = r[n];
                        0 !== i && (Kr.fromBufferAttribute(a, e), o ? Pr.addScaledVector(Kr, i) : Pr.addScaledVector(Kr.sub(t), i))
                    }
                    t.add(Pr)
                }
                return t
            }
            raycast(e, t) {
                const n = this.geometry,
                    i = this.material,
                    r = this.matrixWorld;
                if (void 0 !== i) {
                    if (null === n.boundingSphere && n.computeBoundingSphere(), Tr.copy(n.boundingSphere), Tr.applyMatrix4(r), Rr.copy(e.ray).recast(e.near), !1 === Tr.containsPoint(Rr.origin)) {
                        if (null === Rr.intersectSphere(Tr, Fr)) return;
                        if (Rr.origin.distanceToSquared(Fr) > (e.far - e.near) ** 2) return
                    }
                    Mr.copy(r).invert(), Rr.copy(e.ray).applyMatrix4(Mr), null !== n.boundingBox && !1 === Rr.intersectsBox(n.boundingBox) || this._computeIntersections(e, t, Rr)
                }
            }
            _computeIntersections(e, t, n) {
                let i;
                const r = this.geometry,
                    o = this.material,
                    s = r.index,
                    a = r.attributes.position,
                    l = r.attributes.uv,
                    c = r.attributes.uv1,
                    A = r.attributes.normal,
                    h = r.groups,
                    u = r.drawRange;
                if (null !== s)
                    if (Array.isArray(o))
                        for (let r = 0, a = h.length; r < a; r++) {
                            const a = h[r],
                                d = o[a.materialIndex];
                            for (let r = Math.max(a.start, u.start), o = Math.min(s.count, Math.min(a.start + a.count, u.start + u.count)); r < o; r += 3) {
                                i = Wr(this, d, e, n, l, c, A, s.getX(r), s.getX(r + 1), s.getX(r + 2)), i && (i.faceIndex = Math.floor(r / 3), i.face.materialIndex = a.materialIndex, t.push(i))
                            }
                        } else {
                            for (let r = Math.max(0, u.start), a = Math.min(s.count, u.start + u.count); r < a; r += 3) {
                                i = Wr(this, o, e, n, l, c, A, s.getX(r), s.getX(r + 1), s.getX(r + 2)), i && (i.faceIndex = Math.floor(r / 3), t.push(i))
                            }
                        } else if (void 0 !== a)
                            if (Array.isArray(o))
                                for (let r = 0, s = h.length; r < s; r++) {
                                    const s = h[r],
                                        d = o[s.materialIndex];
                                    for (let r = Math.max(s.start, u.start), o = Math.min(a.count, Math.min(s.start + s.count, u.start + u.count)); r < o; r += 3) {
                                        i = Wr(this, d, e, n, l, c, A, r, r + 1, r + 2), i && (i.faceIndex = Math.floor(r / 3), i.face.materialIndex = s.materialIndex, t.push(i))
                                    }
                                } else {
                                    for (let r = Math.max(0, u.start), s = Math.min(a.count, u.start + u.count); r < s; r += 3) {
                                        i = Wr(this, o, e, n, l, c, A, r, r + 1, r + 2), i && (i.faceIndex = Math.floor(r / 3), t.push(i))
                                    }
                                }
            }
        }

        function Wr(e, t, n, i, r, o, s, a, l, c) {
            e.getVertexPosition(a, Dr), e.getVertexPosition(l, kr), e.getVertexPosition(c, Lr);
            const A = function(e, t, n, i, r, o, s, a) {
                let l;
                if (l = t.side === Me ? i.intersectTriangle(s, o, r, !0, a) : i.intersectTriangle(r, o, s, t.side === Ue, a), null === l) return null;
                Yr.copy(a), Yr.applyMatrix4(e.matrixWorld);
                const c = n.ray.origin.distanceTo(Yr);
                return c < n.near || c > n.far ? null : {
                    distance: c,
                    point: Yr.clone(),
                    object: e
                }
            }(e, t, n, i, Dr, kr, Lr, jr);
            if (A) {
                r && (Gr.fromBufferAttribute(r, a), Vr.fromBufferAttribute(r, l), Or.fromBufferAttribute(r, c), A.uv = tr.getInterpolation(jr, Dr, kr, Lr, Gr, Vr, Or, new dn)), o && (Gr.fromBufferAttribute(o, a), Vr.fromBufferAttribute(o, l), Or.fromBufferAttribute(o, c), A.uv1 = tr.getInterpolation(jr, Dr, kr, Lr, Gr, Vr, Or, new dn)), s && (Nr.fromBufferAttribute(s, a), Hr.fromBufferAttribute(s, l), qr.fromBufferAttribute(s, c), A.normal = tr.getInterpolation(jr, Dr, kr, Lr, Nr, Hr, qr, new On), A.normal.dot(i.direction) > 0 && A.normal.multiplyScalar(-1));
                const e = {
                    a,
                    b: l,
                    c,
                    normal: new On,
                    materialIndex: 0
                };
                tr.getNormal(Dr, kr, Lr, e.normal), A.face = e
            }
            return A
        }
        class zr extends Ur {
            constructor(e = 1, t = 1, n = 1, i = 1, r = 1, o = 1) {
                super(), this.type = "BoxGeometry", this.parameters = {
                    width: e,
                    height: t,
                    depth: n,
                    widthSegments: i,
                    heightSegments: r,
                    depthSegments: o
                };
                const s = this;
                i = Math.floor(i), r = Math.floor(r), o = Math.floor(o);
                const a = [],
                    l = [],
                    c = [],
                    A = [];
                let h = 0,
                    u = 0;

                function d(e, t, n, i, r, o, d, p, g, f, m) {
                    const E = o / g,
                        C = d / f,
                        I = o / 2,
                        S = d / 2,
                        v = p / 2,
                        B = g + 1,
                        x = f + 1;
                    let y = 0,
                        w = 0;
                    const b = new On;
                    for (let o = 0; o < x; o++) {
                        const s = o * C - S;
                        for (let a = 0; a < B; a++) {
                            const h = a * E - I;
                            b[e] = h * i, b[t] = s * r, b[n] = v, l.push(b.x, b.y, b.z), b[e] = 0, b[t] = 0, b[n] = p > 0 ? 1 : -1, c.push(b.x, b.y, b.z), A.push(a / g), A.push(1 - o / f), y += 1
                        }
                    }
                    for (let e = 0; e < f; e++)
                        for (let t = 0; t < g; t++) {
                            const n = h + t + B * e,
                                i = h + t + B * (e + 1),
                                r = h + (t + 1) + B * (e + 1),
                                o = h + (t + 1) + B * e;
                            a.push(n, i, o), a.push(i, r, o), w += 6
                        }
                    s.addGroup(u, w, m), u += w, h += y
                }
                d("z", "y", "x", -1, -1, n, t, e, o, r, 0), d("z", "y", "x", 1, -1, n, t, -e, o, r, 1), d("x", "z", "y", 1, 1, e, n, t, i, o, 2), d("x", "z", "y", 1, -1, e, n, -t, i, o, 3), d("x", "y", "z", 1, -1, e, t, n, i, r, 4), d("x", "y", "z", -1, -1, e, t, -n, i, r, 5), this.setIndex(a), this.setAttribute("position", new Sr(l, 3)), this.setAttribute("normal", new Sr(c, 3)), this.setAttribute("uv", new Sr(A, 2))
            }
            copy(e) {
                return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
            }
            static fromJSON(e) {
                return new zr(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments)
            }
        }

        function Xr(e) {
            const t = {};
            for (const n in e) {
                t[n] = {};
                for (const i in e[n]) {
                    const r = e[n][i];
                    r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), t[n][i] = null) : t[n][i] = r.clone() : Array.isArray(r) ? t[n][i] = r.slice() : t[n][i] = r
                }
            }
            return t
        }

        function Zr(e) {
            const t = {};
            for (let n = 0; n < e.length; n++) {
                const i = Xr(e[n]);
                for (const e in i) t[e] = i[e]
            }
            return t
        }

        function _r(e) {
            const t = e.getRenderTarget();
            return null === t ? e.outputColorSpace : !0 === t.isXRRenderTarget ? t.texture.colorSpace : yn.workingColorSpace
        }
        const $r = {
            clone: Xr,
            merge: Zr
        };
        class eo extends cr {
            constructor(e) {
                super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
                    clipCullDistance: !1,
                    multiDraw: !1
                }, this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv1: [0, 0]
                }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== e && this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = Xr(e.uniforms), this.uniformsGroups = function(e) {
                    const t = [];
                    for (let n = 0; n < e.length; n++) t.push(e[n].clone());
                    return t
                }(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this
            }
            toJSON(e) {
                const t = super.toJSON(e);
                t.glslVersion = this.glslVersion, t.uniforms = {};
                for (const n in this.uniforms) {
                    const i = this.uniforms[n].value;
                    i && i.isTexture ? t.uniforms[n] = {
                        type: "t",
                        value: i.toJSON(e).uuid
                    } : i && i.isColor ? t.uniforms[n] = {
                        type: "c",
                        value: i.getHex()
                    } : i && i.isVector2 ? t.uniforms[n] = {
                        type: "v2",
                        value: i.toArray()
                    } : i && i.isVector3 ? t.uniforms[n] = {
                        type: "v3",
                        value: i.toArray()
                    } : i && i.isVector4 ? t.uniforms[n] = {
                        type: "v4",
                        value: i.toArray()
                    } : i && i.isMatrix3 ? t.uniforms[n] = {
                        type: "m3",
                        value: i.toArray()
                    } : i && i.isMatrix4 ? t.uniforms[n] = {
                        type: "m4",
                        value: i.toArray()
                    } : t.uniforms[n] = {
                        value: i
                    }
                }
                Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
                const n = {};
                for (const e in this.extensions) !0 === this.extensions[e] && (n[e] = !0);
                return Object.keys(n).length > 0 && (t.extensions = n), t
            }
        }
        class to extends qi {
            constructor() {
                super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new mi, this.projectionMatrix = new mi, this.projectionMatrixInverse = new mi, this.coordinateSystem = _t
            }
            copy(e, t) {
                return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this
            }
            getWorldDirection(e) {
                return super.getWorldDirection(e).negate()
            }
            updateMatrixWorld(e) {
                super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            updateWorldMatrix(e, t) {
                super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const no = new On,
            io = new dn,
            ro = new dn;
        class oo extends to {
            constructor(e = 50, t = 1, n = .1, i = 2e3) {
                super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
            }
            copy(e, t) {
                return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
            }
            setFocalLength(e) {
                const t = .5 * this.getFilmHeight() / e;
                this.fov = 2 * on * Math.atan(t), this.updateProjectionMatrix()
            }
            getFocalLength() {
                const e = Math.tan(.5 * rn * this.fov);
                return .5 * this.getFilmHeight() / e
            }
            getEffectiveFOV() {
                return 2 * on * Math.atan(Math.tan(.5 * rn * this.fov) / this.zoom)
            }
            getFilmWidth() {
                return this.filmGauge * Math.min(this.aspect, 1)
            }
            getFilmHeight() {
                return this.filmGauge / Math.max(this.aspect, 1)
            }
            getViewBounds(e, t, n) {
                no.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse), t.set(no.x, no.y).multiplyScalar(-e / no.z), no.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse), n.set(no.x, no.y).multiplyScalar(-e / no.z)
            }
            getViewSize(e, t) {
                return this.getViewBounds(e, io, ro), t.subVectors(ro, io)
            }
            setViewOffset(e, t, n, i, r, o) {
                this.aspect = e / t, null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = o, this.updateProjectionMatrix()
            }
            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const e = this.near;
                let t = e * Math.tan(.5 * rn * this.fov) / this.zoom,
                    n = 2 * t,
                    i = this.aspect * n,
                    r = -.5 * i;
                const o = this.view;
                if (null !== this.view && this.view.enabled) {
                    const e = o.fullWidth,
                        s = o.fullHeight;
                    r += o.offsetX * i / e, t -= o.offsetY * n / s, i *= o.width / e, n *= o.height / s
                }
                const s = this.filmOffset;
                0 !== s && (r += e * s / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, t, t - n, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
            }
        }
        const so = -90;
        class ao extends qi {
            constructor(e, t, n) {
                super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null, this.activeMipmapLevel = 0;
                const i = new oo(so, 1, e, t);
                i.layers = this.layers, this.add(i);
                const r = new oo(so, 1, e, t);
                r.layers = this.layers, this.add(r);
                const o = new oo(so, 1, e, t);
                o.layers = this.layers, this.add(o);
                const s = new oo(so, 1, e, t);
                s.layers = this.layers, this.add(s);
                const a = new oo(so, 1, e, t);
                a.layers = this.layers, this.add(a);
                const l = new oo(so, 1, e, t);
                l.layers = this.layers, this.add(l)
            }
            updateCoordinateSystem() {
                const e = this.coordinateSystem,
                    t = this.children.concat(),
                    [n, i, r, o, s, a] = t;
                for (const e of t) this.remove(e);
                if (e === _t) n.up.set(0, 1, 0), n.lookAt(1, 0, 0), i.up.set(0, 1, 0), i.lookAt(-1, 0, 0), r.up.set(0, 0, -1), r.lookAt(0, 1, 0), o.up.set(0, 0, 1), o.lookAt(0, -1, 0), s.up.set(0, 1, 0), s.lookAt(0, 0, 1), a.up.set(0, 1, 0), a.lookAt(0, 0, -1);
                else {
                    if (e !== $t) throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
                    n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), i.up.set(0, -1, 0), i.lookAt(1, 0, 0), r.up.set(0, 0, 1), r.lookAt(0, 1, 0), o.up.set(0, 0, -1), o.lookAt(0, -1, 0), s.up.set(0, -1, 0), s.lookAt(0, 0, 1), a.up.set(0, -1, 0), a.lookAt(0, 0, -1)
                }
                for (const e of t) this.add(e), e.updateMatrixWorld()
            }
            update(e, t) {
                null === this.parent && this.updateMatrixWorld();
                const {
                    renderTarget: n,
                    activeMipmapLevel: i
                } = this;
                this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
                const [r, o, s, a, l, c] = this.children, A = e.getRenderTarget(), h = e.getActiveCubeFace(), u = e.getActiveMipmapLevel(), d = e.xr.enabled;
                e.xr.enabled = !1;
                const p = n.texture.generateMipmaps;
                n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0, i), e.render(t, r), e.setRenderTarget(n, 1, i), e.render(t, o), e.setRenderTarget(n, 2, i), e.render(t, s), e.setRenderTarget(n, 3, i), e.render(t, a), e.setRenderTarget(n, 4, i), e.render(t, l), n.texture.generateMipmaps = p, e.setRenderTarget(n, 5, i), e.render(t, c), e.setRenderTarget(A, h, u), e.xr.enabled = d, n.texture.needsPMREMUpdate = !0
            }
        }
        class lo extends Dn {
            constructor(e, t, n, i, r, o, s, a, l, c) {
                super(e = void 0 !== e ? e : [], t = void 0 !== t ? t : je, n, i, r, o, s, a, l, c), this.isCubeTexture = !0, this.flipY = !1
            }
            get images() {
                return this.image
            }
            set images(e) {
                this.image = e
            }
        }
        class co extends Kn {
            constructor(e = 1, t = {}) {
                super(e, e, t), this.isWebGLCubeRenderTarget = !0;
                const n = {
                        width: e,
                        height: e,
                        depth: 1
                    },
                    i = [n, n, n, n, n, n];
                this.texture = new lo(i, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== t.generateMipmaps && t.generateMipmaps, this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : nt
            }
            fromEquirectangularTexture(e, t) {
                this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
                const n = {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                        fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
                    },
                    i = new zr(5, 5, 5),
                    r = new eo({
                        name: "CubemapFromEquirect",
                        uniforms: Xr(n.uniforms),
                        vertexShader: n.vertexShader,
                        fragmentShader: n.fragmentShader,
                        side: Me,
                        blending: 0
                    });
                r.uniforms.tEquirect.value = t;
                const o = new Jr(i, r),
                    s = t.minFilter;
                t.minFilter === rt && (t.minFilter = nt);
                return new ao(1, 10, this).update(e, o), t.minFilter = s, o.geometry.dispose(), o.material.dispose(), this
            }
            clear(e, t, n, i) {
                const r = e.getRenderTarget();
                for (let r = 0; r < 6; r++) e.setRenderTarget(this, r), e.clear(t, n, i);
                e.setRenderTarget(r)
            }
        }
        const Ao = new On,
            ho = new On,
            uo = new pn;
        class po {
            constructor(e = new On(1, 0, 0), t = 0) {
                this.isPlane = !0, this.normal = e, this.constant = t
            }
            set(e, t) {
                return this.normal.copy(e), this.constant = t, this
            }
            setComponents(e, t, n, i) {
                return this.normal.set(e, t, n), this.constant = i, this
            }
            setFromNormalAndCoplanarPoint(e, t) {
                return this.normal.copy(e), this.constant = -t.dot(this.normal), this
            }
            setFromCoplanarPoints(e, t, n) {
                const i = Ao.subVectors(n, t).cross(ho.subVectors(e, t)).normalize();
                return this.setFromNormalAndCoplanarPoint(i, e), this
            }
            copy(e) {
                return this.normal.copy(e.normal), this.constant = e.constant, this
            }
            normalize() {
                const e = 1 / this.normal.length();
                return this.normal.multiplyScalar(e), this.constant *= e, this
            }
            negate() {
                return this.constant *= -1, this.normal.negate(), this
            }
            distanceToPoint(e) {
                return this.normal.dot(e) + this.constant
            }
            distanceToSphere(e) {
                return this.distanceToPoint(e.center) - e.radius
            }
            projectPoint(e, t) {
                return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
            }
            intersectLine(e, t) {
                const n = e.delta(Ao),
                    i = this.normal.dot(n);
                if (0 === i) return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
                const r = -(e.start.dot(this.normal) + this.constant) / i;
                return r < 0 || r > 1 ? null : t.copy(e.start).addScaledVector(n, r)
            }
            intersectsLine(e) {
                const t = this.distanceToPoint(e.start),
                    n = this.distanceToPoint(e.end);
                return t < 0 && n > 0 || n < 0 && t > 0
            }
            intersectsBox(e) {
                return e.intersectsPlane(this)
            }
            intersectsSphere(e) {
                return e.intersectsPlane(this)
            }
            coplanarPoint(e) {
                return e.copy(this.normal).multiplyScalar(-this.constant)
            }
            applyMatrix4(e, t) {
                const n = t || uo.getNormalMatrix(e),
                    i = this.coplanarPoint(Ao).applyMatrix4(e),
                    r = this.normal.applyMatrix3(n).normalize();
                return this.constant = -i.dot(r), this
            }
            translate(e) {
                return this.constant -= e.dot(this.normal), this
            }
            equals(e) {
                return e.normal.equals(this.normal) && e.constant === this.constant
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        const go = new li,
            fo = new On;
        class mo {
            constructor(e = new po, t = new po, n = new po, i = new po, r = new po, o = new po) {
                this.planes = [e, t, n, i, r, o]
            }
            set(e, t, n, i, r, o) {
                const s = this.planes;
                return s[0].copy(e), s[1].copy(t), s[2].copy(n), s[3].copy(i), s[4].copy(r), s[5].copy(o), this
            }
            copy(e) {
                const t = this.planes;
                for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
                return this
            }
            setFromProjectionMatrix(e, t = 2e3) {
                const n = this.planes,
                    i = e.elements,
                    r = i[0],
                    o = i[1],
                    s = i[2],
                    a = i[3],
                    l = i[4],
                    c = i[5],
                    A = i[6],
                    h = i[7],
                    u = i[8],
                    d = i[9],
                    p = i[10],
                    g = i[11],
                    f = i[12],
                    m = i[13],
                    E = i[14],
                    C = i[15];
                if (n[0].setComponents(a - r, h - l, g - u, C - f).normalize(), n[1].setComponents(a + r, h + l, g + u, C + f).normalize(), n[2].setComponents(a + o, h + c, g + d, C + m).normalize(), n[3].setComponents(a - o, h - c, g - d, C - m).normalize(), n[4].setComponents(a - s, h - A, g - p, C - E).normalize(), t === _t) n[5].setComponents(a + s, h + A, g + p, C + E).normalize();
                else {
                    if (t !== $t) throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
                    n[5].setComponents(s, A, p, E).normalize()
                }
                return this
            }
            intersectsObject(e) {
                if (void 0 !== e.boundingSphere) null === e.boundingSphere && e.computeBoundingSphere(), go.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
                else {
                    const t = e.geometry;
                    null === t.boundingSphere && t.computeBoundingSphere(), go.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
                }
                return this.intersectsSphere(go)
            }
            intersectsSprite(e) {
                return go.center.set(0, 0, 0), go.radius = .7071067811865476, go.applyMatrix4(e.matrixWorld), this.intersectsSphere(go)
            }
            intersectsSphere(e) {
                const t = this.planes,
                    n = e.center,
                    i = -e.radius;
                for (let e = 0; e < 6; e++) {
                    if (t[e].distanceToPoint(n) < i) return !1
                }
                return !0
            }
            intersectsBox(e) {
                const t = this.planes;
                for (let n = 0; n < 6; n++) {
                    const i = t[n];
                    if (fo.x = i.normal.x > 0 ? e.max.x : e.min.x, fo.y = i.normal.y > 0 ? e.max.y : e.min.y, fo.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(fo) < 0) return !1
                }
                return !0
            }
            containsPoint(e) {
                const t = this.planes;
                for (let n = 0; n < 6; n++)
                    if (t[n].distanceToPoint(e) < 0) return !1;
                return !0
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }

        function Eo() {
            let e = null,
                t = !1,
                n = null,
                i = null;

            function r(t, o) {
                n(t, o), i = e.requestAnimationFrame(r)
            }
            return {
                start: function() {
                    !0 !== t && null !== n && (i = e.requestAnimationFrame(r), t = !0)
                },
                stop: function() {
                    e.cancelAnimationFrame(i), t = !1
                },
                setAnimationLoop: function(e) {
                    n = e
                },
                setContext: function(t) {
                    e = t
                }
            }
        }

        function Co(e) {
            const t = new WeakMap;
            return {
                get: function(e) {
                    return e.isInterleavedBufferAttribute && (e = e.data), t.get(e)
                },
                remove: function(n) {
                    n.isInterleavedBufferAttribute && (n = n.data);
                    const i = t.get(n);
                    i && (e.deleteBuffer(i.buffer), t.delete(n))
                },
                update: function(n, i) {
                    if (n.isGLBufferAttribute) {
                        const e = t.get(n);
                        return void((!e || e.version < n.version) && t.set(n, {
                            buffer: n.buffer,
                            type: n.type,
                            bytesPerElement: n.elementSize,
                            version: n.version
                        }))
                    }
                    n.isInterleavedBufferAttribute && (n = n.data);
                    const r = t.get(n);
                    if (void 0 === r) t.set(n, function(t, n) {
                        const i = t.array,
                            r = t.usage,
                            o = i.byteLength,
                            s = e.createBuffer();
                        let a;
                        if (e.bindBuffer(n, s), e.bufferData(n, i, r), t.onUploadCallback(), i instanceof Float32Array) a = e.FLOAT;
                        else if (i instanceof Uint16Array) a = t.isFloat16BufferAttribute ? e.HALF_FLOAT : e.UNSIGNED_SHORT;
                        else if (i instanceof Int16Array) a = e.SHORT;
                        else if (i instanceof Uint32Array) a = e.UNSIGNED_INT;
                        else if (i instanceof Int32Array) a = e.INT;
                        else if (i instanceof Int8Array) a = e.BYTE;
                        else if (i instanceof Uint8Array) a = e.UNSIGNED_BYTE;
                        else {
                            if (!(i instanceof Uint8ClampedArray)) throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + i);
                            a = e.UNSIGNED_BYTE
                        }
                        return {
                            buffer: s,
                            type: a,
                            bytesPerElement: i.BYTES_PER_ELEMENT,
                            version: t.version,
                            size: o
                        }
                    }(n, i));
                    else if (r.version < n.version) {
                        if (r.size !== n.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
                        ! function(t, n, i) {
                            const r = n.array,
                                o = n._updateRange,
                                s = n.updateRanges;
                            if (e.bindBuffer(i, t), -1 === o.count && 0 === s.length && e.bufferSubData(i, 0, r), 0 !== s.length) {
                                for (let t = 0, n = s.length; t < n; t++) {
                                    const n = s[t];
                                    e.bufferSubData(i, n.start * r.BYTES_PER_ELEMENT, r, n.start, n.count)
                                }
                                n.clearUpdateRanges()
                            } - 1 !== o.count && (e.bufferSubData(i, o.offset * r.BYTES_PER_ELEMENT, r, o.offset, o.count), o.count = -1), n.onUploadCallback()
                        }(r.buffer, n, i), r.version = n.version
                    }
                }
            }
        }
        class Io extends Ur {
            constructor(e = 1, t = 1, n = 1, i = 1) {
                super(), this.type = "PlaneGeometry", this.parameters = {
                    width: e,
                    height: t,
                    widthSegments: n,
                    heightSegments: i
                };
                const r = e / 2,
                    o = t / 2,
                    s = Math.floor(n),
                    a = Math.floor(i),
                    l = s + 1,
                    c = a + 1,
                    A = e / s,
                    h = t / a,
                    u = [],
                    d = [],
                    p = [],
                    g = [];
                for (let e = 0; e < c; e++) {
                    const t = e * h - o;
                    for (let n = 0; n < l; n++) {
                        const i = n * A - r;
                        d.push(i, -t, 0), p.push(0, 0, 1), g.push(n / s), g.push(1 - e / a)
                    }
                }
                for (let e = 0; e < a; e++)
                    for (let t = 0; t < s; t++) {
                        const n = t + l * e,
                            i = t + l * (e + 1),
                            r = t + 1 + l * (e + 1),
                            o = t + 1 + l * e;
                        u.push(n, i, o), u.push(i, r, o)
                    }
                this.setIndex(u), this.setAttribute("position", new Sr(d, 3)), this.setAttribute("normal", new Sr(p, 3)), this.setAttribute("uv", new Sr(g, 2))
            }
            copy(e) {
                return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
            }
            static fromJSON(e) {
                return new Io(e.width, e.height, e.widthSegments, e.heightSegments)
            }
        }
        const So = {
                alphahash_fragment: "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",
                alphahash_pars_fragment: "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",
                alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",
                alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                alphatest_fragment: "#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif",
                alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
                aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
                aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                batching_pars_vertex: "#ifdef USE_BATCHING\n\tattribute float batchId;\n\tuniform highp sampler2D batchingTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
                batching_vertex: "#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( batchId );\n#endif",
                begin_vertex: "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",
                beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
                bsdfs: "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",
                iridescence_fragment: "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
                bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif",
                clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
                clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
                color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
                color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
                color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
                color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
                common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",
                cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
                defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
                displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",
                emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                colorspace_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                colorspace_pars_fragment: "\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n\tvec3( 0.8224621, 0.177538, 0.0 ),\n\tvec3( 0.0331941, 0.9668058, 0.0 ),\n\tvec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.2249401, - 0.2249404, 0.0 ),\n\tvec3( - 0.0420569, 1.0420571, 0.0 ),\n\tvec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn sRGBTransferOETF( value );\n}",
                envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform mat3 envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
                envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                envmap_physical_pars_fragment: "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",
                envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
                fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
                fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
                lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                lights_lambert_fragment: "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
                lights_lambert_pars_fragment: "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",
                lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( LEGACY_LIGHTS )\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#else\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
                lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
                lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",
                lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",
                lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n\tmaterial.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif",
                lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\tfloat dispersion;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                lights_fragment_begin: "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
                lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
                lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif",
                logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF )\n\tgl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\tvFragDepth = 1.0 + gl_Position.w;\n\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif",
                map_fragment: "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
                map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
                map_particle_pars_fragment: "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                morphinstance_vertex: "#ifdef USE_INSTANCING_MORPH\n\tfloat morphTargetInfluences[MORPHTARGETS_COUNT];\n\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n\t}\n#endif",
                morphcolor_vertex: "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
                morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
                morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_INSTANCING_MORPH\n\t\tuniform float morphTargetBaseInfluence;\n\t#endif\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\t#ifndef USE_INSTANCING_MORPH\n\t\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\t#endif\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
                morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
                normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;",
                normal_fragment_maps: "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
                normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
                normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",
                clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif",
                clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",
                clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",
                iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
                opaque_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
                packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",
                premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
                dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                shadowmap_pars_fragment: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tfloat shadow = 1.0;\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\t\n\t\tfloat lightToPositionLength = length( lightToPosition );\n\t\tif ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n\t\t\tfloat dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\t\tdp += shadowBias;\n\t\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\t\tshadow = (\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t\t) * ( 1.0 / 9.0 );\n\t\t\t#else\n\t\t\t\tshadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n#endif",
                shadowmap_pars_vertex: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
                shadowmap_vertex: "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",
                shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
                skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
                specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n\tconst float StartCompression = 0.8 - 0.04;\n\tconst float Desaturation = 0.15;\n\tcolor *= toneMappingExposure;\n\tfloat x = min( color.r, min( color.g, color.b ) );\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max( color.r, max( color.g, color.b ) );\n\tif ( peak < StartCompression ) return color;\n\tfloat d = 1. - StartCompression;\n\tfloat newPeak = 1. - d * d / ( peak + d - StartCompression );\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n\treturn mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
                transmission_fragment: "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",
                transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec4 transmittedLight;\n\t\tvec3 transmittance;\n\t\t#ifdef USE_DISPERSION\n\t\t\tfloat halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n\t\t\tvec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n\t\t\tfor ( int i = 0; i < 3; i ++ ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\t\t\n\t\t\t\tvec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n\t\t\t\ttransmittedLight[ i ] = transmissionSample[ i ];\n\t\t\t\ttransmittedLight.a += transmissionSample.a;\n\t\t\t\ttransmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n\t\t\t}\n\t\t\ttransmittedLight.a /= 3.0;\n\t\t\n\t\t#else\n\t\t\n\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\trefractionCoords += 1.0;\n\t\t\trefractionCoords /= 2.0;\n\t\t\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\t\ttransmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\t\n\t\t#endif\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",
                uv_pars_fragment: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
                uv_pars_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
                uv_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",
                worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
                background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                background_frag: "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                backgroundCube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                backgroundCube_frag: "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                depth_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
                depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
                distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                meshbasic_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshlambert_vert: "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshlambert_frag: "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
                meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
                meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n\tuniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                shadow_vert: "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
                sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}"
            },
            vo = {
                common: {
                    diffuse: {
                        value: new sr(16777215)
                    },
                    opacity: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    mapTransform: {
                        value: new pn
                    },
                    alphaMap: {
                        value: null
                    },
                    alphaMapTransform: {
                        value: new pn
                    },
                    alphaTest: {
                        value: 0
                    }
                },
                specularmap: {
                    specularMap: {
                        value: null
                    },
                    specularMapTransform: {
                        value: new pn
                    }
                },
                envmap: {
                    envMap: {
                        value: null
                    },
                    envMapRotation: {
                        value: new pn
                    },
                    flipEnvMap: {
                        value: -1
                    },
                    reflectivity: {
                        value: 1
                    },
                    ior: {
                        value: 1.5
                    },
                    refractionRatio: {
                        value: .98
                    }
                },
                aomap: {
                    aoMap: {
                        value: null
                    },
                    aoMapIntensity: {
                        value: 1
                    },
                    aoMapTransform: {
                        value: new pn
                    }
                },
                lightmap: {
                    lightMap: {
                        value: null
                    },
                    lightMapIntensity: {
                        value: 1
                    },
                    lightMapTransform: {
                        value: new pn
                    }
                },
                bumpmap: {
                    bumpMap: {
                        value: null
                    },
                    bumpMapTransform: {
                        value: new pn
                    },
                    bumpScale: {
                        value: 1
                    }
                },
                normalmap: {
                    normalMap: {
                        value: null
                    },
                    normalMapTransform: {
                        value: new pn
                    },
                    normalScale: {
                        value: new dn(1, 1)
                    }
                },
                displacementmap: {
                    displacementMap: {
                        value: null
                    },
                    displacementMapTransform: {
                        value: new pn
                    },
                    displacementScale: {
                        value: 1
                    },
                    displacementBias: {
                        value: 0
                    }
                },
                emissivemap: {
                    emissiveMap: {
                        value: null
                    },
                    emissiveMapTransform: {
                        value: new pn
                    }
                },
                metalnessmap: {
                    metalnessMap: {
                        value: null
                    },
                    metalnessMapTransform: {
                        value: new pn
                    }
                },
                roughnessmap: {
                    roughnessMap: {
                        value: null
                    },
                    roughnessMapTransform: {
                        value: new pn
                    }
                },
                gradientmap: {
                    gradientMap: {
                        value: null
                    }
                },
                fog: {
                    fogDensity: {
                        value: 25e-5
                    },
                    fogNear: {
                        value: 1
                    },
                    fogFar: {
                        value: 2e3
                    },
                    fogColor: {
                        value: new sr(16777215)
                    }
                },
                lights: {
                    ambientLightColor: {
                        value: []
                    },
                    lightProbe: {
                        value: []
                    },
                    directionalLights: {
                        value: [],
                        properties: {
                            direction: {},
                            color: {}
                        }
                    },
                    directionalLightShadows: {
                        value: [],
                        properties: {
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    directionalShadowMap: {
                        value: []
                    },
                    directionalShadowMatrix: {
                        value: []
                    },
                    spotLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            direction: {},
                            distance: {},
                            coneCos: {},
                            penumbraCos: {},
                            decay: {}
                        }
                    },
                    spotLightShadows: {
                        value: [],
                        properties: {
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    spotLightMap: {
                        value: []
                    },
                    spotShadowMap: {
                        value: []
                    },
                    spotLightMatrix: {
                        value: []
                    },
                    pointLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            decay: {},
                            distance: {}
                        }
                    },
                    pointLightShadows: {
                        value: [],
                        properties: {
                            shadowBias: {},
                            shadowNormalBias: {},
                            shadowRadius: {},
                            shadowMapSize: {},
                            shadowCameraNear: {},
                            shadowCameraFar: {}
                        }
                    },
                    pointShadowMap: {
                        value: []
                    },
                    pointShadowMatrix: {
                        value: []
                    },
                    hemisphereLights: {
                        value: [],
                        properties: {
                            direction: {},
                            skyColor: {},
                            groundColor: {}
                        }
                    },
                    rectAreaLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            width: {},
                            height: {}
                        }
                    },
                    ltc_1: {
                        value: null
                    },
                    ltc_2: {
                        value: null
                    }
                },
                points: {
                    diffuse: {
                        value: new sr(16777215)
                    },
                    opacity: {
                        value: 1
                    },
                    size: {
                        value: 1
                    },
                    scale: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    alphaMap: {
                        value: null
                    },
                    alphaMapTransform: {
                        value: new pn
                    },
                    alphaTest: {
                        value: 0
                    },
                    uvTransform: {
                        value: new pn
                    }
                },
                sprite: {
                    diffuse: {
                        value: new sr(16777215)
                    },
                    opacity: {
                        value: 1
                    },
                    center: {
                        value: new dn(.5, .5)
                    },
                    rotation: {
                        value: 0
                    },
                    map: {
                        value: null
                    },
                    mapTransform: {
                        value: new pn
                    },
                    alphaMap: {
                        value: null
                    },
                    alphaMapTransform: {
                        value: new pn
                    },
                    alphaTest: {
                        value: 0
                    }
                }
            },
            Bo = {
                basic: {
                    uniforms: Zr([vo.common, vo.specularmap, vo.envmap, vo.aomap, vo.lightmap, vo.fog]),
                    vertexShader: So.meshbasic_vert,
                    fragmentShader: So.meshbasic_frag
                },
                lambert: {
                    uniforms: Zr([vo.common, vo.specularmap, vo.envmap, vo.aomap, vo.lightmap, vo.emissivemap, vo.bumpmap, vo.normalmap, vo.displacementmap, vo.fog, vo.lights, {
                        emissive: {
                            value: new sr(0)
                        }
                    }]),
                    vertexShader: So.meshlambert_vert,
                    fragmentShader: So.meshlambert_frag
                },
                phong: {
                    uniforms: Zr([vo.common, vo.specularmap, vo.envmap, vo.aomap, vo.lightmap, vo.emissivemap, vo.bumpmap, vo.normalmap, vo.displacementmap, vo.fog, vo.lights, {
                        emissive: {
                            value: new sr(0)
                        },
                        specular: {
                            value: new sr(1118481)
                        },
                        shininess: {
                            value: 30
                        }
                    }]),
                    vertexShader: So.meshphong_vert,
                    fragmentShader: So.meshphong_frag
                },
                standard: {
                    uniforms: Zr([vo.common, vo.envmap, vo.aomap, vo.lightmap, vo.emissivemap, vo.bumpmap, vo.normalmap, vo.displacementmap, vo.roughnessmap, vo.metalnessmap, vo.fog, vo.lights, {
                        emissive: {
                            value: new sr(0)
                        },
                        roughness: {
                            value: 1
                        },
                        metalness: {
                            value: 0
                        },
                        envMapIntensity: {
                            value: 1
                        }
                    }]),
                    vertexShader: So.meshphysical_vert,
                    fragmentShader: So.meshphysical_frag
                },
                toon: {
                    uniforms: Zr([vo.common, vo.aomap, vo.lightmap, vo.emissivemap, vo.bumpmap, vo.normalmap, vo.displacementmap, vo.gradientmap, vo.fog, vo.lights, {
                        emissive: {
                            value: new sr(0)
                        }
                    }]),
                    vertexShader: So.meshtoon_vert,
                    fragmentShader: So.meshtoon_frag
                },
                matcap: {
                    uniforms: Zr([vo.common, vo.bumpmap, vo.normalmap, vo.displacementmap, vo.fog, {
                        matcap: {
                            value: null
                        }
                    }]),
                    vertexShader: So.meshmatcap_vert,
                    fragmentShader: So.meshmatcap_frag
                },
                points: {
                    uniforms: Zr([vo.points, vo.fog]),
                    vertexShader: So.points_vert,
                    fragmentShader: So.points_frag
                },
                dashed: {
                    uniforms: Zr([vo.common, vo.fog, {
                        scale: {
                            value: 1
                        },
                        dashSize: {
                            value: 1
                        },
                        totalSize: {
                            value: 2
                        }
                    }]),
                    vertexShader: So.linedashed_vert,
                    fragmentShader: So.linedashed_frag
                },
                depth: {
                    uniforms: Zr([vo.common, vo.displacementmap]),
                    vertexShader: So.depth_vert,
                    fragmentShader: So.depth_frag
                },
                normal: {
                    uniforms: Zr([vo.common, vo.bumpmap, vo.normalmap, vo.displacementmap, {
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: So.meshnormal_vert,
                    fragmentShader: So.meshnormal_frag
                },
                sprite: {
                    uniforms: Zr([vo.sprite, vo.fog]),
                    vertexShader: So.sprite_vert,
                    fragmentShader: So.sprite_frag
                },
                background: {
                    uniforms: {
                        uvTransform: {
                            value: new pn
                        },
                        t2D: {
                            value: null
                        },
                        backgroundIntensity: {
                            value: 1
                        }
                    },
                    vertexShader: So.background_vert,
                    fragmentShader: So.background_frag
                },
                backgroundCube: {
                    uniforms: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        backgroundBlurriness: {
                            value: 0
                        },
                        backgroundIntensity: {
                            value: 1
                        },
                        backgroundRotation: {
                            value: new pn
                        }
                    },
                    vertexShader: So.backgroundCube_vert,
                    fragmentShader: So.backgroundCube_frag
                },
                cube: {
                    uniforms: {
                        tCube: {
                            value: null
                        },
                        tFlip: {
                            value: -1
                        },
                        opacity: {
                            value: 1
                        }
                    },
                    vertexShader: So.cube_vert,
                    fragmentShader: So.cube_frag
                },
                equirect: {
                    uniforms: {
                        tEquirect: {
                            value: null
                        }
                    },
                    vertexShader: So.equirect_vert,
                    fragmentShader: So.equirect_frag
                },
                distanceRGBA: {
                    uniforms: Zr([vo.common, vo.displacementmap, {
                        referencePosition: {
                            value: new On
                        },
                        nearDistance: {
                            value: 1
                        },
                        farDistance: {
                            value: 1e3
                        }
                    }]),
                    vertexShader: So.distanceRGBA_vert,
                    fragmentShader: So.distanceRGBA_frag
                },
                shadow: {
                    uniforms: Zr([vo.lights, vo.fog, {
                        color: {
                            value: new sr(0)
                        },
                        opacity: {
                            value: 1
                        }
                    }]),
                    vertexShader: So.shadow_vert,
                    fragmentShader: So.shadow_frag
                }
            };
        Bo.physical = {
            uniforms: Zr([Bo.standard.uniforms, {
                clearcoat: {
                    value: 0
                },
                clearcoatMap: {
                    value: null
                },
                clearcoatMapTransform: {
                    value: new pn
                },
                clearcoatNormalMap: {
                    value: null
                },
                clearcoatNormalMapTransform: {
                    value: new pn
                },
                clearcoatNormalScale: {
                    value: new dn(1, 1)
                },
                clearcoatRoughness: {
                    value: 0
                },
                clearcoatRoughnessMap: {
                    value: null
                },
                clearcoatRoughnessMapTransform: {
                    value: new pn
                },
                dispersion: {
                    value: 0
                },
                iridescence: {
                    value: 0
                },
                iridescenceMap: {
                    value: null
                },
                iridescenceMapTransform: {
                    value: new pn
                },
                iridescenceIOR: {
                    value: 1.3
                },
                iridescenceThicknessMinimum: {
                    value: 100
                },
                iridescenceThicknessMaximum: {
                    value: 400
                },
                iridescenceThicknessMap: {
                    value: null
                },
                iridescenceThicknessMapTransform: {
                    value: new pn
                },
                sheen: {
                    value: 0
                },
                sheenColor: {
                    value: new sr(0)
                },
                sheenColorMap: {
                    value: null
                },
                sheenColorMapTransform: {
                    value: new pn
                },
                sheenRoughness: {
                    value: 1
                },
                sheenRoughnessMap: {
                    value: null
                },
                sheenRoughnessMapTransform: {
                    value: new pn
                },
                transmission: {
                    value: 0
                },
                transmissionMap: {
                    value: null
                },
                transmissionMapTransform: {
                    value: new pn
                },
                transmissionSamplerSize: {
                    value: new dn
                },
                transmissionSamplerMap: {
                    value: null
                },
                thickness: {
                    value: 0
                },
                thicknessMap: {
                    value: null
                },
                thicknessMapTransform: {
                    value: new pn
                },
                attenuationDistance: {
                    value: 0
                },
                attenuationColor: {
                    value: new sr(0)
                },
                specularColor: {
                    value: new sr(1, 1, 1)
                },
                specularColorMap: {
                    value: null
                },
                specularColorMapTransform: {
                    value: new pn
                },
                specularIntensity: {
                    value: 1
                },
                specularIntensityMap: {
                    value: null
                },
                specularIntensityMapTransform: {
                    value: new pn
                },
                anisotropyVector: {
                    value: new dn
                },
                anisotropyMap: {
                    value: null
                },
                anisotropyMapTransform: {
                    value: new pn
                }
            }]),
            vertexShader: So.meshphysical_vert,
            fragmentShader: So.meshphysical_frag
        };
        const xo = {
                r: 0,
                b: 0,
                g: 0
            },
            yo = new bi,
            wo = new mi;

        function bo(e, t, n, i, r, o, s) {
            const a = new sr(0);
            let l, c, A = !0 === o ? 0 : 1,
                h = null,
                u = 0,
                d = null;

            function p(e) {
                let i = !0 === e.isScene ? e.background : null;
                if (i && i.isTexture) {
                    i = (e.backgroundBlurriness > 0 ? n : t).get(i)
                }
                return i
            }

            function g(t, n) {
                t.getRGB(xo, _r(e)), i.buffers.color.setClear(xo.r, xo.g, xo.b, n, s)
            }
            return {
                getClearColor: function() {
                    return a
                },
                setClearColor: function(e, t = 1) {
                    a.set(e), A = t, g(a, A)
                },
                getClearAlpha: function() {
                    return A
                },
                setClearAlpha: function(e) {
                    A = e, g(a, A)
                },
                render: function(t) {
                    let n = !1;
                    const r = p(t);
                    null === r ? g(a, A) : r && r.isColor && (g(r, 1), n = !0);
                    const o = e.xr.getEnvironmentBlendMode();
                    "additive" === o ? i.buffers.color.setClear(0, 0, 0, 1, s) : "alpha-blend" === o && i.buffers.color.setClear(0, 0, 0, 0, s), (e.autoClear || n) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil)
                },
                addToRenderList: function(t, n) {
                    const i = p(n);
                    i && (i.isCubeTexture || i.mapping === ze) ? (void 0 === c && (c = new Jr(new zr(1, 1, 1), new eo({
                        name: "BackgroundCubeMaterial",
                        uniforms: Xr(Bo.backgroundCube.uniforms),
                        vertexShader: Bo.backgroundCube.vertexShader,
                        fragmentShader: Bo.backgroundCube.fragmentShader,
                        side: Me,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })), c.geometry.deleteAttribute("normal"), c.geometry.deleteAttribute("uv"), c.onBeforeRender = function(e, t, n) {
                        this.matrixWorld.copyPosition(n.matrixWorld)
                    }, Object.defineProperty(c.material, "envMap", {
                        get: function() {
                            return this.uniforms.envMap.value
                        }
                    }), r.update(c)), yo.copy(n.backgroundRotation), yo.x *= -1, yo.y *= -1, yo.z *= -1, i.isCubeTexture && !1 === i.isRenderTargetTexture && (yo.y *= -1, yo.z *= -1), c.material.uniforms.envMap.value = i, c.material.uniforms.flipEnvMap.value = i.isCubeTexture && !1 === i.isRenderTargetTexture ? -1 : 1, c.material.uniforms.backgroundBlurriness.value = n.backgroundBlurriness, c.material.uniforms.backgroundIntensity.value = n.backgroundIntensity, c.material.uniforms.backgroundRotation.value.setFromMatrix4(wo.makeRotationFromEuler(yo)), c.material.toneMapped = yn.getTransfer(i.colorSpace) !== Yt, h === i && u === i.version && d === e.toneMapping || (c.material.needsUpdate = !0, h = i, u = i.version, d = e.toneMapping), c.layers.enableAll(), t.unshift(c, c.geometry, c.material, 0, 0, null)) : i && i.isTexture && (void 0 === l && (l = new Jr(new Io(2, 2), new eo({
                        name: "BackgroundMaterial",
                        uniforms: Xr(Bo.background.uniforms),
                        vertexShader: Bo.background.vertexShader,
                        fragmentShader: Bo.background.fragmentShader,
                        side: Ue,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1
                    })), l.geometry.deleteAttribute("normal"), Object.defineProperty(l.material, "map", {
                        get: function() {
                            return this.uniforms.t2D.value
                        }
                    }), r.update(l)), l.material.uniforms.t2D.value = i, l.material.uniforms.backgroundIntensity.value = n.backgroundIntensity, l.material.toneMapped = yn.getTransfer(i.colorSpace) !== Yt, !0 === i.matrixAutoUpdate && i.updateMatrix(), l.material.uniforms.uvTransform.value.copy(i.matrix), h === i && u === i.version && d === e.toneMapping || (l.material.needsUpdate = !0, h = i, u = i.version, d = e.toneMapping), l.layers.enableAll(), t.unshift(l, l.geometry, l.material, 0, 0, null))
                }
            }
        }

        function Qo(e, t) {
            const n = e.getParameter(e.MAX_VERTEX_ATTRIBS),
                i = {},
                r = c(null);
            let o = r,
                s = !1;

            function a(t) {
                return e.bindVertexArray(t)
            }

            function l(t) {
                return e.deleteVertexArray(t)
            }

            function c(e) {
                const t = [],
                    i = [],
                    r = [];
                for (let e = 0; e < n; e++) t[e] = 0, i[e] = 0, r[e] = 0;
                return {
                    geometry: null,
                    program: null,
                    wireframe: !1,
                    newAttributes: t,
                    enabledAttributes: i,
                    attributeDivisors: r,
                    object: e,
                    attributes: {},
                    index: null
                }
            }

            function A() {
                const e = o.newAttributes;
                for (let t = 0, n = e.length; t < n; t++) e[t] = 0
            }

            function h(e) {
                u(e, 0)
            }

            function u(t, n) {
                const i = o.newAttributes,
                    r = o.enabledAttributes,
                    s = o.attributeDivisors;
                i[t] = 1, 0 === r[t] && (e.enableVertexAttribArray(t), r[t] = 1), s[t] !== n && (e.vertexAttribDivisor(t, n), s[t] = n)
            }

            function d() {
                const t = o.newAttributes,
                    n = o.enabledAttributes;
                for (let i = 0, r = n.length; i < r; i++) n[i] !== t[i] && (e.disableVertexAttribArray(i), n[i] = 0)
            }

            function p(t, n, i, r, o, s, a) {
                !0 === a ? e.vertexAttribIPointer(t, n, i, o, s) : e.vertexAttribPointer(t, n, i, r, o, s)
            }

            function g() {
                f(), s = !0, o !== r && (o = r, a(o.object))
            }

            function f() {
                r.geometry = null, r.program = null, r.wireframe = !1
            }
            return {
                setup: function(n, r, l, g, f) {
                    let m = !1;
                    const E = function(t, n, r) {
                        const o = !0 === r.wireframe;
                        let s = i[t.id];
                        void 0 === s && (s = {}, i[t.id] = s);
                        let a = s[n.id];
                        void 0 === a && (a = {}, s[n.id] = a);
                        let l = a[o];
                        void 0 === l && (l = c(e.createVertexArray()), a[o] = l);
                        return l
                    }(g, l, r);
                    o !== E && (o = E, a(o.object)), m = function(e, t, n, i) {
                        const r = o.attributes,
                            s = t.attributes;
                        let a = 0;
                        const l = n.getAttributes();
                        for (const t in l) {
                            if (l[t].location >= 0) {
                                const n = r[t];
                                let i = s[t];
                                if (void 0 === i && ("instanceMatrix" === t && e.instanceMatrix && (i = e.instanceMatrix), "instanceColor" === t && e.instanceColor && (i = e.instanceColor)), void 0 === n) return !0;
                                if (n.attribute !== i) return !0;
                                if (i && n.data !== i.data) return !0;
                                a++
                            }
                        }
                        return o.attributesNum !== a || o.index !== i
                    }(n, g, l, f), m && function(e, t, n, i) {
                        const r = {},
                            s = t.attributes;
                        let a = 0;
                        const l = n.getAttributes();
                        for (const t in l) {
                            if (l[t].location >= 0) {
                                let n = s[t];
                                void 0 === n && ("instanceMatrix" === t && e.instanceMatrix && (n = e.instanceMatrix), "instanceColor" === t && e.instanceColor && (n = e.instanceColor));
                                const i = {};
                                i.attribute = n, n && n.data && (i.data = n.data), r[t] = i, a++
                            }
                        }
                        o.attributes = r, o.attributesNum = a, o.index = i
                    }(n, g, l, f), null !== f && t.update(f, e.ELEMENT_ARRAY_BUFFER), (m || s) && (s = !1, function(n, i, r, o) {
                        A();
                        const s = o.attributes,
                            a = r.getAttributes(),
                            l = i.defaultAttributeValues;
                        for (const i in a) {
                            const r = a[i];
                            if (r.location >= 0) {
                                let a = s[i];
                                if (void 0 === a && ("instanceMatrix" === i && n.instanceMatrix && (a = n.instanceMatrix), "instanceColor" === i && n.instanceColor && (a = n.instanceColor)), void 0 !== a) {
                                    const i = a.normalized,
                                        s = a.itemSize,
                                        l = t.get(a);
                                    if (void 0 === l) continue;
                                    const c = l.buffer,
                                        A = l.type,
                                        d = l.bytesPerElement,
                                        g = A === e.INT || A === e.UNSIGNED_INT || a.gpuType === st;
                                    if (a.isInterleavedBufferAttribute) {
                                        const t = a.data,
                                            l = t.stride,
                                            f = a.offset;
                                        if (t.isInstancedInterleavedBuffer) {
                                            for (let e = 0; e < r.locationSize; e++) u(r.location + e, t.meshPerAttribute);
                                            !0 !== n.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = t.meshPerAttribute * t.count)
                                        } else
                                            for (let e = 0; e < r.locationSize; e++) h(r.location + e);
                                        e.bindBuffer(e.ARRAY_BUFFER, c);
                                        for (let e = 0; e < r.locationSize; e++) p(r.location + e, s / r.locationSize, A, i, l * d, (f + s / r.locationSize * e) * d, g)
                                    } else {
                                        if (a.isInstancedBufferAttribute) {
                                            for (let e = 0; e < r.locationSize; e++) u(r.location + e, a.meshPerAttribute);
                                            !0 !== n.isInstancedMesh && void 0 === o._maxInstanceCount && (o._maxInstanceCount = a.meshPerAttribute * a.count)
                                        } else
                                            for (let e = 0; e < r.locationSize; e++) h(r.location + e);
                                        e.bindBuffer(e.ARRAY_BUFFER, c);
                                        for (let e = 0; e < r.locationSize; e++) p(r.location + e, s / r.locationSize, A, i, s * d, s / r.locationSize * e * d, g)
                                    }
                                } else if (void 0 !== l) {
                                    const t = l[i];
                                    if (void 0 !== t) switch (t.length) {
                                        case 2:
                                            e.vertexAttrib2fv(r.location, t);
                                            break;
                                        case 3:
                                            e.vertexAttrib3fv(r.location, t);
                                            break;
                                        case 4:
                                            e.vertexAttrib4fv(r.location, t);
                                            break;
                                        default:
                                            e.vertexAttrib1fv(r.location, t)
                                    }
                                }
                            }
                        }
                        d()
                    }(n, r, l, g), null !== f && e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t.get(f).buffer))
                },
                reset: g,
                resetDefaultState: f,
                dispose: function() {
                    g();
                    for (const e in i) {
                        const t = i[e];
                        for (const e in t) {
                            const n = t[e];
                            for (const e in n) l(n[e].object), delete n[e];
                            delete t[e]
                        }
                        delete i[e]
                    }
                },
                releaseStatesOfGeometry: function(e) {
                    if (void 0 === i[e.id]) return;
                    const t = i[e.id];
                    for (const e in t) {
                        const n = t[e];
                        for (const e in n) l(n[e].object), delete n[e];
                        delete t[e]
                    }
                    delete i[e.id]
                },
                releaseStatesOfProgram: function(e) {
                    for (const t in i) {
                        const n = i[t];
                        if (void 0 === n[e.id]) continue;
                        const r = n[e.id];
                        for (const e in r) l(r[e].object), delete r[e];
                        delete n[e.id]
                    }
                },
                initAttributes: A,
                enableAttribute: h,
                disableUnusedAttributes: d
            }
        }

        function Uo(e, t, n) {
            let i;

            function r(t, r, o) {
                0 !== o && (e.drawArraysInstanced(i, t, r, o), n.update(r, i, o))
            }
            this.setMode = function(e) {
                i = e
            }, this.render = function(t, r) {
                e.drawArrays(i, t, r), n.update(r, i, 1)
            }, this.renderInstances = r, this.renderMultiDraw = function(e, r, o) {
                if (0 === o) return;
                const s = t.get("WEBGL_multi_draw");
                if (null === s)
                    for (let t = 0; t < o; t++) this.render(e[t], r[t]);
                else {
                    s.multiDrawArraysWEBGL(i, e, 0, r, 0, o);
                    let t = 0;
                    for (let e = 0; e < o; e++) t += r[e];
                    n.update(t, i, 1)
                }
            }, this.renderMultiDrawInstances = function(e, o, s, a) {
                if (0 === s) return;
                const l = t.get("WEBGL_multi_draw");
                if (null === l)
                    for (let t = 0; t < e.length; t++) r(e[t], o[t], a[t]);
                else {
                    l.multiDrawArraysInstancedWEBGL(i, e, 0, o, 0, a, 0, s);
                    let t = 0;
                    for (let e = 0; e < s; e++) t += o[e];
                    for (let e = 0; e < a.length; e++) n.update(t, i, a[e])
                }
            }
        }

        function Mo(e, t, n, i) {
            let r;

            function o(t) {
                if ("highp" === t) {
                    if (e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision > 0) return "highp";
                    t = "mediump"
                }
                return "mediump" === t && e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
            }
            let s = void 0 !== n.precision ? n.precision : "highp";
            const a = o(s);
            a !== s && (console.warn("THREE.WebGLRenderer:", s, "not supported, using", a, "instead."), s = a);
            const l = !0 === n.logarithmicDepthBuffer,
                c = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),
                A = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
            return {
                isWebGL2: !0,
                getMaxAnisotropy: function() {
                    if (void 0 !== r) return r;
                    if (!0 === t.has("EXT_texture_filter_anisotropic")) {
                        const n = t.get("EXT_texture_filter_anisotropic");
                        r = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                    } else r = 0;
                    return r
                },
                getMaxPrecision: o,
                textureFormatReadable: function(t) {
                    return t === ht || i.convert(t) === e.getParameter(e.IMPLEMENTATION_COLOR_READ_FORMAT)
                },
                textureTypeReadable: function(n) {
                    const r = n === ct && (t.has("EXT_color_buffer_half_float") || t.has("EXT_color_buffer_float"));
                    return !(n !== ot && i.convert(n) !== e.getParameter(e.IMPLEMENTATION_COLOR_READ_TYPE) && n !== lt && !r)
                },
                precision: s,
                logarithmicDepthBuffer: l,
                maxTextures: c,
                maxVertexTextures: A,
                maxTextureSize: e.getParameter(e.MAX_TEXTURE_SIZE),
                maxCubemapSize: e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),
                maxAttributes: e.getParameter(e.MAX_VERTEX_ATTRIBS),
                maxVertexUniforms: e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS),
                maxVaryings: e.getParameter(e.MAX_VARYING_VECTORS),
                maxFragmentUniforms: e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS),
                vertexTextures: A > 0,
                maxSamples: e.getParameter(e.MAX_SAMPLES)
            }
        }

        function Ro(e) {
            const t = this;
            let n = null,
                i = 0,
                r = !1,
                o = !1;
            const s = new po,
                a = new pn,
                l = {
                    value: null,
                    needsUpdate: !1
                };

            function c(e, n, i, r) {
                const o = null !== e ? e.length : 0;
                let c = null;
                if (0 !== o) {
                    if (c = l.value, !0 !== r || null === c) {
                        const t = i + 4 * o,
                            r = n.matrixWorldInverse;
                        a.getNormalMatrix(r), (null === c || c.length < t) && (c = new Float32Array(t));
                        for (let t = 0, n = i; t !== o; ++t, n += 4) s.copy(e[t]).applyMatrix4(r, a), s.normal.toArray(c, n), c[n + 3] = s.constant
                    }
                    l.value = c, l.needsUpdate = !0
                }
                return t.numPlanes = o, t.numIntersection = 0, c
            }
            this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(e, t) {
                const n = 0 !== e.length || t || 0 !== i || r;
                return r = t, i = e.length, n
            }, this.beginShadows = function() {
                o = !0, c(null)
            }, this.endShadows = function() {
                o = !1
            }, this.setGlobalState = function(e, t) {
                n = c(e, t, 0)
            }, this.setState = function(s, a, A) {
                const h = s.clippingPlanes,
                    u = s.clipIntersection,
                    d = s.clipShadows,
                    p = e.get(s);
                if (!r || null === h || 0 === h.length || o && !d) o ? c(null) : function() {
                    l.value !== n && (l.value = n, l.needsUpdate = i > 0);
                    t.numPlanes = i, t.numIntersection = 0
                }();
                else {
                    const e = o ? 0 : i,
                        t = 4 * e;
                    let r = p.clippingState || null;
                    l.value = r, r = c(h, a, t, A);
                    for (let e = 0; e !== t; ++e) r[e] = n[e];
                    p.clippingState = r, this.numIntersection = u ? this.numPlanes : 0, this.numPlanes += e
                }
            }
        }

        function To(e) {
            let t = new WeakMap;

            function n(e, t) {
                return t === Je ? e.mapping = je : t === We && (e.mapping = Ye), e
            }

            function i(e) {
                const n = e.target;
                n.removeEventListener("dispose", i);
                const r = t.get(n);
                void 0 !== r && (t.delete(n), r.dispose())
            }
            return {
                get: function(r) {
                    if (r && r.isTexture) {
                        const o = r.mapping;
                        if (o === Je || o === We) {
                            if (t.has(r)) {
                                return n(t.get(r).texture, r.mapping)
                            } {
                                const o = r.image;
                                if (o && o.height > 0) {
                                    const s = new co(o.height);
                                    return s.fromEquirectangularTexture(e, r), t.set(r, s), r.addEventListener("dispose", i), n(s.texture, r.mapping)
                                }
                                return null
                            }
                        }
                    }
                    return r
                },
                dispose: function() {
                    t = new WeakMap
                }
            }
        }
        class Fo extends to {
            constructor(e = -1, t = 1, n = 1, i = -1, r = .1, o = 2e3) {
                super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = i, this.near = r, this.far = o, this.updateProjectionMatrix()
            }
            copy(e, t) {
                return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this
            }
            setViewOffset(e, t, n, i, r, o) {
                null === this.view && (this.view = {
                    enabled: !0,
                    fullWidth: 1,
                    fullHeight: 1,
                    offsetX: 0,
                    offsetY: 0,
                    width: 1,
                    height: 1
                }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = o, this.updateProjectionMatrix()
            }
            clearViewOffset() {
                null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
            }
            updateProjectionMatrix() {
                const e = (this.right - this.left) / (2 * this.zoom),
                    t = (this.top - this.bottom) / (2 * this.zoom),
                    n = (this.right + this.left) / 2,
                    i = (this.top + this.bottom) / 2;
                let r = n - e,
                    o = n + e,
                    s = i + t,
                    a = i - t;
                if (null !== this.view && this.view.enabled) {
                    const e = (this.right - this.left) / this.view.fullWidth / this.zoom,
                        t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                    r += e * this.view.offsetX, o = r + e * this.view.width, s -= t * this.view.offsetY, a = s - t * this.view.height
                }
                this.projectionMatrix.makeOrthographic(r, o, s, a, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t
            }
        }
        const Do = [.125, .215, .35, .446, .526, .582],
            ko = 20,
            Lo = new Fo,
            Ko = new sr;
        let Po = null,
            Go = 0,
            Vo = 0,
            Oo = !1;
        const No = (1 + Math.sqrt(5)) / 2,
            Ho = 1 / No,
            qo = [new On(-No, Ho, 0), new On(No, Ho, 0), new On(-Ho, 0, No), new On(Ho, 0, No), new On(0, No, -Ho), new On(0, No, Ho), new On(-1, 1, -1), new On(1, 1, -1), new On(-1, 1, 1), new On(1, 1, 1)];
        class jo {
            constructor(e) {
                this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial)
            }
            fromScene(e, t = 0, n = .1, i = 100) {
                Po = this._renderer.getRenderTarget(), Go = this._renderer.getActiveCubeFace(), Vo = this._renderer.getActiveMipmapLevel(), Oo = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(256);
                const r = this._allocateTargets();
                return r.depthBuffer = !0, this._sceneToCubeUV(e, n, i, r), t > 0 && this._blur(r, 0, 0, t), this._applyPMREM(r), this._cleanup(r), r
            }
            fromEquirectangular(e, t = null) {
                return this._fromTexture(e, t)
            }
            fromCubemap(e, t = null) {
                return this._fromTexture(e, t)
            }
            compileCubemapShader() {
                null === this._cubemapMaterial && (this._cubemapMaterial = zo(), this._compileMaterial(this._cubemapMaterial))
            }
            compileEquirectangularShader() {
                null === this._equirectMaterial && (this._equirectMaterial = Wo(), this._compileMaterial(this._equirectMaterial))
            }
            dispose() {
                this._dispose(), null !== this._cubemapMaterial && this._cubemapMaterial.dispose(), null !== this._equirectMaterial && this._equirectMaterial.dispose()
            }
            _setSize(e) {
                this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax)
            }
            _dispose() {
                null !== this._blurMaterial && this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
                for (let e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose()
            }
            _cleanup(e) {
                this._renderer.setRenderTarget(Po, Go, Vo), this._renderer.xr.enabled = Oo, e.scissorTest = !1, Jo(e, 0, 0, e.width, e.height)
            }
            _fromTexture(e, t) {
                e.mapping === je || e.mapping === Ye ? this._setSize(0 === e.image.length ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), Po = this._renderer.getRenderTarget(), Go = this._renderer.getActiveCubeFace(), Vo = this._renderer.getActiveMipmapLevel(), Oo = this._renderer.xr.enabled, this._renderer.xr.enabled = !1;
                const n = t || this._allocateTargets();
                return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n
            }
            _allocateTargets() {
                const e = 3 * Math.max(this._cubeSize, 112),
                    t = 4 * this._cubeSize,
                    n = {
                        magFilter: nt,
                        minFilter: nt,
                        generateMipmaps: !1,
                        type: ct,
                        format: ht,
                        colorSpace: Nt,
                        depthBuffer: !1
                    },
                    i = Yo(e, t, n);
                if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
                    null !== this._pingPongRenderTarget && this._dispose(), this._pingPongRenderTarget = Yo(e, t, n);
                    const {
                        _lodMax: i
                    } = this;
                    ({
                        sizeLods: this._sizeLods,
                        lodPlanes: this._lodPlanes,
                        sigmas: this._sigmas
                    } = function(e) {
                        const t = [],
                            n = [],
                            i = [];
                        let r = e;
                        const o = e - 4 + 1 + Do.length;
                        for (let s = 0; s < o; s++) {
                            const o = Math.pow(2, r);
                            n.push(o);
                            let a = 1 / o;
                            s > e - 4 ? a = Do[s - e + 4 - 1] : 0 === s && (a = 0), i.push(a);
                            const l = 1 / (o - 2),
                                c = -l,
                                A = 1 + l,
                                h = [c, c, A, c, A, A, c, c, A, A, c, A],
                                u = 6,
                                d = 6,
                                p = 3,
                                g = 2,
                                f = 1,
                                m = new Float32Array(p * d * u),
                                E = new Float32Array(g * d * u),
                                C = new Float32Array(f * d * u);
                            for (let e = 0; e < u; e++) {
                                const t = e % 3 * 2 / 3 - 1,
                                    n = e > 2 ? 0 : -1,
                                    i = [t, n, 0, t + 2 / 3, n, 0, t + 2 / 3, n + 1, 0, t, n, 0, t + 2 / 3, n + 1, 0, t, n + 1, 0];
                                m.set(i, p * d * e), E.set(h, g * d * e);
                                const r = [e, e, e, e, e, e];
                                C.set(r, f * d * e)
                            }
                            const I = new Ur;
                            I.setAttribute("position", new Er(m, p)), I.setAttribute("uv", new Er(E, g)), I.setAttribute("faceIndex", new Er(C, f)), t.push(I), r > 4 && r--
                        }
                        return {
                            lodPlanes: t,
                            sizeLods: n,
                            sigmas: i
                        }
                    }(i)), this._blurMaterial = function(e, t, n) {
                        const i = new Float32Array(ko),
                            r = new On(0, 1, 0),
                            o = new eo({
                                name: "SphericalGaussianBlur",
                                defines: {
                                    n: ko,
                                    CUBEUV_TEXEL_WIDTH: 1 / t,
                                    CUBEUV_TEXEL_HEIGHT: 1 / n,
                                    CUBEUV_MAX_MIP: `${e}.0`
                                },
                                uniforms: {
                                    envMap: {
                                        value: null
                                    },
                                    samples: {
                                        value: 1
                                    },
                                    weights: {
                                        value: i
                                    },
                                    latitudinal: {
                                        value: !1
                                    },
                                    dTheta: {
                                        value: 0
                                    },
                                    mipInt: {
                                        value: 0
                                    },
                                    poleAxis: {
                                        value: r
                                    }
                                },
                                vertexShader: Xo(),
                                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                                blending: 0,
                                depthTest: !1,
                                depthWrite: !1
                            });
                        return o
                    }(i, e, t)
                }
                return i
            }
            _compileMaterial(e) {
                const t = new Jr(this._lodPlanes[0], e);
                this._renderer.compile(t, Lo)
            }
            _sceneToCubeUV(e, t, n, i) {
                const r = new oo(90, 1, t, n),
                    o = [1, -1, 1, 1, 1, 1],
                    s = [1, 1, 1, -1, -1, -1],
                    a = this._renderer,
                    l = a.autoClear,
                    c = a.toneMapping;
                a.getClearColor(Ko), a.toneMapping = Le, a.autoClear = !1;
                const A = new Ar({
                        name: "PMREM.Background",
                        side: Me,
                        depthWrite: !1,
                        depthTest: !1
                    }),
                    h = new Jr(new zr, A);
                let u = !1;
                const d = e.background;
                d ? d.isColor && (A.color.copy(d), e.background = null, u = !0) : (A.color.copy(Ko), u = !0);
                for (let t = 0; t < 6; t++) {
                    const n = t % 3;
                    0 === n ? (r.up.set(0, o[t], 0), r.lookAt(s[t], 0, 0)) : 1 === n ? (r.up.set(0, 0, o[t]), r.lookAt(0, s[t], 0)) : (r.up.set(0, o[t], 0), r.lookAt(0, 0, s[t]));
                    const l = this._cubeSize;
                    Jo(i, n * l, t > 2 ? l : 0, l, l), a.setRenderTarget(i), u && a.render(h, r), a.render(e, r)
                }
                h.geometry.dispose(), h.material.dispose(), a.toneMapping = c, a.autoClear = l, e.background = d
            }
            _textureToCubeUV(e, t) {
                const n = this._renderer,
                    i = e.mapping === je || e.mapping === Ye;
                i ? (null === this._cubemapMaterial && (this._cubemapMaterial = zo()), this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === e.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = Wo());
                const r = i ? this._cubemapMaterial : this._equirectMaterial,
                    o = new Jr(this._lodPlanes[0], r);
                r.uniforms.envMap.value = e;
                const s = this._cubeSize;
                Jo(t, 0, 0, 3 * s, 2 * s), n.setRenderTarget(t), n.render(o, Lo)
            }
            _applyPMREM(e) {
                const t = this._renderer,
                    n = t.autoClear;
                t.autoClear = !1;
                const i = this._lodPlanes.length;
                for (let t = 1; t < i; t++) {
                    const n = Math.sqrt(this._sigmas[t] * this._sigmas[t] - this._sigmas[t - 1] * this._sigmas[t - 1]),
                        r = qo[(i - t - 1) % qo.length];
                    this._blur(e, t - 1, t, n, r)
                }
                t.autoClear = n
            }
            _blur(e, t, n, i, r) {
                const o = this._pingPongRenderTarget;
                this._halfBlur(e, o, t, n, i, "latitudinal", r), this._halfBlur(o, e, n, n, i, "longitudinal", r)
            }
            _halfBlur(e, t, n, i, r, o, s) {
                const a = this._renderer,
                    l = this._blurMaterial;
                "latitudinal" !== o && "longitudinal" !== o && console.error("blur direction must be either latitudinal or longitudinal!");
                const c = new Jr(this._lodPlanes[i], l),
                    A = l.uniforms,
                    h = this._sizeLods[n] - 1,
                    u = isFinite(r) ? Math.PI / (2 * h) : 2 * Math.PI / 39,
                    d = r / u,
                    p = isFinite(r) ? 1 + Math.floor(3 * d) : ko;
                p > ko && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${p} samples when the maximum is set to 20`);
                const g = [];
                let f = 0;
                for (let e = 0; e < ko; ++e) {
                    const t = e / d,
                        n = Math.exp(-t * t / 2);
                    g.push(n), 0 === e ? f += n : e < p && (f += 2 * n)
                }
                for (let e = 0; e < g.length; e++) g[e] = g[e] / f;
                A.envMap.value = e.texture, A.samples.value = p, A.weights.value = g, A.latitudinal.value = "latitudinal" === o, s && (A.poleAxis.value = s);
                const {
                    _lodMax: m
                } = this;
                A.dTheta.value = u, A.mipInt.value = m - n;
                const E = this._sizeLods[i];
                Jo(t, 3 * E * (i > m - 4 ? i - m + 4 : 0), 4 * (this._cubeSize - E), 3 * E, 2 * E), a.setRenderTarget(t), a.render(c, Lo)
            }
        }

        function Yo(e, t, n) {
            const i = new Kn(e, t, n);
            return i.texture.mapping = ze, i.texture.name = "PMREM.cubeUv", i.scissorTest = !0, i
        }

        function Jo(e, t, n, i, r) {
            e.viewport.set(t, n, i, r), e.scissor.set(t, n, i, r)
        }

        function Wo() {
            return new eo({
                name: "EquirectangularToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    }
                },
                vertexShader: Xo(),
                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
                blending: 0,
                depthTest: !1,
                depthWrite: !1
            })
        }

        function zo() {
            return new eo({
                name: "CubemapToCubeUV",
                uniforms: {
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    }
                },
                vertexShader: Xo(),
                fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
                blending: 0,
                depthTest: !1,
                depthWrite: !1
            })
        }

        function Xo() {
            return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"
        }

        function Zo(e) {
            let t = new WeakMap,
                n = null;

            function i(e) {
                const n = e.target;
                n.removeEventListener("dispose", i);
                const r = t.get(n);
                void 0 !== r && (t.delete(n), r.dispose())
            }
            return {
                get: function(r) {
                    if (r && r.isTexture) {
                        const o = r.mapping,
                            s = o === Je || o === We,
                            a = o === je || o === Ye;
                        if (s || a) {
                            let o = t.get(r);
                            const l = void 0 !== o ? o.texture.pmremVersion : 0;
                            if (r.isRenderTargetTexture && r.pmremVersion !== l) return null === n && (n = new jo(e)), o = s ? n.fromEquirectangular(r, o) : n.fromCubemap(r, o), o.texture.pmremVersion = r.pmremVersion, t.set(r, o), o.texture;
                            if (void 0 !== o) return o.texture; {
                                const l = r.image;
                                return s && l && l.height > 0 || a && l && function(e) {
                                    let t = 0;
                                    const n = 6;
                                    for (let i = 0; i < n; i++) void 0 !== e[i] && t++;
                                    return t === n
                                }(l) ? (null === n && (n = new jo(e)), o = s ? n.fromEquirectangular(r) : n.fromCubemap(r), o.texture.pmremVersion = r.pmremVersion, t.set(r, o), r.addEventListener("dispose", i), o.texture) : null
                            }
                        }
                    }
                    return r
                },
                dispose: function() {
                    t = new WeakMap, null !== n && (n.dispose(), n = null)
                }
            }
        }

        function _o(e) {
            const t = {};

            function n(n) {
                if (void 0 !== t[n]) return t[n];
                let i;
                switch (n) {
                    case "WEBGL_depth_texture":
                        i = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
                        break;
                    case "EXT_texture_filter_anisotropic":
                        i = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                        break;
                    case "WEBGL_compressed_texture_s3tc":
                        i = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                        break;
                    case "WEBGL_compressed_texture_pvrtc":
                        i = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                        break;
                    default:
                        i = e.getExtension(n)
                }
                return t[n] = i, i
            }
            return {
                has: function(e) {
                    return null !== n(e)
                },
                init: function() {
                    n("EXT_color_buffer_float"), n("WEBGL_clip_cull_distance"), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture"), n("WEBGL_render_shared_exponent")
                },
                get: function(e) {
                    const t = n(e);
                    return null === t && console.warn("THREE.WebGLRenderer: " + e + " extension not supported."), t
                }
            }
        }

        function $o(e, t, n, i) {
            const r = {},
                o = new WeakMap;

            function s(e) {
                const a = e.target;
                null !== a.index && t.remove(a.index);
                for (const e in a.attributes) t.remove(a.attributes[e]);
                for (const e in a.morphAttributes) {
                    const n = a.morphAttributes[e];
                    for (let e = 0, i = n.length; e < i; e++) t.remove(n[e])
                }
                a.removeEventListener("dispose", s), delete r[a.id];
                const l = o.get(a);
                l && (t.remove(l), o.delete(a)), i.releaseStatesOfGeometry(a), !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount, n.memory.geometries--
            }

            function a(e) {
                const n = [],
                    i = e.index,
                    r = e.attributes.position;
                let s = 0;
                if (null !== i) {
                    const e = i.array;
                    s = i.version;
                    for (let t = 0, i = e.length; t < i; t += 3) {
                        const i = e[t + 0],
                            r = e[t + 1],
                            o = e[t + 2];
                        n.push(i, r, r, o, o, i)
                    }
                } else {
                    if (void 0 === r) return; {
                        const e = r.array;
                        s = r.version;
                        for (let t = 0, i = e.length / 3 - 1; t < i; t += 3) {
                            const e = t + 0,
                                i = t + 1,
                                r = t + 2;
                            n.push(e, i, i, r, r, e)
                        }
                    }
                }
                const a = new(fn(n) ? Ir : Cr)(n, 1);
                a.version = s;
                const l = o.get(e);
                l && t.remove(l), o.set(e, a)
            }
            return {
                get: function(e, t) {
                    return !0 === r[t.id] || (t.addEventListener("dispose", s), r[t.id] = !0, n.memory.geometries++), t
                },
                update: function(n) {
                    const i = n.attributes;
                    for (const n in i) t.update(i[n], e.ARRAY_BUFFER);
                    const r = n.morphAttributes;
                    for (const n in r) {
                        const i = r[n];
                        for (let n = 0, r = i.length; n < r; n++) t.update(i[n], e.ARRAY_BUFFER)
                    }
                },
                getWireframeAttribute: function(e) {
                    const t = o.get(e);
                    if (t) {
                        const n = e.index;
                        null !== n && t.version < n.version && a(e)
                    } else a(e);
                    return o.get(e)
                }
            }
        }

        function es(e, t, n) {
            let i, r, o;

            function s(t, s, a) {
                0 !== a && (e.drawElementsInstanced(i, s, r, t * o, a), n.update(s, i, a))
            }
            this.setMode = function(e) {
                i = e
            }, this.setIndex = function(e) {
                r = e.type, o = e.bytesPerElement
            }, this.render = function(t, s) {
                e.drawElements(i, s, r, t * o), n.update(s, i, 1)
            }, this.renderInstances = s, this.renderMultiDraw = function(e, s, a) {
                if (0 === a) return;
                const l = t.get("WEBGL_multi_draw");
                if (null === l)
                    for (let t = 0; t < a; t++) this.render(e[t] / o, s[t]);
                else {
                    l.multiDrawElementsWEBGL(i, s, 0, r, e, 0, a);
                    let t = 0;
                    for (let e = 0; e < a; e++) t += s[e];
                    n.update(t, i, 1)
                }
            }, this.renderMultiDrawInstances = function(e, a, l, c) {
                if (0 === l) return;
                const A = t.get("WEBGL_multi_draw");
                if (null === A)
                    for (let t = 0; t < e.length; t++) s(e[t] / o, a[t], c[t]);
                else {
                    A.multiDrawElementsInstancedWEBGL(i, a, 0, r, e, 0, c, 0, l);
                    let t = 0;
                    for (let e = 0; e < l; e++) t += a[e];
                    for (let e = 0; e < c.length; e++) n.update(t, i, c[e])
                }
            }
        }

        function ts(e) {
            const t = {
                frame: 0,
                calls: 0,
                triangles: 0,
                points: 0,
                lines: 0
            };
            return {
                memory: {
                    geometries: 0,
                    textures: 0
                },
                render: t,
                programs: null,
                autoReset: !0,
                reset: function() {
                    t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0
                },
                update: function(n, i, r) {
                    switch (t.calls++, i) {
                        case e.TRIANGLES:
                            t.triangles += r * (n / 3);
                            break;
                        case e.LINES:
                            t.lines += r * (n / 2);
                            break;
                        case e.LINE_STRIP:
                            t.lines += r * (n - 1);
                            break;
                        case e.LINE_LOOP:
                            t.lines += r * n;
                            break;
                        case e.POINTS:
                            t.points += r * n;
                            break;
                        default:
                            console.error("THREE.WebGLInfo: Unknown draw mode:", i)
                    }
                }
            }
        }

        function ns(e, t, n) {
            const i = new WeakMap,
                r = new kn;
            return {
                update: function(o, s, a) {
                    const l = o.morphTargetInfluences,
                        c = s.morphAttributes.position || s.morphAttributes.normal || s.morphAttributes.color,
                        A = void 0 !== c ? c.length : 0;
                    let h = i.get(s);
                    if (void 0 === h || h.count !== A) {
                        void 0 !== h && h.texture.dispose();
                        const u = void 0 !== s.morphAttributes.position,
                            d = void 0 !== s.morphAttributes.normal,
                            p = void 0 !== s.morphAttributes.color,
                            g = s.morphAttributes.position || [],
                            f = s.morphAttributes.normal || [],
                            m = s.morphAttributes.color || [];
                        let E = 0;
                        !0 === u && (E = 1), !0 === d && (E = 2), !0 === p && (E = 3);
                        let C = s.attributes.position.count * E,
                            I = 1;
                        C > t.maxTextureSize && (I = Math.ceil(C / t.maxTextureSize), C = t.maxTextureSize);
                        const S = new Float32Array(C * I * 4 * A),
                            v = new Pn(S, C, I, A);
                        v.type = lt, v.needsUpdate = !0;
                        const B = 4 * E;
                        for (let y = 0; y < A; y++) {
                            const w = g[y],
                                b = f[y],
                                Q = m[y],
                                U = C * I * 4 * y;
                            for (let M = 0; M < w.count; M++) {
                                const R = M * B;
                                !0 === u && (r.fromBufferAttribute(w, M), S[U + R + 0] = r.x, S[U + R + 1] = r.y, S[U + R + 2] = r.z, S[U + R + 3] = 0), !0 === d && (r.fromBufferAttribute(b, M), S[U + R + 4] = r.x, S[U + R + 5] = r.y, S[U + R + 6] = r.z, S[U + R + 7] = 0), !0 === p && (r.fromBufferAttribute(Q, M), S[U + R + 8] = r.x, S[U + R + 9] = r.y, S[U + R + 10] = r.z, S[U + R + 11] = 4 === Q.itemSize ? r.w : 1)
                            }
                        }

                        function x() {
                            v.dispose(), i.delete(s), s.removeEventListener("dispose", x)
                        }
                        h = {
                            count: A,
                            texture: v,
                            size: new dn(C, I)
                        }, i.set(s, h), s.addEventListener("dispose", x)
                    }
                    if (!0 === o.isInstancedMesh && null !== o.morphTexture) a.getUniforms().setValue(e, "morphTexture", o.morphTexture, n);
                    else {
                        let T = 0;
                        for (let D = 0; D < l.length; D++) T += l[D];
                        const F = s.morphTargetsRelative ? 1 : 1 - T;
                        a.getUniforms().setValue(e, "morphTargetBaseInfluence", F), a.getUniforms().setValue(e, "morphTargetInfluences", l)
                    }
                    a.getUniforms().setValue(e, "morphTargetsTexture", h.texture, n), a.getUniforms().setValue(e, "morphTargetsTextureSize", h.size)
                }
            }
        }

        function is(e, t, n, i) {
            let r = new WeakMap;

            function o(e) {
                const t = e.target;
                t.removeEventListener("dispose", o), n.remove(t.instanceMatrix), null !== t.instanceColor && n.remove(t.instanceColor)
            }
            return {
                update: function(s) {
                    const a = i.render.frame,
                        l = s.geometry,
                        c = t.get(s, l);
                    if (r.get(c) !== a && (t.update(c), r.set(c, a)), s.isInstancedMesh && (!1 === s.hasEventListener("dispose", o) && s.addEventListener("dispose", o), r.get(s) !== a && (n.update(s.instanceMatrix, e.ARRAY_BUFFER), null !== s.instanceColor && n.update(s.instanceColor, e.ARRAY_BUFFER), r.set(s, a))), s.isSkinnedMesh) {
                        const e = s.skeleton;
                        r.get(e) !== a && (e.update(), r.set(e, a))
                    }
                    return c
                },
                dispose: function() {
                    r = new WeakMap
                }
            }
        }
        class rs extends Dn {
            constructor(e, t, n, i, r, o, s, a, l, c) {
                if ((c = void 0 !== c ? c : dt) !== dt && c !== pt) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                void 0 === n && c === dt && (n = at), void 0 === n && c === pt && (n = At), super(null, i, r, o, s, a, c, n, l), this.isDepthTexture = !0, this.image = {
                    width: e,
                    height: t
                }, this.magFilter = void 0 !== s ? s : $e, this.minFilter = void 0 !== a ? a : $e, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null
            }
            copy(e) {
                return super.copy(e), this.compareFunction = e.compareFunction, this
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return null !== this.compareFunction && (t.compareFunction = this.compareFunction), t
            }
        }
        const os = new Dn,
            ss = new rs(1, 1);
        ss.compareFunction = 515;
        const as = new Pn,
            ls = new Gn,
            cs = new lo,
            As = [],
            hs = [],
            us = new Float32Array(16),
            ds = new Float32Array(9),
            ps = new Float32Array(4);

        function gs(e, t, n) {
            const i = e[0];
            if (i <= 0 || i > 0) return e;
            const r = t * n;
            let o = As[r];
            if (void 0 === o && (o = new Float32Array(r), As[r] = o), 0 !== t) {
                i.toArray(o, 0);
                for (let i = 1, r = 0; i !== t; ++i) r += n, e[i].toArray(o, r)
            }
            return o
        }

        function fs(e, t) {
            if (e.length !== t.length) return !1;
            for (let n = 0, i = e.length; n < i; n++)
                if (e[n] !== t[n]) return !1;
            return !0
        }

        function ms(e, t) {
            for (let n = 0, i = t.length; n < i; n++) e[n] = t[n]
        }

        function Es(e, t) {
            let n = hs[t];
            void 0 === n && (n = new Int32Array(t), hs[t] = n);
            for (let i = 0; i !== t; ++i) n[i] = e.allocateTextureUnit();
            return n
        }

        function Cs(e, t) {
            const n = this.cache;
            n[0] !== t && (e.uniform1f(this.addr, t), n[0] = t)
        }

        function Is(e, t) {
            const n = this.cache;
            if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
            else {
                if (fs(n, t)) return;
                e.uniform2fv(this.addr, t), ms(n, t)
            }
        }

        function Ss(e, t) {
            const n = this.cache;
            if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
            else if (void 0 !== t.r) n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), n[0] = t.r, n[1] = t.g, n[2] = t.b);
            else {
                if (fs(n, t)) return;
                e.uniform3fv(this.addr, t), ms(n, t)
            }
        }

        function vs(e, t) {
            const n = this.cache;
            if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
            else {
                if (fs(n, t)) return;
                e.uniform4fv(this.addr, t), ms(n, t)
            }
        }

        function Bs(e, t) {
            const n = this.cache,
                i = t.elements;
            if (void 0 === i) {
                if (fs(n, t)) return;
                e.uniformMatrix2fv(this.addr, !1, t), ms(n, t)
            } else {
                if (fs(n, i)) return;
                ps.set(i), e.uniformMatrix2fv(this.addr, !1, ps), ms(n, i)
            }
        }

        function xs(e, t) {
            const n = this.cache,
                i = t.elements;
            if (void 0 === i) {
                if (fs(n, t)) return;
                e.uniformMatrix3fv(this.addr, !1, t), ms(n, t)
            } else {
                if (fs(n, i)) return;
                ds.set(i), e.uniformMatrix3fv(this.addr, !1, ds), ms(n, i)
            }
        }

        function ys(e, t) {
            const n = this.cache,
                i = t.elements;
            if (void 0 === i) {
                if (fs(n, t)) return;
                e.uniformMatrix4fv(this.addr, !1, t), ms(n, t)
            } else {
                if (fs(n, i)) return;
                us.set(i), e.uniformMatrix4fv(this.addr, !1, us), ms(n, i)
            }
        }

        function ws(e, t) {
            const n = this.cache;
            n[0] !== t && (e.uniform1i(this.addr, t), n[0] = t)
        }

        function bs(e, t) {
            const n = this.cache;
            if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2i(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
            else {
                if (fs(n, t)) return;
                e.uniform2iv(this.addr, t), ms(n, t)
            }
        }

        function Qs(e, t) {
            const n = this.cache;
            if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3i(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
            else {
                if (fs(n, t)) return;
                e.uniform3iv(this.addr, t), ms(n, t)
            }
        }

        function Us(e, t) {
            const n = this.cache;
            if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4i(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
            else {
                if (fs(n, t)) return;
                e.uniform4iv(this.addr, t), ms(n, t)
            }
        }

        function Ms(e, t) {
            const n = this.cache;
            n[0] !== t && (e.uniform1ui(this.addr, t), n[0] = t)
        }

        function Rs(e, t) {
            const n = this.cache;
            if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2ui(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
            else {
                if (fs(n, t)) return;
                e.uniform2uiv(this.addr, t), ms(n, t)
            }
        }

        function Ts(e, t) {
            const n = this.cache;
            if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3ui(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
            else {
                if (fs(n, t)) return;
                e.uniform3uiv(this.addr, t), ms(n, t)
            }
        }

        function Fs(e, t) {
            const n = this.cache;
            if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4ui(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
            else {
                if (fs(n, t)) return;
                e.uniform4uiv(this.addr, t), ms(n, t)
            }
        }

        function Ds(e, t, n) {
            const i = this.cache,
                r = n.allocateTextureUnit();
            i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r);
            const o = this.type === e.SAMPLER_2D_SHADOW ? ss : os;
            n.setTexture2D(t || o, r)
        }

        function ks(e, t, n) {
            const i = this.cache,
                r = n.allocateTextureUnit();
            i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(t || ls, r)
        }

        function Ls(e, t, n) {
            const i = this.cache,
                r = n.allocateTextureUnit();
            i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTextureCube(t || cs, r)
        }

        function Ks(e, t, n) {
            const i = this.cache,
                r = n.allocateTextureUnit();
            i[0] !== r && (e.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(t || as, r)
        }

        function Ps(e, t) {
            e.uniform1fv(this.addr, t)
        }

        function Gs(e, t) {
            const n = gs(t, this.size, 2);
            e.uniform2fv(this.addr, n)
        }

        function Vs(e, t) {
            const n = gs(t, this.size, 3);
            e.uniform3fv(this.addr, n)
        }

        function Os(e, t) {
            const n = gs(t, this.size, 4);
            e.uniform4fv(this.addr, n)
        }

        function Ns(e, t) {
            const n = gs(t, this.size, 4);
            e.uniformMatrix2fv(this.addr, !1, n)
        }

        function Hs(e, t) {
            const n = gs(t, this.size, 9);
            e.uniformMatrix3fv(this.addr, !1, n)
        }

        function qs(e, t) {
            const n = gs(t, this.size, 16);
            e.uniformMatrix4fv(this.addr, !1, n)
        }

        function js(e, t) {
            e.uniform1iv(this.addr, t)
        }

        function Ys(e, t) {
            e.uniform2iv(this.addr, t)
        }

        function Js(e, t) {
            e.uniform3iv(this.addr, t)
        }

        function Ws(e, t) {
            e.uniform4iv(this.addr, t)
        }

        function zs(e, t) {
            e.uniform1uiv(this.addr, t)
        }

        function Xs(e, t) {
            e.uniform2uiv(this.addr, t)
        }

        function Zs(e, t) {
            e.uniform3uiv(this.addr, t)
        }

        function _s(e, t) {
            e.uniform4uiv(this.addr, t)
        }

        function $s(e, t, n) {
            const i = this.cache,
                r = t.length,
                o = Es(n, r);
            fs(i, o) || (e.uniform1iv(this.addr, o), ms(i, o));
            for (let e = 0; e !== r; ++e) n.setTexture2D(t[e] || os, o[e])
        }

        function ea(e, t, n) {
            const i = this.cache,
                r = t.length,
                o = Es(n, r);
            fs(i, o) || (e.uniform1iv(this.addr, o), ms(i, o));
            for (let e = 0; e !== r; ++e) n.setTexture3D(t[e] || ls, o[e])
        }

        function ta(e, t, n) {
            const i = this.cache,
                r = t.length,
                o = Es(n, r);
            fs(i, o) || (e.uniform1iv(this.addr, o), ms(i, o));
            for (let e = 0; e !== r; ++e) n.setTextureCube(t[e] || cs, o[e])
        }

        function na(e, t, n) {
            const i = this.cache,
                r = t.length,
                o = Es(n, r);
            fs(i, o) || (e.uniform1iv(this.addr, o), ms(i, o));
            for (let e = 0; e !== r; ++e) n.setTexture2DArray(t[e] || as, o[e])
        }
        class ia {
            constructor(e, t, n) {
                this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.setValue = function(e) {
                    switch (e) {
                        case 5126:
                            return Cs;
                        case 35664:
                            return Is;
                        case 35665:
                            return Ss;
                        case 35666:
                            return vs;
                        case 35674:
                            return Bs;
                        case 35675:
                            return xs;
                        case 35676:
                            return ys;
                        case 5124:
                        case 35670:
                            return ws;
                        case 35667:
                        case 35671:
                            return bs;
                        case 35668:
                        case 35672:
                            return Qs;
                        case 35669:
                        case 35673:
                            return Us;
                        case 5125:
                            return Ms;
                        case 36294:
                            return Rs;
                        case 36295:
                            return Ts;
                        case 36296:
                            return Fs;
                        case 35678:
                        case 36198:
                        case 36298:
                        case 36306:
                        case 35682:
                            return Ds;
                        case 35679:
                        case 36299:
                        case 36307:
                            return ks;
                        case 35680:
                        case 36300:
                        case 36308:
                        case 36293:
                            return Ls;
                        case 36289:
                        case 36303:
                        case 36311:
                        case 36292:
                            return Ks
                    }
                }(t.type)
            }
        }
        class ra {
            constructor(e, t, n) {
                this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = function(e) {
                    switch (e) {
                        case 5126:
                            return Ps;
                        case 35664:
                            return Gs;
                        case 35665:
                            return Vs;
                        case 35666:
                            return Os;
                        case 35674:
                            return Ns;
                        case 35675:
                            return Hs;
                        case 35676:
                            return qs;
                        case 5124:
                        case 35670:
                            return js;
                        case 35667:
                        case 35671:
                            return Ys;
                        case 35668:
                        case 35672:
                            return Js;
                        case 35669:
                        case 35673:
                            return Ws;
                        case 5125:
                            return zs;
                        case 36294:
                            return Xs;
                        case 36295:
                            return Zs;
                        case 36296:
                            return _s;
                        case 35678:
                        case 36198:
                        case 36298:
                        case 36306:
                        case 35682:
                            return $s;
                        case 35679:
                        case 36299:
                        case 36307:
                            return ea;
                        case 35680:
                        case 36300:
                        case 36308:
                        case 36293:
                            return ta;
                        case 36289:
                        case 36303:
                        case 36311:
                        case 36292:
                            return na
                    }
                }(t.type)
            }
        }
        class oa {
            constructor(e) {
                this.id = e, this.seq = [], this.map = {}
            }
            setValue(e, t, n) {
                const i = this.seq;
                for (let r = 0, o = i.length; r !== o; ++r) {
                    const o = i[r];
                    o.setValue(e, t[o.id], n)
                }
            }
        }
        const sa = /(\w+)(\])?(\[|\.)?/g;

        function aa(e, t) {
            e.seq.push(t), e.map[t.id] = t
        }

        function la(e, t, n) {
            const i = e.name,
                r = i.length;
            for (sa.lastIndex = 0;;) {
                const o = sa.exec(i),
                    s = sa.lastIndex;
                let a = o[1];
                const l = "]" === o[2],
                    c = o[3];
                if (l && (a |= 0), void 0 === c || "[" === c && s + 2 === r) {
                    aa(n, void 0 === c ? new ia(a, e, t) : new ra(a, e, t));
                    break
                } {
                    let e = n.map[a];
                    void 0 === e && (e = new oa(a), aa(n, e)), n = e
                }
            }
        }
        class ca {
            constructor(e, t) {
                this.seq = [], this.map = {};
                const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
                for (let i = 0; i < n; ++i) {
                    const n = e.getActiveUniform(t, i);
                    la(n, e.getUniformLocation(t, n.name), this)
                }
            }
            setValue(e, t, n, i) {
                const r = this.map[t];
                void 0 !== r && r.setValue(e, n, i)
            }
            setOptional(e, t, n) {
                const i = t[n];
                void 0 !== i && this.setValue(e, n, i)
            }
            static upload(e, t, n, i) {
                for (let r = 0, o = t.length; r !== o; ++r) {
                    const o = t[r],
                        s = n[o.id];
                    !1 !== s.needsUpdate && o.setValue(e, s.value, i)
                }
            }
            static seqWithValue(e, t) {
                const n = [];
                for (let i = 0, r = e.length; i !== r; ++i) {
                    const r = e[i];
                    r.id in t && n.push(r)
                }
                return n
            }
        }

        function Aa(e, t, n) {
            const i = e.createShader(t);
            return e.shaderSource(i, n), e.compileShader(i), i
        }
        const ha = 37297;
        let ua = 0;

        function da(e, t, n) {
            const i = e.getShaderParameter(t, e.COMPILE_STATUS),
                r = e.getShaderInfoLog(t).trim();
            if (i && "" === r) return "";
            const o = /ERROR: 0:(\d+)/.exec(r);
            if (o) {
                const i = parseInt(o[1]);
                return n.toUpperCase() + "\n\n" + r + "\n\n" + function(e, t) {
                    const n = e.split("\n"),
                        i = [],
                        r = Math.max(t - 6, 0),
                        o = Math.min(t + 6, n.length);
                    for (let e = r; e < o; e++) {
                        const r = e + 1;
                        i.push(`${r===t?">":" "} ${r}: ${n[e]}`)
                    }
                    return i.join("\n")
                }(e.getShaderSource(t), i)
            }
            return r
        }

        function pa(e, t) {
            const n = function(e) {
                const t = yn.getPrimaries(yn.workingColorSpace),
                    n = yn.getPrimaries(e);
                let i;
                switch (t === n ? i = "" : t === Wt && n === Jt ? i = "LinearDisplayP3ToLinearSRGB" : t === Jt && n === Wt && (i = "LinearSRGBToLinearDisplayP3"), e) {
                    case Nt:
                    case qt:
                        return [i, "LinearTransferOETF"];
                    case Ot:
                    case Ht:
                        return [i, "sRGBTransferOETF"];
                    default:
                        return console.warn("THREE.WebGLProgram: Unsupported color space:", e), [i, "LinearTransferOETF"]
                }
            }(t);
            return `vec4 ${e}( vec4 value ) { return ${n[0]}( ${n[1]}( value ) ); }`
        }

        function ga(e, t) {
            let n;
            switch (t) {
                case Ke:
                    n = "Linear";
                    break;
                case Pe:
                    n = "Reinhard";
                    break;
                case Ge:
                    n = "OptimizedCineon";
                    break;
                case Ve:
                    n = "ACESFilmic";
                    break;
                case Ne:
                    n = "AgX";
                    break;
                case He:
                    n = "Neutral";
                    break;
                case Oe:
                    n = "Custom";
                    break;
                default:
                    console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t), n = "Linear"
            }
            return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
        }

        function fa(e) {
            return "" !== e
        }

        function ma(e, t) {
            const n = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
            return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
        }

        function Ea(e, t) {
            return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
        }
        const Ca = /^[ \t]*#include +<([\w\d./]+)>/gm;

        function Ia(e) {
            return e.replace(Ca, va)
        }
        const Sa = new Map;

        function va(e, t) {
            let n = So[t];
            if (void 0 === n) {
                const e = Sa.get(t);
                if (void 0 === e) throw new Error("Can not resolve #include <" + t + ">");
                n = So[e], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', t, e)
            }
            return Ia(n)
        }
        const Ba = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

        function xa(e) {
            return e.replace(Ba, ya)
        }

        function ya(e, t, n, i) {
            let r = "";
            for (let e = parseInt(t); e < parseInt(n); e++) r += i.replace(/\[\s*i\s*\]/g, "[ " + e + " ]").replace(/UNROLLED_LOOP_INDEX/g, e);
            return r
        }

        function wa(e) {
            let t = `precision ${e.precision} float;\n\tprecision ${e.precision} int;\n\tprecision ${e.precision} sampler2D;\n\tprecision ${e.precision} samplerCube;\n\tprecision ${e.precision} sampler3D;\n\tprecision ${e.precision} sampler2DArray;\n\tprecision ${e.precision} sampler2DShadow;\n\tprecision ${e.precision} samplerCubeShadow;\n\tprecision ${e.precision} sampler2DArrayShadow;\n\tprecision ${e.precision} isampler2D;\n\tprecision ${e.precision} isampler3D;\n\tprecision ${e.precision} isamplerCube;\n\tprecision ${e.precision} isampler2DArray;\n\tprecision ${e.precision} usampler2D;\n\tprecision ${e.precision} usampler3D;\n\tprecision ${e.precision} usamplerCube;\n\tprecision ${e.precision} usampler2DArray;\n\t`;
            return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t
        }

        function ba(e, t, n, i) {
            const r = e.getContext(),
                o = n.defines;
            let s = n.vertexShader,
                a = n.fragmentShader;
            const l = function(e) {
                    let t = "SHADOWMAP_TYPE_BASIC";
                    return e.shadowMapType === we ? t = "SHADOWMAP_TYPE_PCF" : e.shadowMapType === be ? t = "SHADOWMAP_TYPE_PCF_SOFT" : e.shadowMapType === Qe && (t = "SHADOWMAP_TYPE_VSM"), t
                }(n),
                c = function(e) {
                    let t = "ENVMAP_TYPE_CUBE";
                    if (e.envMap) switch (e.envMapMode) {
                        case je:
                        case Ye:
                            t = "ENVMAP_TYPE_CUBE";
                            break;
                        case ze:
                            t = "ENVMAP_TYPE_CUBE_UV"
                    }
                    return t
                }(n),
                A = function(e) {
                    let t = "ENVMAP_MODE_REFLECTION";
                    e.envMap && e.envMapMode === Ye && (t = "ENVMAP_MODE_REFRACTION");
                    return t
                }(n),
                h = function(e) {
                    let t = "ENVMAP_BLENDING_NONE";
                    if (e.envMap) switch (e.combine) {
                        case Fe:
                            t = "ENVMAP_BLENDING_MULTIPLY";
                            break;
                        case De:
                            t = "ENVMAP_BLENDING_MIX";
                            break;
                        case ke:
                            t = "ENVMAP_BLENDING_ADD"
                    }
                    return t
                }(n),
                u = function(e) {
                    const t = e.envMapCubeUVHeight;
                    if (null === t) return null;
                    const n = Math.log2(t) - 2,
                        i = 1 / t;
                    return {
                        texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
                        texelHeight: i,
                        maxMip: n
                    }
                }(n),
                d = function(e) {
                    return [e.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", e.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(fa).join("\n")
                }(n),
                p = function(e) {
                    const t = [];
                    for (const n in e) {
                        const i = e[n];
                        !1 !== i && t.push("#define " + n + " " + i)
                    }
                    return t.join("\n")
                }(o),
                g = r.createProgram();
            let f, m, E = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
            n.isRawShaderMaterial ? (f = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, p].filter(fa).join("\n"), f.length > 0 && (f += "\n"), m = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, p].filter(fa).join("\n"), m.length > 0 && (m += "\n")) : (f = [wa(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, p, n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", n.batching ? "#define USE_BATCHING" : "", n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + A : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.mapUv ? "#define MAP_UV " + n.mapUv : "", n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "", n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "", n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "", n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "", n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "", n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "", n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "", n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "", n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "", n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "", n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "", n.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv : "", n.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv : "", n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "", n.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv : "", n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "", n.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv : "", n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "", n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "", n.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv : "", n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "", n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphColors ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.useLegacyLights ? "#define LEGACY_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "\tuniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "\tattribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "\tattribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "\tattribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(fa).join("\n"), m = [wa(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, p, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + A : "", n.envMap ? "#define " + h : "", u ? "#define CUBEUV_TEXEL_WIDTH " + u.texelWidth : "", u ? "#define CUBEUV_TEXEL_HEIGHT " + u.texelHeight : "", u ? "#define CUBEUV_MAX_MIP " + u.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.dispersion ? "#define USE_DISPERSION" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", n.useLegacyLights ? "#define LEGACY_LIGHTS" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", n.toneMapping !== Le ? "#define TONE_MAPPING" : "", n.toneMapping !== Le ? So.tonemapping_pars_fragment : "", n.toneMapping !== Le ? ga("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", So.colorspace_pars_fragment, pa("linearToOutputTexel", n.outputColorSpace), n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(fa).join("\n")), s = Ia(s), s = ma(s, n), s = Ea(s, n), a = Ia(a), a = ma(a, n), a = Ea(a, n), s = xa(s), a = xa(a), !0 !== n.isRawShaderMaterial && (E = "#version 300 es\n", f = [d, "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + f, m = ["#define varying in", n.glslVersion === Zt ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === Zt ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + m);
            const C = E + f + s,
                I = E + m + a,
                S = Aa(r, r.VERTEX_SHADER, C),
                v = Aa(r, r.FRAGMENT_SHADER, I);

            function B(t) {
                if (e.debug.checkShaderErrors) {
                    const n = r.getProgramInfoLog(g).trim(),
                        i = r.getShaderInfoLog(S).trim(),
                        o = r.getShaderInfoLog(v).trim();
                    let s = !0,
                        a = !0;
                    if (!1 === r.getProgramParameter(g, r.LINK_STATUS))
                        if (s = !1, "function" == typeof e.debug.onShaderError) e.debug.onShaderError(r, g, S, v);
                        else {
                            const e = da(r, S, "vertex"),
                                i = da(r, v, "fragment");
                            console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(g, r.VALIDATE_STATUS) + "\n\nMaterial Name: " + t.name + "\nMaterial Type: " + t.type + "\n\nProgram Info Log: " + n + "\n" + e + "\n" + i)
                        }
                    else "" !== n ? console.warn("THREE.WebGLProgram: Program Info Log:", n) : "" !== i && "" !== o || (a = !1);
                    a && (t.diagnostics = {
                        runnable: s,
                        programLog: n,
                        vertexShader: {
                            log: i,
                            prefix: f
                        },
                        fragmentShader: {
                            log: o,
                            prefix: m
                        }
                    })
                }
                r.deleteShader(S), r.deleteShader(v), x = new ca(r, g), y = function(e, t) {
                    const n = {},
                        i = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES);
                    for (let r = 0; r < i; r++) {
                        const i = e.getActiveAttrib(t, r),
                            o = i.name;
                        let s = 1;
                        i.type === e.FLOAT_MAT2 && (s = 2), i.type === e.FLOAT_MAT3 && (s = 3), i.type === e.FLOAT_MAT4 && (s = 4), n[o] = {
                            type: i.type,
                            location: e.getAttribLocation(t, o),
                            locationSize: s
                        }
                    }
                    return n
                }(r, g)
            }
            let x, y;
            r.attachShader(g, S), r.attachShader(g, v), void 0 !== n.index0AttributeName ? r.bindAttribLocation(g, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(g, 0, "position"), r.linkProgram(g), this.getUniforms = function() {
                return void 0 === x && B(this), x
            }, this.getAttributes = function() {
                return void 0 === y && B(this), y
            };
            let w = !1 === n.rendererExtensionParallelShaderCompile;
            return this.isReady = function() {
                return !1 === w && (w = r.getProgramParameter(g, ha)), w
            }, this.destroy = function() {
                i.releaseStatesOfProgram(this), r.deleteProgram(g), this.program = void 0
            }, this.type = n.shaderType, this.name = n.shaderName, this.id = ua++, this.cacheKey = t, this.usedTimes = 1, this.program = g, this.vertexShader = S, this.fragmentShader = v, this
        }
        let Qa = 0;
        class Ua {
            constructor() {
                this.shaderCache = new Map, this.materialCache = new Map
            }
            update(e) {
                const t = e.vertexShader,
                    n = e.fragmentShader,
                    i = this._getShaderStage(t),
                    r = this._getShaderStage(n),
                    o = this._getShaderCacheForMaterial(e);
                return !1 === o.has(i) && (o.add(i), i.usedTimes++), !1 === o.has(r) && (o.add(r), r.usedTimes++), this
            }
            remove(e) {
                const t = this.materialCache.get(e);
                for (const e of t) e.usedTimes--, 0 === e.usedTimes && this.shaderCache.delete(e.code);
                return this.materialCache.delete(e), this
            }
            getVertexShaderID(e) {
                return this._getShaderStage(e.vertexShader).id
            }
            getFragmentShaderID(e) {
                return this._getShaderStage(e.fragmentShader).id
            }
            dispose() {
                this.shaderCache.clear(), this.materialCache.clear()
            }
            _getShaderCacheForMaterial(e) {
                const t = this.materialCache;
                let n = t.get(e);
                return void 0 === n && (n = new Set, t.set(e, n)), n
            }
            _getShaderStage(e) {
                const t = this.shaderCache;
                let n = t.get(e);
                return void 0 === n && (n = new Ma(e), t.set(e, n)), n
            }
        }
        class Ma {
            constructor(e) {
                this.id = Qa++, this.code = e, this.usedTimes = 0
            }
        }

        function Ra(e, t, n, i, r, o, s) {
            const a = new Qi,
                l = new Ua,
                c = new Set,
                A = [],
                h = r.logarithmicDepthBuffer,
                u = r.vertexTextures;
            let d = r.precision;
            const p = {
                MeshDepthMaterial: "depth",
                MeshDistanceMaterial: "distanceRGBA",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "toon",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                MeshMatcapMaterial: "matcap",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points",
                ShadowMaterial: "shadow",
                SpriteMaterial: "sprite"
            };

            function g(e) {
                return c.add(e), 0 === e ? "uv" : `uv${e}`
            }
            return {
                getParameters: function(o, a, A, f, m) {
                    const E = f.fog,
                        C = m.geometry,
                        I = o.isMeshStandardMaterial ? f.environment : null,
                        S = (o.isMeshStandardMaterial ? n : t).get(o.envMap || I),
                        v = S && S.mapping === ze ? S.image.height : null,
                        B = p[o.type];
                    null !== o.precision && (d = r.getMaxPrecision(o.precision), d !== o.precision && console.warn("THREE.WebGLProgram.getParameters:", o.precision, "not supported, using", d, "instead."));
                    const x = C.morphAttributes.position || C.morphAttributes.normal || C.morphAttributes.color,
                        y = void 0 !== x ? x.length : 0;
                    let w, b, Q, U, M = 0;
                    if (void 0 !== C.morphAttributes.position && (M = 1), void 0 !== C.morphAttributes.normal && (M = 2), void 0 !== C.morphAttributes.color && (M = 3), B) {
                        const e = Bo[B];
                        w = e.vertexShader, b = e.fragmentShader
                    } else w = o.vertexShader, b = o.fragmentShader, l.update(o), Q = l.getVertexShaderID(o), U = l.getFragmentShaderID(o);
                    const R = e.getRenderTarget(),
                        T = !0 === m.isInstancedMesh,
                        F = !0 === m.isBatchedMesh,
                        D = !!o.map,
                        k = !!o.matcap,
                        L = !!S,
                        K = !!o.aoMap,
                        P = !!o.lightMap,
                        G = !!o.bumpMap,
                        V = !!o.normalMap,
                        O = !!o.displacementMap,
                        N = !!o.emissiveMap,
                        H = !!o.metalnessMap,
                        q = !!o.roughnessMap,
                        j = o.anisotropy > 0,
                        Y = o.clearcoat > 0,
                        J = o.dispersion > 0,
                        W = o.iridescence > 0,
                        z = o.sheen > 0,
                        X = o.transmission > 0,
                        Z = j && !!o.anisotropyMap,
                        _ = Y && !!o.clearcoatMap,
                        $ = Y && !!o.clearcoatNormalMap,
                        ee = Y && !!o.clearcoatRoughnessMap,
                        te = W && !!o.iridescenceMap,
                        ne = W && !!o.iridescenceThicknessMap,
                        ie = z && !!o.sheenColorMap,
                        re = z && !!o.sheenRoughnessMap,
                        oe = !!o.specularMap,
                        se = !!o.specularColorMap,
                        ae = !!o.specularIntensityMap,
                        le = X && !!o.transmissionMap,
                        ce = X && !!o.thicknessMap,
                        Ae = !!o.gradientMap,
                        he = !!o.alphaMap,
                        ue = o.alphaTest > 0,
                        de = !!o.alphaHash,
                        pe = !!o.extensions;
                    let ge = Le;
                    o.toneMapped && (null !== R && !0 !== R.isXRRenderTarget || (ge = e.toneMapping));
                    const fe = {
                        shaderID: B,
                        shaderType: o.type,
                        shaderName: o.name,
                        vertexShader: w,
                        fragmentShader: b,
                        defines: o.defines,
                        customVertexShaderID: Q,
                        customFragmentShaderID: U,
                        isRawShaderMaterial: !0 === o.isRawShaderMaterial,
                        glslVersion: o.glslVersion,
                        precision: d,
                        batching: F,
                        instancing: T,
                        instancingColor: T && null !== m.instanceColor,
                        instancingMorph: T && null !== m.morphTexture,
                        supportsVertexTextures: u,
                        outputColorSpace: null === R ? e.outputColorSpace : !0 === R.isXRRenderTarget ? R.texture.colorSpace : Nt,
                        alphaToCoverage: !!o.alphaToCoverage,
                        map: D,
                        matcap: k,
                        envMap: L,
                        envMapMode: L && S.mapping,
                        envMapCubeUVHeight: v,
                        aoMap: K,
                        lightMap: P,
                        bumpMap: G,
                        normalMap: V,
                        displacementMap: u && O,
                        emissiveMap: N,
                        normalMapObjectSpace: V && 1 === o.normalMapType,
                        normalMapTangentSpace: V && 0 === o.normalMapType,
                        metalnessMap: H,
                        roughnessMap: q,
                        anisotropy: j,
                        anisotropyMap: Z,
                        clearcoat: Y,
                        clearcoatMap: _,
                        clearcoatNormalMap: $,
                        clearcoatRoughnessMap: ee,
                        dispersion: J,
                        iridescence: W,
                        iridescenceMap: te,
                        iridescenceThicknessMap: ne,
                        sheen: z,
                        sheenColorMap: ie,
                        sheenRoughnessMap: re,
                        specularMap: oe,
                        specularColorMap: se,
                        specularIntensityMap: ae,
                        transmission: X,
                        transmissionMap: le,
                        thicknessMap: ce,
                        gradientMap: Ae,
                        opaque: !1 === o.transparent && 1 === o.blending && !1 === o.alphaToCoverage,
                        alphaMap: he,
                        alphaTest: ue,
                        alphaHash: de,
                        combine: o.combine,
                        mapUv: D && g(o.map.channel),
                        aoMapUv: K && g(o.aoMap.channel),
                        lightMapUv: P && g(o.lightMap.channel),
                        bumpMapUv: G && g(o.bumpMap.channel),
                        normalMapUv: V && g(o.normalMap.channel),
                        displacementMapUv: O && g(o.displacementMap.channel),
                        emissiveMapUv: N && g(o.emissiveMap.channel),
                        metalnessMapUv: H && g(o.metalnessMap.channel),
                        roughnessMapUv: q && g(o.roughnessMap.channel),
                        anisotropyMapUv: Z && g(o.anisotropyMap.channel),
                        clearcoatMapUv: _ && g(o.clearcoatMap.channel),
                        clearcoatNormalMapUv: $ && g(o.clearcoatNormalMap.channel),
                        clearcoatRoughnessMapUv: ee && g(o.clearcoatRoughnessMap.channel),
                        iridescenceMapUv: te && g(o.iridescenceMap.channel),
                        iridescenceThicknessMapUv: ne && g(o.iridescenceThicknessMap.channel),
                        sheenColorMapUv: ie && g(o.sheenColorMap.channel),
                        sheenRoughnessMapUv: re && g(o.sheenRoughnessMap.channel),
                        specularMapUv: oe && g(o.specularMap.channel),
                        specularColorMapUv: se && g(o.specularColorMap.channel),
                        specularIntensityMapUv: ae && g(o.specularIntensityMap.channel),
                        transmissionMapUv: le && g(o.transmissionMap.channel),
                        thicknessMapUv: ce && g(o.thicknessMap.channel),
                        alphaMapUv: he && g(o.alphaMap.channel),
                        vertexTangents: !!C.attributes.tangent && (V || j),
                        vertexColors: o.vertexColors,
                        vertexAlphas: !0 === o.vertexColors && !!C.attributes.color && 4 === C.attributes.color.itemSize,
                        pointsUvs: !0 === m.isPoints && !!C.attributes.uv && (D || he),
                        fog: !!E,
                        useFog: !0 === o.fog,
                        fogExp2: !!E && E.isFogExp2,
                        flatShading: !0 === o.flatShading,
                        sizeAttenuation: !0 === o.sizeAttenuation,
                        logarithmicDepthBuffer: h,
                        skinning: !0 === m.isSkinnedMesh,
                        morphTargets: void 0 !== C.morphAttributes.position,
                        morphNormals: void 0 !== C.morphAttributes.normal,
                        morphColors: void 0 !== C.morphAttributes.color,
                        morphTargetsCount: y,
                        morphTextureStride: M,
                        numDirLights: a.directional.length,
                        numPointLights: a.point.length,
                        numSpotLights: a.spot.length,
                        numSpotLightMaps: a.spotLightMap.length,
                        numRectAreaLights: a.rectArea.length,
                        numHemiLights: a.hemi.length,
                        numDirLightShadows: a.directionalShadowMap.length,
                        numPointLightShadows: a.pointShadowMap.length,
                        numSpotLightShadows: a.spotShadowMap.length,
                        numSpotLightShadowsWithMaps: a.numSpotLightShadowsWithMaps,
                        numLightProbes: a.numLightProbes,
                        numClippingPlanes: s.numPlanes,
                        numClipIntersection: s.numIntersection,
                        dithering: o.dithering,
                        shadowMapEnabled: e.shadowMap.enabled && A.length > 0,
                        shadowMapType: e.shadowMap.type,
                        toneMapping: ge,
                        useLegacyLights: e._useLegacyLights,
                        decodeVideoTexture: D && !0 === o.map.isVideoTexture && yn.getTransfer(o.map.colorSpace) === Yt,
                        premultipliedAlpha: o.premultipliedAlpha,
                        doubleSided: o.side === Re,
                        flipSided: o.side === Me,
                        useDepthPacking: o.depthPacking >= 0,
                        depthPacking: o.depthPacking || 0,
                        index0AttributeName: o.index0AttributeName,
                        extensionClipCullDistance: pe && !0 === o.extensions.clipCullDistance && i.has("WEBGL_clip_cull_distance"),
                        extensionMultiDraw: pe && !0 === o.extensions.multiDraw && i.has("WEBGL_multi_draw"),
                        rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"),
                        customProgramCacheKey: o.customProgramCacheKey()
                    };
                    return fe.vertexUv1s = c.has(1), fe.vertexUv2s = c.has(2), fe.vertexUv3s = c.has(3), c.clear(), fe
                },
                getProgramCacheKey: function(t) {
                    const n = [];
                    if (t.shaderID ? n.push(t.shaderID) : (n.push(t.customVertexShaderID), n.push(t.customFragmentShaderID)), void 0 !== t.defines)
                        for (const e in t.defines) n.push(e), n.push(t.defines[e]);
                    return !1 === t.isRawShaderMaterial && (! function(e, t) {
                        e.push(t.precision), e.push(t.outputColorSpace), e.push(t.envMapMode), e.push(t.envMapCubeUVHeight), e.push(t.mapUv), e.push(t.alphaMapUv), e.push(t.lightMapUv), e.push(t.aoMapUv), e.push(t.bumpMapUv), e.push(t.normalMapUv), e.push(t.displacementMapUv), e.push(t.emissiveMapUv), e.push(t.metalnessMapUv), e.push(t.roughnessMapUv), e.push(t.anisotropyMapUv), e.push(t.clearcoatMapUv), e.push(t.clearcoatNormalMapUv), e.push(t.clearcoatRoughnessMapUv), e.push(t.iridescenceMapUv), e.push(t.iridescenceThicknessMapUv), e.push(t.sheenColorMapUv), e.push(t.sheenRoughnessMapUv), e.push(t.specularMapUv), e.push(t.specularColorMapUv), e.push(t.specularIntensityMapUv), e.push(t.transmissionMapUv), e.push(t.thicknessMapUv), e.push(t.combine), e.push(t.fogExp2), e.push(t.sizeAttenuation), e.push(t.morphTargetsCount), e.push(t.morphAttributeCount), e.push(t.numDirLights), e.push(t.numPointLights), e.push(t.numSpotLights), e.push(t.numSpotLightMaps), e.push(t.numHemiLights), e.push(t.numRectAreaLights), e.push(t.numDirLightShadows), e.push(t.numPointLightShadows), e.push(t.numSpotLightShadows), e.push(t.numSpotLightShadowsWithMaps), e.push(t.numLightProbes), e.push(t.shadowMapType), e.push(t.toneMapping), e.push(t.numClippingPlanes), e.push(t.numClipIntersection), e.push(t.depthPacking)
                    }(n, t), function(e, t) {
                        a.disableAll(), t.supportsVertexTextures && a.enable(0);
                        t.instancing && a.enable(1);
                        t.instancingColor && a.enable(2);
                        t.instancingMorph && a.enable(3);
                        t.matcap && a.enable(4);
                        t.envMap && a.enable(5);
                        t.normalMapObjectSpace && a.enable(6);
                        t.normalMapTangentSpace && a.enable(7);
                        t.clearcoat && a.enable(8);
                        t.iridescence && a.enable(9);
                        t.alphaTest && a.enable(10);
                        t.vertexColors && a.enable(11);
                        t.vertexAlphas && a.enable(12);
                        t.vertexUv1s && a.enable(13);
                        t.vertexUv2s && a.enable(14);
                        t.vertexUv3s && a.enable(15);
                        t.vertexTangents && a.enable(16);
                        t.anisotropy && a.enable(17);
                        t.alphaHash && a.enable(18);
                        t.batching && a.enable(19);
                        t.dispersion && a.enable(20);
                        e.push(a.mask), a.disableAll(), t.fog && a.enable(0);
                        t.useFog && a.enable(1);
                        t.flatShading && a.enable(2);
                        t.logarithmicDepthBuffer && a.enable(3);
                        t.skinning && a.enable(4);
                        t.morphTargets && a.enable(5);
                        t.morphNormals && a.enable(6);
                        t.morphColors && a.enable(7);
                        t.premultipliedAlpha && a.enable(8);
                        t.shadowMapEnabled && a.enable(9);
                        t.useLegacyLights && a.enable(10);
                        t.doubleSided && a.enable(11);
                        t.flipSided && a.enable(12);
                        t.useDepthPacking && a.enable(13);
                        t.dithering && a.enable(14);
                        t.transmission && a.enable(15);
                        t.sheen && a.enable(16);
                        t.opaque && a.enable(17);
                        t.pointsUvs && a.enable(18);
                        t.decodeVideoTexture && a.enable(19);
                        t.alphaToCoverage && a.enable(20);
                        e.push(a.mask)
                    }(n, t), n.push(e.outputColorSpace)), n.push(t.customProgramCacheKey), n.join()
                },
                getUniforms: function(e) {
                    const t = p[e.type];
                    let n;
                    if (t) {
                        const e = Bo[t];
                        n = $r.clone(e.uniforms)
                    } else n = e.uniforms;
                    return n
                },
                acquireProgram: function(t, n) {
                    let i;
                    for (let e = 0, t = A.length; e < t; e++) {
                        const t = A[e];
                        if (t.cacheKey === n) {
                            i = t, ++i.usedTimes;
                            break
                        }
                    }
                    return void 0 === i && (i = new ba(e, n, t, o), A.push(i)), i
                },
                releaseProgram: function(e) {
                    if (0 == --e.usedTimes) {
                        const t = A.indexOf(e);
                        A[t] = A[A.length - 1], A.pop(), e.destroy()
                    }
                },
                releaseShaderCache: function(e) {
                    l.remove(e)
                },
                programs: A,
                dispose: function() {
                    l.dispose()
                }
            }
        }

        function Ta() {
            let e = new WeakMap;
            return {
                get: function(t) {
                    let n = e.get(t);
                    return void 0 === n && (n = {}, e.set(t, n)), n
                },
                remove: function(t) {
                    e.delete(t)
                },
                update: function(t, n, i) {
                    e.get(t)[n] = i
                },
                dispose: function() {
                    e = new WeakMap
                }
            }
        }

        function Fa(e, t) {
            return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
        }

        function Da(e, t) {
            return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
        }

        function ka() {
            const e = [];
            let t = 0;
            const n = [],
                i = [],
                r = [];

            function o(n, i, r, o, s, a) {
                let l = e[t];
                return void 0 === l ? (l = {
                    id: n.id,
                    object: n,
                    geometry: i,
                    material: r,
                    groupOrder: o,
                    renderOrder: n.renderOrder,
                    z: s,
                    group: a
                }, e[t] = l) : (l.id = n.id, l.object = n, l.geometry = i, l.material = r, l.groupOrder = o, l.renderOrder = n.renderOrder, l.z = s, l.group = a), t++, l
            }
            return {
                opaque: n,
                transmissive: i,
                transparent: r,
                init: function() {
                    t = 0, n.length = 0, i.length = 0, r.length = 0
                },
                push: function(e, t, s, a, l, c) {
                    const A = o(e, t, s, a, l, c);
                    s.transmission > 0 ? i.push(A) : !0 === s.transparent ? r.push(A) : n.push(A)
                },
                unshift: function(e, t, s, a, l, c) {
                    const A = o(e, t, s, a, l, c);
                    s.transmission > 0 ? i.unshift(A) : !0 === s.transparent ? r.unshift(A) : n.unshift(A)
                },
                finish: function() {
                    for (let n = t, i = e.length; n < i; n++) {
                        const t = e[n];
                        if (null === t.id) break;
                        t.id = null, t.object = null, t.geometry = null, t.material = null, t.group = null
                    }
                },
                sort: function(e, t) {
                    n.length > 1 && n.sort(e || Fa), i.length > 1 && i.sort(t || Da), r.length > 1 && r.sort(t || Da)
                }
            }
        }

        function La() {
            let e = new WeakMap;
            return {
                get: function(t, n) {
                    const i = e.get(t);
                    let r;
                    return void 0 === i ? (r = new ka, e.set(t, [r])) : n >= i.length ? (r = new ka, i.push(r)) : r = i[n], r
                },
                dispose: function() {
                    e = new WeakMap
                }
            }
        }

        function Ka() {
            const e = {};
            return {
                get: function(t) {
                    if (void 0 !== e[t.id]) return e[t.id];
                    let n;
                    switch (t.type) {
                        case "DirectionalLight":
                            n = {
                                direction: new On,
                                color: new sr
                            };
                            break;
                        case "SpotLight":
                            n = {
                                position: new On,
                                direction: new On,
                                color: new sr,
                                distance: 0,
                                coneCos: 0,
                                penumbraCos: 0,
                                decay: 0
                            };
                            break;
                        case "PointLight":
                            n = {
                                position: new On,
                                color: new sr,
                                distance: 0,
                                decay: 0
                            };
                            break;
                        case "HemisphereLight":
                            n = {
                                direction: new On,
                                skyColor: new sr,
                                groundColor: new sr
                            };
                            break;
                        case "RectAreaLight":
                            n = {
                                color: new sr,
                                position: new On,
                                halfWidth: new On,
                                halfHeight: new On
                            }
                    }
                    return e[t.id] = n, n
                }
            }
        }
        let Pa = 0;

        function Ga(e, t) {
            return (t.castShadow ? 2 : 0) - (e.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (e.map ? 1 : 0)
        }

        function Va(e) {
            const t = new Ka,
                n = function() {
                    const e = {};
                    return {
                        get: function(t) {
                            if (void 0 !== e[t.id]) return e[t.id];
                            let n;
                            switch (t.type) {
                                case "DirectionalLight":
                                case "SpotLight":
                                    n = {
                                        shadowBias: 0,
                                        shadowNormalBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new dn
                                    };
                                    break;
                                case "PointLight":
                                    n = {
                                        shadowBias: 0,
                                        shadowNormalBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new dn,
                                        shadowCameraNear: 1,
                                        shadowCameraFar: 1e3
                                    }
                            }
                            return e[t.id] = n, n
                        }
                    }
                }(),
                i = {
                    version: 0,
                    hash: {
                        directionalLength: -1,
                        pointLength: -1,
                        spotLength: -1,
                        rectAreaLength: -1,
                        hemiLength: -1,
                        numDirectionalShadows: -1,
                        numPointShadows: -1,
                        numSpotShadows: -1,
                        numSpotMaps: -1,
                        numLightProbes: -1
                    },
                    ambient: [0, 0, 0],
                    probe: [],
                    directional: [],
                    directionalShadow: [],
                    directionalShadowMap: [],
                    directionalShadowMatrix: [],
                    spot: [],
                    spotLightMap: [],
                    spotShadow: [],
                    spotShadowMap: [],
                    spotLightMatrix: [],
                    rectArea: [],
                    rectAreaLTC1: null,
                    rectAreaLTC2: null,
                    point: [],
                    pointShadow: [],
                    pointShadowMap: [],
                    pointShadowMatrix: [],
                    hemi: [],
                    numSpotLightShadowsWithMaps: 0,
                    numLightProbes: 0
                };
            for (let e = 0; e < 9; e++) i.probe.push(new On);
            const r = new On,
                o = new mi,
                s = new mi;
            return {
                setup: function(r, o) {
                    let s = 0,
                        a = 0,
                        l = 0;
                    for (let e = 0; e < 9; e++) i.probe[e].set(0, 0, 0);
                    let c = 0,
                        A = 0,
                        h = 0,
                        u = 0,
                        d = 0,
                        p = 0,
                        g = 0,
                        f = 0,
                        m = 0,
                        E = 0,
                        C = 0;
                    r.sort(Ga);
                    const I = !0 === o ? Math.PI : 1;
                    for (let e = 0, o = r.length; e < o; e++) {
                        const o = r[e],
                            S = o.color,
                            v = o.intensity,
                            B = o.distance,
                            x = o.shadow && o.shadow.map ? o.shadow.map.texture : null;
                        if (o.isAmbientLight) s += S.r * v * I, a += S.g * v * I, l += S.b * v * I;
                        else if (o.isLightProbe) {
                            for (let e = 0; e < 9; e++) i.probe[e].addScaledVector(o.sh.coefficients[e], v);
                            C++
                        } else if (o.isDirectionalLight) {
                            const e = t.get(o);
                            if (e.color.copy(o.color).multiplyScalar(o.intensity * I), o.castShadow) {
                                const e = o.shadow,
                                    t = n.get(o);
                                t.shadowBias = e.bias, t.shadowNormalBias = e.normalBias, t.shadowRadius = e.radius, t.shadowMapSize = e.mapSize, i.directionalShadow[c] = t, i.directionalShadowMap[c] = x, i.directionalShadowMatrix[c] = o.shadow.matrix, p++
                            }
                            i.directional[c] = e, c++
                        } else if (o.isSpotLight) {
                            const e = t.get(o);
                            e.position.setFromMatrixPosition(o.matrixWorld), e.color.copy(S).multiplyScalar(v * I), e.distance = B, e.coneCos = Math.cos(o.angle), e.penumbraCos = Math.cos(o.angle * (1 - o.penumbra)), e.decay = o.decay, i.spot[h] = e;
                            const r = o.shadow;
                            if (o.map && (i.spotLightMap[m] = o.map, m++, r.updateMatrices(o), o.castShadow && E++), i.spotLightMatrix[h] = r.matrix, o.castShadow) {
                                const e = n.get(o);
                                e.shadowBias = r.bias, e.shadowNormalBias = r.normalBias, e.shadowRadius = r.radius, e.shadowMapSize = r.mapSize, i.spotShadow[h] = e, i.spotShadowMap[h] = x, f++
                            }
                            h++
                        } else if (o.isRectAreaLight) {
                            const e = t.get(o);
                            e.color.copy(S).multiplyScalar(v), e.halfWidth.set(.5 * o.width, 0, 0), e.halfHeight.set(0, .5 * o.height, 0), i.rectArea[u] = e, u++
                        } else if (o.isPointLight) {
                            const e = t.get(o);
                            if (e.color.copy(o.color).multiplyScalar(o.intensity * I), e.distance = o.distance, e.decay = o.decay, o.castShadow) {
                                const e = o.shadow,
                                    t = n.get(o);
                                t.shadowBias = e.bias, t.shadowNormalBias = e.normalBias, t.shadowRadius = e.radius, t.shadowMapSize = e.mapSize, t.shadowCameraNear = e.camera.near, t.shadowCameraFar = e.camera.far, i.pointShadow[A] = t, i.pointShadowMap[A] = x, i.pointShadowMatrix[A] = o.shadow.matrix, g++
                            }
                            i.point[A] = e, A++
                        } else if (o.isHemisphereLight) {
                            const e = t.get(o);
                            e.skyColor.copy(o.color).multiplyScalar(v * I), e.groundColor.copy(o.groundColor).multiplyScalar(v * I), i.hemi[d] = e, d++
                        }
                    }
                    u > 0 && (!0 === e.has("OES_texture_float_linear") ? (i.rectAreaLTC1 = vo.LTC_FLOAT_1, i.rectAreaLTC2 = vo.LTC_FLOAT_2) : (i.rectAreaLTC1 = vo.LTC_HALF_1, i.rectAreaLTC2 = vo.LTC_HALF_2)), i.ambient[0] = s, i.ambient[1] = a, i.ambient[2] = l;
                    const S = i.hash;
                    S.directionalLength === c && S.pointLength === A && S.spotLength === h && S.rectAreaLength === u && S.hemiLength === d && S.numDirectionalShadows === p && S.numPointShadows === g && S.numSpotShadows === f && S.numSpotMaps === m && S.numLightProbes === C || (i.directional.length = c, i.spot.length = h, i.rectArea.length = u, i.point.length = A, i.hemi.length = d, i.directionalShadow.length = p, i.directionalShadowMap.length = p, i.pointShadow.length = g, i.pointShadowMap.length = g, i.spotShadow.length = f, i.spotShadowMap.length = f, i.directionalShadowMatrix.length = p, i.pointShadowMatrix.length = g, i.spotLightMatrix.length = f + m - E, i.spotLightMap.length = m, i.numSpotLightShadowsWithMaps = E, i.numLightProbes = C, S.directionalLength = c, S.pointLength = A, S.spotLength = h, S.rectAreaLength = u, S.hemiLength = d, S.numDirectionalShadows = p, S.numPointShadows = g, S.numSpotShadows = f, S.numSpotMaps = m, S.numLightProbes = C, i.version = Pa++)
                },
                setupView: function(e, t) {
                    let n = 0,
                        a = 0,
                        l = 0,
                        c = 0,
                        A = 0;
                    const h = t.matrixWorldInverse;
                    for (let t = 0, u = e.length; t < u; t++) {
                        const u = e[t];
                        if (u.isDirectionalLight) {
                            const e = i.directional[n];
                            e.direction.setFromMatrixPosition(u.matrixWorld), r.setFromMatrixPosition(u.target.matrixWorld), e.direction.sub(r), e.direction.transformDirection(h), n++
                        } else if (u.isSpotLight) {
                            const e = i.spot[l];
                            e.position.setFromMatrixPosition(u.matrixWorld), e.position.applyMatrix4(h), e.direction.setFromMatrixPosition(u.matrixWorld), r.setFromMatrixPosition(u.target.matrixWorld), e.direction.sub(r), e.direction.transformDirection(h), l++
                        } else if (u.isRectAreaLight) {
                            const e = i.rectArea[c];
                            e.position.setFromMatrixPosition(u.matrixWorld), e.position.applyMatrix4(h), s.identity(), o.copy(u.matrixWorld), o.premultiply(h), s.extractRotation(o), e.halfWidth.set(.5 * u.width, 0, 0), e.halfHeight.set(0, .5 * u.height, 0), e.halfWidth.applyMatrix4(s), e.halfHeight.applyMatrix4(s), c++
                        } else if (u.isPointLight) {
                            const e = i.point[a];
                            e.position.setFromMatrixPosition(u.matrixWorld), e.position.applyMatrix4(h), a++
                        } else if (u.isHemisphereLight) {
                            const e = i.hemi[A];
                            e.direction.setFromMatrixPosition(u.matrixWorld), e.direction.transformDirection(h), A++
                        }
                    }
                },
                state: i
            }
        }

        function Oa(e) {
            const t = new Va(e),
                n = [],
                i = [];
            const r = {
                lightsArray: n,
                shadowsArray: i,
                camera: null,
                lights: t,
                transmissionRenderTarget: {}
            };
            return {
                init: function(e) {
                    r.camera = e, n.length = 0, i.length = 0
                },
                state: r,
                setupLights: function(e) {
                    t.setup(n, e)
                },
                setupLightsView: function(e) {
                    t.setupView(n, e)
                },
                pushLight: function(e) {
                    n.push(e)
                },
                pushShadow: function(e) {
                    i.push(e)
                }
            }
        }

        function Na(e) {
            let t = new WeakMap;
            return {
                get: function(n, i = 0) {
                    const r = t.get(n);
                    let o;
                    return void 0 === r ? (o = new Oa(e), t.set(n, [o])) : i >= r.length ? (o = new Oa(e), r.push(o)) : o = r[i], o
                },
                dispose: function() {
                    t = new WeakMap
                }
            }
        }
        class Ha extends cr {
            constructor(e) {
                super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = Pt, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
            }
        }
        class qa extends cr {
            constructor(e) {
                super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
            }
        }

        function ja(e, t, n) {
            let i = new mo;
            const r = new dn,
                o = new dn,
                s = new kn,
                a = new Ha({
                    depthPacking: Gt
                }),
                l = new qa,
                c = {},
                A = n.maxTextureSize,
                h = {
                    [Ue]: Me,
                    [Me]: Ue,
                    [Re]: Re
                },
                u = new eo({
                    defines: {
                        VSM_SAMPLES: 8
                    },
                    uniforms: {
                        shadow_pass: {
                            value: null
                        },
                        resolution: {
                            value: new dn
                        },
                        radius: {
                            value: 4
                        }
                    },
                    vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                    fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
                }),
                d = u.clone();
            d.defines.HORIZONTAL_PASS = 1;
            const p = new Ur;
            p.setAttribute("position", new Er(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
            const g = new Jr(p, u),
                f = this;
            this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = we;
            let m = this.type;

            function E(n, i) {
                const o = t.update(g);
                u.defines.VSM_SAMPLES !== n.blurSamples && (u.defines.VSM_SAMPLES = n.blurSamples, d.defines.VSM_SAMPLES = n.blurSamples, u.needsUpdate = !0, d.needsUpdate = !0), null === n.mapPass && (n.mapPass = new Kn(r.x, r.y)), u.uniforms.shadow_pass.value = n.map.texture, u.uniforms.resolution.value = n.mapSize, u.uniforms.radius.value = n.radius, e.setRenderTarget(n.mapPass), e.clear(), e.renderBufferDirect(i, null, o, u, g, null), d.uniforms.shadow_pass.value = n.mapPass.texture, d.uniforms.resolution.value = n.mapSize, d.uniforms.radius.value = n.radius, e.setRenderTarget(n.map), e.clear(), e.renderBufferDirect(i, null, o, d, g, null)
            }

            function C(t, n, i, r) {
                let o = null;
                const s = !0 === i.isPointLight ? t.customDistanceMaterial : t.customDepthMaterial;
                if (void 0 !== s) o = s;
                else if (o = !0 === i.isPointLight ? l : a, e.localClippingEnabled && !0 === n.clipShadows && Array.isArray(n.clippingPlanes) && 0 !== n.clippingPlanes.length || n.displacementMap && 0 !== n.displacementScale || n.alphaMap && n.alphaTest > 0 || n.map && n.alphaTest > 0) {
                    const e = o.uuid,
                        t = n.uuid;
                    let i = c[e];
                    void 0 === i && (i = {}, c[e] = i);
                    let r = i[t];
                    void 0 === r && (r = o.clone(), i[t] = r, n.addEventListener("dispose", S)), o = r
                }
                if (o.visible = n.visible, o.wireframe = n.wireframe, o.side = r === Qe ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : h[n.side], o.alphaMap = n.alphaMap, o.alphaTest = n.alphaTest, o.map = n.map, o.clipShadows = n.clipShadows, o.clippingPlanes = n.clippingPlanes, o.clipIntersection = n.clipIntersection, o.displacementMap = n.displacementMap, o.displacementScale = n.displacementScale, o.displacementBias = n.displacementBias, o.wireframeLinewidth = n.wireframeLinewidth, o.linewidth = n.linewidth, !0 === i.isPointLight && !0 === o.isMeshDistanceMaterial) {
                    e.properties.get(o).light = i
                }
                return o
            }

            function I(n, r, o, s, a) {
                if (!1 === n.visible) return;
                if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && a === Qe) && (!n.frustumCulled || i.intersectsObject(n))) {
                    n.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, n.matrixWorld);
                    const i = t.update(n),
                        l = n.material;
                    if (Array.isArray(l)) {
                        const t = i.groups;
                        for (let c = 0, A = t.length; c < A; c++) {
                            const A = t[c],
                                h = l[A.materialIndex];
                            if (h && h.visible) {
                                const t = C(n, h, s, a);
                                n.onBeforeShadow(e, n, r, o, i, t, A), e.renderBufferDirect(o, null, i, t, n, A), n.onAfterShadow(e, n, r, o, i, t, A)
                            }
                        }
                    } else if (l.visible) {
                        const t = C(n, l, s, a);
                        n.onBeforeShadow(e, n, r, o, i, t, null), e.renderBufferDirect(o, null, i, t, n, null), n.onAfterShadow(e, n, r, o, i, t, null)
                    }
                }
                const l = n.children;
                for (let e = 0, t = l.length; e < t; e++) I(l[e], r, o, s, a)
            }

            function S(e) {
                e.target.removeEventListener("dispose", S);
                for (const t in c) {
                    const n = c[t],
                        i = e.target.uuid;
                    if (i in n) {
                        n[i].dispose(), delete n[i]
                    }
                }
            }
            this.render = function(t, n, a) {
                if (!1 === f.enabled) return;
                if (!1 === f.autoUpdate && !1 === f.needsUpdate) return;
                if (0 === t.length) return;
                const l = e.getRenderTarget(),
                    c = e.getActiveCubeFace(),
                    h = e.getActiveMipmapLevel(),
                    u = e.state;
                u.setBlending(0), u.buffers.color.setClear(1, 1, 1, 1), u.buffers.depth.setTest(!0), u.setScissorTest(!1);
                const d = m !== Qe && this.type === Qe,
                    p = m === Qe && this.type !== Qe;
                for (let l = 0, c = t.length; l < c; l++) {
                    const c = t[l],
                        h = c.shadow;
                    if (void 0 === h) {
                        console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
                        continue
                    }
                    if (!1 === h.autoUpdate && !1 === h.needsUpdate) continue;
                    r.copy(h.mapSize);
                    const g = h.getFrameExtents();
                    if (r.multiply(g), o.copy(h.mapSize), (r.x > A || r.y > A) && (r.x > A && (o.x = Math.floor(A / g.x), r.x = o.x * g.x, h.mapSize.x = o.x), r.y > A && (o.y = Math.floor(A / g.y), r.y = o.y * g.y, h.mapSize.y = o.y)), null === h.map || !0 === d || !0 === p) {
                        const e = this.type !== Qe ? {
                            minFilter: $e,
                            magFilter: $e
                        } : {};
                        null !== h.map && h.map.dispose(), h.map = new Kn(r.x, r.y, e), h.map.texture.name = c.name + ".shadowMap", h.camera.updateProjectionMatrix()
                    }
                    e.setRenderTarget(h.map), e.clear();
                    const f = h.getViewportCount();
                    for (let e = 0; e < f; e++) {
                        const t = h.getViewport(e);
                        s.set(o.x * t.x, o.y * t.y, o.x * t.z, o.y * t.w), u.viewport(s), h.updateMatrices(c, e), i = h.getFrustum(), I(n, a, h.camera, c, this.type)
                    }!0 !== h.isPointLightShadow && this.type === Qe && E(h, a), h.needsUpdate = !1
                }
                m = this.type, f.needsUpdate = !1, e.setRenderTarget(l, c, h)
            }
        }

        function Ya(e) {
            const t = new function() {
                    let t = !1;
                    const n = new kn;
                    let i = null;
                    const r = new kn(0, 0, 0, 0);
                    return {
                        setMask: function(n) {
                            i === n || t || (e.colorMask(n, n, n, n), i = n)
                        },
                        setLocked: function(e) {
                            t = e
                        },
                        setClear: function(t, i, o, s, a) {
                            !0 === a && (t *= s, i *= s, o *= s), n.set(t, i, o, s), !1 === r.equals(n) && (e.clearColor(t, i, o, s), r.copy(n))
                        },
                        reset: function() {
                            t = !1, i = null, r.set(-1, 0, 0, 0)
                        }
                    }
                },
                n = new function() {
                    let t = !1,
                        n = null,
                        i = null,
                        r = null;
                    return {
                        setTest: function(t) {
                            t ? G(e.DEPTH_TEST) : V(e.DEPTH_TEST)
                        },
                        setMask: function(i) {
                            n === i || t || (e.depthMask(i), n = i)
                        },
                        setFunc: function(t) {
                            if (i !== t) {
                                switch (t) {
                                    case 0:
                                        e.depthFunc(e.NEVER);
                                        break;
                                    case 1:
                                        e.depthFunc(e.ALWAYS);
                                        break;
                                    case 2:
                                        e.depthFunc(e.LESS);
                                        break;
                                    case 3:
                                    default:
                                        e.depthFunc(e.LEQUAL);
                                        break;
                                    case 4:
                                        e.depthFunc(e.EQUAL);
                                        break;
                                    case 5:
                                        e.depthFunc(e.GEQUAL);
                                        break;
                                    case 6:
                                        e.depthFunc(e.GREATER);
                                        break;
                                    case 7:
                                        e.depthFunc(e.NOTEQUAL)
                                }
                                i = t
                            }
                        },
                        setLocked: function(e) {
                            t = e
                        },
                        setClear: function(t) {
                            r !== t && (e.clearDepth(t), r = t)
                        },
                        reset: function() {
                            t = !1, n = null, i = null, r = null
                        }
                    }
                },
                i = new function() {
                    let t = !1,
                        n = null,
                        i = null,
                        r = null,
                        o = null,
                        s = null,
                        a = null,
                        l = null,
                        c = null;
                    return {
                        setTest: function(n) {
                            t || (n ? G(e.STENCIL_TEST) : V(e.STENCIL_TEST))
                        },
                        setMask: function(i) {
                            n === i || t || (e.stencilMask(i), n = i)
                        },
                        setFunc: function(t, n, s) {
                            i === t && r === n && o === s || (e.stencilFunc(t, n, s), i = t, r = n, o = s)
                        },
                        setOp: function(t, n, i) {
                            s === t && a === n && l === i || (e.stencilOp(t, n, i), s = t, a = n, l = i)
                        },
                        setLocked: function(e) {
                            t = e
                        },
                        setClear: function(t) {
                            c !== t && (e.clearStencil(t), c = t)
                        },
                        reset: function() {
                            t = !1, n = null, i = null, r = null, o = null, s = null, a = null, l = null, c = null
                        }
                    }
                },
                r = new WeakMap,
                o = new WeakMap;
            let s = {},
                a = {},
                l = new WeakMap,
                c = [],
                A = null,
                h = !1,
                u = null,
                d = null,
                p = null,
                g = null,
                f = null,
                m = null,
                E = null,
                C = new sr(0, 0, 0),
                I = 0,
                S = !1,
                v = null,
                B = null,
                x = null,
                y = null,
                w = null;
            const b = e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
            let Q = !1,
                U = 0;
            const M = e.getParameter(e.VERSION); - 1 !== M.indexOf("WebGL") ? (U = parseFloat(/^WebGL (\d)/.exec(M)[1]), Q = U >= 1) : -1 !== M.indexOf("OpenGL ES") && (U = parseFloat(/^OpenGL ES (\d)/.exec(M)[1]), Q = U >= 2);
            let R = null,
                T = {};
            const F = e.getParameter(e.SCISSOR_BOX),
                D = e.getParameter(e.VIEWPORT),
                k = (new kn).fromArray(F),
                L = (new kn).fromArray(D);

            function K(t, n, i, r) {
                const o = new Uint8Array(4),
                    s = e.createTexture();
                e.bindTexture(t, s), e.texParameteri(t, e.TEXTURE_MIN_FILTER, e.NEAREST), e.texParameteri(t, e.TEXTURE_MAG_FILTER, e.NEAREST);
                for (let s = 0; s < i; s++) t === e.TEXTURE_3D || t === e.TEXTURE_2D_ARRAY ? e.texImage3D(n, 0, e.RGBA, 1, 1, r, 0, e.RGBA, e.UNSIGNED_BYTE, o) : e.texImage2D(n + s, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, o);
                return s
            }
            const P = {};

            function G(t) {
                !0 !== s[t] && (e.enable(t), s[t] = !0)
            }

            function V(t) {
                !1 !== s[t] && (e.disable(t), s[t] = !1)
            }
            P[e.TEXTURE_2D] = K(e.TEXTURE_2D, e.TEXTURE_2D, 1), P[e.TEXTURE_CUBE_MAP] = K(e.TEXTURE_CUBE_MAP, e.TEXTURE_CUBE_MAP_POSITIVE_X, 6), P[e.TEXTURE_2D_ARRAY] = K(e.TEXTURE_2D_ARRAY, e.TEXTURE_2D_ARRAY, 1, 1), P[e.TEXTURE_3D] = K(e.TEXTURE_3D, e.TEXTURE_3D, 1, 1), t.setClear(0, 0, 0, 1), n.setClear(1), i.setClear(0), G(e.DEPTH_TEST), n.setFunc(3), q(!1), j(1), G(e.CULL_FACE), H(0);
            const O = {
                [Te]: e.FUNC_ADD,
                101: e.FUNC_SUBTRACT,
                102: e.FUNC_REVERSE_SUBTRACT
            };
            O[103] = e.MIN, O[104] = e.MAX;
            const N = {
                200: e.ZERO,
                201: e.ONE,
                202: e.SRC_COLOR,
                204: e.SRC_ALPHA,
                210: e.SRC_ALPHA_SATURATE,
                208: e.DST_COLOR,
                206: e.DST_ALPHA,
                203: e.ONE_MINUS_SRC_COLOR,
                205: e.ONE_MINUS_SRC_ALPHA,
                209: e.ONE_MINUS_DST_COLOR,
                207: e.ONE_MINUS_DST_ALPHA,
                211: e.CONSTANT_COLOR,
                212: e.ONE_MINUS_CONSTANT_COLOR,
                213: e.CONSTANT_ALPHA,
                214: e.ONE_MINUS_CONSTANT_ALPHA
            };

            function H(t, n, i, r, o, s, a, l, c, A) {
                if (0 !== t) {
                    if (!1 === h && (G(e.BLEND), h = !0), 5 === t) o = o || n, s = s || i, a = a || r, n === d && o === f || (e.blendEquationSeparate(O[n], O[o]), d = n, f = o), i === p && r === g && s === m && a === E || (e.blendFuncSeparate(N[i], N[r], N[s], N[a]), p = i, g = r, m = s, E = a), !1 !== l.equals(C) && c === I || (e.blendColor(l.r, l.g, l.b, c), C.copy(l), I = c), u = t, S = !1;
                    else if (t !== u || A !== S) {
                        if (d === Te && f === Te || (e.blendEquation(e.FUNC_ADD), d = Te, f = Te), A) switch (t) {
                            case 1:
                                e.blendFuncSeparate(e.ONE, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA);
                                break;
                            case 2:
                                e.blendFunc(e.ONE, e.ONE);
                                break;
                            case 3:
                                e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE);
                                break;
                            case 4:
                                e.blendFuncSeparate(e.ZERO, e.SRC_COLOR, e.ZERO, e.SRC_ALPHA);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", t)
                        } else switch (t) {
                            case 1:
                                e.blendFuncSeparate(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA);
                                break;
                            case 2:
                                e.blendFunc(e.SRC_ALPHA, e.ONE);
                                break;
                            case 3:
                                e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE);
                                break;
                            case 4:
                                e.blendFunc(e.ZERO, e.SRC_COLOR);
                                break;
                            default:
                                console.error("THREE.WebGLState: Invalid blending: ", t)
                        }
                        p = null, g = null, m = null, E = null, C.set(0, 0, 0), I = 0, u = t, S = A
                    }
                } else !0 === h && (V(e.BLEND), h = !1)
            }

            function q(t) {
                v !== t && (t ? e.frontFace(e.CW) : e.frontFace(e.CCW), v = t)
            }

            function j(t) {
                0 !== t ? (G(e.CULL_FACE), t !== B && (1 === t ? e.cullFace(e.BACK) : 2 === t ? e.cullFace(e.FRONT) : e.cullFace(e.FRONT_AND_BACK))) : V(e.CULL_FACE), B = t
            }

            function Y(t, n, i) {
                t ? (G(e.POLYGON_OFFSET_FILL), y === n && w === i || (e.polygonOffset(n, i), y = n, w = i)) : V(e.POLYGON_OFFSET_FILL)
            }
            return {
                buffers: {
                    color: t,
                    depth: n,
                    stencil: i
                },
                enable: G,
                disable: V,
                bindFramebuffer: function(t, n) {
                    return a[t] !== n && (e.bindFramebuffer(t, n), a[t] = n, t === e.DRAW_FRAMEBUFFER && (a[e.FRAMEBUFFER] = n), t === e.FRAMEBUFFER && (a[e.DRAW_FRAMEBUFFER] = n), !0)
                },
                drawBuffers: function(t, n) {
                    let i = c,
                        r = !1;
                    if (t) {
                        i = l.get(n), void 0 === i && (i = [], l.set(n, i));
                        const o = t.textures;
                        if (i.length !== o.length || i[0] !== e.COLOR_ATTACHMENT0) {
                            for (let t = 0, n = o.length; t < n; t++) i[t] = e.COLOR_ATTACHMENT0 + t;
                            i.length = o.length, r = !0
                        }
                    } else i[0] !== e.BACK && (i[0] = e.BACK, r = !0);
                    r && e.drawBuffers(i)
                },
                useProgram: function(t) {
                    return A !== t && (e.useProgram(t), A = t, !0)
                },
                setBlending: H,
                setMaterial: function(r, o) {
                    r.side === Re ? V(e.CULL_FACE) : G(e.CULL_FACE);
                    let s = r.side === Me;
                    o && (s = !s), q(s), 1 === r.blending && !1 === r.transparent ? H(0) : H(r.blending, r.blendEquation, r.blendSrc, r.blendDst, r.blendEquationAlpha, r.blendSrcAlpha, r.blendDstAlpha, r.blendColor, r.blendAlpha, r.premultipliedAlpha), n.setFunc(r.depthFunc), n.setTest(r.depthTest), n.setMask(r.depthWrite), t.setMask(r.colorWrite);
                    const a = r.stencilWrite;
                    i.setTest(a), a && (i.setMask(r.stencilWriteMask), i.setFunc(r.stencilFunc, r.stencilRef, r.stencilFuncMask), i.setOp(r.stencilFail, r.stencilZFail, r.stencilZPass)), Y(r.polygonOffset, r.polygonOffsetFactor, r.polygonOffsetUnits), !0 === r.alphaToCoverage ? G(e.SAMPLE_ALPHA_TO_COVERAGE) : V(e.SAMPLE_ALPHA_TO_COVERAGE)
                },
                setFlipSided: q,
                setCullFace: j,
                setLineWidth: function(t) {
                    t !== x && (Q && e.lineWidth(t), x = t)
                },
                setPolygonOffset: Y,
                setScissorTest: function(t) {
                    t ? G(e.SCISSOR_TEST) : V(e.SCISSOR_TEST)
                },
                activeTexture: function(t) {
                    void 0 === t && (t = e.TEXTURE0 + b - 1), R !== t && (e.activeTexture(t), R = t)
                },
                bindTexture: function(t, n, i) {
                    void 0 === i && (i = null === R ? e.TEXTURE0 + b - 1 : R);
                    let r = T[i];
                    void 0 === r && (r = {
                        type: void 0,
                        texture: void 0
                    }, T[i] = r), r.type === t && r.texture === n || (R !== i && (e.activeTexture(i), R = i), e.bindTexture(t, n || P[t]), r.type = t, r.texture = n)
                },
                unbindTexture: function() {
                    const t = T[R];
                    void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null), t.type = void 0, t.texture = void 0)
                },
                compressedTexImage2D: function() {
                    try {
                        e.compressedTexImage2D.apply(e, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                compressedTexImage3D: function() {
                    try {
                        e.compressedTexImage3D.apply(e, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                texImage2D: function() {
                    try {
                        e.texImage2D.apply(e, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                texImage3D: function() {
                    try {
                        e.texImage3D.apply(e, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                updateUBOMapping: function(t, n) {
                    let i = o.get(n);
                    void 0 === i && (i = new WeakMap, o.set(n, i));
                    let r = i.get(t);
                    void 0 === r && (r = e.getUniformBlockIndex(n, t.name), i.set(t, r))
                },
                uniformBlockBinding: function(t, n) {
                    const i = o.get(n).get(t);
                    r.get(n) !== i && (e.uniformBlockBinding(n, i, t.__bindingPointIndex), r.set(n, i))
                },
                texStorage2D: function() {
                    try {
                        e.texStorage2D.apply(e, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                texStorage3D: function() {
                    try {
                        e.texStorage3D.apply(e, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                texSubImage2D: function() {
                    try {
                        e.texSubImage2D.apply(e, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                texSubImage3D: function() {
                    try {
                        e.texSubImage3D.apply(e, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                compressedTexSubImage2D: function() {
                    try {
                        e.compressedTexSubImage2D.apply(e, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                compressedTexSubImage3D: function() {
                    try {
                        e.compressedTexSubImage3D.apply(e, arguments)
                    } catch (e) {
                        console.error("THREE.WebGLState:", e)
                    }
                },
                scissor: function(t) {
                    !1 === k.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), k.copy(t))
                },
                viewport: function(t) {
                    !1 === L.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), L.copy(t))
                },
                reset: function() {
                    e.disable(e.BLEND), e.disable(e.CULL_FACE), e.disable(e.DEPTH_TEST), e.disable(e.POLYGON_OFFSET_FILL), e.disable(e.SCISSOR_TEST), e.disable(e.STENCIL_TEST), e.disable(e.SAMPLE_ALPHA_TO_COVERAGE), e.blendEquation(e.FUNC_ADD), e.blendFunc(e.ONE, e.ZERO), e.blendFuncSeparate(e.ONE, e.ZERO, e.ONE, e.ZERO), e.blendColor(0, 0, 0, 0), e.colorMask(!0, !0, !0, !0), e.clearColor(0, 0, 0, 0), e.depthMask(!0), e.depthFunc(e.LESS), e.clearDepth(1), e.stencilMask(4294967295), e.stencilFunc(e.ALWAYS, 0, 4294967295), e.stencilOp(e.KEEP, e.KEEP, e.KEEP), e.clearStencil(0), e.cullFace(e.BACK), e.frontFace(e.CCW), e.polygonOffset(0, 0), e.activeTexture(e.TEXTURE0), e.bindFramebuffer(e.FRAMEBUFFER, null), e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), e.bindFramebuffer(e.READ_FRAMEBUFFER, null), e.useProgram(null), e.lineWidth(1), e.scissor(0, 0, e.canvas.width, e.canvas.height), e.viewport(0, 0, e.canvas.width, e.canvas.height), s = {}, R = null, T = {}, a = {}, l = new WeakMap, c = [], A = null, h = !1, u = null, d = null, p = null, g = null, f = null, m = null, E = null, C = new sr(0, 0, 0), I = 0, S = !1, v = null, B = null, x = null, y = null, w = null, k.set(0, 0, e.canvas.width, e.canvas.height), L.set(0, 0, e.canvas.width, e.canvas.height), t.reset(), n.reset(), i.reset()
                }
            }
        }

        function Ja(e, t, n, i, r, o, s) {
            const a = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null,
                l = "undefined" != typeof navigator && /OculusBrowser/g.test(navigator.userAgent),
                c = new dn,
                A = new WeakMap;
            let h;
            const u = new WeakMap;
            let d = !1;
            try {
                d = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
            } catch (e) {}

            function p(e, t) {
                return d ? new OffscreenCanvas(e, t) : mn("canvas")
            }

            function g(e, t, n) {
                let i = 1;
                const r = G(e);
                if ((r.width > n || r.height > n) && (i = n / Math.max(r.width, r.height)), i < 1) {
                    if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap || "undefined" != typeof VideoFrame && e instanceof VideoFrame) {
                        const n = Math.floor(i * r.width),
                            o = Math.floor(i * r.height);
                        void 0 === h && (h = p(n, o));
                        const s = t ? p(n, o) : h;
                        s.width = n, s.height = o;
                        return s.getContext("2d").drawImage(e, 0, 0, n, o), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + r.width + "x" + r.height + ") to (" + n + "x" + o + ")."), s
                    }
                    return "data" in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + r.width + "x" + r.height + ")."), e
                }
                return e
            }

            function f(e) {
                return e.generateMipmaps && e.minFilter !== $e && e.minFilter !== nt
            }

            function m(t) {
                e.generateMipmap(t)
            }

            function E(n, i, r, o, s = !1) {
                if (null !== n) {
                    if (void 0 !== e[n]) return e[n];
                    console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                }
                let a = i;
                if (i === e.RED && (r === e.FLOAT && (a = e.R32F), r === e.HALF_FLOAT && (a = e.R16F), r === e.UNSIGNED_BYTE && (a = e.R8)), i === e.RED_INTEGER && (r === e.UNSIGNED_BYTE && (a = e.R8UI), r === e.UNSIGNED_SHORT && (a = e.R16UI), r === e.UNSIGNED_INT && (a = e.R32UI), r === e.BYTE && (a = e.R8I), r === e.SHORT && (a = e.R16I), r === e.INT && (a = e.R32I)), i === e.RG && (r === e.FLOAT && (a = e.RG32F), r === e.HALF_FLOAT && (a = e.RG16F), r === e.UNSIGNED_BYTE && (a = e.RG8)), i === e.RG_INTEGER && (r === e.UNSIGNED_BYTE && (a = e.RG8UI), r === e.UNSIGNED_SHORT && (a = e.RG16UI), r === e.UNSIGNED_INT && (a = e.RG32UI), r === e.BYTE && (a = e.RG8I), r === e.SHORT && (a = e.RG16I), r === e.INT && (a = e.RG32I)), i === e.RGB && r === e.UNSIGNED_INT_5_9_9_9_REV && (a = e.RGB9_E5), i === e.RGBA) {
                    const t = s ? jt : yn.getTransfer(o);
                    r === e.FLOAT && (a = e.RGBA32F), r === e.HALF_FLOAT && (a = e.RGBA16F), r === e.UNSIGNED_BYTE && (a = t === Yt ? e.SRGB8_ALPHA8 : e.RGBA8), r === e.UNSIGNED_SHORT_4_4_4_4 && (a = e.RGBA4), r === e.UNSIGNED_SHORT_5_5_5_1 && (a = e.RGB5_A1)
                }
                return a !== e.R16F && a !== e.R32F && a !== e.RG16F && a !== e.RG32F && a !== e.RGBA16F && a !== e.RGBA32F || t.get("EXT_color_buffer_float"), a
            }

            function C(e, t) {
                return !0 === f(e) || e.isFramebufferTexture && e.minFilter !== $e && e.minFilter !== nt ? Math.log2(Math.max(t.width, t.height)) + 1 : void 0 !== e.mipmaps && e.mipmaps.length > 0 ? e.mipmaps.length : e.isCompressedTexture && Array.isArray(e.image) ? t.mipmaps.length : 1
            }

            function I(e) {
                const t = e.target;
                t.removeEventListener("dispose", I),
                    function(e) {
                        const t = i.get(e);
                        if (void 0 === t.__webglInit) return;
                        const n = e.source,
                            r = u.get(n);
                        if (r) {
                            const i = r[t.__cacheKey];
                            i.usedTimes--, 0 === i.usedTimes && v(e), 0 === Object.keys(r).length && u.delete(n)
                        }
                        i.remove(e)
                    }(t), t.isVideoTexture && A.delete(t)
            }

            function S(t) {
                const n = t.target;
                n.removeEventListener("dispose", S),
                    function(t) {
                        const n = i.get(t);
                        t.depthTexture && t.depthTexture.dispose();
                        if (t.isWebGLCubeRenderTarget)
                            for (let t = 0; t < 6; t++) {
                                if (Array.isArray(n.__webglFramebuffer[t]))
                                    for (let i = 0; i < n.__webglFramebuffer[t].length; i++) e.deleteFramebuffer(n.__webglFramebuffer[t][i]);
                                else e.deleteFramebuffer(n.__webglFramebuffer[t]);
                                n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer[t])
                            } else {
                                if (Array.isArray(n.__webglFramebuffer))
                                    for (let t = 0; t < n.__webglFramebuffer.length; t++) e.deleteFramebuffer(n.__webglFramebuffer[t]);
                                else e.deleteFramebuffer(n.__webglFramebuffer);
                                if (n.__webglDepthbuffer && e.deleteRenderbuffer(n.__webglDepthbuffer), n.__webglMultisampledFramebuffer && e.deleteFramebuffer(n.__webglMultisampledFramebuffer), n.__webglColorRenderbuffer)
                                    for (let t = 0; t < n.__webglColorRenderbuffer.length; t++) n.__webglColorRenderbuffer[t] && e.deleteRenderbuffer(n.__webglColorRenderbuffer[t]);
                                n.__webglDepthRenderbuffer && e.deleteRenderbuffer(n.__webglDepthRenderbuffer)
                            }
                        const r = t.textures;
                        for (let t = 0, n = r.length; t < n; t++) {
                            const n = i.get(r[t]);
                            n.__webglTexture && (e.deleteTexture(n.__webglTexture), s.memory.textures--), i.remove(r[t])
                        }
                        i.remove(t)
                    }(n)
            }

            function v(t) {
                const n = i.get(t);
                e.deleteTexture(n.__webglTexture);
                const r = t.source;
                delete u.get(r)[n.__cacheKey], s.memory.textures--
            }
            let B = 0;

            function x(t, r) {
                const o = i.get(t);
                if (t.isVideoTexture && function(e) {
                        const t = s.render.frame;
                        A.get(e) !== t && (A.set(e, t), e.update())
                    }(t), !1 === t.isRenderTargetTexture && t.version > 0 && o.__version !== t.version) {
                    const e = t.image;
                    if (null === e) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
                    else {
                        if (!1 !== e.complete) return void M(o, t, r);
                        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                    }
                }
                n.bindTexture(e.TEXTURE_2D, o.__webglTexture, e.TEXTURE0 + r)
            }
            const y = {
                    [Xe]: e.REPEAT,
                    [Ze]: e.CLAMP_TO_EDGE,
                    [_e]: e.MIRRORED_REPEAT
                },
                w = {
                    [$e]: e.NEAREST,
                    [et]: e.NEAREST_MIPMAP_NEAREST,
                    [tt]: e.NEAREST_MIPMAP_LINEAR,
                    [nt]: e.LINEAR,
                    [it]: e.LINEAR_MIPMAP_NEAREST,
                    [rt]: e.LINEAR_MIPMAP_LINEAR
                },
                b = {
                    512: e.NEVER,
                    519: e.ALWAYS,
                    513: e.LESS,
                    515: e.LEQUAL,
                    514: e.EQUAL,
                    518: e.GEQUAL,
                    516: e.GREATER,
                    517: e.NOTEQUAL
                };

            function Q(n, o) {
                if (o.type !== lt || !1 !== t.has("OES_texture_float_linear") || o.magFilter !== nt && o.magFilter !== it && o.magFilter !== tt && o.magFilter !== rt && o.minFilter !== nt && o.minFilter !== it && o.minFilter !== tt && o.minFilter !== rt || console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), e.texParameteri(n, e.TEXTURE_WRAP_S, y[o.wrapS]), e.texParameteri(n, e.TEXTURE_WRAP_T, y[o.wrapT]), n !== e.TEXTURE_3D && n !== e.TEXTURE_2D_ARRAY || e.texParameteri(n, e.TEXTURE_WRAP_R, y[o.wrapR]), e.texParameteri(n, e.TEXTURE_MAG_FILTER, w[o.magFilter]), e.texParameteri(n, e.TEXTURE_MIN_FILTER, w[o.minFilter]), o.compareFunction && (e.texParameteri(n, e.TEXTURE_COMPARE_MODE, e.COMPARE_REF_TO_TEXTURE), e.texParameteri(n, e.TEXTURE_COMPARE_FUNC, b[o.compareFunction])), !0 === t.has("EXT_texture_filter_anisotropic")) {
                    if (o.magFilter === $e) return;
                    if (o.minFilter !== tt && o.minFilter !== rt) return;
                    if (o.type === lt && !1 === t.has("OES_texture_float_linear")) return;
                    if (o.anisotropy > 1 || i.get(o).__currentAnisotropy) {
                        const s = t.get("EXT_texture_filter_anisotropic");
                        e.texParameterf(n, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(o.anisotropy, r.getMaxAnisotropy())), i.get(o).__currentAnisotropy = o.anisotropy
                    }
                }
            }

            function U(t, n) {
                let i = !1;
                void 0 === t.__webglInit && (t.__webglInit = !0, n.addEventListener("dispose", I));
                const r = n.source;
                let o = u.get(r);
                void 0 === o && (o = {}, u.set(r, o));
                const a = function(e) {
                    const t = [];
                    return t.push(e.wrapS), t.push(e.wrapT), t.push(e.wrapR || 0), t.push(e.magFilter), t.push(e.minFilter), t.push(e.anisotropy), t.push(e.internalFormat), t.push(e.format), t.push(e.type), t.push(e.generateMipmaps), t.push(e.premultiplyAlpha), t.push(e.flipY), t.push(e.unpackAlignment), t.push(e.colorSpace), t.join()
                }(n);
                if (a !== t.__cacheKey) {
                    void 0 === o[a] && (o[a] = {
                        texture: e.createTexture(),
                        usedTimes: 0
                    }, s.memory.textures++, i = !0), o[a].usedTimes++;
                    const r = o[t.__cacheKey];
                    void 0 !== r && (o[t.__cacheKey].usedTimes--, 0 === r.usedTimes && v(n)), t.__cacheKey = a, t.__webglTexture = o[a].texture
                }
                return i
            }

            function M(t, s, a) {
                let l = e.TEXTURE_2D;
                (s.isDataArrayTexture || s.isCompressedArrayTexture) && (l = e.TEXTURE_2D_ARRAY), s.isData3DTexture && (l = e.TEXTURE_3D);
                const c = U(t, s),
                    A = s.source;
                n.bindTexture(l, t.__webglTexture, e.TEXTURE0 + a);
                const h = i.get(A);
                if (A.version !== h.__version || !0 === c) {
                    n.activeTexture(e.TEXTURE0 + a);
                    const t = yn.getPrimaries(yn.workingColorSpace),
                        i = s.colorSpace === Vt ? null : yn.getPrimaries(s.colorSpace),
                        u = s.colorSpace === Vt || t === i ? e.NONE : e.BROWSER_DEFAULT_WEBGL;
                    e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, s.flipY), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, s.premultiplyAlpha), e.pixelStorei(e.UNPACK_ALIGNMENT, s.unpackAlignment), e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, u);
                    let d = g(s.image, !1, r.maxTextureSize);
                    d = P(s, d);
                    const p = o.convert(s.format, s.colorSpace),
                        I = o.convert(s.type);
                    let S, v = E(s.internalFormat, p, I, s.colorSpace, s.isVideoTexture);
                    Q(l, s);
                    const B = s.mipmaps,
                        x = !0 !== s.isVideoTexture,
                        y = void 0 === h.__version || !0 === c,
                        w = A.dataReady,
                        b = C(s, d);
                    if (s.isDepthTexture) v = e.DEPTH_COMPONENT16, s.type === lt ? v = e.DEPTH_COMPONENT32F : s.type === at ? v = e.DEPTH_COMPONENT24 : s.type === At && (v = e.DEPTH24_STENCIL8), y && (x ? n.texStorage2D(e.TEXTURE_2D, 1, v, d.width, d.height) : n.texImage2D(e.TEXTURE_2D, 0, v, d.width, d.height, 0, p, I, null));
                    else if (s.isDataTexture)
                        if (B.length > 0) {
                            x && y && n.texStorage2D(e.TEXTURE_2D, b, v, B[0].width, B[0].height);
                            for (let t = 0, i = B.length; t < i; t++) S = B[t], x ? w && n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, S.width, S.height, p, I, S.data) : n.texImage2D(e.TEXTURE_2D, t, v, S.width, S.height, 0, p, I, S.data);
                            s.generateMipmaps = !1
                        } else x ? (y && n.texStorage2D(e.TEXTURE_2D, b, v, d.width, d.height), w && n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, d.width, d.height, p, I, d.data)) : n.texImage2D(e.TEXTURE_2D, 0, v, d.width, d.height, 0, p, I, d.data);
                    else if (s.isCompressedTexture)
                        if (s.isCompressedArrayTexture) {
                            x && y && n.texStorage3D(e.TEXTURE_2D_ARRAY, b, v, B[0].width, B[0].height, d.depth);
                            for (let t = 0, i = B.length; t < i; t++) S = B[t], s.format !== ht ? null !== p ? x ? w && n.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY, t, 0, 0, 0, S.width, S.height, d.depth, p, S.data, 0, 0) : n.compressedTexImage3D(e.TEXTURE_2D_ARRAY, t, v, S.width, S.height, d.depth, 0, S.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : x ? w && n.texSubImage3D(e.TEXTURE_2D_ARRAY, t, 0, 0, 0, S.width, S.height, d.depth, p, I, S.data) : n.texImage3D(e.TEXTURE_2D_ARRAY, t, v, S.width, S.height, d.depth, 0, p, I, S.data)
                        } else {
                            x && y && n.texStorage2D(e.TEXTURE_2D, b, v, B[0].width, B[0].height);
                            for (let t = 0, i = B.length; t < i; t++) S = B[t], s.format !== ht ? null !== p ? x ? w && n.compressedTexSubImage2D(e.TEXTURE_2D, t, 0, 0, S.width, S.height, p, S.data) : n.compressedTexImage2D(e.TEXTURE_2D, t, v, S.width, S.height, 0, S.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : x ? w && n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, S.width, S.height, p, I, S.data) : n.texImage2D(e.TEXTURE_2D, t, v, S.width, S.height, 0, p, I, S.data)
                        }
                    else if (s.isDataArrayTexture) x ? (y && n.texStorage3D(e.TEXTURE_2D_ARRAY, b, v, d.width, d.height, d.depth), w && n.texSubImage3D(e.TEXTURE_2D_ARRAY, 0, 0, 0, 0, d.width, d.height, d.depth, p, I, d.data)) : n.texImage3D(e.TEXTURE_2D_ARRAY, 0, v, d.width, d.height, d.depth, 0, p, I, d.data);
                    else if (s.isData3DTexture) x ? (y && n.texStorage3D(e.TEXTURE_3D, b, v, d.width, d.height, d.depth), w && n.texSubImage3D(e.TEXTURE_3D, 0, 0, 0, 0, d.width, d.height, d.depth, p, I, d.data)) : n.texImage3D(e.TEXTURE_3D, 0, v, d.width, d.height, d.depth, 0, p, I, d.data);
                    else if (s.isFramebufferTexture) {
                        if (y)
                            if (x) n.texStorage2D(e.TEXTURE_2D, b, v, d.width, d.height);
                            else {
                                let t = d.width,
                                    i = d.height;
                                for (let r = 0; r < b; r++) n.texImage2D(e.TEXTURE_2D, r, v, t, i, 0, p, I, null), t >>= 1, i >>= 1
                            }
                    } else if (B.length > 0) {
                        if (x && y) {
                            const t = G(B[0]);
                            n.texStorage2D(e.TEXTURE_2D, b, v, t.width, t.height)
                        }
                        for (let t = 0, i = B.length; t < i; t++) S = B[t], x ? w && n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, p, I, S) : n.texImage2D(e.TEXTURE_2D, t, v, p, I, S);
                        s.generateMipmaps = !1
                    } else if (x) {
                        if (y) {
                            const t = G(d);
                            n.texStorage2D(e.TEXTURE_2D, b, v, t.width, t.height)
                        }
                        w && n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, p, I, d)
                    } else n.texImage2D(e.TEXTURE_2D, 0, v, p, I, d);
                    f(s) && m(l), h.__version = A.version, s.onUpdate && s.onUpdate(s)
                }
                t.__version = s.version
            }

            function R(t, r, s, l, c, A) {
                const h = o.convert(s.format, s.colorSpace),
                    u = o.convert(s.type),
                    d = E(s.internalFormat, h, u, s.colorSpace);
                if (!i.get(r).__hasExternalTextures) {
                    const t = Math.max(1, r.width >> A),
                        i = Math.max(1, r.height >> A);
                    c === e.TEXTURE_3D || c === e.TEXTURE_2D_ARRAY ? n.texImage3D(c, A, d, t, i, r.depth, 0, h, u, null) : n.texImage2D(c, A, d, t, i, 0, h, u, null)
                }
                n.bindFramebuffer(e.FRAMEBUFFER, t), K(r) ? a.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, l, c, i.get(s).__webglTexture, 0, L(r)) : (c === e.TEXTURE_2D || c >= e.TEXTURE_CUBE_MAP_POSITIVE_X && c <= e.TEXTURE_CUBE_MAP_NEGATIVE_Z) && e.framebufferTexture2D(e.FRAMEBUFFER, l, c, i.get(s).__webglTexture, A), n.bindFramebuffer(e.FRAMEBUFFER, null)
            }

            function T(t, n, i) {
                if (e.bindRenderbuffer(e.RENDERBUFFER, t), n.depthBuffer && !n.stencilBuffer) {
                    let r = e.DEPTH_COMPONENT24;
                    if (i || K(n)) {
                        const t = n.depthTexture;
                        t && t.isDepthTexture && (t.type === lt ? r = e.DEPTH_COMPONENT32F : t.type === at && (r = e.DEPTH_COMPONENT24));
                        const i = L(n);
                        K(n) ? a.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, i, r, n.width, n.height) : e.renderbufferStorageMultisample(e.RENDERBUFFER, i, r, n.width, n.height)
                    } else e.renderbufferStorage(e.RENDERBUFFER, r, n.width, n.height);
                    e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.RENDERBUFFER, t)
                } else if (n.depthBuffer && n.stencilBuffer) {
                    const r = L(n);
                    i && !1 === K(n) ? e.renderbufferStorageMultisample(e.RENDERBUFFER, r, e.DEPTH24_STENCIL8, n.width, n.height) : K(n) ? a.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, r, e.DEPTH24_STENCIL8, n.width, n.height) : e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, n.width, n.height), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.RENDERBUFFER, t)
                } else {
                    const t = n.textures;
                    for (let r = 0; r < t.length; r++) {
                        const s = t[r],
                            l = o.convert(s.format, s.colorSpace),
                            c = o.convert(s.type),
                            A = E(s.internalFormat, l, c, s.colorSpace),
                            h = L(n);
                        i && !1 === K(n) ? e.renderbufferStorageMultisample(e.RENDERBUFFER, h, A, n.width, n.height) : K(n) ? a.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, h, A, n.width, n.height) : e.renderbufferStorage(e.RENDERBUFFER, A, n.width, n.height)
                    }
                }
                e.bindRenderbuffer(e.RENDERBUFFER, null)
            }

            function F(t) {
                const r = i.get(t),
                    o = !0 === t.isWebGLCubeRenderTarget;
                if (t.depthTexture && !r.__autoAllocateDepthBuffer) {
                    if (o) throw new Error("target.depthTexture not supported in Cube render targets");
                    ! function(t, r) {
                        if (r && r.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                        if (n.bindFramebuffer(e.FRAMEBUFFER, t), !r.depthTexture || !r.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                        i.get(r.depthTexture).__webglTexture && r.depthTexture.image.width === r.width && r.depthTexture.image.height === r.height || (r.depthTexture.image.width = r.width, r.depthTexture.image.height = r.height, r.depthTexture.needsUpdate = !0), x(r.depthTexture, 0);
                        const o = i.get(r.depthTexture).__webglTexture,
                            s = L(r);
                        if (r.depthTexture.format === dt) K(r) ? a.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, o, 0, s) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, o, 0);
                        else {
                            if (r.depthTexture.format !== pt) throw new Error("Unknown depthTexture format");
                            K(r) ? a.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, o, 0, s) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, o, 0)
                        }
                    }(r.__webglFramebuffer, t)
                } else if (o) {
                    r.__webglDepthbuffer = [];
                    for (let i = 0; i < 6; i++) n.bindFramebuffer(e.FRAMEBUFFER, r.__webglFramebuffer[i]), r.__webglDepthbuffer[i] = e.createRenderbuffer(), T(r.__webglDepthbuffer[i], t, !1)
                } else n.bindFramebuffer(e.FRAMEBUFFER, r.__webglFramebuffer), r.__webglDepthbuffer = e.createRenderbuffer(), T(r.__webglDepthbuffer, t, !1);
                n.bindFramebuffer(e.FRAMEBUFFER, null)
            }
            const D = [],
                k = [];

            function L(e) {
                return Math.min(r.maxSamples, e.samples)
            }

            function K(e) {
                const n = i.get(e);
                return e.samples > 0 && !0 === t.has("WEBGL_multisampled_render_to_texture") && !1 !== n.__useRenderToTexture
            }

            function P(e, t) {
                const n = e.colorSpace,
                    i = e.format,
                    r = e.type;
                return !0 === e.isCompressedTexture || !0 === e.isVideoTexture || n !== Nt && n !== Vt && (yn.getTransfer(n) === Yt ? i === ht && r === ot || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", n)), t
            }

            function G(e) {
                return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement ? (c.width = e.naturalWidth || e.width, c.height = e.naturalHeight || e.height) : "undefined" != typeof VideoFrame && e instanceof VideoFrame ? (c.width = e.displayWidth, c.height = e.displayHeight) : (c.width = e.width, c.height = e.height), c
            }
            this.allocateTextureUnit = function() {
                const e = B;
                return e >= r.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + r.maxTextures), B += 1, e
            }, this.resetTextureUnits = function() {
                B = 0
            }, this.setTexture2D = x, this.setTexture2DArray = function(t, r) {
                const o = i.get(t);
                t.version > 0 && o.__version !== t.version ? M(o, t, r) : n.bindTexture(e.TEXTURE_2D_ARRAY, o.__webglTexture, e.TEXTURE0 + r)
            }, this.setTexture3D = function(t, r) {
                const o = i.get(t);
                t.version > 0 && o.__version !== t.version ? M(o, t, r) : n.bindTexture(e.TEXTURE_3D, o.__webglTexture, e.TEXTURE0 + r)
            }, this.setTextureCube = function(t, s) {
                const a = i.get(t);
                t.version > 0 && a.__version !== t.version ? function(t, s, a) {
                    if (6 !== s.image.length) return;
                    const l = U(t, s),
                        c = s.source;
                    n.bindTexture(e.TEXTURE_CUBE_MAP, t.__webglTexture, e.TEXTURE0 + a);
                    const A = i.get(c);
                    if (c.version !== A.__version || !0 === l) {
                        n.activeTexture(e.TEXTURE0 + a);
                        const t = yn.getPrimaries(yn.workingColorSpace),
                            i = s.colorSpace === Vt ? null : yn.getPrimaries(s.colorSpace),
                            h = s.colorSpace === Vt || t === i ? e.NONE : e.BROWSER_DEFAULT_WEBGL;
                        e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, s.flipY), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, s.premultiplyAlpha), e.pixelStorei(e.UNPACK_ALIGNMENT, s.unpackAlignment), e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, h);
                        const u = s.isCompressedTexture || s.image[0].isCompressedTexture,
                            d = s.image[0] && s.image[0].isDataTexture,
                            p = [];
                        for (let e = 0; e < 6; e++) p[e] = u || d ? d ? s.image[e].image : s.image[e] : g(s.image[e], !0, r.maxCubemapSize), p[e] = P(s, p[e]);
                        const I = p[0],
                            S = o.convert(s.format, s.colorSpace),
                            v = o.convert(s.type),
                            B = E(s.internalFormat, S, v, s.colorSpace),
                            x = !0 !== s.isVideoTexture,
                            y = void 0 === A.__version || !0 === l,
                            w = c.dataReady;
                        let b, U = C(s, I);
                        if (Q(e.TEXTURE_CUBE_MAP, s), u) {
                            x && y && n.texStorage2D(e.TEXTURE_CUBE_MAP, U, B, I.width, I.height);
                            for (let t = 0; t < 6; t++) {
                                b = p[t].mipmaps;
                                for (let i = 0; i < b.length; i++) {
                                    const r = b[i];
                                    s.format !== ht ? null !== S ? x ? w && n.compressedTexSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i, 0, 0, r.width, r.height, S, r.data) : n.compressedTexImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i, B, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : x ? w && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i, 0, 0, r.width, r.height, S, v, r.data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i, B, r.width, r.height, 0, S, v, r.data)
                                }
                            }
                        } else {
                            if (b = s.mipmaps, x && y) {
                                b.length > 0 && U++;
                                const t = G(p[0]);
                                n.texStorage2D(e.TEXTURE_CUBE_MAP, U, B, t.width, t.height)
                            }
                            for (let t = 0; t < 6; t++)
                                if (d) {
                                    x ? w && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, 0, 0, p[t].width, p[t].height, S, v, p[t].data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, B, p[t].width, p[t].height, 0, S, v, p[t].data);
                                    for (let i = 0; i < b.length; i++) {
                                        const r = b[i].image[t].image;
                                        x ? w && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, 0, 0, r.width, r.height, S, v, r.data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, B, r.width, r.height, 0, S, v, r.data)
                                    }
                                } else {
                                    x ? w && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, 0, 0, S, v, p[t]) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, 0, B, S, v, p[t]);
                                    for (let i = 0; i < b.length; i++) {
                                        const r = b[i];
                                        x ? w && n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, 0, 0, S, v, r.image[t]) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + t, i + 1, B, S, v, r.image[t])
                                    }
                                }
                        }
                        f(s) && m(e.TEXTURE_CUBE_MAP), A.__version = c.version, s.onUpdate && s.onUpdate(s)
                    }
                    t.__version = s.version
                }(a, t, s) : n.bindTexture(e.TEXTURE_CUBE_MAP, a.__webglTexture, e.TEXTURE0 + s)
            }, this.rebindTextures = function(t, n, r) {
                const o = i.get(t);
                void 0 !== n && R(o.__webglFramebuffer, t, t.texture, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, 0), void 0 !== r && F(t)
            }, this.setupRenderTarget = function(t) {
                const r = t.texture,
                    a = i.get(t),
                    l = i.get(r);
                t.addEventListener("dispose", S);
                const c = t.textures,
                    A = !0 === t.isWebGLCubeRenderTarget,
                    h = c.length > 1;
                if (h || (void 0 === l.__webglTexture && (l.__webglTexture = e.createTexture()), l.__version = r.version, s.memory.textures++), A) {
                    a.__webglFramebuffer = [];
                    for (let t = 0; t < 6; t++)
                        if (r.mipmaps && r.mipmaps.length > 0) {
                            a.__webglFramebuffer[t] = [];
                            for (let n = 0; n < r.mipmaps.length; n++) a.__webglFramebuffer[t][n] = e.createFramebuffer()
                        } else a.__webglFramebuffer[t] = e.createFramebuffer()
                } else {
                    if (r.mipmaps && r.mipmaps.length > 0) {
                        a.__webglFramebuffer = [];
                        for (let t = 0; t < r.mipmaps.length; t++) a.__webglFramebuffer[t] = e.createFramebuffer()
                    } else a.__webglFramebuffer = e.createFramebuffer();
                    if (h)
                        for (let t = 0, n = c.length; t < n; t++) {
                            const n = i.get(c[t]);
                            void 0 === n.__webglTexture && (n.__webglTexture = e.createTexture(), s.memory.textures++)
                        }
                    if (t.samples > 0 && !1 === K(t)) {
                        a.__webglMultisampledFramebuffer = e.createFramebuffer(), a.__webglColorRenderbuffer = [], n.bindFramebuffer(e.FRAMEBUFFER, a.__webglMultisampledFramebuffer);
                        for (let n = 0; n < c.length; n++) {
                            const i = c[n];
                            a.__webglColorRenderbuffer[n] = e.createRenderbuffer(), e.bindRenderbuffer(e.RENDERBUFFER, a.__webglColorRenderbuffer[n]);
                            const r = o.convert(i.format, i.colorSpace),
                                s = o.convert(i.type),
                                l = E(i.internalFormat, r, s, i.colorSpace, !0 === t.isXRRenderTarget),
                                A = L(t);
                            e.renderbufferStorageMultisample(e.RENDERBUFFER, A, l, t.width, t.height), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + n, e.RENDERBUFFER, a.__webglColorRenderbuffer[n])
                        }
                        e.bindRenderbuffer(e.RENDERBUFFER, null), t.depthBuffer && (a.__webglDepthRenderbuffer = e.createRenderbuffer(), T(a.__webglDepthRenderbuffer, t, !0)), n.bindFramebuffer(e.FRAMEBUFFER, null)
                    }
                }
                if (A) {
                    n.bindTexture(e.TEXTURE_CUBE_MAP, l.__webglTexture), Q(e.TEXTURE_CUBE_MAP, r);
                    for (let n = 0; n < 6; n++)
                        if (r.mipmaps && r.mipmaps.length > 0)
                            for (let i = 0; i < r.mipmaps.length; i++) R(a.__webglFramebuffer[n][i], t, r, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + n, i);
                        else R(a.__webglFramebuffer[n], t, r, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + n, 0);
                    f(r) && m(e.TEXTURE_CUBE_MAP), n.unbindTexture()
                } else if (h) {
                    for (let r = 0, o = c.length; r < o; r++) {
                        const o = c[r],
                            s = i.get(o);
                        n.bindTexture(e.TEXTURE_2D, s.__webglTexture), Q(e.TEXTURE_2D, o), R(a.__webglFramebuffer, t, o, e.COLOR_ATTACHMENT0 + r, e.TEXTURE_2D, 0), f(o) && m(e.TEXTURE_2D)
                    }
                    n.unbindTexture()
                } else {
                    let i = e.TEXTURE_2D;
                    if ((t.isWebGL3DRenderTarget || t.isWebGLArrayRenderTarget) && (i = t.isWebGL3DRenderTarget ? e.TEXTURE_3D : e.TEXTURE_2D_ARRAY), n.bindTexture(i, l.__webglTexture), Q(i, r), r.mipmaps && r.mipmaps.length > 0)
                        for (let n = 0; n < r.mipmaps.length; n++) R(a.__webglFramebuffer[n], t, r, e.COLOR_ATTACHMENT0, i, n);
                    else R(a.__webglFramebuffer, t, r, e.COLOR_ATTACHMENT0, i, 0);
                    f(r) && m(i), n.unbindTexture()
                }
                t.depthBuffer && F(t)
            }, this.updateRenderTargetMipmap = function(t) {
                const r = t.textures;
                for (let o = 0, s = r.length; o < s; o++) {
                    const s = r[o];
                    if (f(s)) {
                        const r = t.isWebGLCubeRenderTarget ? e.TEXTURE_CUBE_MAP : e.TEXTURE_2D,
                            o = i.get(s).__webglTexture;
                        n.bindTexture(r, o), m(r), n.unbindTexture()
                    }
                }
            }, this.updateMultisampleRenderTarget = function(t) {
                if (t.samples > 0)
                    if (!1 === K(t)) {
                        const r = t.textures,
                            o = t.width,
                            s = t.height;
                        let a = e.COLOR_BUFFER_BIT;
                        const c = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT,
                            A = i.get(t),
                            h = r.length > 1;
                        if (h)
                            for (let t = 0; t < r.length; t++) n.bindFramebuffer(e.FRAMEBUFFER, A.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.RENDERBUFFER, null), n.bindFramebuffer(e.FRAMEBUFFER, A.__webglFramebuffer), e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.TEXTURE_2D, null, 0);
                        n.bindFramebuffer(e.READ_FRAMEBUFFER, A.__webglMultisampledFramebuffer), n.bindFramebuffer(e.DRAW_FRAMEBUFFER, A.__webglFramebuffer);
                        for (let n = 0; n < r.length; n++) {
                            if (t.resolveDepthBuffer && (t.depthBuffer && (a |= e.DEPTH_BUFFER_BIT), t.stencilBuffer && t.resolveStencilBuffer && (a |= e.STENCIL_BUFFER_BIT)), h) {
                                e.framebufferRenderbuffer(e.READ_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, A.__webglColorRenderbuffer[n]);
                                const t = i.get(r[n]).__webglTexture;
                                e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, t, 0)
                            }
                            e.blitFramebuffer(0, 0, o, s, 0, 0, o, s, a, e.NEAREST), !0 === l && (D.length = 0, k.length = 0, D.push(e.COLOR_ATTACHMENT0 + n), t.depthBuffer && !1 === t.resolveDepthBuffer && (D.push(c), k.push(c), e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, k)), e.invalidateFramebuffer(e.READ_FRAMEBUFFER, D))
                        }
                        if (n.bindFramebuffer(e.READ_FRAMEBUFFER, null), n.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), h)
                            for (let t = 0; t < r.length; t++) {
                                n.bindFramebuffer(e.FRAMEBUFFER, A.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.RENDERBUFFER, A.__webglColorRenderbuffer[t]);
                                const o = i.get(r[t]).__webglTexture;
                                n.bindFramebuffer(e.FRAMEBUFFER, A.__webglFramebuffer), e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + t, e.TEXTURE_2D, o, 0)
                            }
                        n.bindFramebuffer(e.DRAW_FRAMEBUFFER, A.__webglMultisampledFramebuffer)
                    } else if (t.depthBuffer && !1 === t.resolveDepthBuffer && l) {
                    const n = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT;
                    e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, [n])
                }
            }, this.setupDepthRenderbuffer = F, this.setupFrameBufferTexture = R, this.useMultisampledRTT = K
        }

        function Wa(e, t) {
            return {
                convert: function(n, i = Vt) {
                    let r;
                    const o = yn.getTransfer(i);
                    if (n === ot) return e.UNSIGNED_BYTE;
                    if (1017 === n) return e.UNSIGNED_SHORT_4_4_4_4;
                    if (1018 === n) return e.UNSIGNED_SHORT_5_5_5_1;
                    if (35902 === n) return e.UNSIGNED_INT_5_9_9_9_REV;
                    if (1010 === n) return e.BYTE;
                    if (1011 === n) return e.SHORT;
                    if (1012 === n) return e.UNSIGNED_SHORT;
                    if (n === st) return e.INT;
                    if (n === at) return e.UNSIGNED_INT;
                    if (n === lt) return e.FLOAT;
                    if (n === ct) return e.HALF_FLOAT;
                    if (1021 === n) return e.ALPHA;
                    if (1022 === n) return e.RGB;
                    if (n === ht) return e.RGBA;
                    if (n === ut) return e.LUMINANCE;
                    if (1025 === n) return e.LUMINANCE_ALPHA;
                    if (n === dt) return e.DEPTH_COMPONENT;
                    if (n === pt) return e.DEPTH_STENCIL;
                    if (n === gt) return e.RED;
                    if (1029 === n) return e.RED_INTEGER;
                    if (n === ft) return e.RG;
                    if (1031 === n) return e.RG_INTEGER;
                    if (1033 === n) return e.RGBA_INTEGER;
                    if (n === mt || n === Et || n === Ct || n === It)
                        if (o === Yt) {
                            if (r = t.get("WEBGL_compressed_texture_s3tc_srgb"), null === r) return null;
                            if (n === mt) return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                            if (n === Et) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                            if (n === Ct) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                            if (n === It) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                        } else {
                            if (r = t.get("WEBGL_compressed_texture_s3tc"), null === r) return null;
                            if (n === mt) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
                            if (n === Et) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                            if (n === Ct) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                            if (n === It) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT
                        }
                    if (n === St || 35841 === n || n === vt || 35843 === n) {
                        if (r = t.get("WEBGL_compressed_texture_pvrtc"), null === r) return null;
                        if (n === St) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (35841 === n) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (n === vt) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (35843 === n) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    }
                    if (n === Bt || n === xt || n === yt) {
                        if (r = t.get("WEBGL_compressed_texture_etc"), null === r) return null;
                        if (n === Bt || n === xt) return o === Yt ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
                        if (n === yt) return o === Yt ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC
                    }
                    if (n === wt || 37809 === n || 37810 === n || 37811 === n || n === bt || 37813 === n || 37814 === n || 37815 === n || 37816 === n || 37817 === n || 37818 === n || 37819 === n || 37820 === n || 37821 === n) {
                        if (r = t.get("WEBGL_compressed_texture_astc"), null === r) return null;
                        if (n === wt) return o === Yt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
                        if (37809 === n) return o === Yt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
                        if (37810 === n) return o === Yt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
                        if (37811 === n) return o === Yt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
                        if (n === bt) return o === Yt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
                        if (37813 === n) return o === Yt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
                        if (37814 === n) return o === Yt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
                        if (37815 === n) return o === Yt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
                        if (37816 === n) return o === Yt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
                        if (37817 === n) return o === Yt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
                        if (37818 === n) return o === Yt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
                        if (37819 === n) return o === Yt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
                        if (37820 === n) return o === Yt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
                        if (37821 === n) return o === Yt ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR
                    }
                    if (n === Qt || 36494 === n || 36495 === n) {
                        if (r = t.get("EXT_texture_compression_bptc"), null === r) return null;
                        if (n === Qt) return o === Yt ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                        if (36494 === n) return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                        if (36495 === n) return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
                    }
                    if (36283 === n || 36284 === n || 36285 === n || 36286 === n) {
                        if (r = t.get("EXT_texture_compression_rgtc"), null === r) return null;
                        if (n === Qt) return r.COMPRESSED_RED_RGTC1_EXT;
                        if (36284 === n) return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                        if (36285 === n) return r.COMPRESSED_RED_GREEN_RGTC2_EXT;
                        if (36286 === n) return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
                    }
                    return n === At ? e.UNSIGNED_INT_24_8 : void 0 !== e[n] ? e[n] : null
                }
            }
        }
        class za extends oo {
            constructor(e = []) {
                super(), this.isArrayCamera = !0, this.cameras = e
            }
        }
        class Xa extends qi {
            constructor() {
                super(), this.isGroup = !0, this.type = "Group"
            }
        }
        const Za = {
            type: "move"
        };
        class _a {
            constructor() {
                this._targetRay = null, this._grip = null, this._hand = null
            }
            getHandSpace() {
                return null === this._hand && (this._hand = new Xa, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
                    pinching: !1
                }), this._hand
            }
            getTargetRaySpace() {
                return null === this._targetRay && (this._targetRay = new Xa, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new On, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new On), this._targetRay
            }
            getGripSpace() {
                return null === this._grip && (this._grip = new Xa, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new On, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new On), this._grip
            }
            dispatchEvent(e) {
                return null !== this._targetRay && this._targetRay.dispatchEvent(e), null !== this._grip && this._grip.dispatchEvent(e), null !== this._hand && this._hand.dispatchEvent(e), this
            }
            connect(e) {
                if (e && e.hand) {
                    const t = this._hand;
                    if (t)
                        for (const n of e.hand.values()) this._getHandJoint(t, n)
                }
                return this.dispatchEvent({
                    type: "connected",
                    data: e
                }), this
            }
            disconnect(e) {
                return this.dispatchEvent({
                    type: "disconnected",
                    data: e
                }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
            }
            update(e, t, n) {
                let i = null,
                    r = null,
                    o = null;
                const s = this._targetRay,
                    a = this._grip,
                    l = this._hand;
                if (e && "visible-blurred" !== t.session.visibilityState) {
                    if (l && e.hand) {
                        o = !0;
                        for (const i of e.hand.values()) {
                            const e = t.getJointPose(i, n),
                                r = this._getHandJoint(l, i);
                            null !== e && (r.matrix.fromArray(e.transform.matrix), r.matrix.decompose(r.position, r.rotation, r.scale), r.matrixWorldNeedsUpdate = !0, r.jointRadius = e.radius), r.visible = null !== e
                        }
                        const i = l.joints["index-finger-tip"],
                            r = l.joints["thumb-tip"],
                            s = i.position.distanceTo(r.position),
                            a = .02,
                            c = .005;
                        l.inputState.pinching && s > a + c ? (l.inputState.pinching = !1, this.dispatchEvent({
                            type: "pinchend",
                            handedness: e.handedness,
                            target: this
                        })) : !l.inputState.pinching && s <= a - c && (l.inputState.pinching = !0, this.dispatchEvent({
                            type: "pinchstart",
                            handedness: e.handedness,
                            target: this
                        }))
                    } else null !== a && e.gripSpace && (r = t.getPose(e.gripSpace, n), null !== r && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), a.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1, r.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1));
                    null !== s && (i = t.getPose(e.targetRaySpace, n), null === i && null !== r && (i = r), null !== i && (s.matrix.fromArray(i.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale), s.matrixWorldNeedsUpdate = !0, i.linearVelocity ? (s.hasLinearVelocity = !0, s.linearVelocity.copy(i.linearVelocity)) : s.hasLinearVelocity = !1, i.angularVelocity ? (s.hasAngularVelocity = !0, s.angularVelocity.copy(i.angularVelocity)) : s.hasAngularVelocity = !1, this.dispatchEvent(Za)))
                }
                return null !== s && (s.visible = null !== i), null !== a && (a.visible = null !== r), null !== l && (l.visible = null !== o), this
            }
            _getHandJoint(e, t) {
                if (void 0 === e.joints[t.jointName]) {
                    const n = new Xa;
                    n.matrixAutoUpdate = !1, n.visible = !1, e.joints[t.jointName] = n, e.add(n)
                }
                return e.joints[t.jointName]
            }
        }
        class $a {
            constructor() {
                this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0
            }
            init(e, t, n) {
                if (null === this.texture) {
                    const i = new Dn;
                    e.properties.get(i).__webglTexture = t.texture, t.depthNear == n.depthNear && t.depthFar == n.depthFar || (this.depthNear = t.depthNear, this.depthFar = t.depthFar), this.texture = i
                }
            }
            render(e, t) {
                if (null !== this.texture) {
                    if (null === this.mesh) {
                        const e = t.cameras[0].viewport,
                            n = new eo({
                                vertexShader: "\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}",
                                fragmentShader: "\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}",
                                uniforms: {
                                    depthColor: {
                                        value: this.texture
                                    },
                                    depthWidth: {
                                        value: e.z
                                    },
                                    depthHeight: {
                                        value: e.w
                                    }
                                }
                            });
                        this.mesh = new Jr(new Io(20, 20), n)
                    }
                    e.render(this.mesh, t)
                }
            }
            reset() {
                this.texture = null, this.mesh = null
            }
        }
        class el extends en {
            constructor(e, t) {
                super();
                const n = this;
                let i = null,
                    r = 1,
                    o = null,
                    s = "local-floor",
                    a = 1,
                    l = null,
                    c = null,
                    A = null,
                    h = null,
                    u = null,
                    d = null;
                const p = new $a,
                    g = t.getContextAttributes();
                let f = null,
                    m = null;
                const E = [],
                    C = [],
                    I = new dn;
                let S = null;
                const v = new oo;
                v.layers.enable(1), v.viewport = new kn;
                const B = new oo;
                B.layers.enable(2), B.viewport = new kn;
                const x = [v, B],
                    y = new za;
                y.layers.enable(1), y.layers.enable(2);
                let w = null,
                    b = null;

                function Q(e) {
                    const t = C.indexOf(e.inputSource);
                    if (-1 === t) return;
                    const n = E[t];
                    void 0 !== n && (n.update(e.inputSource, e.frame, l || o), n.dispatchEvent({
                        type: e.type,
                        data: e.inputSource
                    }))
                }

                function U() {
                    i.removeEventListener("select", Q), i.removeEventListener("selectstart", Q), i.removeEventListener("selectend", Q), i.removeEventListener("squeeze", Q), i.removeEventListener("squeezestart", Q), i.removeEventListener("squeezeend", Q), i.removeEventListener("end", U), i.removeEventListener("inputsourceschange", M);
                    for (let e = 0; e < E.length; e++) {
                        const t = C[e];
                        null !== t && (C[e] = null, E[e].disconnect(t))
                    }
                    w = null, b = null, p.reset(), e.setRenderTarget(f), u = null, h = null, A = null, i = null, m = null, k.stop(), n.isPresenting = !1, e.setPixelRatio(S), e.setSize(I.width, I.height, !1), n.dispatchEvent({
                        type: "sessionend"
                    })
                }

                function M(e) {
                    for (let t = 0; t < e.removed.length; t++) {
                        const n = e.removed[t],
                            i = C.indexOf(n);
                        i >= 0 && (C[i] = null, E[i].disconnect(n))
                    }
                    for (let t = 0; t < e.added.length; t++) {
                        const n = e.added[t];
                        let i = C.indexOf(n);
                        if (-1 === i) {
                            for (let e = 0; e < E.length; e++) {
                                if (e >= C.length) {
                                    C.push(n), i = e;
                                    break
                                }
                                if (null === C[e]) {
                                    C[e] = n, i = e;
                                    break
                                }
                            }
                            if (-1 === i) break
                        }
                        const r = E[i];
                        r && r.connect(n)
                    }
                }
                this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(e) {
                    let t = E[e];
                    return void 0 === t && (t = new _a, E[e] = t), t.getTargetRaySpace()
                }, this.getControllerGrip = function(e) {
                    let t = E[e];
                    return void 0 === t && (t = new _a, E[e] = t), t.getGripSpace()
                }, this.getHand = function(e) {
                    let t = E[e];
                    return void 0 === t && (t = new _a, E[e] = t), t.getHandSpace()
                }, this.setFramebufferScaleFactor = function(e) {
                    r = e, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                }, this.setReferenceSpaceType = function(e) {
                    s = e, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                }, this.getReferenceSpace = function() {
                    return l || o
                }, this.setReferenceSpace = function(e) {
                    l = e
                }, this.getBaseLayer = function() {
                    return null !== h ? h : u
                }, this.getBinding = function() {
                    return A
                }, this.getFrame = function() {
                    return d
                }, this.getSession = function() {
                    return i
                }, this.setSession = async function(c) {
                    if (i = c, null !== i) {
                        if (f = e.getRenderTarget(), i.addEventListener("select", Q), i.addEventListener("selectstart", Q), i.addEventListener("selectend", Q), i.addEventListener("squeeze", Q), i.addEventListener("squeezestart", Q), i.addEventListener("squeezeend", Q), i.addEventListener("end", U), i.addEventListener("inputsourceschange", M), !0 !== g.xrCompatible && await t.makeXRCompatible(), S = e.getPixelRatio(), e.getSize(I), void 0 === i.renderState.layers) {
                            const n = {
                                antialias: g.antialias,
                                alpha: !0,
                                depth: g.depth,
                                stencil: g.stencil,
                                framebufferScaleFactor: r
                            };
                            u = new XRWebGLLayer(i, t, n), i.updateRenderState({
                                baseLayer: u
                            }), e.setPixelRatio(1), e.setSize(u.framebufferWidth, u.framebufferHeight, !1), m = new Kn(u.framebufferWidth, u.framebufferHeight, {
                                format: ht,
                                type: ot,
                                colorSpace: e.outputColorSpace,
                                stencilBuffer: g.stencil
                            })
                        } else {
                            let n = null,
                                o = null,
                                s = null;
                            g.depth && (s = g.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, n = g.stencil ? pt : dt, o = g.stencil ? At : at);
                            const a = {
                                colorFormat: t.RGBA8,
                                depthFormat: s,
                                scaleFactor: r
                            };
                            A = new XRWebGLBinding(i, t), h = A.createProjectionLayer(a), i.updateRenderState({
                                layers: [h]
                            }), e.setPixelRatio(1), e.setSize(h.textureWidth, h.textureHeight, !1), m = new Kn(h.textureWidth, h.textureHeight, {
                                format: ht,
                                type: ot,
                                depthTexture: new rs(h.textureWidth, h.textureHeight, o, void 0, void 0, void 0, void 0, void 0, void 0, n),
                                stencilBuffer: g.stencil,
                                colorSpace: e.outputColorSpace,
                                samples: g.antialias ? 4 : 0,
                                resolveDepthBuffer: !1 === h.ignoreDepthValues
                            })
                        }
                        m.isXRRenderTarget = !0, this.setFoveation(a), l = null, o = await i.requestReferenceSpace(s), k.setContext(i), k.start(), n.isPresenting = !0, n.dispatchEvent({
                            type: "sessionstart"
                        })
                    }
                }, this.getEnvironmentBlendMode = function() {
                    if (null !== i) return i.environmentBlendMode
                };
                const R = new On,
                    T = new On;

                function F(e, t) {
                    null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.copy(e.matrixWorld).invert()
                }
                this.updateCamera = function(e) {
                    if (null === i) return;
                    null !== p.texture && (e.near = p.depthNear, e.far = p.depthFar), y.near = B.near = v.near = e.near, y.far = B.far = v.far = e.far, w === y.near && b === y.far || (i.updateRenderState({
                        depthNear: y.near,
                        depthFar: y.far
                    }), w = y.near, b = y.far, v.near = w, v.far = b, B.near = w, B.far = b, v.updateProjectionMatrix(), B.updateProjectionMatrix(), e.updateProjectionMatrix());
                    const t = e.parent,
                        n = y.cameras;
                    F(y, t);
                    for (let e = 0; e < n.length; e++) F(n[e], t);
                    2 === n.length ? function(e, t, n) {
                            R.setFromMatrixPosition(t.matrixWorld), T.setFromMatrixPosition(n.matrixWorld);
                            const i = R.distanceTo(T),
                                r = t.projectionMatrix.elements,
                                o = n.projectionMatrix.elements,
                                s = r[14] / (r[10] - 1),
                                a = r[14] / (r[10] + 1),
                                l = (r[9] + 1) / r[5],
                                c = (r[9] - 1) / r[5],
                                A = (r[8] - 1) / r[0],
                                h = (o[8] + 1) / o[0],
                                u = s * A,
                                d = s * h,
                                p = i / (-A + h),
                                g = p * -A;
                            t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(g), e.translateZ(p), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.copy(e.matrixWorld).invert();
                            const f = s + p,
                                m = a + p,
                                E = u - g,
                                C = d + (i - g),
                                I = l * a / m * f,
                                S = c * a / m * f;
                            e.projectionMatrix.makePerspective(E, C, I, S, f, m), e.projectionMatrixInverse.copy(e.projectionMatrix).invert()
                        }(y, v, B) : y.projectionMatrix.copy(v.projectionMatrix),
                        function(e, t, n) {
                            null === n ? e.matrix.copy(t.matrixWorld) : (e.matrix.copy(n.matrixWorld), e.matrix.invert(), e.matrix.multiply(t.matrixWorld));
                            e.matrix.decompose(e.position, e.quaternion, e.scale), e.updateMatrixWorld(!0), e.projectionMatrix.copy(t.projectionMatrix), e.projectionMatrixInverse.copy(t.projectionMatrixInverse), e.isPerspectiveCamera && (e.fov = 2 * on * Math.atan(1 / e.projectionMatrix.elements[5]), e.zoom = 1)
                        }(e, y, t)
                }, this.getCamera = function() {
                    return y
                }, this.getFoveation = function() {
                    if (null !== h || null !== u) return a
                }, this.setFoveation = function(e) {
                    a = e, null !== h && (h.fixedFoveation = e), null !== u && void 0 !== u.fixedFoveation && (u.fixedFoveation = e)
                }, this.hasDepthSensing = function() {
                    return null !== p.texture
                };
                let D = null;
                const k = new Eo;
                k.setAnimationLoop((function(t, r) {
                    if (c = r.getViewerPose(l || o), d = r, null !== c) {
                        const t = c.views;
                        null !== u && (e.setRenderTargetFramebuffer(m, u.framebuffer), e.setRenderTarget(m));
                        let n = !1;
                        t.length !== y.cameras.length && (y.cameras.length = 0, n = !0);
                        for (let i = 0; i < t.length; i++) {
                            const r = t[i];
                            let o = null;
                            if (null !== u) o = u.getViewport(r);
                            else {
                                const t = A.getViewSubImage(h, r);
                                o = t.viewport, 0 === i && (e.setRenderTargetTextures(m, t.colorTexture, h.ignoreDepthValues ? void 0 : t.depthStencilTexture), e.setRenderTarget(m))
                            }
                            let s = x[i];
                            void 0 === s && (s = new oo, s.layers.enable(i), s.viewport = new kn, x[i] = s), s.matrix.fromArray(r.transform.matrix), s.matrix.decompose(s.position, s.quaternion, s.scale), s.projectionMatrix.fromArray(r.projectionMatrix), s.projectionMatrixInverse.copy(s.projectionMatrix).invert(), s.viewport.set(o.x, o.y, o.width, o.height), 0 === i && (y.matrix.copy(s.matrix), y.matrix.decompose(y.position, y.quaternion, y.scale)), !0 === n && y.cameras.push(s)
                        }
                        const r = i.enabledFeatures;
                        if (r && r.includes("depth-sensing")) {
                            const n = A.getDepthInformation(t[0]);
                            n && n.isValid && n.texture && p.init(e, n, i.renderState)
                        }
                    }
                    for (let e = 0; e < E.length; e++) {
                        const t = C[e],
                            n = E[e];
                        null !== t && void 0 !== n && n.update(t, r, l || o)
                    }
                    p.render(e, y), D && D(t, r), r.detectedPlanes && n.dispatchEvent({
                        type: "planesdetected",
                        data: r
                    }), d = null
                })), this.setAnimationLoop = function(e) {
                    D = e
                }, this.dispose = function() {}
            }
        }
        const tl = new bi,
            nl = new mi;

        function il(e, t) {
            function n(e, t) {
                !0 === e.matrixAutoUpdate && e.updateMatrix(), t.value.copy(e.matrix)
            }

            function i(i, r) {
                i.opacity.value = r.opacity, r.color && i.diffuse.value.copy(r.color), r.emissive && i.emissive.value.copy(r.emissive).multiplyScalar(r.emissiveIntensity), r.map && (i.map.value = r.map, n(r.map, i.mapTransform)), r.alphaMap && (i.alphaMap.value = r.alphaMap, n(r.alphaMap, i.alphaMapTransform)), r.bumpMap && (i.bumpMap.value = r.bumpMap, n(r.bumpMap, i.bumpMapTransform), i.bumpScale.value = r.bumpScale, r.side === Me && (i.bumpScale.value *= -1)), r.normalMap && (i.normalMap.value = r.normalMap, n(r.normalMap, i.normalMapTransform), i.normalScale.value.copy(r.normalScale), r.side === Me && i.normalScale.value.negate()), r.displacementMap && (i.displacementMap.value = r.displacementMap, n(r.displacementMap, i.displacementMapTransform), i.displacementScale.value = r.displacementScale, i.displacementBias.value = r.displacementBias), r.emissiveMap && (i.emissiveMap.value = r.emissiveMap, n(r.emissiveMap, i.emissiveMapTransform)), r.specularMap && (i.specularMap.value = r.specularMap, n(r.specularMap, i.specularMapTransform)), r.alphaTest > 0 && (i.alphaTest.value = r.alphaTest);
                const o = t.get(r),
                    s = o.envMap,
                    a = o.envMapRotation;
                if (s && (i.envMap.value = s, tl.copy(a), tl.x *= -1, tl.y *= -1, tl.z *= -1, s.isCubeTexture && !1 === s.isRenderTargetTexture && (tl.y *= -1, tl.z *= -1), i.envMapRotation.value.setFromMatrix4(nl.makeRotationFromEuler(tl)), i.flipEnvMap.value = s.isCubeTexture && !1 === s.isRenderTargetTexture ? -1 : 1, i.reflectivity.value = r.reflectivity, i.ior.value = r.ior, i.refractionRatio.value = r.refractionRatio), r.lightMap) {
                    i.lightMap.value = r.lightMap;
                    const t = !0 === e._useLegacyLights ? Math.PI : 1;
                    i.lightMapIntensity.value = r.lightMapIntensity * t, n(r.lightMap, i.lightMapTransform)
                }
                r.aoMap && (i.aoMap.value = r.aoMap, i.aoMapIntensity.value = r.aoMapIntensity, n(r.aoMap, i.aoMapTransform))
            }
            return {
                refreshFogUniforms: function(t, n) {
                    n.color.getRGB(t.fogColor.value, _r(e)), n.isFog ? (t.fogNear.value = n.near, t.fogFar.value = n.far) : n.isFogExp2 && (t.fogDensity.value = n.density)
                },
                refreshMaterialUniforms: function(e, r, o, s, a) {
                    r.isMeshBasicMaterial || r.isMeshLambertMaterial ? i(e, r) : r.isMeshToonMaterial ? (i(e, r), function(e, t) {
                        t.gradientMap && (e.gradientMap.value = t.gradientMap)
                    }(e, r)) : r.isMeshPhongMaterial ? (i(e, r), function(e, t) {
                        e.specular.value.copy(t.specular), e.shininess.value = Math.max(t.shininess, 1e-4)
                    }(e, r)) : r.isMeshStandardMaterial ? (i(e, r), function(e, t) {
                        e.metalness.value = t.metalness, t.metalnessMap && (e.metalnessMap.value = t.metalnessMap, n(t.metalnessMap, e.metalnessMapTransform));
                        e.roughness.value = t.roughness, t.roughnessMap && (e.roughnessMap.value = t.roughnessMap, n(t.roughnessMap, e.roughnessMapTransform));
                        t.envMap && (e.envMapIntensity.value = t.envMapIntensity)
                    }(e, r), r.isMeshPhysicalMaterial && function(e, t, i) {
                        e.ior.value = t.ior, t.sheen > 0 && (e.sheenColor.value.copy(t.sheenColor).multiplyScalar(t.sheen), e.sheenRoughness.value = t.sheenRoughness, t.sheenColorMap && (e.sheenColorMap.value = t.sheenColorMap, n(t.sheenColorMap, e.sheenColorMapTransform)), t.sheenRoughnessMap && (e.sheenRoughnessMap.value = t.sheenRoughnessMap, n(t.sheenRoughnessMap, e.sheenRoughnessMapTransform)));
                        t.clearcoat > 0 && (e.clearcoat.value = t.clearcoat, e.clearcoatRoughness.value = t.clearcoatRoughness, t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap, n(t.clearcoatMap, e.clearcoatMapTransform)), t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap, n(t.clearcoatRoughnessMap, e.clearcoatRoughnessMapTransform)), t.clearcoatNormalMap && (e.clearcoatNormalMap.value = t.clearcoatNormalMap, n(t.clearcoatNormalMap, e.clearcoatNormalMapTransform), e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale), t.side === Me && e.clearcoatNormalScale.value.negate()));
                        t.dispersion > 0 && (e.dispersion.value = t.dispersion);
                        t.iridescence > 0 && (e.iridescence.value = t.iridescence, e.iridescenceIOR.value = t.iridescenceIOR, e.iridescenceThicknessMinimum.value = t.iridescenceThicknessRange[0], e.iridescenceThicknessMaximum.value = t.iridescenceThicknessRange[1], t.iridescenceMap && (e.iridescenceMap.value = t.iridescenceMap, n(t.iridescenceMap, e.iridescenceMapTransform)), t.iridescenceThicknessMap && (e.iridescenceThicknessMap.value = t.iridescenceThicknessMap, n(t.iridescenceThicknessMap, e.iridescenceThicknessMapTransform)));
                        t.transmission > 0 && (e.transmission.value = t.transmission, e.transmissionSamplerMap.value = i.texture, e.transmissionSamplerSize.value.set(i.width, i.height), t.transmissionMap && (e.transmissionMap.value = t.transmissionMap, n(t.transmissionMap, e.transmissionMapTransform)), e.thickness.value = t.thickness, t.thicknessMap && (e.thicknessMap.value = t.thicknessMap, n(t.thicknessMap, e.thicknessMapTransform)), e.attenuationDistance.value = t.attenuationDistance, e.attenuationColor.value.copy(t.attenuationColor));
                        t.anisotropy > 0 && (e.anisotropyVector.value.set(t.anisotropy * Math.cos(t.anisotropyRotation), t.anisotropy * Math.sin(t.anisotropyRotation)), t.anisotropyMap && (e.anisotropyMap.value = t.anisotropyMap, n(t.anisotropyMap, e.anisotropyMapTransform)));
                        e.specularIntensity.value = t.specularIntensity, e.specularColor.value.copy(t.specularColor), t.specularColorMap && (e.specularColorMap.value = t.specularColorMap, n(t.specularColorMap, e.specularColorMapTransform));
                        t.specularIntensityMap && (e.specularIntensityMap.value = t.specularIntensityMap, n(t.specularIntensityMap, e.specularIntensityMapTransform))
                    }(e, r, a)) : r.isMeshMatcapMaterial ? (i(e, r), function(e, t) {
                        t.matcap && (e.matcap.value = t.matcap)
                    }(e, r)) : r.isMeshDepthMaterial ? i(e, r) : r.isMeshDistanceMaterial ? (i(e, r), function(e, n) {
                        const i = t.get(n).light;
                        e.referencePosition.value.setFromMatrixPosition(i.matrixWorld), e.nearDistance.value = i.shadow.camera.near, e.farDistance.value = i.shadow.camera.far
                    }(e, r)) : r.isMeshNormalMaterial ? i(e, r) : r.isLineBasicMaterial ? (function(e, t) {
                        e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, t.map && (e.map.value = t.map, n(t.map, e.mapTransform))
                    }(e, r), r.isLineDashedMaterial && function(e, t) {
                        e.dashSize.value = t.dashSize, e.totalSize.value = t.dashSize + t.gapSize, e.scale.value = t.scale
                    }(e, r)) : r.isPointsMaterial ? function(e, t, i, r) {
                        e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.size.value = t.size * i, e.scale.value = .5 * r, t.map && (e.map.value = t.map, n(t.map, e.uvTransform));
                        t.alphaMap && (e.alphaMap.value = t.alphaMap, n(t.alphaMap, e.alphaMapTransform));
                        t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest)
                    }(e, r, o, s) : r.isSpriteMaterial ? function(e, t) {
                        e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.rotation.value = t.rotation, t.map && (e.map.value = t.map, n(t.map, e.mapTransform));
                        t.alphaMap && (e.alphaMap.value = t.alphaMap, n(t.alphaMap, e.alphaMapTransform));
                        t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest)
                    }(e, r) : r.isShadowMaterial ? (e.color.value.copy(r.color), e.opacity.value = r.opacity) : r.isShaderMaterial && (r.uniformsNeedUpdate = !1)
                }
            }
        }

        function rl(e, t, n, i) {
            let r = {},
                o = {},
                s = [];
            const a = e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS);

            function l(e, t, n, i) {
                const r = e.value,
                    o = t + "_" + n;
                if (void 0 === i[o]) return i[o] = "number" == typeof r || "boolean" == typeof r ? r : r.clone(), !0; {
                    const e = i[o];
                    if ("number" == typeof r || "boolean" == typeof r) {
                        if (e !== r) return i[o] = r, !0
                    } else if (!1 === e.equals(r)) return e.copy(r), !0
                }
                return !1
            }

            function c(e) {
                const t = {
                    boundary: 0,
                    storage: 0
                };
                return "number" == typeof e || "boolean" == typeof e ? (t.boundary = 4, t.storage = 4) : e.isVector2 ? (t.boundary = 8, t.storage = 8) : e.isVector3 || e.isColor ? (t.boundary = 16, t.storage = 12) : e.isVector4 ? (t.boundary = 16, t.storage = 16) : e.isMatrix3 ? (t.boundary = 48, t.storage = 48) : e.isMatrix4 ? (t.boundary = 64, t.storage = 64) : e.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", e), t
            }

            function A(t) {
                const n = t.target;
                n.removeEventListener("dispose", A);
                const i = s.indexOf(n.__bindingPointIndex);
                s.splice(i, 1), e.deleteBuffer(r[n.id]), delete r[n.id], delete o[n.id]
            }
            return {
                bind: function(e, t) {
                    const n = t.program;
                    i.uniformBlockBinding(e, n)
                },
                update: function(n, h) {
                    let u = r[n.id];
                    void 0 === u && (! function(e) {
                        const t = e.uniforms;
                        let n = 0;
                        const i = 16;
                        for (let e = 0, r = t.length; e < r; e++) {
                            const r = Array.isArray(t[e]) ? t[e] : [t[e]];
                            for (let e = 0, t = r.length; e < t; e++) {
                                const t = r[e],
                                    o = Array.isArray(t.value) ? t.value : [t.value];
                                for (let e = 0, r = o.length; e < r; e++) {
                                    const r = c(o[e]),
                                        s = n % i;
                                    0 !== s && i - s < r.boundary && (n += i - s), t.__data = new Float32Array(r.storage / Float32Array.BYTES_PER_ELEMENT), t.__offset = n, n += r.storage
                                }
                            }
                        }
                        const r = n % i;
                        r > 0 && (n += i - r);
                        e.__size = n, e.__cache = {}
                    }(n), u = function(t) {
                        const n = function() {
                            for (let e = 0; e < a; e++)
                                if (-1 === s.indexOf(e)) return s.push(e), e;
                            return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0
                        }();
                        t.__bindingPointIndex = n;
                        const i = e.createBuffer(),
                            r = t.__size,
                            o = t.usage;
                        return e.bindBuffer(e.UNIFORM_BUFFER, i), e.bufferData(e.UNIFORM_BUFFER, r, o), e.bindBuffer(e.UNIFORM_BUFFER, null), e.bindBufferBase(e.UNIFORM_BUFFER, n, i), i
                    }(n), r[n.id] = u, n.addEventListener("dispose", A));
                    const d = h.program;
                    i.updateUBOMapping(n, d);
                    const p = t.render.frame;
                    o[n.id] !== p && (! function(t) {
                        const n = r[t.id],
                            i = t.uniforms,
                            o = t.__cache;
                        e.bindBuffer(e.UNIFORM_BUFFER, n);
                        for (let t = 0, n = i.length; t < n; t++) {
                            const n = Array.isArray(i[t]) ? i[t] : [i[t]];
                            for (let i = 0, r = n.length; i < r; i++) {
                                const r = n[i];
                                if (!0 === l(r, t, i, o)) {
                                    const t = r.__offset,
                                        n = Array.isArray(r.value) ? r.value : [r.value];
                                    let i = 0;
                                    for (let o = 0; o < n.length; o++) {
                                        const s = n[o],
                                            a = c(s);
                                        "number" == typeof s || "boolean" == typeof s ? (r.__data[0] = s, e.bufferSubData(e.UNIFORM_BUFFER, t + i, r.__data)) : s.isMatrix3 ? (r.__data[0] = s.elements[0], r.__data[1] = s.elements[1], r.__data[2] = s.elements[2], r.__data[3] = 0, r.__data[4] = s.elements[3], r.__data[5] = s.elements[4], r.__data[6] = s.elements[5], r.__data[7] = 0, r.__data[8] = s.elements[6], r.__data[9] = s.elements[7], r.__data[10] = s.elements[8], r.__data[11] = 0) : (s.toArray(r.__data, i), i += a.storage / Float32Array.BYTES_PER_ELEMENT)
                                    }
                                    e.bufferSubData(e.UNIFORM_BUFFER, t, r.__data)
                                }
                            }
                        }
                        e.bindBuffer(e.UNIFORM_BUFFER, null)
                    }(n), o[n.id] = p)
                },
                dispose: function() {
                    for (const t in r) e.deleteBuffer(r[t]);
                    s = [], r = {}, o = {}
                }
            }
        }
        class ol {
            constructor(e = {}) {
                const {
                    canvas: t = En(),
                    context: n = null,
                    depth: i = !0,
                    stencil: r = !1,
                    alpha: o = !1,
                    antialias: s = !1,
                    premultipliedAlpha: a = !0,
                    preserveDrawingBuffer: l = !1,
                    powerPreference: c = "default",
                    failIfMajorPerformanceCaveat: A = !1
                } = e;
                let h;
                if (this.isWebGLRenderer = !0, null !== n) {
                    if ("undefined" != typeof WebGLRenderingContext && n instanceof WebGLRenderingContext) throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
                    h = n.getContextAttributes().alpha
                } else h = o;
                const u = new Uint32Array(4),
                    d = new Int32Array(4);
                let p = null,
                    g = null;
                const f = [],
                    m = [];
                this.domElement = t, this.debug = {
                    checkShaderErrors: !0,
                    onShaderError: null
                }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = Ot, this._useLegacyLights = !1, this.toneMapping = Le, this.toneMappingExposure = 1;
                const E = this;
                let C = !1,
                    I = 0,
                    S = 0,
                    v = null,
                    B = -1,
                    x = null;
                const y = new kn,
                    w = new kn;
                let b = null;
                const Q = new sr(0);
                let U = 0,
                    M = t.width,
                    R = t.height,
                    T = 1,
                    F = null,
                    D = null;
                const k = new kn(0, 0, M, R),
                    L = new kn(0, 0, M, R);
                let K = !1;
                const P = new mo;
                let G = !1,
                    V = !1;
                const O = new mi,
                    N = new On,
                    H = {
                        background: null,
                        fog: null,
                        environment: null,
                        overrideMaterial: null,
                        isScene: !0
                    };

                function q() {
                    return null === v ? T : 1
                }
                let j, Y, J, W, z, X, Z, _, $, ee, te, ne, ie, re, oe, se, ae, le, ce, Ae, he, ue, de, pe, ge = n;

                function fe(e, n) {
                    return t.getContext(e, n)
                }
                try {
                    const e = {
                        alpha: !0,
                        depth: i,
                        stencil: r,
                        antialias: s,
                        premultipliedAlpha: a,
                        preserveDrawingBuffer: l,
                        powerPreference: c,
                        failIfMajorPerformanceCaveat: A
                    };
                    if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${ye}`), t.addEventListener("webglcontextlost", Ce, !1), t.addEventListener("webglcontextrestored", Ie, !1), t.addEventListener("webglcontextcreationerror", Se, !1), null === ge) {
                        const t = "webgl2";
                        if (ge = fe(t, e), null === ge) throw fe(t) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                    }
                } catch (e) {
                    throw console.error("THREE.WebGLRenderer: " + e.message), e
                }

                function me() {
                    j = new _o(ge), j.init(), ue = new Wa(ge, j), Y = new Mo(ge, j, e, ue), J = new Ya(ge), W = new ts(ge), z = new Ta, X = new Ja(ge, j, J, z, Y, ue, W), Z = new To(E), _ = new Zo(E), $ = new Co(ge), de = new Qo(ge, $), ee = new $o(ge, $, W, de), te = new is(ge, ee, $, W), ce = new ns(ge, Y, X), se = new Ro(z), ne = new Ra(E, Z, _, j, Y, de, se), ie = new il(E, z), re = new La, oe = new Na(j), le = new bo(E, Z, _, J, te, h, a), ae = new ja(E, te, Y), pe = new rl(ge, W, Y, J), Ae = new Uo(ge, j, W), he = new es(ge, j, W), W.programs = ne.programs, E.capabilities = Y, E.extensions = j, E.properties = z, E.renderLists = re, E.shadowMap = ae, E.state = J, E.info = W
                }
                me();
                const Ee = new el(E, ge);

                function Ce(e) {
                    e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), C = !0
                }

                function Ie() {
                    console.log("THREE.WebGLRenderer: Context Restored."), C = !1;
                    const e = W.autoReset,
                        t = ae.enabled,
                        n = ae.autoUpdate,
                        i = ae.needsUpdate,
                        r = ae.type;
                    me(), W.autoReset = e, ae.enabled = t, ae.autoUpdate = n, ae.needsUpdate = i, ae.type = r
                }

                function Se(e) {
                    console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", e.statusMessage)
                }

                function ve(e) {
                    const t = e.target;
                    t.removeEventListener("dispose", ve),
                        function(e) {
                            (function(e) {
                                const t = z.get(e).programs;
                                void 0 !== t && (t.forEach((function(e) {
                                    ne.releaseProgram(e)
                                })), e.isShaderMaterial && ne.releaseShaderCache(e))
                            })(e), z.remove(e)
                        }(t)
                }

                function Be(e, t, n) {
                    !0 === e.transparent && e.side === Re && !1 === e.forceSinglePass ? (e.side = Me, e.needsUpdate = !0, Pe(e, t, n), e.side = Ue, e.needsUpdate = !0, Pe(e, t, n), e.side = Re) : Pe(e, t, n)
                }
                this.xr = Ee, this.getContext = function() {
                    return ge
                }, this.getContextAttributes = function() {
                    return ge.getContextAttributes()
                }, this.forceContextLoss = function() {
                    const e = j.get("WEBGL_lose_context");
                    e && e.loseContext()
                }, this.forceContextRestore = function() {
                    const e = j.get("WEBGL_lose_context");
                    e && e.restoreContext()
                }, this.getPixelRatio = function() {
                    return T
                }, this.setPixelRatio = function(e) {
                    void 0 !== e && (T = e, this.setSize(M, R, !1))
                }, this.getSize = function(e) {
                    return e.set(M, R)
                }, this.setSize = function(e, n, i = !0) {
                    Ee.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (M = e, R = n, t.width = Math.floor(e * T), t.height = Math.floor(n * T), !0 === i && (t.style.width = e + "px", t.style.height = n + "px"), this.setViewport(0, 0, e, n))
                }, this.getDrawingBufferSize = function(e) {
                    return e.set(M * T, R * T).floor()
                }, this.setDrawingBufferSize = function(e, n, i) {
                    M = e, R = n, T = i, t.width = Math.floor(e * i), t.height = Math.floor(n * i), this.setViewport(0, 0, e, n)
                }, this.getCurrentViewport = function(e) {
                    return e.copy(y)
                }, this.getViewport = function(e) {
                    return e.copy(k)
                }, this.setViewport = function(e, t, n, i) {
                    e.isVector4 ? k.set(e.x, e.y, e.z, e.w) : k.set(e, t, n, i), J.viewport(y.copy(k).multiplyScalar(T).round())
                }, this.getScissor = function(e) {
                    return e.copy(L)
                }, this.setScissor = function(e, t, n, i) {
                    e.isVector4 ? L.set(e.x, e.y, e.z, e.w) : L.set(e, t, n, i), J.scissor(w.copy(L).multiplyScalar(T).round())
                }, this.getScissorTest = function() {
                    return K
                }, this.setScissorTest = function(e) {
                    J.setScissorTest(K = e)
                }, this.setOpaqueSort = function(e) {
                    F = e
                }, this.setTransparentSort = function(e) {
                    D = e
                }, this.getClearColor = function(e) {
                    return e.copy(le.getClearColor())
                }, this.setClearColor = function() {
                    le.setClearColor.apply(le, arguments)
                }, this.getClearAlpha = function() {
                    return le.getClearAlpha()
                }, this.setClearAlpha = function() {
                    le.setClearAlpha.apply(le, arguments)
                }, this.clear = function(e = !0, t = !0, n = !0) {
                    let i = 0;
                    if (e) {
                        let e = !1;
                        if (null !== v) {
                            const t = v.texture.format;
                            e = 1033 === t || 1031 === t || 1029 === t
                        }
                        if (e) {
                            const e = v.texture.type,
                                t = e === ot || e === at || 1012 === e || e === At || 1017 === e || 1018 === e,
                                n = le.getClearColor(),
                                i = le.getClearAlpha(),
                                r = n.r,
                                o = n.g,
                                s = n.b;
                            t ? (u[0] = r, u[1] = o, u[2] = s, u[3] = i, ge.clearBufferuiv(ge.COLOR, 0, u)) : (d[0] = r, d[1] = o, d[2] = s, d[3] = i, ge.clearBufferiv(ge.COLOR, 0, d))
                        } else i |= ge.COLOR_BUFFER_BIT
                    }
                    t && (i |= ge.DEPTH_BUFFER_BIT), n && (i |= ge.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), ge.clear(i)
                }, this.clearColor = function() {
                    this.clear(!0, !1, !1)
                }, this.clearDepth = function() {
                    this.clear(!1, !0, !1)
                }, this.clearStencil = function() {
                    this.clear(!1, !1, !0)
                }, this.dispose = function() {
                    t.removeEventListener("webglcontextlost", Ce, !1), t.removeEventListener("webglcontextrestored", Ie, !1), t.removeEventListener("webglcontextcreationerror", Se, !1), re.dispose(), oe.dispose(), z.dispose(), Z.dispose(), _.dispose(), te.dispose(), de.dispose(), pe.dispose(), ne.dispose(), Ee.dispose(), Ee.removeEventListener("sessionstart", we), Ee.removeEventListener("sessionend", be), Qe.stop()
                }, this.renderBufferDirect = function(e, t, n, i, r, o) {
                    null === t && (t = H);
                    const s = r.isMesh && r.matrixWorld.determinant() < 0,
                        a = function(e, t, n, i, r) {
                            !0 !== t.isScene && (t = H);
                            X.resetTextureUnits();
                            const o = t.fog,
                                s = i.isMeshStandardMaterial ? t.environment : null,
                                a = null === v ? E.outputColorSpace : !0 === v.isXRRenderTarget ? v.texture.colorSpace : Nt,
                                l = (i.isMeshStandardMaterial ? _ : Z).get(i.envMap || s),
                                c = !0 === i.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize,
                                A = !!n.attributes.tangent && (!!i.normalMap || i.anisotropy > 0),
                                h = !!n.morphAttributes.position,
                                u = !!n.morphAttributes.normal,
                                d = !!n.morphAttributes.color;
                            let p = Le;
                            i.toneMapped && (null !== v && !0 !== v.isXRRenderTarget || (p = E.toneMapping));
                            const f = n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color,
                                m = void 0 !== f ? f.length : 0,
                                C = z.get(i),
                                I = g.state.lights;
                            if (!0 === G && (!0 === V || e !== x)) {
                                const t = e === x && i.id === B;
                                se.setState(i, e, t)
                            }
                            let S = !1;
                            i.version === C.__version ? C.needsLights && C.lightsStateVersion !== I.state.version || C.outputColorSpace !== a || r.isBatchedMesh && !1 === C.batching ? S = !0 : r.isBatchedMesh || !0 !== C.batching ? r.isInstancedMesh && !1 === C.instancing ? S = !0 : r.isInstancedMesh || !0 !== C.instancing ? r.isSkinnedMesh && !1 === C.skinning ? S = !0 : r.isSkinnedMesh || !0 !== C.skinning ? r.isInstancedMesh && !0 === C.instancingColor && null === r.instanceColor || r.isInstancedMesh && !1 === C.instancingColor && null !== r.instanceColor || r.isInstancedMesh && !0 === C.instancingMorph && null === r.morphTexture || r.isInstancedMesh && !1 === C.instancingMorph && null !== r.morphTexture || C.envMap !== l || !0 === i.fog && C.fog !== o ? S = !0 : void 0 === C.numClippingPlanes || C.numClippingPlanes === se.numPlanes && C.numIntersection === se.numIntersection ? (C.vertexAlphas !== c || C.vertexTangents !== A || C.morphTargets !== h || C.morphNormals !== u || C.morphColors !== d || C.toneMapping !== p || C.morphTargetsCount !== m) && (S = !0) : S = !0 : S = !0 : S = !0 : S = !0 : (S = !0, C.__version = i.version);
                            let y = C.currentProgram;
                            !0 === S && (y = Pe(i, t, r));
                            let w = !1,
                                b = !1,
                                Q = !1;
                            const U = y.getUniforms(),
                                M = C.uniforms;
                            J.useProgram(y.program) && (w = !0, b = !0, Q = !0);
                            i.id !== B && (B = i.id, b = !0);
                            if (w || x !== e) {
                                U.setValue(ge, "projectionMatrix", e.projectionMatrix), U.setValue(ge, "viewMatrix", e.matrixWorldInverse);
                                const t = U.map.cameraPosition;
                                void 0 !== t && t.setValue(ge, N.setFromMatrixPosition(e.matrixWorld)), Y.logarithmicDepthBuffer && U.setValue(ge, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), (i.isMeshPhongMaterial || i.isMeshToonMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial) && U.setValue(ge, "isOrthographic", !0 === e.isOrthographicCamera), x !== e && (x = e, b = !0, Q = !0)
                            }
                            if (r.isSkinnedMesh) {
                                U.setOptional(ge, r, "bindMatrix"), U.setOptional(ge, r, "bindMatrixInverse");
                                const e = r.skeleton;
                                e && (null === e.boneTexture && e.computeBoneTexture(), U.setValue(ge, "boneTexture", e.boneTexture, X))
                            }
                            r.isBatchedMesh && (U.setOptional(ge, r, "batchingTexture"), U.setValue(ge, "batchingTexture", r._matricesTexture, X));
                            const F = n.morphAttributes;
                            void 0 === F.position && void 0 === F.normal && void 0 === F.color || ce.update(r, n, y);
                            (b || C.receiveShadow !== r.receiveShadow) && (C.receiveShadow = r.receiveShadow, U.setValue(ge, "receiveShadow", r.receiveShadow));
                            i.isMeshGouraudMaterial && null !== i.envMap && (M.envMap.value = l, M.flipEnvMap.value = l.isCubeTexture && !1 === l.isRenderTargetTexture ? -1 : 1);
                            i.isMeshStandardMaterial && null === i.envMap && null !== t.environment && (M.envMapIntensity.value = t.environmentIntensity);
                            b && (U.setValue(ge, "toneMappingExposure", E.toneMappingExposure), C.needsLights && (k = Q, (D = M).ambientLightColor.needsUpdate = k, D.lightProbe.needsUpdate = k, D.directionalLights.needsUpdate = k, D.directionalLightShadows.needsUpdate = k, D.pointLights.needsUpdate = k, D.pointLightShadows.needsUpdate = k, D.spotLights.needsUpdate = k, D.spotLightShadows.needsUpdate = k, D.rectAreaLights.needsUpdate = k, D.hemisphereLights.needsUpdate = k), o && !0 === i.fog && ie.refreshFogUniforms(M, o), ie.refreshMaterialUniforms(M, i, T, R, g.state.transmissionRenderTarget[e.id]), ca.upload(ge, Ge(C), M, X));
                            var D, k;
                            i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (ca.upload(ge, Ge(C), M, X), i.uniformsNeedUpdate = !1);
                            i.isSpriteMaterial && U.setValue(ge, "center", r.center);
                            if (U.setValue(ge, "modelViewMatrix", r.modelViewMatrix), U.setValue(ge, "normalMatrix", r.normalMatrix), U.setValue(ge, "modelMatrix", r.matrixWorld), i.isShaderMaterial || i.isRawShaderMaterial) {
                                const e = i.uniformsGroups;
                                for (let t = 0, n = e.length; t < n; t++) {
                                    const n = e[t];
                                    pe.update(n, y), pe.bind(n, y)
                                }
                            }
                            return y
                        }(e, t, n, i, r);
                    J.setMaterial(i, s);
                    let l = n.index,
                        c = 1;
                    if (!0 === i.wireframe) {
                        if (l = ee.getWireframeAttribute(n), void 0 === l) return;
                        c = 2
                    }
                    const A = n.drawRange,
                        h = n.attributes.position;
                    let u = A.start * c,
                        d = (A.start + A.count) * c;
                    null !== o && (u = Math.max(u, o.start * c), d = Math.min(d, (o.start + o.count) * c)), null !== l ? (u = Math.max(u, 0), d = Math.min(d, l.count)) : null != h && (u = Math.max(u, 0), d = Math.min(d, h.count));
                    const p = d - u;
                    if (p < 0 || p === 1 / 0) return;
                    let f;
                    de.setup(r, i, a, n, l);
                    let m = Ae;
                    if (null !== l && (f = $.get(l), m = he, m.setIndex(f)), r.isMesh) !0 === i.wireframe ? (J.setLineWidth(i.wireframeLinewidth * q()), m.setMode(ge.LINES)) : m.setMode(ge.TRIANGLES);
                    else if (r.isLine) {
                        let e = i.linewidth;
                        void 0 === e && (e = 1), J.setLineWidth(e * q()), r.isLineSegments ? m.setMode(ge.LINES) : r.isLineLoop ? m.setMode(ge.LINE_LOOP) : m.setMode(ge.LINE_STRIP)
                    } else r.isPoints ? m.setMode(ge.POINTS) : r.isSprite && m.setMode(ge.TRIANGLES);
                    if (r.isBatchedMesh) null !== r._multiDrawInstances ? m.renderMultiDrawInstances(r._multiDrawStarts, r._multiDrawCounts, r._multiDrawCount, r._multiDrawInstances) : m.renderMultiDraw(r._multiDrawStarts, r._multiDrawCounts, r._multiDrawCount);
                    else if (r.isInstancedMesh) m.renderInstances(u, p, r.count);
                    else if (n.isInstancedBufferGeometry) {
                        const e = void 0 !== n._maxInstanceCount ? n._maxInstanceCount : 1 / 0,
                            t = Math.min(n.instanceCount, e);
                        m.renderInstances(u, p, t)
                    } else m.render(u, p)
                }, this.compile = function(e, t, n = null) {
                    null === n && (n = e), g = oe.get(n), g.init(t), m.push(g), n.traverseVisible((function(e) {
                        e.isLight && e.layers.test(t.layers) && (g.pushLight(e), e.castShadow && g.pushShadow(e))
                    })), e !== n && e.traverseVisible((function(e) {
                        e.isLight && e.layers.test(t.layers) && (g.pushLight(e), e.castShadow && g.pushShadow(e))
                    })), g.setupLights(E._useLegacyLights);
                    const i = new Set;
                    return e.traverse((function(e) {
                        const t = e.material;
                        if (t)
                            if (Array.isArray(t))
                                for (let r = 0; r < t.length; r++) {
                                    const o = t[r];
                                    Be(o, n, e), i.add(o)
                                } else Be(t, n, e), i.add(t)
                    })), m.pop(), g = null, i
                }, this.compileAsync = function(e, t, n = null) {
                    const i = this.compile(e, t, n);
                    return new Promise((t => {
                        function n() {
                            i.forEach((function(e) {
                                z.get(e).currentProgram.isReady() && i.delete(e)
                            })), 0 !== i.size ? setTimeout(n, 10) : t(e)
                        }
                        null !== j.get("KHR_parallel_shader_compile") ? n() : setTimeout(n, 10)
                    }))
                };
                let xe = null;

                function we() {
                    Qe.stop()
                }

                function be() {
                    Qe.start()
                }
                const Qe = new Eo;

                function Te(e, t, n, i) {
                    if (!1 === e.visible) return;
                    if (e.layers.test(t.layers))
                        if (e.isGroup) n = e.renderOrder;
                        else if (e.isLOD) !0 === e.autoUpdate && e.update(t);
                    else if (e.isLight) g.pushLight(e), e.castShadow && g.pushShadow(e);
                    else if (e.isSprite) {
                        if (!e.frustumCulled || P.intersectsSprite(e)) {
                            i && N.setFromMatrixPosition(e.matrixWorld).applyMatrix4(O);
                            const t = te.update(e),
                                r = e.material;
                            r.visible && p.push(e, t, r, n, N.z, null)
                        }
                    } else if ((e.isMesh || e.isLine || e.isPoints) && (!e.frustumCulled || P.intersectsObject(e))) {
                        const t = te.update(e),
                            r = e.material;
                        if (i && (void 0 !== e.boundingSphere ? (null === e.boundingSphere && e.computeBoundingSphere(), N.copy(e.boundingSphere.center)) : (null === t.boundingSphere && t.computeBoundingSphere(), N.copy(t.boundingSphere.center)), N.applyMatrix4(e.matrixWorld).applyMatrix4(O)), Array.isArray(r)) {
                            const i = t.groups;
                            for (let o = 0, s = i.length; o < s; o++) {
                                const s = i[o],
                                    a = r[s.materialIndex];
                                a && a.visible && p.push(e, t, a, n, N.z, s)
                            }
                        } else r.visible && p.push(e, t, r, n, N.z, null)
                    }
                    const r = e.children;
                    for (let e = 0, o = r.length; e < o; e++) Te(r[e], t, n, i)
                }

                function Fe(e, t, n, i) {
                    const r = e.opaque,
                        o = e.transmissive,
                        s = e.transparent;
                    g.setupLightsView(n), !0 === G && se.setGlobalState(E.clippingPlanes, n), i && J.viewport(y.copy(i)), r.length > 0 && ke(r, t, n), o.length > 0 && ke(o, t, n), s.length > 0 && ke(s, t, n), J.buffers.depth.setTest(!0), J.buffers.depth.setMask(!0), J.buffers.color.setMask(!0), J.setPolygonOffset(!1)
                }

                function De(e, t, n, i) {
                    if (null !== (!0 === n.isScene ? n.overrideMaterial : null)) return;
                    void 0 === g.state.transmissionRenderTarget[i.id] && (g.state.transmissionRenderTarget[i.id] = new Kn(1, 1, {
                        generateMipmaps: !0,
                        type: j.has("EXT_color_buffer_half_float") || j.has("EXT_color_buffer_float") ? ct : ot,
                        minFilter: rt,
                        samples: 4,
                        stencilBuffer: r,
                        resolveDepthBuffer: !1,
                        resolveStencilBuffer: !1
                    }));
                    const o = g.state.transmissionRenderTarget[i.id],
                        s = i.viewport || y;
                    o.setSize(s.z, s.w);
                    const a = E.getRenderTarget();
                    E.setRenderTarget(o), E.getClearColor(Q), U = E.getClearAlpha(), U < 1 && E.setClearColor(16777215, .5), E.clear();
                    const l = E.toneMapping;
                    E.toneMapping = Le;
                    const c = i.viewport;
                    if (void 0 !== i.viewport && (i.viewport = void 0), g.setupLightsView(i), !0 === G && se.setGlobalState(E.clippingPlanes, i), ke(e, n, i), X.updateMultisampleRenderTarget(o), X.updateRenderTargetMipmap(o), !1 === j.has("WEBGL_multisampled_render_to_texture")) {
                        let e = !1;
                        for (let r = 0, o = t.length; r < o; r++) {
                            const o = t[r],
                                s = o.object,
                                a = o.geometry,
                                l = o.material,
                                c = o.group;
                            if (l.side === Re && s.layers.test(i.layers)) {
                                const t = l.side;
                                l.side = Me, l.needsUpdate = !0, Ke(s, n, i, a, l, c), l.side = t, l.needsUpdate = !0, e = !0
                            }
                        }!0 === e && (X.updateMultisampleRenderTarget(o), X.updateRenderTargetMipmap(o))
                    }
                    E.setRenderTarget(a), E.setClearColor(Q, U), void 0 !== c && (i.viewport = c), E.toneMapping = l
                }

                function ke(e, t, n) {
                    const i = !0 === t.isScene ? t.overrideMaterial : null;
                    for (let r = 0, o = e.length; r < o; r++) {
                        const o = e[r],
                            s = o.object,
                            a = o.geometry,
                            l = null === i ? o.material : i,
                            c = o.group;
                        s.layers.test(n.layers) && Ke(s, t, n, a, l, c)
                    }
                }

                function Ke(e, t, n, i, r, o) {
                    e.onBeforeRender(E, t, n, i, r, o), e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), r.onBeforeRender(E, t, n, i, e, o), !0 === r.transparent && r.side === Re && !1 === r.forceSinglePass ? (r.side = Me, r.needsUpdate = !0, E.renderBufferDirect(n, t, i, r, e, o), r.side = Ue, r.needsUpdate = !0, E.renderBufferDirect(n, t, i, r, e, o), r.side = Re) : E.renderBufferDirect(n, t, i, r, e, o), e.onAfterRender(E, t, n, i, r, o)
                }

                function Pe(e, t, n) {
                    !0 !== t.isScene && (t = H);
                    const i = z.get(e),
                        r = g.state.lights,
                        o = g.state.shadowsArray,
                        s = r.state.version,
                        a = ne.getParameters(e, r.state, o, t, n),
                        l = ne.getProgramCacheKey(a);
                    let c = i.programs;
                    i.environment = e.isMeshStandardMaterial ? t.environment : null, i.fog = t.fog, i.envMap = (e.isMeshStandardMaterial ? _ : Z).get(e.envMap || i.environment), i.envMapRotation = null !== i.environment && null === e.envMap ? t.environmentRotation : e.envMapRotation, void 0 === c && (e.addEventListener("dispose", ve), c = new Map, i.programs = c);
                    let A = c.get(l);
                    if (void 0 !== A) {
                        if (i.currentProgram === A && i.lightsStateVersion === s) return Ve(e, a), A
                    } else a.uniforms = ne.getUniforms(e), e.onBuild(n, a, E), e.onBeforeCompile(a, E), A = ne.acquireProgram(a, l), c.set(l, A), i.uniforms = a.uniforms;
                    const h = i.uniforms;
                    return (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (h.clippingPlanes = se.uniform), Ve(e, a), i.needsLights = function(e) {
                        return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights
                    }(e), i.lightsStateVersion = s, i.needsLights && (h.ambientLightColor.value = r.state.ambient, h.lightProbe.value = r.state.probe, h.directionalLights.value = r.state.directional, h.directionalLightShadows.value = r.state.directionalShadow, h.spotLights.value = r.state.spot, h.spotLightShadows.value = r.state.spotShadow, h.rectAreaLights.value = r.state.rectArea, h.ltc_1.value = r.state.rectAreaLTC1, h.ltc_2.value = r.state.rectAreaLTC2, h.pointLights.value = r.state.point, h.pointLightShadows.value = r.state.pointShadow, h.hemisphereLights.value = r.state.hemi, h.directionalShadowMap.value = r.state.directionalShadowMap, h.directionalShadowMatrix.value = r.state.directionalShadowMatrix, h.spotShadowMap.value = r.state.spotShadowMap, h.spotLightMatrix.value = r.state.spotLightMatrix, h.spotLightMap.value = r.state.spotLightMap, h.pointShadowMap.value = r.state.pointShadowMap, h.pointShadowMatrix.value = r.state.pointShadowMatrix), i.currentProgram = A, i.uniformsList = null, A
                }

                function Ge(e) {
                    if (null === e.uniformsList) {
                        const t = e.currentProgram.getUniforms();
                        e.uniformsList = ca.seqWithValue(t.seq, e.uniforms)
                    }
                    return e.uniformsList
                }

                function Ve(e, t) {
                    const n = z.get(e);
                    n.outputColorSpace = t.outputColorSpace, n.batching = t.batching, n.instancing = t.instancing, n.instancingColor = t.instancingColor, n.instancingMorph = t.instancingMorph, n.skinning = t.skinning, n.morphTargets = t.morphTargets, n.morphNormals = t.morphNormals, n.morphColors = t.morphColors, n.morphTargetsCount = t.morphTargetsCount, n.numClippingPlanes = t.numClippingPlanes, n.numIntersection = t.numClipIntersection, n.vertexAlphas = t.vertexAlphas, n.vertexTangents = t.vertexTangents, n.toneMapping = t.toneMapping
                }
                Qe.setAnimationLoop((function(e) {
                    xe && xe(e)
                })), "undefined" != typeof self && Qe.setContext(self), this.setAnimationLoop = function(e) {
                    xe = e, Ee.setAnimationLoop(e), null === e ? Qe.stop() : Qe.start()
                }, Ee.addEventListener("sessionstart", we), Ee.addEventListener("sessionend", be), this.render = function(e, t) {
                    if (void 0 !== t && !0 !== t.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                    if (!0 === C) return;
                    !0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(), null === t.parent && !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(), !0 === Ee.enabled && !0 === Ee.isPresenting && (!0 === Ee.cameraAutoUpdate && Ee.updateCamera(t), t = Ee.getCamera()), !0 === e.isScene && e.onBeforeRender(E, e, t, v), g = oe.get(e, m.length), g.init(t), m.push(g), O.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), P.setFromProjectionMatrix(O), V = this.localClippingEnabled, G = se.init(this.clippingPlanes, V), p = re.get(e, f.length), p.init(), f.push(p), Te(e, t, 0, E.sortObjects), p.finish(), !0 === E.sortObjects && p.sort(F, D);
                    const n = !1 === Ee.enabled || !1 === Ee.isPresenting || !1 === Ee.hasDepthSensing();
                    n && le.addToRenderList(p, e), this.info.render.frame++, !0 === G && se.beginShadows();
                    const i = g.state.shadowsArray;
                    ae.render(i, e, t), !0 === G && se.endShadows(), !0 === this.info.autoReset && this.info.reset();
                    const r = p.opaque,
                        o = p.transmissive;
                    if (g.setupLights(E._useLegacyLights), t.isArrayCamera) {
                        const i = t.cameras;
                        if (o.length > 0)
                            for (let t = 0, n = i.length; t < n; t++) {
                                De(r, o, e, i[t])
                            }
                        n && le.render(e);
                        for (let t = 0, n = i.length; t < n; t++) {
                            const n = i[t];
                            Fe(p, e, n, n.viewport)
                        }
                    } else o.length > 0 && De(r, o, e, t), n && le.render(e), Fe(p, e, t);
                    null !== v && (X.updateMultisampleRenderTarget(v), X.updateRenderTargetMipmap(v)), !0 === e.isScene && e.onAfterRender(E, e, t), de.resetDefaultState(), B = -1, x = null, m.pop(), m.length > 0 ? (g = m[m.length - 1], !0 === G && se.setGlobalState(E.clippingPlanes, g.state.camera)) : g = null, f.pop(), p = f.length > 0 ? f[f.length - 1] : null
                }, this.getActiveCubeFace = function() {
                    return I
                }, this.getActiveMipmapLevel = function() {
                    return S
                }, this.getRenderTarget = function() {
                    return v
                }, this.setRenderTargetTextures = function(e, t, n) {
                    z.get(e.texture).__webglTexture = t, z.get(e.depthTexture).__webglTexture = n;
                    const i = z.get(e);
                    i.__hasExternalTextures = !0, i.__autoAllocateDepthBuffer = void 0 === n, i.__autoAllocateDepthBuffer || !0 === j.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), i.__useRenderToTexture = !1)
                }, this.setRenderTargetFramebuffer = function(e, t) {
                    const n = z.get(e);
                    n.__webglFramebuffer = t, n.__useDefaultFramebuffer = void 0 === t
                }, this.setRenderTarget = function(e, t = 0, n = 0) {
                    v = e, I = t, S = n;
                    let i = !0,
                        r = null,
                        o = !1,
                        s = !1;
                    if (e) {
                        const a = z.get(e);
                        void 0 !== a.__useDefaultFramebuffer ? (J.bindFramebuffer(ge.FRAMEBUFFER, null), i = !1) : void 0 === a.__webglFramebuffer ? X.setupRenderTarget(e) : a.__hasExternalTextures && X.rebindTextures(e, z.get(e.texture).__webglTexture, z.get(e.depthTexture).__webglTexture);
                        const l = e.texture;
                        (l.isData3DTexture || l.isDataArrayTexture || l.isCompressedArrayTexture) && (s = !0);
                        const c = z.get(e).__webglFramebuffer;
                        e.isWebGLCubeRenderTarget ? (r = Array.isArray(c[t]) ? c[t][n] : c[t], o = !0) : r = e.samples > 0 && !1 === X.useMultisampledRTT(e) ? z.get(e).__webglMultisampledFramebuffer : Array.isArray(c) ? c[n] : c, y.copy(e.viewport), w.copy(e.scissor), b = e.scissorTest
                    } else y.copy(k).multiplyScalar(T).floor(), w.copy(L).multiplyScalar(T).floor(), b = K;
                    if (J.bindFramebuffer(ge.FRAMEBUFFER, r) && i && J.drawBuffers(e, r), J.viewport(y), J.scissor(w), J.setScissorTest(b), o) {
                        const i = z.get(e.texture);
                        ge.framebufferTexture2D(ge.FRAMEBUFFER, ge.COLOR_ATTACHMENT0, ge.TEXTURE_CUBE_MAP_POSITIVE_X + t, i.__webglTexture, n)
                    } else if (s) {
                        const i = z.get(e.texture),
                            r = t || 0;
                        ge.framebufferTextureLayer(ge.FRAMEBUFFER, ge.COLOR_ATTACHMENT0, i.__webglTexture, n || 0, r)
                    }
                    B = -1
                }, this.readRenderTargetPixels = function(e, t, n, i, r, o, s) {
                    if (!e || !e.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                    let a = z.get(e).__webglFramebuffer;
                    if (e.isWebGLCubeRenderTarget && void 0 !== s && (a = a[s]), a) {
                        J.bindFramebuffer(ge.FRAMEBUFFER, a);
                        try {
                            const s = e.texture,
                                a = s.format,
                                l = s.type;
                            if (!Y.textureFormatReadable(a)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                            if (!Y.textureTypeReadable(l)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                            t >= 0 && t <= e.width - i && n >= 0 && n <= e.height - r && ge.readPixels(t, n, i, r, ue.convert(a), ue.convert(l), o)
                        } finally {
                            const e = null !== v ? z.get(v).__webglFramebuffer : null;
                            J.bindFramebuffer(ge.FRAMEBUFFER, e)
                        }
                    }
                }, this.copyFramebufferToTexture = function(e, t, n = 0) {
                    const i = Math.pow(2, -n),
                        r = Math.floor(t.image.width * i),
                        o = Math.floor(t.image.height * i);
                    X.setTexture2D(t, 0), ge.copyTexSubImage2D(ge.TEXTURE_2D, n, 0, 0, e.x, e.y, r, o), J.unbindTexture()
                }, this.copyTextureToTexture = function(e, t, n, i = 0) {
                    const r = t.image.width,
                        o = t.image.height,
                        s = ue.convert(n.format),
                        a = ue.convert(n.type);
                    X.setTexture2D(n, 0), ge.pixelStorei(ge.UNPACK_FLIP_Y_WEBGL, n.flipY), ge.pixelStorei(ge.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n.premultiplyAlpha), ge.pixelStorei(ge.UNPACK_ALIGNMENT, n.unpackAlignment), t.isDataTexture ? ge.texSubImage2D(ge.TEXTURE_2D, i, e.x, e.y, r, o, s, a, t.image.data) : t.isCompressedTexture ? ge.compressedTexSubImage2D(ge.TEXTURE_2D, i, e.x, e.y, t.mipmaps[0].width, t.mipmaps[0].height, s, t.mipmaps[0].data) : ge.texSubImage2D(ge.TEXTURE_2D, i, e.x, e.y, s, a, t.image), 0 === i && n.generateMipmaps && ge.generateMipmap(ge.TEXTURE_2D), J.unbindTexture()
                }, this.copyTextureToTexture3D = function(e, t, n, i, r = 0) {
                    const o = e.max.x - e.min.x,
                        s = e.max.y - e.min.y,
                        a = e.max.z - e.min.z,
                        l = ue.convert(i.format),
                        c = ue.convert(i.type);
                    let A;
                    if (i.isData3DTexture) X.setTexture3D(i, 0), A = ge.TEXTURE_3D;
                    else {
                        if (!i.isDataArrayTexture && !i.isCompressedArrayTexture) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                        X.setTexture2DArray(i, 0), A = ge.TEXTURE_2D_ARRAY
                    }
                    ge.pixelStorei(ge.UNPACK_FLIP_Y_WEBGL, i.flipY), ge.pixelStorei(ge.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha), ge.pixelStorei(ge.UNPACK_ALIGNMENT, i.unpackAlignment);
                    const h = ge.getParameter(ge.UNPACK_ROW_LENGTH),
                        u = ge.getParameter(ge.UNPACK_IMAGE_HEIGHT),
                        d = ge.getParameter(ge.UNPACK_SKIP_PIXELS),
                        p = ge.getParameter(ge.UNPACK_SKIP_ROWS),
                        g = ge.getParameter(ge.UNPACK_SKIP_IMAGES),
                        f = n.isCompressedTexture ? n.mipmaps[r] : n.image;
                    ge.pixelStorei(ge.UNPACK_ROW_LENGTH, f.width), ge.pixelStorei(ge.UNPACK_IMAGE_HEIGHT, f.height), ge.pixelStorei(ge.UNPACK_SKIP_PIXELS, e.min.x), ge.pixelStorei(ge.UNPACK_SKIP_ROWS, e.min.y), ge.pixelStorei(ge.UNPACK_SKIP_IMAGES, e.min.z), n.isDataTexture || n.isData3DTexture ? ge.texSubImage3D(A, r, t.x, t.y, t.z, o, s, a, l, c, f.data) : i.isCompressedArrayTexture ? ge.compressedTexSubImage3D(A, r, t.x, t.y, t.z, o, s, a, l, f.data) : ge.texSubImage3D(A, r, t.x, t.y, t.z, o, s, a, l, c, f), ge.pixelStorei(ge.UNPACK_ROW_LENGTH, h), ge.pixelStorei(ge.UNPACK_IMAGE_HEIGHT, u), ge.pixelStorei(ge.UNPACK_SKIP_PIXELS, d), ge.pixelStorei(ge.UNPACK_SKIP_ROWS, p), ge.pixelStorei(ge.UNPACK_SKIP_IMAGES, g), 0 === r && i.generateMipmaps && ge.generateMipmap(A), J.unbindTexture()
                }, this.initTexture = function(e) {
                    e.isCubeTexture ? X.setTextureCube(e, 0) : e.isData3DTexture ? X.setTexture3D(e, 0) : e.isDataArrayTexture || e.isCompressedArrayTexture ? X.setTexture2DArray(e, 0) : X.setTexture2D(e, 0), J.unbindTexture()
                }, this.resetState = function() {
                    I = 0, S = 0, v = null, J.reset(), de.reset()
                }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                    detail: this
                }))
            }
            get coordinateSystem() {
                return _t
            }
            get outputColorSpace() {
                return this._outputColorSpace
            }
            set outputColorSpace(e) {
                this._outputColorSpace = e;
                const t = this.getContext();
                t.drawingBufferColorSpace = e === Ht ? "display-p3" : "srgb", t.unpackColorSpace = yn.workingColorSpace === qt ? "display-p3" : "srgb"
            }
            get useLegacyLights() {
                return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights
            }
            set useLegacyLights(e) {
                console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights = e
            }
        }
        class sl {
            constructor(e, t = 1, n = 1e3) {
                this.isFog = !0, this.name = "", this.color = new sr(e), this.near = t, this.far = n
            }
            clone() {
                return new sl(this.color, this.near, this.far)
            }
            toJSON() {
                return {
                    type: "Fog",
                    name: this.name,
                    color: this.color.getHex(),
                    near: this.near,
                    far: this.far
                }
            }
        }
        class al extends qi {
            constructor() {
                super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new bi, this.environmentIntensity = 1, this.environmentRotation = new bi, this.overrideMaterial = null, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                    detail: this
                }))
            }
            copy(e, t) {
                return super.copy(e, t), null !== e.background && (this.background = e.background.clone()), null !== e.environment && (this.environment = e.environment.clone()), null !== e.fog && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return null !== this.fog && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), 1 !== this.backgroundIntensity && (t.object.backgroundIntensity = this.backgroundIntensity), t.object.backgroundRotation = this.backgroundRotation.toArray(), 1 !== this.environmentIntensity && (t.object.environmentIntensity = this.environmentIntensity), t.object.environmentRotation = this.environmentRotation.toArray(), t
            }
        }
        class ll {
            constructor(e, t) {
                this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = void 0 !== e ? e.length / t : 0, this.usage = Xt, this._updateRange = {
                    offset: 0,
                    count: -1
                }, this.updateRanges = [], this.version = 0, this.uuid = sn()
            }
            onUploadCallback() {}
            set needsUpdate(e) {
                !0 === e && this.version++
            }
            get updateRange() {
                return In("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange
            }
            setUsage(e) {
                return this.usage = e, this
            }
            addUpdateRange(e, t) {
                this.updateRanges.push({
                    start: e,
                    count: t
                })
            }
            clearUpdateRanges() {
                this.updateRanges.length = 0
            }
            copy(e) {
                return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this
            }
            copyAt(e, t, n) {
                e *= this.stride, n *= t.stride;
                for (let i = 0, r = this.stride; i < r; i++) this.array[e + i] = t.array[n + i];
                return this
            }
            set(e, t = 0) {
                return this.array.set(e, t), this
            }
            clone(e) {
                void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = sn()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),
                    n = new this.constructor(t, this.stride);
                return n.setUsage(this.usage), n
            }
            onUpload(e) {
                return this.onUploadCallback = e, this
            }
            toJSON(e) {
                return void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = sn()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
                    uuid: this.uuid,
                    buffer: this.array.buffer._uuid,
                    type: this.array.constructor.name,
                    stride: this.stride
                }
            }
        }
        const cl = new On;
        class Al {
            constructor(e, t, n, i = !1) {
                this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = i
            }
            get count() {
                return this.data.count
            }
            get array() {
                return this.data.array
            }
            set needsUpdate(e) {
                this.data.needsUpdate = e
            }
            applyMatrix4(e) {
                for (let t = 0, n = this.data.count; t < n; t++) cl.fromBufferAttribute(this, t), cl.applyMatrix4(e), this.setXYZ(t, cl.x, cl.y, cl.z);
                return this
            }
            applyNormalMatrix(e) {
                for (let t = 0, n = this.count; t < n; t++) cl.fromBufferAttribute(this, t), cl.applyNormalMatrix(e), this.setXYZ(t, cl.x, cl.y, cl.z);
                return this
            }
            transformDirection(e) {
                for (let t = 0, n = this.count; t < n; t++) cl.fromBufferAttribute(this, t), cl.transformDirection(e), this.setXYZ(t, cl.x, cl.y, cl.z);
                return this
            }
            getComponent(e, t) {
                let n = this.array[e * this.data.stride + this.offset + t];
                return this.normalized && (n = An(n, this.array)), n
            }
            setComponent(e, t, n) {
                return this.normalized && (n = hn(n, this.array)), this.data.array[e * this.data.stride + this.offset + t] = n, this
            }
            setX(e, t) {
                return this.normalized && (t = hn(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this
            }
            setY(e, t) {
                return this.normalized && (t = hn(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this
            }
            setZ(e, t) {
                return this.normalized && (t = hn(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this
            }
            setW(e, t) {
                return this.normalized && (t = hn(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this
            }
            getX(e) {
                let t = this.data.array[e * this.data.stride + this.offset];
                return this.normalized && (t = An(t, this.array)), t
            }
            getY(e) {
                let t = this.data.array[e * this.data.stride + this.offset + 1];
                return this.normalized && (t = An(t, this.array)), t
            }
            getZ(e) {
                let t = this.data.array[e * this.data.stride + this.offset + 2];
                return this.normalized && (t = An(t, this.array)), t
            }
            getW(e) {
                let t = this.data.array[e * this.data.stride + this.offset + 3];
                return this.normalized && (t = An(t, this.array)), t
            }
            setXY(e, t, n) {
                return e = e * this.data.stride + this.offset, this.normalized && (t = hn(t, this.array), n = hn(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this
            }
            setXYZ(e, t, n, i) {
                return e = e * this.data.stride + this.offset, this.normalized && (t = hn(t, this.array), n = hn(n, this.array), i = hn(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this
            }
            setXYZW(e, t, n, i, r) {
                return e = e * this.data.stride + this.offset, this.normalized && (t = hn(t, this.array), n = hn(n, this.array), i = hn(i, this.array), r = hn(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this.data.array[e + 3] = r, this
            }
            clone(e) {
                if (void 0 === e) {
                    console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
                    const e = [];
                    for (let t = 0; t < this.count; t++) {
                        const n = t * this.data.stride + this.offset;
                        for (let t = 0; t < this.itemSize; t++) e.push(this.data.array[n + t])
                    }
                    return new Er(new this.array.constructor(e), this.itemSize, this.normalized)
                }
                return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new Al(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
            }
            toJSON(e) {
                if (void 0 === e) {
                    console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
                    const e = [];
                    for (let t = 0; t < this.count; t++) {
                        const n = t * this.data.stride + this.offset;
                        for (let t = 0; t < this.itemSize; t++) e.push(this.data.array[n + t])
                    }
                    return {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: e,
                        normalized: this.normalized
                    }
                }
                return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
                    isInterleavedBufferAttribute: !0,
                    itemSize: this.itemSize,
                    data: this.data.uuid,
                    offset: this.offset,
                    normalized: this.normalized
                }
            }
        }
        const hl = new On,
            ul = new kn,
            dl = new kn,
            pl = new On,
            gl = new mi,
            fl = new On,
            ml = new li,
            El = new mi,
            Cl = new fi;
        class Il extends Jr {
            constructor(e, t) {
                super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = qe, this.bindMatrix = new mi, this.bindMatrixInverse = new mi, this.boundingBox = null, this.boundingSphere = null
            }
            computeBoundingBox() {
                const e = this.geometry;
                null === this.boundingBox && (this.boundingBox = new qn), this.boundingBox.makeEmpty();
                const t = e.getAttribute("position");
                for (let e = 0; e < t.count; e++) this.getVertexPosition(e, fl), this.boundingBox.expandByPoint(fl)
            }
            computeBoundingSphere() {
                const e = this.geometry;
                null === this.boundingSphere && (this.boundingSphere = new li), this.boundingSphere.makeEmpty();
                const t = e.getAttribute("position");
                for (let e = 0; e < t.count; e++) this.getVertexPosition(e, fl), this.boundingSphere.expandByPoint(fl)
            }
            copy(e, t) {
                return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this
            }
            raycast(e, t) {
                const n = this.material,
                    i = this.matrixWorld;
                void 0 !== n && (null === this.boundingSphere && this.computeBoundingSphere(), ml.copy(this.boundingSphere), ml.applyMatrix4(i), !1 !== e.ray.intersectsSphere(ml) && (El.copy(i).invert(), Cl.copy(e.ray).applyMatrix4(El), null !== this.boundingBox && !1 === Cl.intersectsBox(this.boundingBox) || this._computeIntersections(e, t, Cl)))
            }
            getVertexPosition(e, t) {
                return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t
            }
            bind(e, t) {
                this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert()
            }
            pose() {
                this.skeleton.pose()
            }
            normalizeSkinWeights() {
                const e = new kn,
                    t = this.geometry.attributes.skinWeight;
                for (let n = 0, i = t.count; n < i; n++) {
                    e.fromBufferAttribute(t, n);
                    const i = 1 / e.manhattanLength();
                    i !== 1 / 0 ? e.multiplyScalar(i) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w)
                }
            }
            updateMatrixWorld(e) {
                super.updateMatrixWorld(e), this.bindMode === qe ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
            }
            applyBoneTransform(e, t) {
                const n = this.skeleton,
                    i = this.geometry;
                ul.fromBufferAttribute(i.attributes.skinIndex, e), dl.fromBufferAttribute(i.attributes.skinWeight, e), hl.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
                for (let e = 0; e < 4; e++) {
                    const i = dl.getComponent(e);
                    if (0 !== i) {
                        const r = ul.getComponent(e);
                        gl.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]), t.addScaledVector(pl.copy(hl).applyMatrix4(gl), i)
                    }
                }
                return t.applyMatrix4(this.bindMatrixInverse)
            }
        }
        class Sl extends qi {
            constructor() {
                super(), this.isBone = !0, this.type = "Bone"
            }
        }
        class vl extends Dn {
            constructor(e = null, t = 1, n = 1, i, r, o, s, a, l = 1003, c = 1003, A, h) {
                super(null, o, s, a, l, c, i, r, A, h), this.isDataTexture = !0, this.image = {
                    data: e,
                    width: t,
                    height: n
                }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
            }
        }
        const Bl = new mi,
            xl = new mi;
        class yl {
            constructor(e = [], t = []) {
                this.uuid = sn(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.init()
            }
            init() {
                const e = this.bones,
                    t = this.boneInverses;
                if (this.boneMatrices = new Float32Array(16 * e.length), 0 === t.length) this.calculateInverses();
                else if (e.length !== t.length) {
                    console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
                    for (let e = 0, t = this.bones.length; e < t; e++) this.boneInverses.push(new mi)
                }
            }
            calculateInverses() {
                this.boneInverses.length = 0;
                for (let e = 0, t = this.bones.length; e < t; e++) {
                    const t = new mi;
                    this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(t)
                }
            }
            pose() {
                for (let e = 0, t = this.bones.length; e < t; e++) {
                    const t = this.bones[e];
                    t && t.matrixWorld.copy(this.boneInverses[e]).invert()
                }
                for (let e = 0, t = this.bones.length; e < t; e++) {
                    const t = this.bones[e];
                    t && (t.parent && t.parent.isBone ? (t.matrix.copy(t.parent.matrixWorld).invert(), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale))
                }
            }
            update() {
                const e = this.bones,
                    t = this.boneInverses,
                    n = this.boneMatrices,
                    i = this.boneTexture;
                for (let i = 0, r = e.length; i < r; i++) {
                    const r = e[i] ? e[i].matrixWorld : xl;
                    Bl.multiplyMatrices(r, t[i]), Bl.toArray(n, 16 * i)
                }
                null !== i && (i.needsUpdate = !0)
            }
            clone() {
                return new yl(this.bones, this.boneInverses)
            }
            computeBoneTexture() {
                let e = Math.sqrt(4 * this.bones.length);
                e = 4 * Math.ceil(e / 4), e = Math.max(e, 4);
                const t = new Float32Array(e * e * 4);
                t.set(this.boneMatrices);
                const n = new vl(t, e, e, ht, lt);
                return n.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = n, this
            }
            getBoneByName(e) {
                for (let t = 0, n = this.bones.length; t < n; t++) {
                    const n = this.bones[t];
                    if (n.name === e) return n
                }
            }
            dispose() {
                null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null)
            }
            fromJSON(e, t) {
                this.uuid = e.uuid;
                for (let n = 0, i = e.bones.length; n < i; n++) {
                    const i = e.bones[n];
                    let r = t[i];
                    void 0 === r && (console.warn("THREE.Skeleton: No bone found with UUID:", i), r = new Sl), this.bones.push(r), this.boneInverses.push((new mi).fromArray(e.boneInverses[n]))
                }
                return this.init(), this
            }
            toJSON() {
                const e = {
                    metadata: {
                        version: 4.6,
                        type: "Skeleton",
                        generator: "Skeleton.toJSON"
                    },
                    bones: [],
                    boneInverses: []
                };
                e.uuid = this.uuid;
                const t = this.bones,
                    n = this.boneInverses;
                for (let i = 0, r = t.length; i < r; i++) {
                    const r = t[i];
                    e.bones.push(r.uuid);
                    const o = n[i];
                    e.boneInverses.push(o.toArray())
                }
                return e
            }
        }
        class wl extends Er {
            constructor(e, t, n, i = 1) {
                super(e, t, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = i
            }
            copy(e) {
                return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
            }
            toJSON() {
                const e = super.toJSON();
                return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e
            }
        }
        const bl = new mi,
            Ql = new mi,
            Ul = [],
            Ml = new qn,
            Rl = new mi,
            Tl = new Jr,
            Fl = new li;
        class Dl extends Jr {
            constructor(e, t, n) {
                super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new wl(new Float32Array(16 * n), 16), this.instanceColor = null, this.morphTexture = null, this.count = n, this.boundingBox = null, this.boundingSphere = null;
                for (let e = 0; e < n; e++) this.setMatrixAt(e, Rl)
            }
            computeBoundingBox() {
                const e = this.geometry,
                    t = this.count;
                null === this.boundingBox && (this.boundingBox = new qn), null === e.boundingBox && e.computeBoundingBox(), this.boundingBox.makeEmpty();
                for (let n = 0; n < t; n++) this.getMatrixAt(n, bl), Ml.copy(e.boundingBox).applyMatrix4(bl), this.boundingBox.union(Ml)
            }
            computeBoundingSphere() {
                const e = this.geometry,
                    t = this.count;
                null === this.boundingSphere && (this.boundingSphere = new li), null === e.boundingSphere && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
                for (let n = 0; n < t; n++) this.getMatrixAt(n, bl), Fl.copy(e.boundingSphere).applyMatrix4(bl), this.boundingSphere.union(Fl)
            }
            copy(e, t) {
                return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), null !== e.morphTexture && (this.morphTexture = e.morphTexture.clone()), null !== e.instanceColor && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this
            }
            getColorAt(e, t) {
                t.fromArray(this.instanceColor.array, 3 * e)
            }
            getMatrixAt(e, t) {
                t.fromArray(this.instanceMatrix.array, 16 * e)
            }
            getMorphAt(e, t) {
                const n = t.morphTargetInfluences,
                    i = this.morphTexture.source.data.data,
                    r = e * (n.length + 1) + 1;
                for (let e = 0; e < n.length; e++) n[e] = i[r + e]
            }
            raycast(e, t) {
                const n = this.matrixWorld,
                    i = this.count;
                if (Tl.geometry = this.geometry, Tl.material = this.material, void 0 !== Tl.material && (null === this.boundingSphere && this.computeBoundingSphere(), Fl.copy(this.boundingSphere), Fl.applyMatrix4(n), !1 !== e.ray.intersectsSphere(Fl)))
                    for (let r = 0; r < i; r++) {
                        this.getMatrixAt(r, bl), Ql.multiplyMatrices(n, bl), Tl.matrixWorld = Ql, Tl.raycast(e, Ul);
                        for (let e = 0, n = Ul.length; e < n; e++) {
                            const n = Ul[e];
                            n.instanceId = r, n.object = this, t.push(n)
                        }
                        Ul.length = 0
                    }
            }
            setColorAt(e, t) {
                null === this.instanceColor && (this.instanceColor = new wl(new Float32Array(3 * this.instanceMatrix.count), 3)), t.toArray(this.instanceColor.array, 3 * e)
            }
            setMatrixAt(e, t) {
                t.toArray(this.instanceMatrix.array, 16 * e)
            }
            setMorphAt(e, t) {
                const n = t.morphTargetInfluences,
                    i = n.length + 1;
                null === this.morphTexture && (this.morphTexture = new vl(new Float32Array(i * this.count), i, this.count, gt, lt));
                const r = this.morphTexture.source.data.data;
                let o = 0;
                for (let e = 0; e < n.length; e++) o += n[e];
                const s = this.geometry.morphTargetsRelative ? 1 : 1 - o,
                    a = i * e;
                r[a] = s, r.set(n, a + 1)
            }
            updateMorphTargets() {}
            dispose() {
                return this.dispatchEvent({
                    type: "dispose"
                }), null !== this.morphTexture && (this.morphTexture.dispose(), this.morphTexture = null), this
            }
        }
        class kl extends cr {
            constructor(e) {
                super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new sr(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this
            }
        }
        const Ll = new On,
            Kl = new On,
            Pl = new mi,
            Gl = new fi,
            Vl = new li,
            Ol = new On,
            Nl = new On;
        class Hl extends qi {
            constructor(e = new Ur, t = new kl) {
                super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets()
            }
            copy(e, t) {
                return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this
            }
            computeLineDistances() {
                const e = this.geometry;
                if (null === e.index) {
                    const t = e.attributes.position,
                        n = [0];
                    for (let e = 1, i = t.count; e < i; e++) Ll.fromBufferAttribute(t, e - 1), Kl.fromBufferAttribute(t, e), n[e] = n[e - 1], n[e] += Ll.distanceTo(Kl);
                    e.setAttribute("lineDistance", new Sr(n, 1))
                } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                return this
            }
            raycast(e, t) {
                const n = this.geometry,
                    i = this.matrixWorld,
                    r = e.params.Line.threshold,
                    o = n.drawRange;
                if (null === n.boundingSphere && n.computeBoundingSphere(), Vl.copy(n.boundingSphere), Vl.applyMatrix4(i), Vl.radius += r, !1 === e.ray.intersectsSphere(Vl)) return;
                Pl.copy(i).invert(), Gl.copy(e.ray).applyMatrix4(Pl);
                const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                    a = s * s,
                    l = this.isLineSegments ? 2 : 1,
                    c = n.index,
                    A = n.attributes.position;
                if (null !== c) {
                    const n = Math.max(0, o.start),
                        i = Math.min(c.count, o.start + o.count);
                    for (let r = n, o = i - 1; r < o; r += l) {
                        const n = c.getX(r),
                            i = c.getX(r + 1),
                            o = ql(this, e, Gl, a, n, i);
                        o && t.push(o)
                    }
                    if (this.isLineLoop) {
                        const r = c.getX(i - 1),
                            o = c.getX(n),
                            s = ql(this, e, Gl, a, r, o);
                        s && t.push(s)
                    }
                } else {
                    const n = Math.max(0, o.start),
                        i = Math.min(A.count, o.start + o.count);
                    for (let r = n, o = i - 1; r < o; r += l) {
                        const n = ql(this, e, Gl, a, r, r + 1);
                        n && t.push(n)
                    }
                    if (this.isLineLoop) {
                        const r = ql(this, e, Gl, a, i - 1, n);
                        r && t.push(r)
                    }
                }
            }
            updateMorphTargets() {
                const e = this.geometry.morphAttributes,
                    t = Object.keys(e);
                if (t.length > 0) {
                    const n = e[t[0]];
                    if (void 0 !== n) {
                        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                        for (let e = 0, t = n.length; e < t; e++) {
                            const t = n[e].name || String(e);
                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = e
                        }
                    }
                }
            }
        }

        function ql(e, t, n, i, r, o) {
            const s = e.geometry.attributes.position;
            Ll.fromBufferAttribute(s, r), Kl.fromBufferAttribute(s, o);
            if (n.distanceSqToSegment(Ll, Kl, Ol, Nl) > i) return;
            Ol.applyMatrix4(e.matrixWorld);
            const a = t.ray.origin.distanceTo(Ol);
            return a < t.near || a > t.far ? void 0 : {
                distance: a,
                point: Nl.clone().applyMatrix4(e.matrixWorld),
                index: r,
                face: null,
                faceIndex: null,
                object: e
            }
        }
        const jl = new On,
            Yl = new On;
        class Jl extends Hl {
            constructor(e, t) {
                super(e, t), this.isLineSegments = !0, this.type = "LineSegments"
            }
            computeLineDistances() {
                const e = this.geometry;
                if (null === e.index) {
                    const t = e.attributes.position,
                        n = [];
                    for (let e = 0, i = t.count; e < i; e += 2) jl.fromBufferAttribute(t, e), Yl.fromBufferAttribute(t, e + 1), n[e] = 0 === e ? 0 : n[e - 1], n[e + 1] = n[e] + jl.distanceTo(Yl);
                    e.setAttribute("lineDistance", new Sr(n, 1))
                } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                return this
            }
        }
        class Wl extends Hl {
            constructor(e, t) {
                super(e, t), this.isLineLoop = !0, this.type = "LineLoop"
            }
        }
        class zl extends cr {
            constructor(e) {
                super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new sr(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this
            }
        }
        const Xl = new mi,
            Zl = new fi,
            _l = new li,
            $l = new On;
        class ec extends qi {
            constructor(e = new Ur, t = new zl) {
                super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets()
            }
            copy(e, t) {
                return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this
            }
            raycast(e, t) {
                const n = this.geometry,
                    i = this.matrixWorld,
                    r = e.params.Points.threshold,
                    o = n.drawRange;
                if (null === n.boundingSphere && n.computeBoundingSphere(), _l.copy(n.boundingSphere), _l.applyMatrix4(i), _l.radius += r, !1 === e.ray.intersectsSphere(_l)) return;
                Xl.copy(i).invert(), Zl.copy(e.ray).applyMatrix4(Xl);
                const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                    a = s * s,
                    l = n.index,
                    c = n.attributes.position;
                if (null !== l) {
                    for (let n = Math.max(0, o.start), r = Math.min(l.count, o.start + o.count); n < r; n++) {
                        const r = l.getX(n);
                        $l.fromBufferAttribute(c, r), tc($l, r, a, i, e, t, this)
                    }
                } else {
                    for (let n = Math.max(0, o.start), r = Math.min(c.count, o.start + o.count); n < r; n++) $l.fromBufferAttribute(c, n), tc($l, n, a, i, e, t, this)
                }
            }
            updateMorphTargets() {
                const e = this.geometry.morphAttributes,
                    t = Object.keys(e);
                if (t.length > 0) {
                    const n = e[t[0]];
                    if (void 0 !== n) {
                        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                        for (let e = 0, t = n.length; e < t; e++) {
                            const t = n[e].name || String(e);
                            this.morphTargetInfluences.push(0), this.morphTargetDictionary[t] = e
                        }
                    }
                }
            }
        }

        function tc(e, t, n, i, r, o, s) {
            const a = Zl.distanceSqToPoint(e);
            if (a < n) {
                const n = new On;
                Zl.closestPointToPoint(e, n), n.applyMatrix4(i);
                const l = r.ray.origin.distanceTo(n);
                if (l < r.near || l > r.far) return;
                o.push({
                    distance: l,
                    distanceToRay: Math.sqrt(a),
                    point: n,
                    index: t,
                    face: null,
                    object: s
                })
            }
        }
        class nc extends Dn {
            constructor(e, t, n, i, r, o, s, a, l) {
                super(e, t, n, i, r, o, s, a, l), this.isVideoTexture = !0, this.minFilter = void 0 !== o ? o : nt, this.magFilter = void 0 !== r ? r : nt, this.generateMipmaps = !1;
                const c = this;
                "requestVideoFrameCallback" in e && e.requestVideoFrameCallback((function t() {
                    c.needsUpdate = !0, e.requestVideoFrameCallback(t)
                }))
            }
            clone() {
                return new this.constructor(this.image).copy(this)
            }
            update() {
                const e = this.image;
                !1 === "requestVideoFrameCallback" in e && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
            }
        }
        class ic extends Dn {
            constructor(e, t, n, i, r, o, s, a, l, c, A, h) {
                super(null, o, s, a, l, c, i, r, A, h), this.isCompressedTexture = !0, this.image = {
                    width: t,
                    height: n
                }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1
            }
        }
        class rc extends ic {
            constructor(e, t, n, i, r, o) {
                super(e, t, n, r, o), this.isCompressedArrayTexture = !0, this.image.depth = i, this.wrapR = Ze
            }
        }
        class oc extends ic {
            constructor(e, t, n) {
                super(void 0, e[0].width, e[0].height, t, n, je), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = e
            }
        }
        class sc {
            constructor() {
                this.type = "Curve", this.arcLengthDivisions = 200
            }
            getPoint() {
                return console.warn("THREE.Curve: .getPoint() not implemented."), null
            }
            getPointAt(e, t) {
                const n = this.getUtoTmapping(e);
                return this.getPoint(n, t)
            }
            getPoints(e = 5) {
                const t = [];
                for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
                return t
            }
            getSpacedPoints(e = 5) {
                const t = [];
                for (let n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
                return t
            }
            getLength() {
                const e = this.getLengths();
                return e[e.length - 1]
            }
            getLengths(e = this.arcLengthDivisions) {
                if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
                this.needsUpdate = !1;
                const t = [];
                let n, i = this.getPoint(0),
                    r = 0;
                t.push(0);
                for (let o = 1; o <= e; o++) n = this.getPoint(o / e), r += n.distanceTo(i), t.push(r), i = n;
                return this.cacheArcLengths = t, t
            }
            updateArcLengths() {
                this.needsUpdate = !0, this.getLengths()
            }
            getUtoTmapping(e, t) {
                const n = this.getLengths();
                let i = 0;
                const r = n.length;
                let o;
                o = t || e * n[r - 1];
                let s, a = 0,
                    l = r - 1;
                for (; a <= l;)
                    if (i = Math.floor(a + (l - a) / 2), s = n[i] - o, s < 0) a = i + 1;
                    else {
                        if (!(s > 0)) {
                            l = i;
                            break
                        }
                        l = i - 1
                    }
                if (i = l, n[i] === o) return i / (r - 1);
                const c = n[i];
                return (i + (o - c) / (n[i + 1] - c)) / (r - 1)
            }
            getTangent(e, t) {
                const n = 1e-4;
                let i = e - n,
                    r = e + n;
                i < 0 && (i = 0), r > 1 && (r = 1);
                const o = this.getPoint(i),
                    s = this.getPoint(r),
                    a = t || (o.isVector2 ? new dn : new On);
                return a.copy(s).sub(o).normalize(), a
            }
            getTangentAt(e, t) {
                const n = this.getUtoTmapping(e);
                return this.getTangent(n, t)
            }
            computeFrenetFrames(e, t) {
                const n = new On,
                    i = [],
                    r = [],
                    o = [],
                    s = new On,
                    a = new mi;
                for (let t = 0; t <= e; t++) {
                    const n = t / e;
                    i[t] = this.getTangentAt(n, new On)
                }
                r[0] = new On, o[0] = new On;
                let l = Number.MAX_VALUE;
                const c = Math.abs(i[0].x),
                    A = Math.abs(i[0].y),
                    h = Math.abs(i[0].z);
                c <= l && (l = c, n.set(1, 0, 0)), A <= l && (l = A, n.set(0, 1, 0)), h <= l && n.set(0, 0, 1), s.crossVectors(i[0], n).normalize(), r[0].crossVectors(i[0], s), o[0].crossVectors(i[0], r[0]);
                for (let t = 1; t <= e; t++) {
                    if (r[t] = r[t - 1].clone(), o[t] = o[t - 1].clone(), s.crossVectors(i[t - 1], i[t]), s.length() > Number.EPSILON) {
                        s.normalize();
                        const e = Math.acos(an(i[t - 1].dot(i[t]), -1, 1));
                        r[t].applyMatrix4(a.makeRotationAxis(s, e))
                    }
                    o[t].crossVectors(i[t], r[t])
                }
                if (!0 === t) {
                    let t = Math.acos(an(r[0].dot(r[e]), -1, 1));
                    t /= e, i[0].dot(s.crossVectors(r[0], r[e])) > 0 && (t = -t);
                    for (let n = 1; n <= e; n++) r[n].applyMatrix4(a.makeRotationAxis(i[n], t * n)), o[n].crossVectors(i[n], r[n])
                }
                return {
                    tangents: i,
                    normals: r,
                    binormals: o
                }
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            copy(e) {
                return this.arcLengthDivisions = e.arcLengthDivisions, this
            }
            toJSON() {
                const e = {
                    metadata: {
                        version: 4.6,
                        type: "Curve",
                        generator: "Curve.toJSON"
                    }
                };
                return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e
            }
            fromJSON(e) {
                return this.arcLengthDivisions = e.arcLengthDivisions, this
            }
        }
        const ac = function(e, t, n = 2) {
            const i = t && t.length,
                r = i ? t[0] * n : e.length;
            let o = lc(e, 0, r, n, !0);
            const s = [];
            if (!o || o.next === o.prev) return s;
            let a, l, c, A, h, u, d;
            if (i && (o = function(e, t, n, i) {
                    const r = [];
                    let o, s, a, l, c;
                    for (o = 0, s = t.length; o < s; o++) a = t[o] * i, l = o < s - 1 ? t[o + 1] * i : e.length, c = lc(e, a, l, i, !1), c === c.next && (c.steiner = !0), r.push(Cc(c));
                    for (r.sort(gc), o = 0; o < r.length; o++) n = fc(r[o], n);
                    return n
                }(e, t, o, n)), e.length > 80 * n) {
                a = c = e[0], l = A = e[1];
                for (let t = n; t < r; t += n) h = e[t], u = e[t + 1], h < a && (a = h), u < l && (l = u), h > c && (c = h), u > A && (A = u);
                d = Math.max(c - a, A - l), d = 0 !== d ? 32767 / d : 0
            }
            return Ac(o, s, n, a, l, d, 0), s
        };

        function lc(e, t, n, i, r) {
            let o, s;
            if (r === function(e, t, n, i) {
                    let r = 0;
                    for (let o = t, s = n - i; o < n; o += i) r += (e[s] - e[o]) * (e[o + 1] + e[s + 1]), s = o;
                    return r
                }(e, t, n, i) > 0)
                for (o = t; o < n; o += i) s = Uc(o, e[o], e[o + 1], s);
            else
                for (o = n - i; o >= t; o -= i) s = Uc(o, e[o], e[o + 1], s);
            return s && Bc(s, s.next) && (Mc(s), s = s.next), s
        }

        function cc(e, t) {
            if (!e) return e;
            t || (t = e);
            let n, i = e;
            do {
                if (n = !1, i.steiner || !Bc(i, i.next) && 0 !== vc(i.prev, i, i.next)) i = i.next;
                else {
                    if (Mc(i), i = t = i.prev, i === i.next) break;
                    n = !0
                }
            } while (n || i !== t);
            return t
        }

        function Ac(e, t, n, i, r, o, s) {
            if (!e) return;
            !s && o && function(e, t, n, i) {
                let r = e;
                do {
                    0 === r.z && (r.z = Ec(r.x, r.y, t, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next
                } while (r !== e);
                r.prevZ.nextZ = null, r.prevZ = null,
                    function(e) {
                        let t, n, i, r, o, s, a, l, c = 1;
                        do {
                            for (n = e, e = null, o = null, s = 0; n;) {
                                for (s++, i = n, a = 0, t = 0; t < c && (a++, i = i.nextZ, i); t++);
                                for (l = c; a > 0 || l > 0 && i;) 0 !== a && (0 === l || !i || n.z <= i.z) ? (r = n, n = n.nextZ, a--) : (r = i, i = i.nextZ, l--), o ? o.nextZ = r : e = r, r.prevZ = o, o = r;
                                n = i
                            }
                            o.nextZ = null, c *= 2
                        } while (s > 1)
                    }(r)
            }(e, i, r, o);
            let a, l, c = e;
            for (; e.prev !== e.next;)
                if (a = e.prev, l = e.next, o ? uc(e, i, r, o) : hc(e)) t.push(a.i / n | 0), t.push(e.i / n | 0), t.push(l.i / n | 0), Mc(e), e = l.next, c = l.next;
                else if ((e = l) === c) {
                s ? 1 === s ? Ac(e = dc(cc(e), t, n), t, n, i, r, o, 2) : 2 === s && pc(e, t, n, i, r, o) : Ac(cc(e), t, n, i, r, o, 1);
                break
            }
        }

        function hc(e) {
            const t = e.prev,
                n = e,
                i = e.next;
            if (vc(t, n, i) >= 0) return !1;
            const r = t.x,
                o = n.x,
                s = i.x,
                a = t.y,
                l = n.y,
                c = i.y,
                A = r < o ? r < s ? r : s : o < s ? o : s,
                h = a < l ? a < c ? a : c : l < c ? l : c,
                u = r > o ? r > s ? r : s : o > s ? o : s,
                d = a > l ? a > c ? a : c : l > c ? l : c;
            let p = i.next;
            for (; p !== t;) {
                if (p.x >= A && p.x <= u && p.y >= h && p.y <= d && Ic(r, a, o, l, s, c, p.x, p.y) && vc(p.prev, p, p.next) >= 0) return !1;
                p = p.next
            }
            return !0
        }

        function uc(e, t, n, i) {
            const r = e.prev,
                o = e,
                s = e.next;
            if (vc(r, o, s) >= 0) return !1;
            const a = r.x,
                l = o.x,
                c = s.x,
                A = r.y,
                h = o.y,
                u = s.y,
                d = a < l ? a < c ? a : c : l < c ? l : c,
                p = A < h ? A < u ? A : u : h < u ? h : u,
                g = a > l ? a > c ? a : c : l > c ? l : c,
                f = A > h ? A > u ? A : u : h > u ? h : u,
                m = Ec(d, p, t, n, i),
                E = Ec(g, f, t, n, i);
            let C = e.prevZ,
                I = e.nextZ;
            for (; C && C.z >= m && I && I.z <= E;) {
                if (C.x >= d && C.x <= g && C.y >= p && C.y <= f && C !== r && C !== s && Ic(a, A, l, h, c, u, C.x, C.y) && vc(C.prev, C, C.next) >= 0) return !1;
                if (C = C.prevZ, I.x >= d && I.x <= g && I.y >= p && I.y <= f && I !== r && I !== s && Ic(a, A, l, h, c, u, I.x, I.y) && vc(I.prev, I, I.next) >= 0) return !1;
                I = I.nextZ
            }
            for (; C && C.z >= m;) {
                if (C.x >= d && C.x <= g && C.y >= p && C.y <= f && C !== r && C !== s && Ic(a, A, l, h, c, u, C.x, C.y) && vc(C.prev, C, C.next) >= 0) return !1;
                C = C.prevZ
            }
            for (; I && I.z <= E;) {
                if (I.x >= d && I.x <= g && I.y >= p && I.y <= f && I !== r && I !== s && Ic(a, A, l, h, c, u, I.x, I.y) && vc(I.prev, I, I.next) >= 0) return !1;
                I = I.nextZ
            }
            return !0
        }

        function dc(e, t, n) {
            let i = e;
            do {
                const r = i.prev,
                    o = i.next.next;
                !Bc(r, o) && xc(r, i, i.next, o) && bc(r, o) && bc(o, r) && (t.push(r.i / n | 0), t.push(i.i / n | 0), t.push(o.i / n | 0), Mc(i), Mc(i.next), i = e = o), i = i.next
            } while (i !== e);
            return cc(i)
        }

        function pc(e, t, n, i, r, o) {
            let s = e;
            do {
                let e = s.next.next;
                for (; e !== s.prev;) {
                    if (s.i !== e.i && Sc(s, e)) {
                        let a = Qc(s, e);
                        return s = cc(s, s.next), a = cc(a, a.next), Ac(s, t, n, i, r, o, 0), void Ac(a, t, n, i, r, o, 0)
                    }
                    e = e.next
                }
                s = s.next
            } while (s !== e)
        }

        function gc(e, t) {
            return e.x - t.x
        }

        function fc(e, t) {
            const n = function(e, t) {
                let n, i = t,
                    r = -1 / 0;
                const o = e.x,
                    s = e.y;
                do {
                    if (s <= i.y && s >= i.next.y && i.next.y !== i.y) {
                        const e = i.x + (s - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
                        if (e <= o && e > r && (r = e, n = i.x < i.next.x ? i : i.next, e === o)) return n
                    }
                    i = i.next
                } while (i !== t);
                if (!n) return null;
                const a = n,
                    l = n.x,
                    c = n.y;
                let A, h = 1 / 0;
                i = n;
                do {
                    o >= i.x && i.x >= l && o !== i.x && Ic(s < c ? o : r, s, l, c, s < c ? r : o, s, i.x, i.y) && (A = Math.abs(s - i.y) / (o - i.x), bc(i, e) && (A < h || A === h && (i.x > n.x || i.x === n.x && mc(n, i))) && (n = i, h = A)), i = i.next
                } while (i !== a);
                return n
            }(e, t);
            if (!n) return t;
            const i = Qc(n, e);
            return cc(i, i.next), cc(n, n.next)
        }

        function mc(e, t) {
            return vc(e.prev, e, t.prev) < 0 && vc(t.next, e, e.next) < 0
        }

        function Ec(e, t, n, i, r) {
            return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - n) * r | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - i) * r | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
        }

        function Cc(e) {
            let t = e,
                n = e;
            do {
                (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t), t = t.next
            } while (t !== e);
            return n
        }

        function Ic(e, t, n, i, r, o, s, a) {
            return (r - s) * (t - a) >= (e - s) * (o - a) && (e - s) * (i - a) >= (n - s) * (t - a) && (n - s) * (o - a) >= (r - s) * (i - a)
        }

        function Sc(e, t) {
            return e.next.i !== t.i && e.prev.i !== t.i && ! function(e, t) {
                let n = e;
                do {
                    if (n.i !== e.i && n.next.i !== e.i && n.i !== t.i && n.next.i !== t.i && xc(n, n.next, e, t)) return !0;
                    n = n.next
                } while (n !== e);
                return !1
            }(e, t) && (bc(e, t) && bc(t, e) && function(e, t) {
                let n = e,
                    i = !1;
                const r = (e.x + t.x) / 2,
                    o = (e.y + t.y) / 2;
                do {
                    n.y > o != n.next.y > o && n.next.y !== n.y && r < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next
                } while (n !== e);
                return i
            }(e, t) && (vc(e.prev, e, t.prev) || vc(e, t.prev, t)) || Bc(e, t) && vc(e.prev, e, e.next) > 0 && vc(t.prev, t, t.next) > 0)
        }

        function vc(e, t, n) {
            return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y)
        }

        function Bc(e, t) {
            return e.x === t.x && e.y === t.y
        }

        function xc(e, t, n, i) {
            const r = wc(vc(e, t, n)),
                o = wc(vc(e, t, i)),
                s = wc(vc(n, i, e)),
                a = wc(vc(n, i, t));
            return r !== o && s !== a || (!(0 !== r || !yc(e, n, t)) || (!(0 !== o || !yc(e, i, t)) || (!(0 !== s || !yc(n, e, i)) || !(0 !== a || !yc(n, t, i)))))
        }

        function yc(e, t, n) {
            return t.x <= Math.max(e.x, n.x) && t.x >= Math.min(e.x, n.x) && t.y <= Math.max(e.y, n.y) && t.y >= Math.min(e.y, n.y)
        }

        function wc(e) {
            return e > 0 ? 1 : e < 0 ? -1 : 0
        }

        function bc(e, t) {
            return vc(e.prev, e, e.next) < 0 ? vc(e, t, e.next) >= 0 && vc(e, e.prev, t) >= 0 : vc(e, t, e.prev) < 0 || vc(e, e.next, t) < 0
        }

        function Qc(e, t) {
            const n = new Rc(e.i, e.x, e.y),
                i = new Rc(t.i, t.x, t.y),
                r = e.next,
                o = t.prev;
            return e.next = t, t.prev = e, n.next = r, r.prev = n, i.next = n, n.prev = i, o.next = i, i.prev = o, i
        }

        function Uc(e, t, n, i) {
            const r = new Rc(e, t, n);
            return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r
        }

        function Mc(e) {
            e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ)
        }

        function Rc(e, t, n) {
            this.i = e, this.x = t, this.y = n, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1
        }
        class Tc {
            static area(e) {
                const t = e.length;
                let n = 0;
                for (let i = t - 1, r = 0; r < t; i = r++) n += e[i].x * e[r].y - e[r].x * e[i].y;
                return .5 * n
            }
            static isClockWise(e) {
                return Tc.area(e) < 0
            }
            static triangulateShape(e, t) {
                const n = [],
                    i = [],
                    r = [];
                Fc(e), Dc(n, e);
                let o = e.length;
                t.forEach(Fc);
                for (let e = 0; e < t.length; e++) i.push(o), o += t[e].length, Dc(n, t[e]);
                const s = ac(n, i);
                for (let e = 0; e < s.length; e += 3) r.push(s.slice(e, e + 3));
                return r
            }
        }

        function Fc(e) {
            const t = e.length;
            t > 2 && e[t - 1].equals(e[0]) && e.pop()
        }

        function Dc(e, t) {
            for (let n = 0; n < t.length; n++) e.push(t[n].x), e.push(t[n].y)
        }
        class kc extends Ur {
            constructor(e = 1, t = 32, n = 16, i = 0, r = 2 * Math.PI, o = 0, s = Math.PI) {
                super(), this.type = "SphereGeometry", this.parameters = {
                    radius: e,
                    widthSegments: t,
                    heightSegments: n,
                    phiStart: i,
                    phiLength: r,
                    thetaStart: o,
                    thetaLength: s
                }, t = Math.max(3, Math.floor(t)), n = Math.max(2, Math.floor(n));
                const a = Math.min(o + s, Math.PI);
                let l = 0;
                const c = [],
                    A = new On,
                    h = new On,
                    u = [],
                    d = [],
                    p = [],
                    g = [];
                for (let u = 0; u <= n; u++) {
                    const f = [],
                        m = u / n;
                    let E = 0;
                    0 === u && 0 === o ? E = .5 / t : u === n && a === Math.PI && (E = -.5 / t);
                    for (let n = 0; n <= t; n++) {
                        const a = n / t;
                        A.x = -e * Math.cos(i + a * r) * Math.sin(o + m * s), A.y = e * Math.cos(o + m * s), A.z = e * Math.sin(i + a * r) * Math.sin(o + m * s), d.push(A.x, A.y, A.z), h.copy(A).normalize(), p.push(h.x, h.y, h.z), g.push(a + E, 1 - m), f.push(l++)
                    }
                    c.push(f)
                }
                for (let e = 0; e < n; e++)
                    for (let i = 0; i < t; i++) {
                        const t = c[e][i + 1],
                            r = c[e][i],
                            s = c[e + 1][i],
                            l = c[e + 1][i + 1];
                        (0 !== e || o > 0) && u.push(t, r, l), (e !== n - 1 || a < Math.PI) && u.push(r, s, l)
                    }
                this.setIndex(u), this.setAttribute("position", new Sr(d, 3)), this.setAttribute("normal", new Sr(p, 3)), this.setAttribute("uv", new Sr(g, 2))
            }
            copy(e) {
                return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
            }
            static fromJSON(e) {
                return new kc(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength)
            }
        }
        class Lc extends cr {
            constructor(e) {
                super(), this.isMeshStandardMaterial = !0, this.defines = {
                    STANDARD: ""
                }, this.type = "MeshStandardMaterial", this.color = new sr(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new sr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new dn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new bi, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.defines = {
                    STANDARD: ""
                }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
            }
        }
        class Kc extends Lc {
            constructor(e) {
                super(), this.isMeshPhysicalMaterial = !0, this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new dn(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
                    get: function() {
                        return an(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                    },
                    set: function(e) {
                        this.ior = (1 + .4 * e) / (1 - .4 * e)
                    }
                }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new sr(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new sr(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new sr(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e)
            }
            get anisotropy() {
                return this._anisotropy
            }
            set anisotropy(e) {
                this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e
            }
            get clearcoat() {
                return this._clearcoat
            }
            set clearcoat(e) {
                this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e
            }
            get iridescence() {
                return this._iridescence
            }
            set iridescence(e) {
                this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e
            }
            get dispersion() {
                return this._dispersion
            }
            set dispersion(e) {
                this._dispersion > 0 != e > 0 && this.version++, this._dispersion = e
            }
            get sheen() {
                return this._sheen
            }
            set sheen(e) {
                this._sheen > 0 != e > 0 && this.version++, this._sheen = e
            }
            get transmission() {
                return this._transmission
            }
            set transmission(e) {
                this._transmission > 0 != e > 0 && this.version++, this._transmission = e
            }
            copy(e) {
                return super.copy(e), this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.dispersion = e.dispersion, this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this
            }
        }
        class Pc extends cr {
            constructor(e) {
                super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new sr(16777215), this.specular = new sr(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new sr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new dn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new bi, this.combine = Fe, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
            }
        }
        class Gc extends cr {
            constructor(e) {
                super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new sr(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new sr(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new dn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new bi, this.combine = Fe, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
            }
            copy(e) {
                return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
            }
        }

        function Vc(e, t, n) {
            return !e || !n && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
        }

        function Oc(e) {
            return ArrayBuffer.isView(e) && !(e instanceof DataView)
        }

        function Nc(e) {
            const t = e.length,
                n = new Array(t);
            for (let e = 0; e !== t; ++e) n[e] = e;
            return n.sort((function(t, n) {
                return e[t] - e[n]
            })), n
        }

        function Hc(e, t, n) {
            const i = e.length,
                r = new e.constructor(i);
            for (let o = 0, s = 0; s !== i; ++o) {
                const i = n[o] * t;
                for (let n = 0; n !== t; ++n) r[s++] = e[i + n]
            }
            return r
        }

        function qc(e, t, n, i) {
            let r = 1,
                o = e[0];
            for (; void 0 !== o && void 0 === o[i];) o = e[r++];
            if (void 0 === o) return;
            let s = o[i];
            if (void 0 !== s)
                if (Array.isArray(s))
                    do {
                        s = o[i], void 0 !== s && (t.push(o.time), n.push.apply(n, s)), o = e[r++]
                    } while (void 0 !== o);
                else if (void 0 !== s.toArray)
                do {
                    s = o[i], void 0 !== s && (t.push(o.time), s.toArray(n, n.length)), o = e[r++]
                } while (void 0 !== o);
            else
                do {
                    s = o[i], void 0 !== s && (t.push(o.time), n.push(s)), o = e[r++]
                } while (void 0 !== o)
        }
        class jc {
            constructor(e, t, n, i) {
                this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {}
            }
            evaluate(e) {
                const t = this.parameterPositions;
                let n = this._cachedIndex,
                    i = t[n],
                    r = t[n - 1];
                e: {
                    t: {
                        let o;n: {
                            i: if (!(e < i)) {
                                for (let o = n + 2;;) {
                                    if (void 0 === i) {
                                        if (e < r) break i;
                                        return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1)
                                    }
                                    if (n === o) break;
                                    if (r = i, i = t[++n], e < i) break t
                                }
                                o = t.length;
                                break n
                            }if (e >= r) break e; {
                                const s = t[1];
                                e < s && (n = 2, r = s);
                                for (let o = n - 2;;) {
                                    if (void 0 === r) return this._cachedIndex = 0, this.copySampleValue_(0);
                                    if (n === o) break;
                                    if (i = r, r = t[--n - 1], e >= r) break t
                                }
                                o = n, n = 0
                            }
                        }
                        for (; n < o;) {
                            const i = n + o >>> 1;
                            e < t[i] ? o = i : n = i + 1
                        }
                        if (i = t[n], r = t[n - 1], void 0 === r) return this._cachedIndex = 0, this.copySampleValue_(0);
                        if (void 0 === i) return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1)
                    }
                    this._cachedIndex = n,
                    this.intervalChanged_(n, r, i)
                }
                return this.interpolate_(n, r, e, i)
            }
            getSettings_() {
                return this.settings || this.DefaultSettings_
            }
            copySampleValue_(e) {
                const t = this.resultBuffer,
                    n = this.sampleValues,
                    i = this.valueSize,
                    r = e * i;
                for (let e = 0; e !== i; ++e) t[e] = n[r + e];
                return t
            }
            interpolate_() {
                throw new Error("call to abstract method")
            }
            intervalChanged_() {}
        }
        class Yc extends jc {
            constructor(e, t, n, i) {
                super(e, t, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
                    endingStart: Dt,
                    endingEnd: Dt
                }
            }
            intervalChanged_(e, t, n) {
                const i = this.parameterPositions;
                let r = e - 2,
                    o = e + 1,
                    s = i[r],
                    a = i[o];
                if (void 0 === s) switch (this.getSettings_().endingStart) {
                    case kt:
                        r = e, s = 2 * t - n;
                        break;
                    case Lt:
                        r = i.length - 2, s = t + i[r] - i[r + 1];
                        break;
                    default:
                        r = e, s = n
                }
                if (void 0 === a) switch (this.getSettings_().endingEnd) {
                    case kt:
                        o = e, a = 2 * n - t;
                        break;
                    case Lt:
                        o = 1, a = n + i[1] - i[0];
                        break;
                    default:
                        o = e - 1, a = t
                }
                const l = .5 * (n - t),
                    c = this.valueSize;
                this._weightPrev = l / (t - s), this._weightNext = l / (a - n), this._offsetPrev = r * c, this._offsetNext = o * c
            }
            interpolate_(e, t, n, i) {
                const r = this.resultBuffer,
                    o = this.sampleValues,
                    s = this.valueSize,
                    a = e * s,
                    l = a - s,
                    c = this._offsetPrev,
                    A = this._offsetNext,
                    h = this._weightPrev,
                    u = this._weightNext,
                    d = (n - t) / (i - t),
                    p = d * d,
                    g = p * d,
                    f = -h * g + 2 * h * p - h * d,
                    m = (1 + h) * g + (-1.5 - 2 * h) * p + (-.5 + h) * d + 1,
                    E = (-1 - u) * g + (1.5 + u) * p + .5 * d,
                    C = u * g - u * p;
                for (let e = 0; e !== s; ++e) r[e] = f * o[c + e] + m * o[l + e] + E * o[a + e] + C * o[A + e];
                return r
            }
        }
        class Jc extends jc {
            constructor(e, t, n, i) {
                super(e, t, n, i)
            }
            interpolate_(e, t, n, i) {
                const r = this.resultBuffer,
                    o = this.sampleValues,
                    s = this.valueSize,
                    a = e * s,
                    l = a - s,
                    c = (n - t) / (i - t),
                    A = 1 - c;
                for (let e = 0; e !== s; ++e) r[e] = o[l + e] * A + o[a + e] * c;
                return r
            }
        }
        class Wc extends jc {
            constructor(e, t, n, i) {
                super(e, t, n, i)
            }
            interpolate_(e) {
                return this.copySampleValue_(e - 1)
            }
        }
        class zc {
            constructor(e, t, n, i) {
                if (void 0 === e) throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (void 0 === t || 0 === t.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
                this.name = e, this.times = Vc(t, this.TimeBufferType), this.values = Vc(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
            }
            static toJSON(e) {
                const t = e.constructor;
                let n;
                if (t.toJSON !== this.toJSON) n = t.toJSON(e);
                else {
                    n = {
                        name: e.name,
                        times: Vc(e.times, Array),
                        values: Vc(e.values, Array)
                    };
                    const t = e.getInterpolation();
                    t !== e.DefaultInterpolation && (n.interpolation = t)
                }
                return n.type = e.ValueTypeName, n
            }
            InterpolantFactoryMethodDiscrete(e) {
                return new Wc(this.times, this.values, this.getValueSize(), e)
            }
            InterpolantFactoryMethodLinear(e) {
                return new Jc(this.times, this.values, this.getValueSize(), e)
            }
            InterpolantFactoryMethodSmooth(e) {
                return new Yc(this.times, this.values, this.getValueSize(), e)
            }
            setInterpolation(e) {
                let t;
                switch (e) {
                    case Rt:
                        t = this.InterpolantFactoryMethodDiscrete;
                        break;
                    case Tt:
                        t = this.InterpolantFactoryMethodLinear;
                        break;
                    case Ft:
                        t = this.InterpolantFactoryMethodSmooth
                }
                if (void 0 === t) {
                    const t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                    if (void 0 === this.createInterpolant) {
                        if (e === this.DefaultInterpolation) throw new Error(t);
                        this.setInterpolation(this.DefaultInterpolation)
                    }
                    return console.warn("THREE.KeyframeTrack:", t), this
                }
                return this.createInterpolant = t, this
            }
            getInterpolation() {
                switch (this.createInterpolant) {
                    case this.InterpolantFactoryMethodDiscrete:
                        return Rt;
                    case this.InterpolantFactoryMethodLinear:
                        return Tt;
                    case this.InterpolantFactoryMethodSmooth:
                        return Ft
                }
            }
            getValueSize() {
                return this.values.length / this.times.length
            }
            shift(e) {
                if (0 !== e) {
                    const t = this.times;
                    for (let n = 0, i = t.length; n !== i; ++n) t[n] += e
                }
                return this
            }
            scale(e) {
                if (1 !== e) {
                    const t = this.times;
                    for (let n = 0, i = t.length; n !== i; ++n) t[n] *= e
                }
                return this
            }
            trim(e, t) {
                const n = this.times,
                    i = n.length;
                let r = 0,
                    o = i - 1;
                for (; r !== i && n[r] < e;) ++r;
                for (; - 1 !== o && n[o] > t;) --o;
                if (++o, 0 !== r || o !== i) {
                    r >= o && (o = Math.max(o, 1), r = o - 1);
                    const e = this.getValueSize();
                    this.times = n.slice(r, o), this.values = this.values.slice(r * e, o * e)
                }
                return this
            }
            validate() {
                let e = !0;
                const t = this.getValueSize();
                t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
                const n = this.times,
                    i = this.values,
                    r = n.length;
                0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
                let o = null;
                for (let t = 0; t !== r; t++) {
                    const i = n[t];
                    if ("number" == typeof i && isNaN(i)) {
                        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, t, i), e = !1;
                        break
                    }
                    if (null !== o && o > i) {
                        console.error("THREE.KeyframeTrack: Out of order keys.", this, t, i, o), e = !1;
                        break
                    }
                    o = i
                }
                if (void 0 !== i && Oc(i))
                    for (let t = 0, n = i.length; t !== n; ++t) {
                        const n = i[t];
                        if (isNaN(n)) {
                            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, t, n), e = !1;
                            break
                        }
                    }
                return e
            }
            optimize() {
                const e = this.times.slice(),
                    t = this.values.slice(),
                    n = this.getValueSize(),
                    i = this.getInterpolation() === Ft,
                    r = e.length - 1;
                let o = 1;
                for (let s = 1; s < r; ++s) {
                    let r = !1;
                    const a = e[s];
                    if (a !== e[s + 1] && (1 !== s || a !== e[0]))
                        if (i) r = !0;
                        else {
                            const e = s * n,
                                i = e - n,
                                o = e + n;
                            for (let s = 0; s !== n; ++s) {
                                const n = t[e + s];
                                if (n !== t[i + s] || n !== t[o + s]) {
                                    r = !0;
                                    break
                                }
                            }
                        }
                    if (r) {
                        if (s !== o) {
                            e[o] = e[s];
                            const i = s * n,
                                r = o * n;
                            for (let e = 0; e !== n; ++e) t[r + e] = t[i + e]
                        }++o
                    }
                }
                if (r > 0) {
                    e[o] = e[r];
                    for (let e = r * n, i = o * n, s = 0; s !== n; ++s) t[i + s] = t[e + s];
                    ++o
                }
                return o !== e.length ? (this.times = e.slice(0, o), this.values = t.slice(0, o * n)) : (this.times = e, this.values = t), this
            }
            clone() {
                const e = this.times.slice(),
                    t = this.values.slice(),
                    n = new(0, this.constructor)(this.name, e, t);
                return n.createInterpolant = this.createInterpolant, n
            }
        }
        zc.prototype.TimeBufferType = Float32Array, zc.prototype.ValueBufferType = Float32Array, zc.prototype.DefaultInterpolation = Tt;
        class Xc extends zc {}
        Xc.prototype.ValueTypeName = "bool", Xc.prototype.ValueBufferType = Array, Xc.prototype.DefaultInterpolation = Rt, Xc.prototype.InterpolantFactoryMethodLinear = void 0, Xc.prototype.InterpolantFactoryMethodSmooth = void 0;
        class Zc extends zc {}
        Zc.prototype.ValueTypeName = "color";
        class _c extends zc {}
        _c.prototype.ValueTypeName = "number";
        class $c extends jc {
            constructor(e, t, n, i) {
                super(e, t, n, i)
            }
            interpolate_(e, t, n, i) {
                const r = this.resultBuffer,
                    o = this.sampleValues,
                    s = this.valueSize,
                    a = (n - t) / (i - t);
                let l = e * s;
                for (let e = l + s; l !== e; l += 4) Vn.slerpFlat(r, 0, o, l - s, o, l, a);
                return r
            }
        }
        class eA extends zc {
            InterpolantFactoryMethodLinear(e) {
                return new $c(this.times, this.values, this.getValueSize(), e)
            }
        }
        eA.prototype.ValueTypeName = "quaternion", eA.prototype.DefaultInterpolation = Tt, eA.prototype.InterpolantFactoryMethodSmooth = void 0;
        class tA extends zc {}
        tA.prototype.ValueTypeName = "string", tA.prototype.ValueBufferType = Array, tA.prototype.DefaultInterpolation = Rt, tA.prototype.InterpolantFactoryMethodLinear = void 0, tA.prototype.InterpolantFactoryMethodSmooth = void 0;
        class nA extends zc {}
        nA.prototype.ValueTypeName = "vector";
        class iA {
            constructor(e = "", t = -1, n = [], i = Kt) {
                this.name = e, this.tracks = n, this.duration = t, this.blendMode = i, this.uuid = sn(), this.duration < 0 && this.resetDuration()
            }
            static parse(e) {
                const t = [],
                    n = e.tracks,
                    i = 1 / (e.fps || 1);
                for (let e = 0, r = n.length; e !== r; ++e) t.push(rA(n[e]).scale(i));
                const r = new this(e.name, e.duration, t, e.blendMode);
                return r.uuid = e.uuid, r
            }
            static toJSON(e) {
                const t = [],
                    n = e.tracks,
                    i = {
                        name: e.name,
                        duration: e.duration,
                        tracks: t,
                        uuid: e.uuid,
                        blendMode: e.blendMode
                    };
                for (let e = 0, i = n.length; e !== i; ++e) t.push(zc.toJSON(n[e]));
                return i
            }
            static CreateFromMorphTargetSequence(e, t, n, i) {
                const r = t.length,
                    o = [];
                for (let e = 0; e < r; e++) {
                    let s = [],
                        a = [];
                    s.push((e + r - 1) % r, e, (e + 1) % r), a.push(0, 1, 0);
                    const l = Nc(s);
                    s = Hc(s, 1, l), a = Hc(a, 1, l), i || 0 !== s[0] || (s.push(r), a.push(a[0])), o.push(new _c(".morphTargetInfluences[" + t[e].name + "]", s, a).scale(1 / n))
                }
                return new this(e, -1, o)
            }
            static findByName(e, t) {
                let n = e;
                if (!Array.isArray(e)) {
                    const t = e;
                    n = t.geometry && t.geometry.animations || t.animations
                }
                for (let e = 0; e < n.length; e++)
                    if (n[e].name === t) return n[e];
                return null
            }
            static CreateClipsFromMorphTargetSequences(e, t, n) {
                const i = {},
                    r = /^([\w-]*?)([\d]+)$/;
                for (let t = 0, n = e.length; t < n; t++) {
                    const n = e[t],
                        o = n.name.match(r);
                    if (o && o.length > 1) {
                        const e = o[1];
                        let t = i[e];
                        t || (i[e] = t = []), t.push(n)
                    }
                }
                const o = [];
                for (const e in i) o.push(this.CreateFromMorphTargetSequence(e, i[e], t, n));
                return o
            }
            static parseAnimation(e, t) {
                if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                const n = function(e, t, n, i, r) {
                        if (0 !== n.length) {
                            const o = [],
                                s = [];
                            qc(n, o, s, i), 0 !== o.length && r.push(new e(t, o, s))
                        }
                    },
                    i = [],
                    r = e.name || "default",
                    o = e.fps || 30,
                    s = e.blendMode;
                let a = e.length || -1;
                const l = e.hierarchy || [];
                for (let e = 0; e < l.length; e++) {
                    const r = l[e].keys;
                    if (r && 0 !== r.length)
                        if (r[0].morphTargets) {
                            const e = {};
                            let t;
                            for (t = 0; t < r.length; t++)
                                if (r[t].morphTargets)
                                    for (let n = 0; n < r[t].morphTargets.length; n++) e[r[t].morphTargets[n]] = -1;
                            for (const n in e) {
                                const e = [],
                                    o = [];
                                for (let i = 0; i !== r[t].morphTargets.length; ++i) {
                                    const i = r[t];
                                    e.push(i.time), o.push(i.morphTarget === n ? 1 : 0)
                                }
                                i.push(new _c(".morphTargetInfluence[" + n + "]", e, o))
                            }
                            a = e.length * o
                        } else {
                            const o = ".bones[" + t[e].name + "]";
                            n(nA, o + ".position", r, "pos", i), n(eA, o + ".quaternion", r, "rot", i), n(nA, o + ".scale", r, "scl", i)
                        }
                }
                if (0 === i.length) return null;
                return new this(r, a, i, s)
            }
            resetDuration() {
                let e = 0;
                for (let t = 0, n = this.tracks.length; t !== n; ++t) {
                    const n = this.tracks[t];
                    e = Math.max(e, n.times[n.times.length - 1])
                }
                return this.duration = e, this
            }
            trim() {
                for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
                return this
            }
            validate() {
                let e = !0;
                for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
                return e
            }
            optimize() {
                for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
                return this
            }
            clone() {
                const e = [];
                for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
                return new this.constructor(this.name, this.duration, e, this.blendMode)
            }
            toJSON() {
                return this.constructor.toJSON(this)
            }
        }

        function rA(e) {
            if (void 0 === e.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
            const t = function(e) {
                switch (e.toLowerCase()) {
                    case "scalar":
                    case "double":
                    case "float":
                    case "number":
                    case "integer":
                        return _c;
                    case "vector":
                    case "vector2":
                    case "vector3":
                    case "vector4":
                        return nA;
                    case "color":
                        return Zc;
                    case "quaternion":
                        return eA;
                    case "bool":
                    case "boolean":
                        return Xc;
                    case "string":
                        return tA
                }
                throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
            }(e.type);
            if (void 0 === e.times) {
                const t = [],
                    n = [];
                qc(e.keys, t, n, "value"), e.times = t, e.values = n
            }
            return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation)
        }
        const oA = {
            enabled: !1,
            files: {},
            add: function(e, t) {
                !1 !== this.enabled && (this.files[e] = t)
            },
            get: function(e) {
                if (!1 !== this.enabled) return this.files[e]
            },
            remove: function(e) {
                delete this.files[e]
            },
            clear: function() {
                this.files = {}
            }
        };
        class sA {
            constructor(e, t, n) {
                const i = this;
                let r, o = !1,
                    s = 0,
                    a = 0;
                const l = [];
                this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(e) {
                    a++, !1 === o && void 0 !== i.onStart && i.onStart(e, s, a), o = !0
                }, this.itemEnd = function(e) {
                    s++, void 0 !== i.onProgress && i.onProgress(e, s, a), s === a && (o = !1, void 0 !== i.onLoad && i.onLoad())
                }, this.itemError = function(e) {
                    void 0 !== i.onError && i.onError(e)
                }, this.resolveURL = function(e) {
                    return r ? r(e) : e
                }, this.setURLModifier = function(e) {
                    return r = e, this
                }, this.addHandler = function(e, t) {
                    return l.push(e, t), this
                }, this.removeHandler = function(e) {
                    const t = l.indexOf(e);
                    return -1 !== t && l.splice(t, 2), this
                }, this.getHandler = function(e) {
                    for (let t = 0, n = l.length; t < n; t += 2) {
                        const n = l[t],
                            i = l[t + 1];
                        if (n.global && (n.lastIndex = 0), n.test(e)) return i
                    }
                    return null
                }
            }
        }
        const aA = new sA;
        class lA {
            constructor(e) {
                this.manager = void 0 !== e ? e : aA, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
            }
            load() {}
            loadAsync(e, t) {
                const n = this;
                return new Promise((function(i, r) {
                    n.load(e, i, t, r)
                }))
            }
            parse() {}
            setCrossOrigin(e) {
                return this.crossOrigin = e, this
            }
            setWithCredentials(e) {
                return this.withCredentials = e, this
            }
            setPath(e) {
                return this.path = e, this
            }
            setResourcePath(e) {
                return this.resourcePath = e, this
            }
            setRequestHeader(e) {
                return this.requestHeader = e, this
            }
        }
        lA.DEFAULT_MATERIAL_NAME = "__DEFAULT";
        const cA = {};
        class AA extends Error {
            constructor(e, t) {
                super(e), this.response = t
            }
        }
        class hA extends lA {
            constructor(e) {
                super(e)
            }
            load(e, t, n, i) {
                void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                const r = oA.get(e);
                if (void 0 !== r) return this.manager.itemStart(e), setTimeout((() => {
                    t && t(r), this.manager.itemEnd(e)
                }), 0), r;
                if (void 0 !== cA[e]) return void cA[e].push({
                    onLoad: t,
                    onProgress: n,
                    onError: i
                });
                cA[e] = [], cA[e].push({
                    onLoad: t,
                    onProgress: n,
                    onError: i
                });
                const o = new Request(e, {
                        headers: new Headers(this.requestHeader),
                        credentials: this.withCredentials ? "include" : "same-origin"
                    }),
                    s = this.mimeType,
                    a = this.responseType;
                fetch(o).then((t => {
                    if (200 === t.status || 0 === t.status) {
                        if (0 === t.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), "undefined" == typeof ReadableStream || void 0 === t.body || void 0 === t.body.getReader) return t;
                        const n = cA[e],
                            i = t.body.getReader(),
                            r = t.headers.get("X-File-Size") || t.headers.get("Content-Length"),
                            o = r ? parseInt(r) : 0,
                            s = 0 !== o;
                        let a = 0;
                        const l = new ReadableStream({
                            start(e) {
                                ! function t() {
                                    i.read().then((({
                                        done: i,
                                        value: r
                                    }) => {
                                        if (i) e.close();
                                        else {
                                            a += r.byteLength;
                                            const i = new ProgressEvent("progress", {
                                                lengthComputable: s,
                                                loaded: a,
                                                total: o
                                            });
                                            for (let e = 0, t = n.length; e < t; e++) {
                                                const t = n[e];
                                                t.onProgress && t.onProgress(i)
                                            }
                                            e.enqueue(r), t()
                                        }
                                    }))
                                }()
                            }
                        });
                        return new Response(l)
                    }
                    throw new AA(`fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`, t)
                })).then((e => {
                    switch (a) {
                        case "arraybuffer":
                            return e.arrayBuffer();
                        case "blob":
                            return e.blob();
                        case "document":
                            return e.text().then((e => (new DOMParser).parseFromString(e, s)));
                        case "json":
                            return e.json();
                        default:
                            if (void 0 === s) return e.text(); {
                                const t = /charset="?([^;"\s]*)"?/i.exec(s),
                                    n = t && t[1] ? t[1].toLowerCase() : void 0,
                                    i = new TextDecoder(n);
                                return e.arrayBuffer().then((e => i.decode(e)))
                            }
                    }
                })).then((t => {
                    oA.add(e, t);
                    const n = cA[e];
                    delete cA[e];
                    for (let e = 0, i = n.length; e < i; e++) {
                        const i = n[e];
                        i.onLoad && i.onLoad(t)
                    }
                })).catch((t => {
                    const n = cA[e];
                    if (void 0 === n) throw this.manager.itemError(e), t;
                    delete cA[e];
                    for (let e = 0, i = n.length; e < i; e++) {
                        const i = n[e];
                        i.onError && i.onError(t)
                    }
                    this.manager.itemError(e)
                })).finally((() => {
                    this.manager.itemEnd(e)
                })), this.manager.itemStart(e)
            }
            setResponseType(e) {
                return this.responseType = e, this
            }
            setMimeType(e) {
                return this.mimeType = e, this
            }
        }
        class uA extends lA {
            constructor(e) {
                super(e)
            }
            load(e, t, n, i) {
                void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                const r = this,
                    o = oA.get(e);
                if (void 0 !== o) return r.manager.itemStart(e), setTimeout((function() {
                    t && t(o), r.manager.itemEnd(e)
                }), 0), o;
                const s = mn("img");

                function a() {
                    c(), oA.add(e, this), t && t(this), r.manager.itemEnd(e)
                }

                function l(t) {
                    c(), i && i(t), r.manager.itemError(e), r.manager.itemEnd(e)
                }

                function c() {
                    s.removeEventListener("load", a, !1), s.removeEventListener("error", l, !1)
                }
                return s.addEventListener("load", a, !1), s.addEventListener("error", l, !1), "data:" !== e.slice(0, 5) && void 0 !== this.crossOrigin && (s.crossOrigin = this.crossOrigin), r.manager.itemStart(e), s.src = e, s
            }
        }
        class dA extends lA {
            constructor(e) {
                super(e)
            }
            load(e, t, n, i) {
                const r = this,
                    o = new vl,
                    s = new hA(this.manager);
                return s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setPath(this.path), s.setWithCredentials(r.withCredentials), s.load(e, (function(e) {
                    let n;
                    try {
                        n = r.parse(e)
                    } catch (e) {
                        if (void 0 === i) return void console.error(e);
                        i(e)
                    }
                    void 0 !== n.image ? o.image = n.image : void 0 !== n.data && (o.image.width = n.width, o.image.height = n.height, o.image.data = n.data), o.wrapS = void 0 !== n.wrapS ? n.wrapS : Ze, o.wrapT = void 0 !== n.wrapT ? n.wrapT : Ze, o.magFilter = void 0 !== n.magFilter ? n.magFilter : nt, o.minFilter = void 0 !== n.minFilter ? n.minFilter : nt, o.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.colorSpace && (o.colorSpace = n.colorSpace), void 0 !== n.flipY && (o.flipY = n.flipY), void 0 !== n.format && (o.format = n.format), void 0 !== n.type && (o.type = n.type), void 0 !== n.mipmaps && (o.mipmaps = n.mipmaps, o.minFilter = rt), 1 === n.mipmapCount && (o.minFilter = nt), void 0 !== n.generateMipmaps && (o.generateMipmaps = n.generateMipmaps), o.needsUpdate = !0, t && t(o, n)
                }), n, i), o
            }
        }
        class pA extends lA {
            constructor(e) {
                super(e)
            }
            load(e, t, n, i) {
                const r = new Dn,
                    o = new uA(this.manager);
                return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, (function(e) {
                    r.image = e, r.needsUpdate = !0, void 0 !== t && t(r)
                }), n, i), r
            }
        }
        class gA extends qi {
            constructor(e, t = 1) {
                super(), this.isLight = !0, this.type = "Light", this.color = new sr(e), this.intensity = t
            }
            dispose() {}
            copy(e, t) {
                return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this
            }
            toJSON(e) {
                const t = super.toJSON(e);
                return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t
            }
        }
        const fA = new mi,
            mA = new On,
            EA = new On;
        class CA {
            constructor(e) {
                this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new dn(512, 512), this.map = null, this.mapPass = null, this.matrix = new mi, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new mo, this._frameExtents = new dn(1, 1), this._viewportCount = 1, this._viewports = [new kn(0, 0, 1, 1)]
            }
            getViewportCount() {
                return this._viewportCount
            }
            getFrustum() {
                return this._frustum
            }
            updateMatrices(e) {
                const t = this.camera,
                    n = this.matrix;
                mA.setFromMatrixPosition(e.matrixWorld), t.position.copy(mA), EA.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(EA), t.updateMatrixWorld(), fA.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(fA), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(fA)
            }
            getViewport(e) {
                return this._viewports[e]
            }
            getFrameExtents() {
                return this._frameExtents
            }
            dispose() {
                this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
            }
            copy(e) {
                return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
            }
            clone() {
                return (new this.constructor).copy(this)
            }
            toJSON() {
                const e = {};
                return 0 !== this.bias && (e.bias = this.bias), 0 !== this.normalBias && (e.normalBias = this.normalBias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
            }
        }
        class IA extends CA {
            constructor() {
                super(new oo(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1
            }
            updateMatrices(e) {
                const t = this.camera,
                    n = 2 * on * e.angle * this.focus,
                    i = this.mapSize.width / this.mapSize.height,
                    r = e.distance || t.far;
                n === t.fov && i === t.aspect && r === t.far || (t.fov = n, t.aspect = i, t.far = r, t.updateProjectionMatrix()), super.updateMatrices(e)
            }
            copy(e) {
                return super.copy(e), this.focus = e.focus, this
            }
        }
        class SA extends gA {
            constructor(e, t, n = 0, i = Math.PI / 3, r = 0, o = 2) {
                super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(qi.DEFAULT_UP), this.updateMatrix(), this.target = new qi, this.distance = n, this.angle = i, this.penumbra = r, this.decay = o, this.map = null, this.shadow = new IA
            }
            get power() {
                return this.intensity * Math.PI
            }
            set power(e) {
                this.intensity = e / Math.PI
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(e, t) {
                return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
            }
        }
        const vA = new mi,
            BA = new On,
            xA = new On;
        class yA extends CA {
            constructor() {
                super(new oo(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new dn(4, 2), this._viewportCount = 6, this._viewports = [new kn(2, 1, 1, 1), new kn(0, 1, 1, 1), new kn(3, 1, 1, 1), new kn(1, 1, 1, 1), new kn(3, 0, 1, 1), new kn(1, 0, 1, 1)], this._cubeDirections = [new On(1, 0, 0), new On(-1, 0, 0), new On(0, 0, 1), new On(0, 0, -1), new On(0, 1, 0), new On(0, -1, 0)], this._cubeUps = [new On(0, 1, 0), new On(0, 1, 0), new On(0, 1, 0), new On(0, 1, 0), new On(0, 0, 1), new On(0, 0, -1)]
            }
            updateMatrices(e, t = 0) {
                const n = this.camera,
                    i = this.matrix,
                    r = e.distance || n.far;
                r !== n.far && (n.far = r, n.updateProjectionMatrix()), BA.setFromMatrixPosition(e.matrixWorld), n.position.copy(BA), xA.copy(n.position), xA.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(xA), n.updateMatrixWorld(), i.makeTranslation(-BA.x, -BA.y, -BA.z), vA.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(vA)
            }
        }
        class wA extends gA {
            constructor(e, t, n = 0, i = 2) {
                super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new yA
            }
            get power() {
                return 4 * this.intensity * Math.PI
            }
            set power(e) {
                this.intensity = e / (4 * Math.PI)
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(e, t) {
                return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
            }
        }
        class bA extends CA {
            constructor() {
                super(new Fo(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0
            }
        }
        class QA extends gA {
            constructor(e, t) {
                super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(qi.DEFAULT_UP), this.updateMatrix(), this.target = new qi, this.shadow = new bA
            }
            dispose() {
                this.shadow.dispose()
            }
            copy(e) {
                return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
            }
        }
        class UA extends gA {
            constructor(e, t) {
                super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight"
            }
        }
        class MA {
            static decodeText(e) {
                if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(e);
                let t = "";
                for (let n = 0, i = e.length; n < i; n++) t += String.fromCharCode(e[n]);
                try {
                    return decodeURIComponent(escape(t))
                } catch (e) {
                    return t
                }
            }
            static extractUrlBase(e) {
                const t = e.lastIndexOf("/");
                return -1 === t ? "./" : e.slice(0, t + 1)
            }
            static resolveURL(e, t) {
                return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
            }
        }
        class RA extends lA {
            constructor(e) {
                super(e), this.isImageBitmapLoader = !0, "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
                    premultiplyAlpha: "none"
                }
            }
            setOptions(e) {
                return this.options = e, this
            }
            load(e, t, n, i) {
                void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                const r = this,
                    o = oA.get(e);
                if (void 0 !== o) return r.manager.itemStart(e), o.then ? void o.then((n => {
                    t && t(n), r.manager.itemEnd(e)
                })).catch((e => {
                    i && i(e)
                })) : (setTimeout((function() {
                    t && t(o), r.manager.itemEnd(e)
                }), 0), o);
                const s = {};
                s.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", s.headers = this.requestHeader;
                const a = fetch(e, s).then((function(e) {
                    return e.blob()
                })).then((function(e) {
                    return createImageBitmap(e, Object.assign(r.options, {
                        colorSpaceConversion: "none"
                    }))
                })).then((function(n) {
                    return oA.add(e, n), t && t(n), r.manager.itemEnd(e), n
                })).catch((function(t) {
                    i && i(t), oA.remove(e), r.manager.itemError(e), r.manager.itemEnd(e)
                }));
                oA.add(e, a), r.manager.itemStart(e)
            }
        }
        class TA {
            constructor(e = !0) {
                this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
            }
            start() {
                this.startTime = FA(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
            }
            stop() {
                this.getElapsedTime(), this.running = !1, this.autoStart = !1
            }
            getElapsedTime() {
                return this.getDelta(), this.elapsedTime
            }
            getDelta() {
                let e = 0;
                if (this.autoStart && !this.running) return this.start(), 0;
                if (this.running) {
                    const t = FA();
                    e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e
                }
                return e
            }
        }

        function FA() {
            return ("undefined" == typeof performance ? Date : performance).now()
        }
        class DA {
            constructor(e, t, n) {
                let i, r, o;
                switch (this.binding = e, this.valueSize = n, t) {
                    case "quaternion":
                        i = this._slerp, r = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5;
                        break;
                    case "string":
                    case "bool":
                        i = this._select, r = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n);
                        break;
                    default:
                        i = this._lerp, r = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n)
                }
                this._mixBufferRegion = i, this._mixBufferRegionAdditive = r, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
            }
            accumulate(e, t) {
                const n = this.buffer,
                    i = this.valueSize,
                    r = e * i + i;
                let o = this.cumulativeWeight;
                if (0 === o) {
                    for (let e = 0; e !== i; ++e) n[r + e] = n[e];
                    o = t
                } else {
                    o += t;
                    const e = t / o;
                    this._mixBufferRegion(n, r, 0, e, i)
                }
                this.cumulativeWeight = o
            }
            accumulateAdditive(e) {
                const t = this.buffer,
                    n = this.valueSize,
                    i = n * this._addIndex;
                0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(t, i, 0, e, n), this.cumulativeWeightAdditive += e
            }
            apply(e) {
                const t = this.valueSize,
                    n = this.buffer,
                    i = e * t + t,
                    r = this.cumulativeWeight,
                    o = this.cumulativeWeightAdditive,
                    s = this.binding;
                if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
                    const e = t * this._origIndex;
                    this._mixBufferRegion(n, i, e, 1 - r, t)
                }
                o > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t);
                for (let e = t, r = t + t; e !== r; ++e)
                    if (n[e] !== n[e + t]) {
                        s.setValue(n, i);
                        break
                    }
            }
            saveOriginalState() {
                const e = this.binding,
                    t = this.buffer,
                    n = this.valueSize,
                    i = n * this._origIndex;
                e.getValue(t, i);
                for (let e = n, r = i; e !== r; ++e) t[e] = t[i + e % n];
                this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
            }
            restoreOriginalState() {
                const e = 3 * this.valueSize;
                this.binding.setValue(this.buffer, e)
            }
            _setAdditiveIdentityNumeric() {
                const e = this._addIndex * this.valueSize,
                    t = e + this.valueSize;
                for (let n = e; n < t; n++) this.buffer[n] = 0
            }
            _setAdditiveIdentityQuaternion() {
                this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
            }
            _setAdditiveIdentityOther() {
                const e = this._origIndex * this.valueSize,
                    t = this._addIndex * this.valueSize;
                for (let n = 0; n < this.valueSize; n++) this.buffer[t + n] = this.buffer[e + n]
            }
            _select(e, t, n, i, r) {
                if (i >= .5)
                    for (let i = 0; i !== r; ++i) e[t + i] = e[n + i]
            }
            _slerp(e, t, n, i) {
                Vn.slerpFlat(e, t, e, t, e, n, i)
            }
            _slerpAdditive(e, t, n, i, r) {
                const o = this._workIndex * r;
                Vn.multiplyQuaternionsFlat(e, o, e, t, e, n), Vn.slerpFlat(e, t, e, t, e, o, i)
            }
            _lerp(e, t, n, i, r) {
                const o = 1 - i;
                for (let s = 0; s !== r; ++s) {
                    const r = t + s;
                    e[r] = e[r] * o + e[n + s] * i
                }
            }
            _lerpAdditive(e, t, n, i, r) {
                for (let o = 0; o !== r; ++o) {
                    const r = t + o;
                    e[r] = e[r] + e[n + o] * i
                }
            }
        }
        const kA = "\\[\\]\\.:\\/",
            LA = new RegExp("[" + kA + "]", "g"),
            KA = "[^" + kA + "]",
            PA = "[^" + kA.replace("\\.", "") + "]",
            GA = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", KA) + /(WCOD+)?/.source.replace("WCOD", PA) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", KA) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", KA) + "$"),
            VA = ["material", "materials", "bones", "map"];
        class OA {
            constructor(e, t, n) {
                this.path = t, this.parsedPath = n || OA.parseTrackName(t), this.node = OA.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
            }
            static create(e, t, n) {
                return e && e.isAnimationObjectGroup ? new OA.Composite(e, t, n) : new OA(e, t, n)
            }
            static sanitizeNodeName(e) {
                return e.replace(/\s/g, "_").replace(LA, "")
            }
            static parseTrackName(e) {
                const t = GA.exec(e);
                if (null === t) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
                const n = {
                        nodeName: t[2],
                        objectName: t[3],
                        objectIndex: t[4],
                        propertyName: t[5],
                        propertyIndex: t[6]
                    },
                    i = n.nodeName && n.nodeName.lastIndexOf(".");
                if (void 0 !== i && -1 !== i) {
                    const e = n.nodeName.substring(i + 1); - 1 !== VA.indexOf(e) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = e)
                }
                if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
                return n
            }
            static findNode(e, t) {
                if (void 0 === t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e;
                if (e.skeleton) {
                    const n = e.skeleton.getBoneByName(t);
                    if (void 0 !== n) return n
                }
                if (e.children) {
                    const n = function(e) {
                            for (let i = 0; i < e.length; i++) {
                                const r = e[i];
                                if (r.name === t || r.uuid === t) return r;
                                const o = n(r.children);
                                if (o) return o
                            }
                            return null
                        },
                        i = n(e.children);
                    if (i) return i
                }
                return null
            }
            _getValue_unavailable() {}
            _setValue_unavailable() {}
            _getValue_direct(e, t) {
                e[t] = this.targetObject[this.propertyName]
            }
            _getValue_array(e, t) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i) e[t++] = n[i]
            }
            _getValue_arrayElement(e, t) {
                e[t] = this.resolvedProperty[this.propertyIndex]
            }
            _getValue_toArray(e, t) {
                this.resolvedProperty.toArray(e, t)
            }
            _setValue_direct(e, t) {
                this.targetObject[this.propertyName] = e[t]
            }
            _setValue_direct_setNeedsUpdate(e, t) {
                this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
            }
            _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
                this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_array(e, t) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++]
            }
            _setValue_array_setNeedsUpdate(e, t) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
                this.targetObject.needsUpdate = !0
            }
            _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
                const n = this.resolvedProperty;
                for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
                this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_arrayElement(e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t]
            }
            _setValue_arrayElement_setNeedsUpdate(e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
            }
            _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
                this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _setValue_fromArray(e, t) {
                this.resolvedProperty.fromArray(e, t)
            }
            _setValue_fromArray_setNeedsUpdate(e, t) {
                this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
            }
            _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
                this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
            }
            _getValue_unbound(e, t) {
                this.bind(), this.getValue(e, t)
            }
            _setValue_unbound(e, t) {
                this.bind(), this.setValue(e, t)
            }
            bind() {
                let e = this.node;
                const t = this.parsedPath,
                    n = t.objectName,
                    i = t.propertyName;
                let r = t.propertyIndex;
                if (e || (e = OA.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) return void console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
                if (n) {
                    let i = t.objectIndex;
                    switch (n) {
                        case "materials":
                            if (!e.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            if (!e.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                            e = e.material.materials;
                            break;
                        case "bones":
                            if (!e.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                            e = e.skeleton.bones;
                            for (let t = 0; t < e.length; t++)
                                if (e[t].name === i) {
                                    i = t;
                                    break
                                }
                            break;
                        case "map":
                            if ("map" in e) {
                                e = e.map;
                                break
                            }
                            if (!e.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            if (!e.material.map) return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                            e = e.material.map;
                            break;
                        default:
                            if (void 0 === e[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                            e = e[n]
                    }
                    if (void 0 !== i) {
                        if (void 0 === e[i]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                        e = e[i]
                    }
                }
                const o = e[i];
                if (void 0 === o) {
                    const n = t.nodeName;
                    return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + i + " but it wasn't found.", e)
                }
                let s = this.Versioning.None;
                this.targetObject = e, void 0 !== e.needsUpdate ? s = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (s = this.Versioning.MatrixWorldNeedsUpdate);
                let a = this.BindingType.Direct;
                if (void 0 !== r) {
                    if ("morphTargetInfluences" === i) {
                        if (!e.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                        if (!e.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                        void 0 !== e.morphTargetDictionary[r] && (r = e.morphTargetDictionary[r])
                    }
                    a = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = r
                } else void 0 !== o.fromArray && void 0 !== o.toArray ? (a = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (a = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = i;
                this.getValue = this.GetterByBindingType[a], this.setValue = this.SetterByBindingTypeAndVersioning[a][s]
            }
            unbind() {
                this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
            }
        }
        OA.Composite = class {
            constructor(e, t, n) {
                const i = n || OA.parseTrackName(t);
                this._targetGroup = e, this._bindings = e.subscribe_(t, i)
            }
            getValue(e, t) {
                this.bind();
                const n = this._targetGroup.nCachedObjects_,
                    i = this._bindings[n];
                void 0 !== i && i.getValue(e, t)
            }
            setValue(e, t) {
                const n = this._bindings;
                for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i) n[i].setValue(e, t)
            }
            bind() {
                const e = this._bindings;
                for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind()
            }
            unbind() {
                const e = this._bindings;
                for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind()
            }
        }, OA.prototype.BindingType = {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        }, OA.prototype.Versioning = {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        }, OA.prototype.GetterByBindingType = [OA.prototype._getValue_direct, OA.prototype._getValue_array, OA.prototype._getValue_arrayElement, OA.prototype._getValue_toArray], OA.prototype.SetterByBindingTypeAndVersioning = [
            [OA.prototype._setValue_direct, OA.prototype._setValue_direct_setNeedsUpdate, OA.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
            [OA.prototype._setValue_array, OA.prototype._setValue_array_setNeedsUpdate, OA.prototype._setValue_array_setMatrixWorldNeedsUpdate],
            [OA.prototype._setValue_arrayElement, OA.prototype._setValue_arrayElement_setNeedsUpdate, OA.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
            [OA.prototype._setValue_fromArray, OA.prototype._setValue_fromArray_setNeedsUpdate, OA.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
        ];
        class NA {
            constructor(e, t, n = null, i = t.blendMode) {
                this._mixer = e, this._clip = t, this._localRoot = n, this.blendMode = i;
                const r = t.tracks,
                    o = r.length,
                    s = new Array(o),
                    a = {
                        endingStart: Dt,
                        endingEnd: Dt
                    };
                for (let e = 0; e !== o; ++e) {
                    const t = r[e].createInterpolant(null);
                    s[e] = t, t.settings = a
                }
                this._interpolantSettings = a, this._interpolants = s, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = Mt, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
            }
            play() {
                return this._mixer._activateAction(this), this
            }
            stop() {
                return this._mixer._deactivateAction(this), this.reset()
            }
            reset() {
                return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
            }
            isRunning() {
                return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
            }
            isScheduled() {
                return this._mixer._isActiveAction(this)
            }
            startAt(e) {
                return this._startTime = e, this
            }
            setLoop(e, t) {
                return this.loop = e, this.repetitions = t, this
            }
            setEffectiveWeight(e) {
                return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading()
            }
            getEffectiveWeight() {
                return this._effectiveWeight
            }
            fadeIn(e) {
                return this._scheduleFading(e, 0, 1)
            }
            fadeOut(e) {
                return this._scheduleFading(e, 1, 0)
            }
            crossFadeFrom(e, t, n) {
                if (e.fadeOut(t), this.fadeIn(t), n) {
                    const n = this._clip.duration,
                        i = e._clip.duration,
                        r = i / n,
                        o = n / i;
                    e.warp(1, r, t), this.warp(o, 1, t)
                }
                return this
            }
            crossFadeTo(e, t, n) {
                return e.crossFadeFrom(this, t, n)
            }
            stopFading() {
                const e = this._weightInterpolant;
                return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
            }
            setEffectiveTimeScale(e) {
                return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping()
            }
            getEffectiveTimeScale() {
                return this._effectiveTimeScale
            }
            setDuration(e) {
                return this.timeScale = this._clip.duration / e, this.stopWarping()
            }
            syncWith(e) {
                return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping()
            }
            halt(e) {
                return this.warp(this._effectiveTimeScale, 0, e)
            }
            warp(e, t, n) {
                const i = this._mixer,
                    r = i.time,
                    o = this.timeScale;
                let s = this._timeScaleInterpolant;
                null === s && (s = i._lendControlInterpolant(), this._timeScaleInterpolant = s);
                const a = s.parameterPositions,
                    l = s.sampleValues;
                return a[0] = r, a[1] = r + n, l[0] = e / o, l[1] = t / o, this
            }
            stopWarping() {
                const e = this._timeScaleInterpolant;
                return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
            }
            getMixer() {
                return this._mixer
            }
            getClip() {
                return this._clip
            }
            getRoot() {
                return this._localRoot || this._mixer._root
            }
            _update(e, t, n, i) {
                if (!this.enabled) return void this._updateWeight(e);
                const r = this._startTime;
                if (null !== r) {
                    const i = (e - r) * n;
                    i < 0 || 0 === n ? t = 0 : (this._startTime = null, t = n * i)
                }
                t *= this._updateTimeScale(e);
                const o = this._updateTime(t),
                    s = this._updateWeight(e);
                if (s > 0) {
                    const e = this._interpolants,
                        t = this._propertyBindings;
                    if (2501 === this.blendMode)
                        for (let n = 0, i = e.length; n !== i; ++n) e[n].evaluate(o), t[n].accumulateAdditive(s);
                    else
                        for (let n = 0, r = e.length; n !== r; ++n) e[n].evaluate(o), t[n].accumulate(i, s)
                }
            }
            _updateWeight(e) {
                let t = 0;
                if (this.enabled) {
                    t = this.weight;
                    const n = this._weightInterpolant;
                    if (null !== n) {
                        const i = n.evaluate(e)[0];
                        t *= i, e > n.parameterPositions[1] && (this.stopFading(), 0 === i && (this.enabled = !1))
                    }
                }
                return this._effectiveWeight = t, t
            }
            _updateTimeScale(e) {
                let t = 0;
                if (!this.paused) {
                    t = this.timeScale;
                    const n = this._timeScaleInterpolant;
                    if (null !== n) {
                        t *= n.evaluate(e)[0], e > n.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t)
                    }
                }
                return this._effectiveTimeScale = t, t
            }
            _updateTime(e) {
                const t = this._clip.duration,
                    n = this.loop;
                let i = this.time + e,
                    r = this._loopCount;
                const o = 2202 === n;
                if (0 === e) return -1 === r || !o || 1 & ~r ? i : t - i;
                if (n === Ut) {
                    -1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                    e: {
                        if (i >= t) i = t;
                        else {
                            if (!(i < 0)) {
                                this.time = i;
                                break e
                            }
                            i = 0
                        }
                        this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                        this.time = i,
                        this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: e < 0 ? -1 : 1
                        })
                    }
                } else {
                    if (-1 === r && (e >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)), i >= t || i < 0) {
                        const n = Math.floor(i / t);
                        i -= t * n, r += Math.abs(n);
                        const s = this.repetitions - r;
                        if (s <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, i = e > 0 ? t : 0, this.time = i, this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: e > 0 ? 1 : -1
                        });
                        else {
                            if (1 === s) {
                                const t = e < 0;
                                this._setEndings(t, !t, o)
                            } else this._setEndings(!1, !1, o);
                            this._loopCount = r, this.time = i, this._mixer.dispatchEvent({
                                type: "loop",
                                action: this,
                                loopDelta: n
                            })
                        }
                    } else this.time = i;
                    if (o && !(1 & ~r)) return t - i
                }
                return i
            }
            _setEndings(e, t, n) {
                const i = this._interpolantSettings;
                n ? (i.endingStart = kt, i.endingEnd = kt) : (i.endingStart = e ? this.zeroSlopeAtStart ? kt : Dt : Lt, i.endingEnd = t ? this.zeroSlopeAtEnd ? kt : Dt : Lt)
            }
            _scheduleFading(e, t, n) {
                const i = this._mixer,
                    r = i.time;
                let o = this._weightInterpolant;
                null === o && (o = i._lendControlInterpolant(), this._weightInterpolant = o);
                const s = o.parameterPositions,
                    a = o.sampleValues;
                return s[0] = r, a[0] = t, s[1] = r + e, a[1] = n, this
            }
        }
        const HA = new Float32Array(1);
        class qA extends en {
            constructor(e) {
                super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
            }
            _bindAction(e, t) {
                const n = e._localRoot || this._root,
                    i = e._clip.tracks,
                    r = i.length,
                    o = e._propertyBindings,
                    s = e._interpolants,
                    a = n.uuid,
                    l = this._bindingsByRootAndName;
                let c = l[a];
                void 0 === c && (c = {}, l[a] = c);
                for (let e = 0; e !== r; ++e) {
                    const r = i[e],
                        l = r.name;
                    let A = c[l];
                    if (void 0 !== A) ++A.referenceCount, o[e] = A;
                    else {
                        if (A = o[e], void 0 !== A) {
                            null === A._cacheIndex && (++A.referenceCount, this._addInactiveBinding(A, a, l));
                            continue
                        }
                        const i = t && t._propertyBindings[e].binding.parsedPath;
                        A = new DA(OA.create(n, l, i), r.ValueTypeName, r.getValueSize()), ++A.referenceCount, this._addInactiveBinding(A, a, l), o[e] = A
                    }
                    s[e].resultBuffer = A.buffer
                }
            }
            _activateAction(e) {
                if (!this._isActiveAction(e)) {
                    if (null === e._cacheIndex) {
                        const t = (e._localRoot || this._root).uuid,
                            n = e._clip.uuid,
                            i = this._actionsByClip[n];
                        this._bindAction(e, i && i.knownActions[0]), this._addInactiveAction(e, n, t)
                    }
                    const t = e._propertyBindings;
                    for (let e = 0, n = t.length; e !== n; ++e) {
                        const n = t[e];
                        0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState())
                    }
                    this._lendAction(e)
                }
            }
            _deactivateAction(e) {
                if (this._isActiveAction(e)) {
                    const t = e._propertyBindings;
                    for (let e = 0, n = t.length; e !== n; ++e) {
                        const n = t[e];
                        0 == --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n))
                    }
                    this._takeBackAction(e)
                }
            }
            _initMemoryManager() {
                this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                const e = this;
                this.stats = {
                    actions: {
                        get total() {
                            return e._actions.length
                        },
                        get inUse() {
                            return e._nActiveActions
                        }
                    },
                    bindings: {
                        get total() {
                            return e._bindings.length
                        },
                        get inUse() {
                            return e._nActiveBindings
                        }
                    },
                    controlInterpolants: {
                        get total() {
                            return e._controlInterpolants.length
                        },
                        get inUse() {
                            return e._nActiveControlInterpolants
                        }
                    }
                }
            }
            _isActiveAction(e) {
                const t = e._cacheIndex;
                return null !== t && t < this._nActiveActions
            }
            _addInactiveAction(e, t, n) {
                const i = this._actions,
                    r = this._actionsByClip;
                let o = r[t];
                if (void 0 === o) o = {
                    knownActions: [e],
                    actionByRoot: {}
                }, e._byClipCacheIndex = 0, r[t] = o;
                else {
                    const t = o.knownActions;
                    e._byClipCacheIndex = t.length, t.push(e)
                }
                e._cacheIndex = i.length, i.push(e), o.actionByRoot[n] = e
            }
            _removeInactiveAction(e) {
                const t = this._actions,
                    n = t[t.length - 1],
                    i = e._cacheIndex;
                n._cacheIndex = i, t[i] = n, t.pop(), e._cacheIndex = null;
                const r = e._clip.uuid,
                    o = this._actionsByClip,
                    s = o[r],
                    a = s.knownActions,
                    l = a[a.length - 1],
                    c = e._byClipCacheIndex;
                l._byClipCacheIndex = c, a[c] = l, a.pop(), e._byClipCacheIndex = null;
                delete s.actionByRoot[(e._localRoot || this._root).uuid], 0 === a.length && delete o[r], this._removeInactiveBindingsForAction(e)
            }
            _removeInactiveBindingsForAction(e) {
                const t = e._propertyBindings;
                for (let e = 0, n = t.length; e !== n; ++e) {
                    const n = t[e];
                    0 == --n.referenceCount && this._removeInactiveBinding(n)
                }
            }
            _lendAction(e) {
                const t = this._actions,
                    n = e._cacheIndex,
                    i = this._nActiveActions++,
                    r = t[i];
                e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r
            }
            _takeBackAction(e) {
                const t = this._actions,
                    n = e._cacheIndex,
                    i = --this._nActiveActions,
                    r = t[i];
                e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r
            }
            _addInactiveBinding(e, t, n) {
                const i = this._bindingsByRootAndName,
                    r = this._bindings;
                let o = i[t];
                void 0 === o && (o = {}, i[t] = o), o[n] = e, e._cacheIndex = r.length, r.push(e)
            }
            _removeInactiveBinding(e) {
                const t = this._bindings,
                    n = e.binding,
                    i = n.rootNode.uuid,
                    r = n.path,
                    o = this._bindingsByRootAndName,
                    s = o[i],
                    a = t[t.length - 1],
                    l = e._cacheIndex;
                a._cacheIndex = l, t[l] = a, t.pop(), delete s[r], 0 === Object.keys(s).length && delete o[i]
            }
            _lendBinding(e) {
                const t = this._bindings,
                    n = e._cacheIndex,
                    i = this._nActiveBindings++,
                    r = t[i];
                e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r
            }
            _takeBackBinding(e) {
                const t = this._bindings,
                    n = e._cacheIndex,
                    i = --this._nActiveBindings,
                    r = t[i];
                e._cacheIndex = i, t[i] = e, r._cacheIndex = n, t[n] = r
            }
            _lendControlInterpolant() {
                const e = this._controlInterpolants,
                    t = this._nActiveControlInterpolants++;
                let n = e[t];
                return void 0 === n && (n = new Jc(new Float32Array(2), new Float32Array(2), 1, HA), n.__cacheIndex = t, e[t] = n), n
            }
            _takeBackControlInterpolant(e) {
                const t = this._controlInterpolants,
                    n = e.__cacheIndex,
                    i = --this._nActiveControlInterpolants,
                    r = t[i];
                e.__cacheIndex = i, t[i] = e, r.__cacheIndex = n, t[n] = r
            }
            clipAction(e, t, n) {
                const i = t || this._root,
                    r = i.uuid;
                let o = "string" == typeof e ? iA.findByName(i, e) : e;
                const s = null !== o ? o.uuid : e,
                    a = this._actionsByClip[s];
                let l = null;
                if (void 0 === n && (n = null !== o ? o.blendMode : Kt), void 0 !== a) {
                    const e = a.actionByRoot[r];
                    if (void 0 !== e && e.blendMode === n) return e;
                    l = a.knownActions[0], null === o && (o = l._clip)
                }
                if (null === o) return null;
                const c = new NA(this, o, t, n);
                return this._bindAction(c, l), this._addInactiveAction(c, s, r), c
            }
            existingAction(e, t) {
                const n = t || this._root,
                    i = n.uuid,
                    r = "string" == typeof e ? iA.findByName(n, e) : e,
                    o = r ? r.uuid : e,
                    s = this._actionsByClip[o];
                return void 0 !== s && s.actionByRoot[i] || null
            }
            stopAllAction() {
                const e = this._actions;
                for (let t = this._nActiveActions - 1; t >= 0; --t) e[t].stop();
                return this
            }
            update(e) {
                e *= this.timeScale;
                const t = this._actions,
                    n = this._nActiveActions,
                    i = this.time += e,
                    r = Math.sign(e),
                    o = this._accuIndex ^= 1;
                for (let s = 0; s !== n; ++s) {
                    t[s]._update(i, e, r, o)
                }
                const s = this._bindings,
                    a = this._nActiveBindings;
                for (let e = 0; e !== a; ++e) s[e].apply(o);
                return this
            }
            setTime(e) {
                this.time = 0;
                for (let e = 0; e < this._actions.length; e++) this._actions[e].time = 0;
                return this.update(e)
            }
            getRoot() {
                return this._root
            }
            uncacheClip(e) {
                const t = this._actions,
                    n = e.uuid,
                    i = this._actionsByClip,
                    r = i[n];
                if (void 0 !== r) {
                    const e = r.knownActions;
                    for (let n = 0, i = e.length; n !== i; ++n) {
                        const i = e[n];
                        this._deactivateAction(i);
                        const r = i._cacheIndex,
                            o = t[t.length - 1];
                        i._cacheIndex = null, i._byClipCacheIndex = null, o._cacheIndex = r, t[r] = o, t.pop(), this._removeInactiveBindingsForAction(i)
                    }
                    delete i[n]
                }
            }
            uncacheRoot(e) {
                const t = e.uuid,
                    n = this._actionsByClip;
                for (const e in n) {
                    const i = n[e].actionByRoot[t];
                    void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
                }
                const i = this._bindingsByRootAndName[t];
                if (void 0 !== i)
                    for (const e in i) {
                        const t = i[e];
                        t.restoreOriginalState(), this._removeInactiveBinding(t)
                    }
            }
            uncacheAction(e, t) {
                const n = this.existingAction(e, t);
                null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
            }
        }
        class jA {
            constructor(e) {
                this.value = e
            }
            clone() {
                return new jA(void 0 === this.value.clone ? this.value : this.value.clone())
            }
        }
        const YA = new mi;
        class JA {
            constructor(e, t, n = 0, i = 1 / 0) {
                this.ray = new fi(e, t), this.near = n, this.far = i, this.camera = null, this.layers = new Qi, this.params = {
                    Mesh: {},
                    Line: {
                        threshold: 1
                    },
                    LOD: {},
                    Points: {
                        threshold: 1
                    },
                    Sprite: {}
                }
            }
            set(e, t) {
                this.ray.set(e, t)
            }
            setFromCamera(e, t) {
                t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
            }
            setFromXRController(e) {
                return YA.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(YA), this
            }
            intersectObject(e, t = !0, n = []) {
                return zA(e, this, n, t), n.sort(WA), n
            }
            intersectObjects(e, t = !0, n = []) {
                for (let i = 0, r = e.length; i < r; i++) zA(e[i], this, n, t);
                return n.sort(WA), n
            }
        }

        function WA(e, t) {
            return e.distance - t.distance
        }

        function zA(e, t, n, i) {
            if (e.layers.test(t.layers) && e.raycast(t, n), !0 === i) {
                const i = e.children;
                for (let e = 0, r = i.length; e < r; e++) zA(i[e], t, n, !0)
            }
        }
        const XA = new On,
            ZA = new On;
        class _A {
            constructor(e = new On, t = new On) {
                this.start = e, this.end = t
            }
            set(e, t) {
                return this.start.copy(e), this.end.copy(t), this
            }
            copy(e) {
                return this.start.copy(e.start), this.end.copy(e.end), this
            }
            getCenter(e) {
                return e.addVectors(this.start, this.end).multiplyScalar(.5)
            }
            delta(e) {
                return e.subVectors(this.end, this.start)
            }
            distanceSq() {
                return this.start.distanceToSquared(this.end)
            }
            distance() {
                return this.start.distanceTo(this.end)
            }
            at(e, t) {
                return this.delta(t).multiplyScalar(e).add(this.start)
            }
            closestPointToPointParameter(e, t) {
                XA.subVectors(e, this.start), ZA.subVectors(this.end, this.start);
                const n = ZA.dot(ZA);
                let i = ZA.dot(XA) / n;
                return t && (i = an(i, 0, 1)), i
            }
            closestPointToPoint(e, t, n) {
                const i = this.closestPointToPointParameter(e, t);
                return this.delta(n).multiplyScalar(i).add(this.start)
            }
            applyMatrix4(e) {
                return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
            }
            equals(e) {
                return e.start.equals(this.start) && e.end.equals(this.end)
            }
            clone() {
                return (new this.constructor).copy(this)
            }
        }
        "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
            detail: {
                revision: ye
            }
        })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = ye);
        const $A = !1,
            eh = "imported_texture",
            th = (a.Group, a.Water, a.Scene, a.Mesh, l.Box, l.Plane, a.Camera, c.Perspective, c.Orthographic, a.Light, A.Ambient, A.Directional, A.Point, A.Spot, 768),
            nh = 992;

        function ih() {
            return un.generateUUID()
        }
        A.Ambient, A.Directional, A.Point, A.Spot;
        u.Front, u.Back, u.Double, g.Clamp, g.Repeat, g.MirroredRepeat;
        const rh = (e, t) => e.startsWith(t) ? e.substring(t.length) : e,
            oh = (e, t) => e.endsWith(t) ? e.substring(0, e.length - t.length) : e;

        function sh(e) {
            let t = function(e, t) {
                let n = e,
                    i = rh(n, t);
                for (; i !== n;) n = i, i = rh(n, t);
                for (n = i, i = oh(n, t); i !== n;) n = i, i = oh(n, t);
                return i
            }(e, "/");
            return t.startsWith("/") || (t = `/${t}`), t.endsWith("/") || (t = `${t}/`), t
        }

        function ah(e) {
            try {
                const t = new URL(e);
                return t ? String(t) : `https://${e}`
            } catch (t) {
                return `https://${e}`
            }
        }
        const lh = {
            [j.Video]: [".mp4", ".mov", ".webm"],
            [j.Font]: [".ttf", ".otf", ".woff"],
            [j.Image]: [".jpg", ".jpeg", ".png", ".ico", ".webp", ".gif"],
            [j.Vector]: [".svg"],
            [j.Audio]: [".mp3", ".wav", ".webm"],
            [j.Model3d]: [".gltf", ".fbx", ".obj", ".glb"],
            [j.Hdri]: [".exr", ".hdr"]
        };
        Object.entries(lh).reverse().reduce(((e, [t, n]) => (n.forEach((n => e[n] = t)), e)), {});

        function ch(e, t) {
            const n = Math.pow(10, t),
                i = Math.round(e * n) / n;
            return parseFloat(i.toFixed(Math.max(0, t)))
        }

        function Ah(e, t, n) {
            const i = (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y);
            return 0 === i ? 0 : i > 0 ? 1 : 2
        }

        function hh(e, t) {
            const n = t.x - e.x,
                i = t.y - e.y;
            return Math.sqrt(n * n + i * i)
        }

        function uh(e, t, n) {
            return (t.x - e.x) * (n.y - e.y) - (n.x - e.x) * (t.y - e.y)
        }

        function dh(e, t) {
            return 0 !== function(e, t) {
                let n = 0;
                for (let i = 0; i < t.length; i++) {
                    const r = t[i],
                        o = t[(i + 1) % t.length];
                    r.y <= e.y ? o.y > e.y && uh(r, o, e) > 0 && n++ : o.y <= e.y && uh(r, o, e) < 0 && n--
                }
                return n
            }(e, t)
        }

        function ph(e) {
            e.preventDefault ? e.preventDefault() : e.returnValue = !1
        }

        function gh(e) {
            e.stopPropagation ? e.stopPropagation() : e.cancelBubble = !0
        }

        function fh(e, t) {
            const n = t === I.ScrollTransform;
            return {
                type: e,
                delay: 0,
                duration: 300,
                stiffness: n ? 500 : 400,
                damping: n ? 60 : 30,
                mass: 1
            }
        }

        function mh(e) {
            const t = {
                opacity: 1,
                scale: 1,
                rotateType: S.Rotate2D,
                rotateX: 0,
                rotateY: 0,
                rotateZ: 0,
                offsetX: 0,
                offsetY: 0
            };
            switch (e) {
                case b.Fade:
                    return Object.assign(Object.assign({}, t), {
                        opacity: 0
                    });
                case b.Scale:
                    return Object.assign(Object.assign({}, t), {
                        scale: .5
                    });
                case b.ScaleBottom:
                    return Object.assign(Object.assign({}, t), {
                        scale: .5,
                        offsetY: 50
                    });
                case b.FlipHorizontal:
                    return Object.assign(Object.assign({}, t), {
                        rotateType: S.Rotate3D,
                        rotateY: -180
                    });
                case b.FlipVertical:
                    return Object.assign(Object.assign({}, t), {
                        rotateType: S.Rotate3D,
                        rotateX: -180
                    });
                case b.SlideTop:
                    return Object.assign(Object.assign({}, t), {
                        opacity: 0,
                        offsetY: -150
                    });
                case b.SlideLeft:
                    return Object.assign(Object.assign({}, t), {
                        opacity: 0,
                        offsetX: -150
                    });
                case b.SlideRight:
                    return Object.assign(Object.assign({}, t), {
                        opacity: 0,
                        offsetX: 150
                    });
                case b.SlideBottom:
                    return Object.assign(Object.assign({}, t), {
                        opacity: 0,
                        offsetY: 150
                    });
                default:
                    return t
            }
        }
        x.ElementInView, b.Scale;
        const Eh = Q.Upload,
            Ch = M.Waveform,
            Ih = e.Pointer,
            Sh = "#252627";
        M.PlayPause, M.Waveform, M.Speaker, M.PlayPause, M.Waveform, M.Speaker;

        function vh(e) {
            return e.playIconType || Ch
        }

        function Bh(e) {
            if (vh(e) !== M.None) return e.iconPlayUrl
        }

        function xh(e) {
            if (vh(e) !== M.None) return e.iconPauseUrl
        }

        function yh(e, t) {
            const n = document.createElement("div");
            n.style.width = "100%", n.style.height = "100%";
            return vh(t) === M.Custom ? (n.style.backgroundImage = `url("${encodeURI(e)}")`, n.style.backgroundSize = "contain", n.style.backgroundPosition = "center", n.style.backgroundRepeat = "no-repeat") : (n.style.backgroundColor = function(e) {
                return e.playIconColor || Sh
            }(t), n.style.maskImage = `url("${encodeURI(e)}")`, n.style.maskSize = "contain", n.style.maskPosition = "center", n.style.maskRepeat = "no-repeat"), n
        }
        const wh = {
            [R.Top]: R.Bottom,
            [R.Bottom]: R.Top,
            [R.Left]: R.Right,
            [R.Right]: R.Left
        };

        function bh(e) {
            const {
                position: t,
                align: n
            } = e, i = {
                top: "auto",
                right: "auto",
                bottom: "auto",
                left: "auto",
                transform: "none"
            };
            i[wh[t]] = "100%";
            const r = [R.Left, R.Right].includes(t);
            let o = r ? R.Top : R.Left;
            n === T.End && (o = wh[o]);
            const s = n === T.Center ? "50%" : "0px";
            i[o] = s;
            const a = [];
            n === T.Center && a.push(r ? "translateY(-50%)" : "translateX(-50%)");
            const l = function(e) {
                const {
                    position: t,
                    offsetOrthogonal: n,
                    offsetParallel: i
                } = e, r = [R.Top, R.Left].includes(t) ? -1 : 1, o = [R.Top, R.Bottom].includes(t), s = [n * r, i];
                o && s.reverse();
                return {
                    x: s[0],
                    y: s[1]
                }
            }(e);
            return l.x && a.push(`translateX(${l.x}px)`), l.y && a.push(`translateY(${l.y}px)`), a.length > 0 && (i.transform = a.join(" ")), i
        }
        const Qh = Math.pow,
            Uh = Math.sqrt,
            Mh = Math.sin,
            Rh = Math.cos,
            Th = Math.PI,
            Fh = 1.70158,
            Dh = 1.525 * Fh,
            kh = Fh + 1,
            Lh = 2 * Th / 3,
            Kh = 2 * Th / 4.5,
            Ph = function(e) {
                const t = 7.5625,
                    n = 2.75;
                return e < 1 / n ? t * e * e : e < 2 / n ? t * (e -= 1.5 / n) * e + .75 : e < 2.5 / n ? t * (e -= 2.25 / n) * e + .9375 : t * (e -= 2.625 / n) * e + .984375
            },
            Gh = {
                lenisDefault: e => Math.min(1, 1.001 - Math.pow(2, -10 * e)),
                linear: e => e,
                easeInQuad: function(e) {
                    return e * e
                },
                easeOutQuad: function(e) {
                    return 1 - (1 - e) * (1 - e)
                },
                easeInOutQuad: function(e) {
                    return e < .5 ? 2 * e * e : 1 - Qh(-2 * e + 2, 2) / 2
                },
                easeInCubic: function(e) {
                    return e * e * e
                },
                easeOutCubic: function(e) {
                    return 1 - Qh(1 - e, 3)
                },
                easeInOutCubic: function(e) {
                    return e < .5 ? 4 * e * e * e : 1 - Qh(-2 * e + 2, 3) / 2
                },
                easeInQuart: function(e) {
                    return e * e * e * e
                },
                easeOutQuart: function(e) {
                    return 1 - Qh(1 - e, 4)
                },
                easeInOutQuart: function(e) {
                    return e < .5 ? 8 * e * e * e * e : 1 - Qh(-2 * e + 2, 4) / 2
                },
                easeInQuint: function(e) {
                    return e * e * e * e * e
                },
                easeOutQuint: function(e) {
                    return 1 - Qh(1 - e, 5)
                },
                easeInOutQuint: function(e) {
                    return e < .5 ? 16 * e * e * e * e * e : 1 - Qh(-2 * e + 2, 5) / 2
                },
                easeInSine: function(e) {
                    return 1 - Rh(e * Th / 2)
                },
                easeOutSine: function(e) {
                    return Mh(e * Th / 2)
                },
                easeInOutSine: function(e) {
                    return -(Rh(Th * e) - 1) / 2
                },
                easeInExpo: function(e) {
                    return 0 === e ? 0 : Qh(2, 10 * e - 10)
                },
                easeOutExpo: function(e) {
                    return 1 === e ? 1 : 1 - Qh(2, -10 * e)
                },
                easeInOutExpo: function(e) {
                    return 0 === e ? 0 : 1 === e ? 1 : e < .5 ? Qh(2, 20 * e - 10) / 2 : (2 - Qh(2, -20 * e + 10)) / 2
                },
                easeInCirc: function(e) {
                    return 1 - Uh(1 - Qh(e, 2))
                },
                easeOutCirc: function(e) {
                    return Uh(1 - Qh(e - 1, 2))
                },
                easeInOutCirc: function(e) {
                    return e < .5 ? (1 - Uh(1 - Qh(2 * e, 2))) / 2 : (Uh(1 - Qh(-2 * e + 2, 2)) + 1) / 2
                },
                easeInBack: function(e) {
                    return kh * e * e * e - Fh * e * e
                },
                easeOutBack: function(e) {
                    return 1 + kh * Qh(e - 1, 3) + Fh * Qh(e - 1, 2)
                },
                easeInOutBack: function(e) {
                    return e < .5 ? Qh(2 * e, 2) * (7.189819 * e - Dh) / 2 : (Qh(2 * e - 2, 2) * ((Dh + 1) * (2 * e - 2) + Dh) + 2) / 2
                },
                easeInElastic: function(e) {
                    return 0 === e ? 0 : 1 === e ? 1 : -Qh(2, 10 * e - 10) * Mh((10 * e - 10.75) * Lh)
                },
                easeOutElastic: function(e) {
                    return 0 === e ? 0 : 1 === e ? 1 : Qh(2, -10 * e) * Mh((10 * e - .75) * Lh) + 1
                },
                easeInOutElastic: function(e) {
                    return 0 === e ? 0 : 1 === e ? 1 : e < .5 ? -Qh(2, 20 * e - 10) * Mh((20 * e - 11.125) * Kh) / 2 : Qh(2, -20 * e + 10) * Mh((20 * e - 11.125) * Kh) / 2 + 1
                },
                easeInBounce: function(e) {
                    return 1 - Ph(1 - e)
                },
                easeOutBounce: Ph,
                easeInOutBounce: function(e) {
                    return e < .5 ? (1 - Ph(1 - 2 * e)) / 2 : (1 + Ph(2 * e - 1)) / 2
                }
            },
            Vh = Gh;
        Vh.lenisDefault, Vh.linear, Vh.easeInSine, Vh.easeOutSine, Vh.easeInOutSine, Vh.easeInQuad, Vh.easeOutQuad, Vh.easeInOutQuad, Vh.easeInCubic, Vh.easeOutCubic, Vh.easeInOutCubic, Vh.easeInQuart, Vh.easeOutQuart, Vh.easeInOutQuart, Vh.easeInQuint, Vh.easeOutQuint, Vh.easeInOutQuint, Vh.easeInExpo, Vh.easeOutExpo, Vh.easeInOutExpo, Vh.easeInCirc, Vh.easeOutCirc, Vh.easeInOutCirc;
        var Oh, Nh;
        ! function(e) {
            e.Position = "position", e.Spacing = "spacing", e.Size = "size", e.Layout = "layout", e.Style = "style", e.Font = "font", e.Image = "image", e.Video = "video", e.Link = "link", e.Scene = "scene", e.ScrollSection = "scrollSection", e.Effects = "effects", e.Audio = "audio", e.AudioStyle = "audioStyle", e.Interactions = "interactions", e.RelativeOverlay = "relativeOverlay", e.LoadingBar = "loadingBar"
        }(Oh || (Oh = {})),
        function(e) {
            e.Wrapper = "wrapper", e.Text = "text", e.TextNode = "textnode", e.Block = "block", e.Rows = "rows", e.Columns = "columns", e.Grid = "grid", e.Image = "image", e.Video = "video", e.Background = "background", e.Scene = "scene", e.LinkBox = "link", e.Audio = "audio", e.RelativeOverlay = "relativeOverlay", e.LoadingBar = "loadingBar"
        }(Nh || (Nh = {}));
        const Hh = "pwb-relative-overlay",
            qh = "pwb-loading-wrap",
            jh = "pwb-body-wrap",
            Yh = "pwb-error-page-wrap";
        const Jh = "object" == typeof global && global && global.Object === Object && global;
        var Wh = "object" == typeof self && self && self.Object === Object && self;
        const zh = Jh || Wh || Function("return this")();
        const Xh = zh.Symbol;
        const Zh = function(e, t) {
            for (var n = -1, i = null == e ? 0 : e.length, r = Array(i); ++n < i;) r[n] = t(e[n], n, e);
            return r
        };
        const _h = Array.isArray;
        var $h = Object.prototype,
            eu = $h.hasOwnProperty,
            tu = $h.toString,
            nu = Xh ? Xh.toStringTag : void 0;
        const iu = function(e) {
            var t = eu.call(e, nu),
                n = e[nu];
            try {
                e[nu] = void 0;
                var i = !0
            } catch (e) {}
            var r = tu.call(e);
            return i && (t ? e[nu] = n : delete e[nu]), r
        };
        var ru = Object.prototype.toString;
        const ou = function(e) {
            return ru.call(e)
        };
        var su = Xh ? Xh.toStringTag : void 0;
        const au = function(e) {
            return null == e ? void 0 === e ? "[object Undefined]" : "[object Null]" : su && su in Object(e) ? iu(e) : ou(e)
        };
        const lu = function(e) {
            return null != e && "object" == typeof e
        };
        const cu = function(e) {
            return "symbol" == typeof e || lu(e) && "[object Symbol]" == au(e)
        };
        var Au = Xh ? Xh.prototype : void 0,
            hu = Au ? Au.toString : void 0;
        const uu = function e(t) {
            if ("string" == typeof t) return t;
            if (_h(t)) return Zh(t, e) + "";
            if (cu(t)) return hu ? hu.call(t) : "";
            var n = t + "";
            return "0" == n && 1 / t == -Infinity ? "-0" : n
        };
        const du = function(e) {
            return null == e ? "" : uu(e)
        };
        const pu = function(e) {
                return du(e).toLowerCase()
            },
            gu = (Oh.Layout, Oh.Position, Oh.Size, Oh.Spacing, Oh.Style, Oh.Link, Oh.ScrollSection, Oh.Effects, Oh.Interactions, Oh.Layout, Oh.Position, Oh.Size, Oh.Spacing, Oh.Style, Oh.Link, Oh.ScrollSection, Oh.Effects, Oh.Interactions, Nh.Block, Nh.Block, Oh.Layout, Oh.Position, Oh.Size, Oh.Spacing, Oh.Style, Oh.Link, Oh.ScrollSection, Oh.Effects, Oh.Interactions, Nh.Block, Nh.Block, Oh.Layout, Oh.Position, Oh.Size, Oh.Spacing, Oh.Style, Oh.Link, Oh.ScrollSection, Oh.Effects, Oh.Interactions, Nh.Block, Nh.Block, Nh.Block, Nh.Block, {
                display: "block",
                width: "100%",
                "font-family": "Inter",
                "font-size": "16px",
                "font-weight": "400",
                "letter-spacing": "0px",
                "line-height": "24px",
                "padding-top": "10px",
                "padding-bottom": "10px",
                "padding-left": "10px",
                "padding-right": "10px",
                color: "#000"
            });
        Oh.Position, Oh.Size, Oh.Spacing, Oh.Style, Oh.Font, Oh.Link, Oh.ScrollSection, Oh.Effects, Oh.Interactions, Nh.TextNode;
        Oh.Spacing, Oh.Layout, Oh.Style, Oh.Scene, Oh.Position, Oh.Size, Oh.Style, Oh.Link, Oh.ScrollSection, Oh.Effects, Oh.Interactions, Oh.Layout, Oh.Position, Oh.Size, Oh.Spacing, Oh.Style, Oh.Link, Oh.ScrollSection, Oh.Effects, Oh.Interactions, Nh.Text, Nh.TextNode, Oh.Position, Oh.Size, Oh.Spacing, Oh.Style, Oh.ScrollSection, Oh.Effects, Oh.Audio, Oh.AudioStyle, Oh.RelativeOverlay, Oh.Layout, Oh.Size, Oh.Spacing, Oh.Style, Oh.Link, Oh.ScrollSection, Oh.Effects, Oh.Interactions;
        const fu = "pwb-loading-bar-text";
        Oh.LoadingBar, Oh.Position, Oh.Size, Oh.Spacing, Oh.Style, Oh.Font;
        Nh.Block, Nh.Wrapper, Nh.TextNode, Nh.Columns, Nh.Rows, Nh.Grid, Nh.Text, Nh.Image, Nh.Video, Nh.Background, Nh.Scene, Nh.LinkBox, Nh.Audio, Nh.RelativeOverlay, Nh.LoadingBar;
        const mu = window._pwInitialPath,
            Eu = !!window._pwIsPreview,
            Cu = !!window._pwShowStats;
        var Iu = function(e, t, n, i) {
            return new(n || (n = Promise))((function(r, o) {
                function s(e) {
                    try {
                        l(i.next(e))
                    } catch (e) {
                        o(e)
                    }
                }

                function a(e) {
                    try {
                        l(i.throw(e))
                    } catch (e) {
                        o(e)
                    }
                }

                function l(e) {
                    var t;
                    e.done ? r(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(s, a)
                }
                l((i = i.apply(e, t || [])).next())
            }))
        };

        function Su(e) {
            return Iu(this, void 0, void 0, (function*() {
                if (!window._pwLoadFileFromCache) throw new Error("Load file from cache function missing.");
                return yield window._pwLoadFileFromCache(e)
            }))
        }

        function vu(e, t) {
            window._pwSetFileCache && window._pwSetFileCache(e, t)
        }
        var Bu = function(e, t, n, i) {
            return new(n || (n = Promise))((function(r, o) {
                function s(e) {
                    try {
                        l(i.next(e))
                    } catch (e) {
                        o(e)
                    }
                }

                function a(e) {
                    try {
                        l(i.throw(e))
                    } catch (e) {
                        o(e)
                    }
                }

                function l(e) {
                    var t;
                    e.done ? r(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(s, a)
                }
                l((i = i.apply(e, t || [])).next())
            }))
        };
        const xu = (e, t, n = "/") => Bu(void 0, void 0, void 0, (function*() {
                const i = `${sh(n)}${e}`,
                    r = yield Su(i);
                if (!r) throw new Error(`Failed to fetch "${i}".`);
                const o = yield fetch(r), s = o.headers.get("content-type") || "";
                if (!s.includes(t)) throw new Error(`Unexpected content type "${s}" for file "${i}".`);
                return o
            })),
            yu = () => Bu(void 0, void 0, void 0, (function*() {
                const e = yield xu(t.SceneState, "application/json");
                return yield e.json()
            })),
            wu = e => Bu(void 0, void 0, void 0, (function*() {
                const n = yield xu(t.UIState, "application/json", e);
                return yield n.json()
            })),
            bu = e => Bu(void 0, void 0, void 0, (function*() {
                const n = yield xu(t.Index, "text/html", e);
                return yield n.text()
            })),
            Qu = e => Bu(void 0, void 0, void 0, (function*() {
                const n = yield xu(t.Styles, "text/css", e);
                return yield n.text()
            })),
            Uu = () => Bu(void 0, void 0, void 0, (function*() {
                const e = yield xu(t.ErrorPage, "text/html");
                return yield e.text()
            })),
            Mu = () => Bu(void 0, void 0, void 0, (function*() {
                const e = yield xu(t.ErrorPageStyles, "text/css");
                return yield e.text()
            }));
        var Ru = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
            Tu = /^\w*$/;
        const Fu = function(e, t) {
            if (_h(e)) return !1;
            var n = typeof e;
            return !("number" != n && "symbol" != n && "boolean" != n && null != e && !cu(e)) || (Tu.test(e) || !Ru.test(e) || null != t && e in Object(t))
        };
        const Du = function(e) {
            var t = typeof e;
            return null != e && ("object" == t || "function" == t)
        };
        const ku = function(e) {
            if (!Du(e)) return !1;
            var t = au(e);
            return "[object Function]" == t || "[object GeneratorFunction]" == t || "[object AsyncFunction]" == t || "[object Proxy]" == t
        };
        const Lu = zh["__core-js_shared__"];
        var Ku, Pu = (Ku = /[^.]+$/.exec(Lu && Lu.keys && Lu.keys.IE_PROTO || "")) ? "Symbol(src)_1." + Ku : "";
        const Gu = function(e) {
            return !!Pu && Pu in e
        };
        var Vu = Function.prototype.toString;
        const Ou = function(e) {
            if (null != e) {
                try {
                    return Vu.call(e)
                } catch (e) {}
                try {
                    return e + ""
                } catch (e) {}
            }
            return ""
        };
        var Nu = /^\[object .+?Constructor\]$/,
            Hu = Function.prototype,
            qu = Object.prototype,
            ju = Hu.toString,
            Yu = qu.hasOwnProperty,
            Ju = RegExp("^" + ju.call(Yu).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
        const Wu = function(e) {
            return !(!Du(e) || Gu(e)) && (ku(e) ? Ju : Nu).test(Ou(e))
        };
        const zu = function(e, t) {
            return null == e ? void 0 : e[t]
        };
        const Xu = function(e, t) {
            var n = zu(e, t);
            return Wu(n) ? n : void 0
        };
        const Zu = Xu(Object, "create");
        const _u = function() {
            this.__data__ = Zu ? Zu(null) : {}, this.size = 0
        };
        const $u = function(e) {
            var t = this.has(e) && delete this.__data__[e];
            return this.size -= t ? 1 : 0, t
        };
        var ed = Object.prototype.hasOwnProperty;
        const td = function(e) {
            var t = this.__data__;
            if (Zu) {
                var n = t[e];
                return "__lodash_hash_undefined__" === n ? void 0 : n
            }
            return ed.call(t, e) ? t[e] : void 0
        };
        var nd = Object.prototype.hasOwnProperty;
        const id = function(e) {
            var t = this.__data__;
            return Zu ? void 0 !== t[e] : nd.call(t, e)
        };
        const rd = function(e, t) {
            var n = this.__data__;
            return this.size += this.has(e) ? 0 : 1, n[e] = Zu && void 0 === t ? "__lodash_hash_undefined__" : t, this
        };

        function od(e) {
            var t = -1,
                n = null == e ? 0 : e.length;
            for (this.clear(); ++t < n;) {
                var i = e[t];
                this.set(i[0], i[1])
            }
        }
        od.prototype.clear = _u, od.prototype.delete = $u, od.prototype.get = td, od.prototype.has = id, od.prototype.set = rd;
        const sd = od;
        const ad = function() {
            this.__data__ = [], this.size = 0
        };
        const ld = function(e, t) {
            return e === t || e != e && t != t
        };
        const cd = function(e, t) {
            for (var n = e.length; n--;)
                if (ld(e[n][0], t)) return n;
            return -1
        };
        var Ad = Array.prototype.splice;
        const hd = function(e) {
            var t = this.__data__,
                n = cd(t, e);
            return !(n < 0) && (n == t.length - 1 ? t.pop() : Ad.call(t, n, 1), --this.size, !0)
        };
        const ud = function(e) {
            var t = this.__data__,
                n = cd(t, e);
            return n < 0 ? void 0 : t[n][1]
        };
        const dd = function(e) {
            return cd(this.__data__, e) > -1
        };
        const pd = function(e, t) {
            var n = this.__data__,
                i = cd(n, e);
            return i < 0 ? (++this.size, n.push([e, t])) : n[i][1] = t, this
        };

        function gd(e) {
            var t = -1,
                n = null == e ? 0 : e.length;
            for (this.clear(); ++t < n;) {
                var i = e[t];
                this.set(i[0], i[1])
            }
        }
        gd.prototype.clear = ad, gd.prototype.delete = hd, gd.prototype.get = ud, gd.prototype.has = dd, gd.prototype.set = pd;
        const fd = gd;
        const md = Xu(zh, "Map");
        const Ed = function() {
            this.size = 0, this.__data__ = {
                hash: new sd,
                map: new(md || fd),
                string: new sd
            }
        };
        const Cd = function(e) {
            var t = typeof e;
            return "string" == t || "number" == t || "symbol" == t || "boolean" == t ? "__proto__" !== e : null === e
        };
        const Id = function(e, t) {
            var n = e.__data__;
            return Cd(t) ? n["string" == typeof t ? "string" : "hash"] : n.map
        };
        const Sd = function(e) {
            var t = Id(this, e).delete(e);
            return this.size -= t ? 1 : 0, t
        };
        const vd = function(e) {
            return Id(this, e).get(e)
        };
        const Bd = function(e) {
            return Id(this, e).has(e)
        };
        const xd = function(e, t) {
            var n = Id(this, e),
                i = n.size;
            return n.set(e, t), this.size += n.size == i ? 0 : 1, this
        };

        function yd(e) {
            var t = -1,
                n = null == e ? 0 : e.length;
            for (this.clear(); ++t < n;) {
                var i = e[t];
                this.set(i[0], i[1])
            }
        }
        yd.prototype.clear = Ed, yd.prototype.delete = Sd, yd.prototype.get = vd, yd.prototype.has = Bd, yd.prototype.set = xd;
        const wd = yd;

        function bd(e, t) {
            if ("function" != typeof e || null != t && "function" != typeof t) throw new TypeError("Expected a function");
            var n = function() {
                var i = arguments,
                    r = t ? t.apply(this, i) : i[0],
                    o = n.cache;
                if (o.has(r)) return o.get(r);
                var s = e.apply(this, i);
                return n.cache = o.set(r, s) || o, s
            };
            return n.cache = new(bd.Cache || wd), n
        }
        bd.Cache = wd;
        const Qd = bd;
        const Ud = function(e) {
            var t = Qd(e, (function(e) {
                    return 500 === n.size && n.clear(), e
                })),
                n = t.cache;
            return t
        };
        var Md = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
            Rd = /\\(\\)?/g,
            Td = Ud((function(e) {
                var t = [];
                return 46 === e.charCodeAt(0) && t.push(""), e.replace(Md, (function(e, n, i, r) {
                    t.push(i ? r.replace(Rd, "$1") : n || e)
                })), t
            }));
        const Fd = Td;
        const Dd = function(e, t) {
            return _h(e) ? e : Fu(e, t) ? [e] : Fd(du(e))
        };
        const kd = function(e) {
            if ("string" == typeof e || cu(e)) return e;
            var t = e + "";
            return "0" == t && 1 / e == -Infinity ? "-0" : t
        };
        const Ld = function(e, t) {
            for (var n = 0, i = (t = Dd(t, e)).length; null != e && n < i;) e = e[kd(t[n++])];
            return n && n == i ? e : void 0
        };
        const Kd = function(e, t, n) {
            var i = null == e ? void 0 : Ld(e, t);
            return void 0 === i ? n : i
        };
        const Pd = function(e, t) {
            return function(n) {
                return e(t(n))
            }
        };
        const Gd = Pd(Object.getPrototypeOf, Object);
        var Vd = Function.prototype,
            Od = Object.prototype,
            Nd = Vd.toString,
            Hd = Od.hasOwnProperty,
            qd = Nd.call(Object);
        const jd = function(e) {
            if (!lu(e) || "[object Object]" != au(e)) return !1;
            var t = Gd(e);
            if (null === t) return !0;
            var n = Hd.call(t, "constructor") && t.constructor;
            return "function" == typeof n && n instanceof n && Nd.call(n) == qd
        };
        const Yd = function(e) {
                var t = null == e ? 0 : e.length;
                return t ? e[t - 1] : void 0
            },
            Jd = new WeakMap,
            Wd = new WeakMap,
            zd = Symbol("pointerMeta"),
            Xd = {
                get(e, t) {
                    if (t === zd) return Jd.get(e);
                    let n = Wd.get(e);
                    n || (n = new Map, Wd.set(e, n));
                    const i = n.get(t);
                    if (void 0 !== i) return i;
                    const r = Jd.get(e),
                        o = $d({
                            root: r.root,
                            path: [...r.path, t]
                        });
                    return n.set(t, o), o
                }
            },
            Zd = e => e[zd],
            _d = e => {
                const {
                    root: t,
                    path: n
                } = Zd(e);
                return {
                    root: t,
                    path: n
                }
            };

        function $d(e) {
            var t;
            const n = {
                    root: e.root,
                    path: null !== (t = e.path) && void 0 !== t ? t : []
                },
                i = {};
            return Jd.set(i, n), new Proxy(i, Xd)
        }
        const ep = $d,
            tp = e => e && !!Zd(e);
        const np = (e, t, n) => {
            if (0 === t.length) return n(e);
            if (Array.isArray(e)) {
                let [i, ...r] = t;
                i = parseInt(String(i), 10), isNaN(i) && (i = 0);
                const o = e[i],
                    s = np(o, r, n);
                if (o === s) return e;
                const a = [...e];
                return a.splice(i, 1, s), a
            }
            if ("object" == typeof e && null !== e) {
                const [i, ...r] = t, o = e[i], s = np(o, r, n);
                if (o === s) return e;
                return Object.assign(Object.assign({}, e), {
                    [i]: s
                })
            } {
                const [e, ...i] = t;
                return {
                    [e]: np(void 0, i, n)
                }
            }
        };
        class ip {
            constructor() {
                this._head = void 0
            }
            peek() {
                return this._head && this._head.data
            }
            pop() {
                const e = this._head;
                if (e) return this._head = e.next, e.data
            }
            push(e) {
                const t = {
                    next: this._head,
                    data: e
                };
                this._head = t
            }
        }

        function rp() {
            const e = new ip,
                t = () => {};
            return {
                type: "Dataverse_discoveryMechanism",
                startIgnoringDependencies: () => {
                    e.push(t)
                },
                stopIgnoringDependencies: () => {
                    e.peek() !== t || e.pop()
                },
                reportResolutionStart: n => {
                    const i = e.peek();
                    i && i(n), e.push(t)
                },
                reportResolutionEnd: t => {
                    e.pop()
                },
                pushCollector: t => {
                    e.push(t)
                },
                popCollector: t => {
                    if (e.peek() !== t) throw new Error("Popped collector is not on top of the stack");
                    e.pop()
                }
            }
        }
        const {
            startIgnoringDependencies: op,
            stopIgnoringDependencies: sp,
            reportResolutionEnd: ap,
            reportResolutionStart: lp,
            pushCollector: cp,
            popCollector: Ap
        } = function() {
            const e = "__dataverse_discoveryMechanism_sharedStack",
                t = "undefined" != typeof window ? window : void 0 !== n.g ? n.g : {};
            if (t) {
                const n = t[e];
                if (n && "object" == typeof n && "Dataverse_discoveryMechanism" === n.type) return n; {
                    const n = rp();
                    return t[e] = n, n
                }
            }
            return rp()
        }(), hp = () => {};
        class up {
            constructor(e, t) {
                this._fn = e, this._prismInstance = t, this._didMarkDependentsAsStale = !1, this._isFresh = !1, this._cacheOfDendencyValues = new Map, this._dependents = new Set, this._dependencies = new Set, this._possiblyStaleDeps = new Set, this._scope = new gp(this), this._lastValue = void 0, this._forciblySetToStale = !1, this._reactToDependencyGoingStale = e => {
                    this._possiblyStaleDeps.add(e), this._markAsStale()
                };
                for (const e of this._dependencies) e._addDependent(this._reactToDependencyGoingStale);
                op(), this.getValue(), sp()
            }
            get hasDependents() {
                return this._dependents.size > 0
            }
            removeDependent(e) {
                this._dependents.delete(e)
            }
            addDependent(e) {
                this._dependents.add(e)
            }
            destroy() {
                for (const e of this._dependencies) e._removeDependent(this._reactToDependencyGoingStale);
                fp(this._scope)
            }
            getValue() {
                if (!this._isFresh) {
                    const e = this._recalculate();
                    this._lastValue = e, this._isFresh = !0, this._didMarkDependentsAsStale = !1, this._forciblySetToStale = !1
                }
                return this._lastValue
            }
            _recalculate() {
                let e;
                if (!this._forciblySetToStale && this._possiblyStaleDeps.size > 0) {
                    let e = !1;
                    op();
                    for (const t of this._possiblyStaleDeps)
                        if (this._cacheOfDendencyValues.get(t) !== t.getValue()) {
                            e = !0;
                            break
                        }
                    if (sp(), this._possiblyStaleDeps.clear(), !e) return this._lastValue
                }
                const t = new Set;
                this._cacheOfDendencyValues.clear();
                const n = e => {
                    t.add(e), this._addDependency(e)
                };
                cp(n), Ep.push(this._scope);
                try {
                    e = this._fn()
                } catch (e) {
                    console.error(e)
                } finally {
                    Ep.pop() !== this._scope && console.warn("The Prism hook stack has slipped. This is a bug.")
                }
                Ap(n);
                for (const e of this._dependencies) t.has(e) || this._removeDependency(e);
                this._dependencies = t, op();
                for (const e of t) this._cacheOfDendencyValues.set(e, e.getValue());
                return sp(), e
            }
            forceStale() {
                this._forciblySetToStale = !0, this._markAsStale()
            }
            _markAsStale() {
                if (!this._didMarkDependentsAsStale) {
                    this._didMarkDependentsAsStale = !0, this._isFresh = !1;
                    for (const e of this._dependents) e(this._prismInstance)
                }
            }
            _addDependency(e) {
                this._dependencies.has(e) || (this._dependencies.add(e), e._addDependent(this._reactToDependencyGoingStale))
            }
            _removeDependency(e) {
                this._dependencies.has(e) && (this._dependencies.delete(e), e._removeDependent(this._reactToDependencyGoingStale))
            }
        }
        const dp = {};
        class pp {
            constructor(e) {
                this._fn = e, this.isPrism = !0, this._state = {
                    hot: !1,
                    handle: void 0
                }
            }
            get isHot() {
                return this._state.hot
            }
            onChange(e, t, n = !1) {
                const i = () => {
                    e.onThisOrNextTick(o)
                };
                let r = dp;
                const o = () => {
                    const e = this.getValue();
                    e !== r && (r = e, t(e))
                };
                this._addDependent(i), n && (r = this.getValue(), t(r));
                return () => {
                    this._removeDependent(i), e.offThisOrNextTick(o), e.offNextTick(o)
                }
            }
            onStale(e) {
                const t = () => e();
                return this._addDependent(t), () => {
                    this._removeDependent(t)
                }
            }
            keepHot() {
                return this.onStale((() => {}))
            }
            _addDependent(e) {
                this._state.hot || this._goHot(), this._state.handle.addDependent(e)
            }
            _goHot() {
                const e = new up(this._fn, this);
                this._state = {
                    hot: !0,
                    handle: e
                }
            }
            _removeDependent(e) {
                const t = this._state;
                if (!t.hot) return;
                const n = t.handle;
                n.removeDependent(e), n.hasDependents || (this._state = {
                    hot: !1,
                    handle: void 0
                }, n.destroy())
            }
            getValue() {
                lp(this);
                const e = this._state;
                let t;
                return t = e.hot ? e.handle.getValue() : function(e) {
                    const t = new vp;
                    let n;
                    Ep.push(t);
                    try {
                        n = e()
                    } catch (e) {
                        console.error(e)
                    } finally {
                        Ep.pop() !== t && console.warn("The Prism hook stack has slipped. This is a bug.")
                    }
                    return n
                }(this._fn), ap(this), t
            }
        }
        class gp {
            constructor(e) {
                this._hotHandle = e, this._refs = new Map, this.isPrismScope = !0, this.subs = {}, this.effects = new Map, this.memos = new Map
            }
            ref(e, t) {
                const n = this._refs.get(e);
                if (void 0 !== n) return n; {
                    const n = {
                        current: t
                    };
                    return this._refs.set(e, n), n
                }
            }
            effect(e, t, n) {
                let i = this.effects.get(e);
                void 0 === i && (i = {
                    cleanup: hp,
                    deps: void 0
                }, this.effects.set(e, i)), Cp(i.deps, n) && (i.cleanup(), op(), i.cleanup = mp(t, hp).value, sp(), i.deps = n)
            }
            memo(e, t, n) {
                let i = this.memos.get(e);
                return void 0 === i && (i = {
                    cachedValue: null,
                    deps: void 0
                }, this.memos.set(e, i)), Cp(i.deps, n) && (op(), i.cachedValue = mp(t, void 0).value, sp(), i.deps = n), i.cachedValue
            }
            state(e, t) {
                const {
                    value: n,
                    setValue: i
                } = this.memo("state/" + e, (() => {
                    const e = {
                        current: t
                    };
                    return {
                        value: e,
                        setValue: t => {
                            e.current = t, this._hotHandle.forceStale()
                        }
                    }
                }), []);
                return [n.current, i]
            }
            sub(e) {
                return this.subs[e] || (this.subs[e] = new gp(this._hotHandle)), this.subs[e]
            }
            cleanupEffects() {
                for (const e of this.effects.values()) mp(e.cleanup, void 0);
                this.effects.clear()
            }
            source(e, t) {
                return this.effect("$$source/blah", (() => e((() => {
                    this._hotHandle.forceStale()
                }))), [e]), t()
            }
        }

        function fp(e) {
            for (const t of Object.values(e.subs)) fp(t);
            e.cleanupEffects()
        }

        function mp(e, t) {
            try {
                return {
                    value: e(),
                    ok: !0
                }
            } catch (e) {
                return setTimeout((function() {
                    throw e
                })), {
                    value: t,
                    ok: !1
                }
            }
        }
        const Ep = new ip;

        function Cp(e, t) {
            if (void 0 === e || void 0 === t) return !0;
            const n = e.length;
            if (n !== t.length) return !0;
            for (let i = 0; i < n; i++)
                if (e[i] !== t[i]) return !0;
            return !1
        }

        function Ip(e, t, n) {
            const i = Ep.peek();
            if (!i) throw new Error("prism.memo() is called outside of a prism() call.");
            return i.memo(e, t, n)
        }
        const Sp = e => new pp(e);
        class vp {
            effect(e, t, n) {
                console.warn("prism.effect() does not run in cold prisms")
            }
            memo(e, t, n) {
                return t()
            }
            state(e, t) {
                return [t, () => {}]
            }
            ref(e, t) {
                return {
                    current: t
                }
            }
            sub(e) {
                return new vp
            }
            source(e, t) {
                return t()
            }
        }
        Sp.ref = function(e, t) {
            const n = Ep.peek();
            if (!n) throw new Error("prism.ref() is called outside of a prism() call.");
            return n.ref(e, t)
        }, Sp.effect = function(e, t, n) {
            const i = Ep.peek();
            if (!i) throw new Error("prism.effect() is called outside of a prism() call.");
            return i.effect(e, t, n)
        }, Sp.memo = Ip, Sp.ensurePrism = function() {
            if (!Ep.peek()) throw new Error("The parent function is called outside of a prism() call.")
        }, Sp.state = function(e, t) {
            const n = Ep.peek();
            if (!n) throw new Error("prism.state() is called outside of a prism() call.");
            return n.state(e, t)
        }, Sp.scope = function(e, t) {
            const n = Ep.peek();
            if (!n) throw new Error("prism.scope() is called outside of a prism() call.");
            const i = n.sub(e);
            Ep.push(i);
            const r = mp(t, void 0).value;
            return Ep.pop(), r
        }, Sp.sub = function(e, t, n) {
            return Ip(e, (() => Sp(t)), n).getValue()
        }, Sp.inPrism = function() {
            return !!Ep.peek()
        }, Sp.source = function(e, t) {
            const n = Ep.peek();
            if (!n) throw new Error("prism.source() is called outside of a prism() call.");
            return n.source(e, t)
        };
        const Bp = Sp;
        var xp;
        ! function(e) {
            e[e.Dict = 0] = "Dict", e[e.Array = 1] = "Array", e[e.Other = 2] = "Other"
        }(xp || (xp = {}));
        const yp = e => Array.isArray(e) ? xp.Array : jd(e) ? xp.Dict : xp.Other,
            wp = (e, t, n = yp(e)) => n === xp.Dict && "string" == typeof t || n === xp.Array && bp(t) ? e[t] : void 0,
            bp = e => {
                const t = "number" == typeof e ? e : parseInt(e, 10);
                return !isNaN(t) && t >= 0 && t < 1 / 0 && (0 | t) === t
            };
        class Qp {
            constructor(e, t) {
                this._parent = e, this._path = t, this.children = new Map, this.identityChangeListeners = new Set
            }
            addIdentityChangeListener(e) {
                this.identityChangeListeners.add(e)
            }
            removeIdentityChangeListener(e) {
                this.identityChangeListeners.delete(e), this._checkForGC()
            }
            removeChild(e) {
                this.children.delete(e), this._checkForGC()
            }
            getChild(e) {
                return this.children.get(e)
            }
            getOrCreateChild(e) {
                let t = this.children.get(e);
                return t || (t = t = new Qp(this, this._path.concat([e])), this.children.set(e, t)), t
            }
            _checkForGC() {
                this.identityChangeListeners.size > 0 || this.children.size > 0 || this._parent && this._parent.removeChild(Yd(this._path))
            }
        }
        class Up {
            constructor(e) {
                this.$$isPointerToPrismProvider = !0, this.pointer = ep({
                    root: this,
                    path: []
                }), this.prism = this.pointerToPrism(this.pointer), this.onChangeByPointer = (e, t) => {
                    const n = tp(e) ? e : e(this.pointer),
                        {
                            path: i
                        } = _d(n),
                        r = this._getOrCreateScopeForPath(i);
                    r.identityChangeListeners.add(t);
                    return () => {
                        r.identityChangeListeners.delete(t)
                    }
                }, this._currentState = e, this._rootScope = new Qp(void 0, [])
            }
            set(e) {
                const t = this._currentState;
                this._currentState = e, this._checkUpdates(this._rootScope, t, e)
            }
            get() {
                return this._currentState
            }
            getByPointer(e) {
                const t = tp(e) ? e : e(this.pointer),
                    n = _d(t).path;
                return this._getIn(n)
            }
            _getIn(e) {
                return 0 === e.length ? this.get() : Kd(this.get(), e)
            }
            reduce(e) {
                this.set(e(this.get()))
            }
            reduceByPointer(e, t) {
                const n = tp(e) ? e : e(this.pointer),
                    i = _d(n).path,
                    r = function(e, t, n) {
                        return 0 === t.length ? n(e) : np(e, t, n)
                    }(this.get(), i, t);
                this.set(r)
            }
            setByPointer(e, t) {
                this.reduceByPointer(e, (() => t))
            }
            _checkUpdates(e, t, n) {
                if (t === n) return;
                for (const t of e.identityChangeListeners) t(n);
                if (0 === e.children.size) return;
                const i = yp(t),
                    r = yp(n);
                if (i !== xp.Other || i !== r)
                    for (const [o, s] of e.children) {
                        const e = wp(t, o, i),
                            a = wp(n, o, r);
                        this._checkUpdates(s, e, a)
                    }
            }
            _getOrCreateScopeForPath(e) {
                let t = this._rootScope;
                for (const n of e) t = t.getOrCreateChild(n);
                return t
            }
            onChange(e) {
                return this.onChangeByPointer(this.pointer, e)
            }
            pointerToPrism(e) {
                const {
                    path: t
                } = _d(e), n = t => this.onChangeByPointer(e, t), i = () => this._getIn(t);
                return Bp((() => Bp.source(n, i)))
            }
        }

        function Mp(e) {
            return !(!e || !e.isPrism || !0 !== e.isPrism)
        }
        const Rp = new WeakMap;
        const Tp = e => {
                const t = Zd(e);
                let n = Rp.get(t);
                if (!n) {
                    const i = t.root;
                    if (! function(e) {
                            return "object" == typeof e && null !== e && !0 === e.$$isPointerToPrismProvider
                        }(i)) throw new Error("Cannot run pointerToPrism() on a pointer whose root is not an PointerToPrismProvider");
                    n = i.pointerToPrism(e), Rp.set(t, n)
                }
                return n
            },
            Fp = e => tp(e) ? Tp(e).getValue() : Mp(e) ? e.getValue() : e;
        class Dp {
            get dormant() {
                return this._dormant
            }
            constructor(e) {
                this._conf = e, this._ticking = !1, this._dormant = !0, this._numberOfDormantTicks = 0, this.__ticks = 0, this._scheduledForThisOrNextTick = new Set, this._scheduledForNextTick = new Set, this._timeAtCurrentTick = 0
            }
            onThisOrNextTick(e) {
                this._scheduledForThisOrNextTick.add(e), this._dormant && this._goActive()
            }
            onNextTick(e) {
                this._scheduledForNextTick.add(e), this._dormant && this._goActive()
            }
            offThisOrNextTick(e) {
                this._scheduledForThisOrNextTick.delete(e)
            }
            offNextTick(e) {
                this._scheduledForNextTick.delete(e)
            }
            get time() {
                return this._ticking ? this._timeAtCurrentTick : performance.now()
            }
            _goActive() {
                var e, t;
                this._dormant && (this._dormant = !1, null === (t = null === (e = this._conf) || void 0 === e ? void 0 : e.onActive) || void 0 === t || t.call(e))
            }
            _goDormant() {
                var e, t;
                this._dormant || (this._dormant = !0, this._numberOfDormantTicks = 0, null === (t = null === (e = this._conf) || void 0 === e ? void 0 : e.onDormant) || void 0 === t || t.call(e))
            }
            tick(e = performance.now()) {
                if (this.__ticks++, !this._dormant && 0 === this._scheduledForNextTick.size && 0 === this._scheduledForThisOrNextTick.size && (this._numberOfDormantTicks++, this._numberOfDormantTicks >= 180)) this._goDormant();
                else {
                    this._ticking = !0, this._timeAtCurrentTick = e;
                    for (const e of this._scheduledForNextTick) this._scheduledForThisOrNextTick.add(e);
                    this._scheduledForNextTick.clear(), this._tick(0), this._ticking = !1
                }
            }
            _tick(e) {
                const t = this.time;
                if (e > 10 && console.warn("_tick() recursing for 10 times"), e > 100) throw new Error("Maximum recursion limit for _tick()");
                const n = this._scheduledForThisOrNextTick;
                this._scheduledForThisOrNextTick = new Set;
                for (const e of n) e(t);
                if (this._scheduledForThisOrNextTick.size > 0) return this._tick(e + 1)
            }
        }
        class kp {
            constructor(e) {
                this.$$isPointerToPrismProvider = !0, this._currentPointerBox = new Up(e), this.pointer = ep({
                    root: this,
                    path: []
                })
            }
            setPointer(e) {
                this._currentPointerBox.set(e)
            }
            pointerToPrism(e) {
                const {
                    path: t
                } = Zd(e);
                return Bp((() => {
                    const e = this._currentPointerBox.prism.getValue(),
                        n = t.reduce(((e, t) => e[t]), e);
                    return Fp(n)
                }))
            }
        }
        const Lp = new class {
                constructor() {
                    this.atom = new Up({
                        projects: {}
                    })
                }
                add(e, t) {
                    this.atom.setByPointer((t => t.projects[e]), t)
                }
                get(e) {
                    return this.atom.get().projects[e]
                }
                has(e) {
                    return !!this.get(e)
                }
            },
            Kp = Lp,
            Pp = new WeakMap;

        function Gp(e) {
            return Pp.get(e)
        }

        function Vp(e, t) {
            Pp.set(e, t)
        }
        const Op = [];

        function Np(e, t) {
            return 0 === t.length ? e : Kd(e, t)
        }
        class Hp {
            constructor() {
                this._values = {}
            }
            get(e, t) {
                if (this.has(e)) return this._values[e]; {
                    const n = t();
                    return this._values[e] = n, n
                }
            }
            has(e) {
                return this._values.hasOwnProperty(e)
            }
        }
        const qp = function() {
            try {
                var e = Xu(Object, "defineProperty");
                return e({}, "", {}), e
            } catch (e) {}
        }();
        const jp = function(e, t, n) {
            "__proto__" == t && qp ? qp(e, t, {
                configurable: !0,
                enumerable: !0,
                value: n,
                writable: !0
            }) : e[t] = n
        };
        var Yp = Object.prototype.hasOwnProperty;
        const Jp = function(e, t, n) {
            var i = e[t];
            Yp.call(e, t) && ld(i, n) && (void 0 !== n || t in e) || jp(e, t, n)
        };
        var Wp = /^(?:0|[1-9]\d*)$/;
        const zp = function(e, t) {
            var n = typeof e;
            return !!(t = null == t ? 9007199254740991 : t) && ("number" == n || "symbol" != n && Wp.test(e)) && e > -1 && e % 1 == 0 && e < t
        };
        const Xp = function(e, t, n, i) {
            if (!Du(e)) return e;
            for (var r = -1, o = (t = Dd(t, e)).length, s = o - 1, a = e; null != a && ++r < o;) {
                var l = kd(t[r]),
                    c = n;
                if ("__proto__" === l || "constructor" === l || "prototype" === l) return e;
                if (r != s) {
                    var A = a[l];
                    void 0 === (c = i ? i(A, l, a) : void 0) && (c = Du(A) ? A : zp(t[r + 1]) ? [] : {})
                }
                Jp(a, l, c), a = a[l]
            }
            return e
        };
        const Zp = function(e, t, n) {
                return null == e ? e : Xp(e, t, n)
            },
            _p = new WeakMap;

        function $p(e) {
            if (_p.has(e)) return _p.get(e);
            const t = "compound" === e.type ? function(e) {
                const t = {};
                for (const [n, i] of Object.entries(e.props)) t[n] = $p(i);
                return t
            }(e) : "enum" === e.type ? function(e) {
                const t = {
                    $case: e.defaultCase
                };
                for (const [n, i] of Object.entries(e.cases)) t[n] = $p(i);
                return t
            }(e) : e.default;
            return _p.set(e, t), t
        }
        var eg = n(314),
            tg = n.n(eg);
        const ng = function() {
            this.__data__ = new fd, this.size = 0
        };
        const ig = function(e) {
            var t = this.__data__,
                n = t.delete(e);
            return this.size = t.size, n
        };
        const rg = function(e) {
            return this.__data__.get(e)
        };
        const og = function(e) {
            return this.__data__.has(e)
        };
        const sg = function(e, t) {
            var n = this.__data__;
            if (n instanceof fd) {
                var i = n.__data__;
                if (!md || i.length < 199) return i.push([e, t]), this.size = ++n.size, this;
                n = this.__data__ = new wd(i)
            }
            return n.set(e, t), this.size = n.size, this
        };

        function ag(e) {
            var t = this.__data__ = new fd(e);
            this.size = t.size
        }
        ag.prototype.clear = ng, ag.prototype.delete = ig, ag.prototype.get = rg, ag.prototype.has = og, ag.prototype.set = sg;
        const lg = ag;
        const cg = function(e, t) {
            for (var n = -1, i = null == e ? 0 : e.length; ++n < i && !1 !== t(e[n], n, e););
            return e
        };
        const Ag = function(e, t, n, i) {
            var r = !n;
            n || (n = {});
            for (var o = -1, s = t.length; ++o < s;) {
                var a = t[o],
                    l = i ? i(n[a], e[a], a, n, e) : void 0;
                void 0 === l && (l = e[a]), r ? jp(n, a, l) : Jp(n, a, l)
            }
            return n
        };
        const hg = function(e, t) {
            for (var n = -1, i = Array(e); ++n < e;) i[n] = t(n);
            return i
        };
        const ug = function(e) {
            return lu(e) && "[object Arguments]" == au(e)
        };
        var dg = Object.prototype,
            pg = dg.hasOwnProperty,
            gg = dg.propertyIsEnumerable;
        const fg = ug(function() {
            return arguments
        }()) ? ug : function(e) {
            return lu(e) && pg.call(e, "callee") && !gg.call(e, "callee")
        };
        const mg = function() {
            return !1
        };
        var Eg = "object" == typeof exports && exports && !exports.nodeType && exports,
            Cg = Eg && "object" == typeof module && module && !module.nodeType && module,
            Ig = Cg && Cg.exports === Eg ? zh.Buffer : void 0;
        const Sg = (Ig ? Ig.isBuffer : void 0) || mg;
        const vg = function(e) {
            return "number" == typeof e && e > -1 && e % 1 == 0 && e <= 9007199254740991
        };
        var Bg = {};
        Bg["[object Float32Array]"] = Bg["[object Float64Array]"] = Bg["[object Int8Array]"] = Bg["[object Int16Array]"] = Bg["[object Int32Array]"] = Bg["[object Uint8Array]"] = Bg["[object Uint8ClampedArray]"] = Bg["[object Uint16Array]"] = Bg["[object Uint32Array]"] = !0, Bg["[object Arguments]"] = Bg["[object Array]"] = Bg["[object ArrayBuffer]"] = Bg["[object Boolean]"] = Bg["[object DataView]"] = Bg["[object Date]"] = Bg["[object Error]"] = Bg["[object Function]"] = Bg["[object Map]"] = Bg["[object Number]"] = Bg["[object Object]"] = Bg["[object RegExp]"] = Bg["[object Set]"] = Bg["[object String]"] = Bg["[object WeakMap]"] = !1;
        const xg = function(e) {
            return lu(e) && vg(e.length) && !!Bg[au(e)]
        };
        const yg = function(e) {
            return function(t) {
                return e(t)
            }
        };
        var wg = "object" == typeof exports && exports && !exports.nodeType && exports,
            bg = wg && "object" == typeof module && module && !module.nodeType && module,
            Qg = bg && bg.exports === wg && Jh.process;
        const Ug = function() {
            try {
                var e = bg && bg.require && bg.require("util").types;
                return e || Qg && Qg.binding && Qg.binding("util")
            } catch (e) {}
        }();
        var Mg = Ug && Ug.isTypedArray;
        const Rg = Mg ? yg(Mg) : xg;
        var Tg = Object.prototype.hasOwnProperty;
        const Fg = function(e, t) {
            var n = _h(e),
                i = !n && fg(e),
                r = !n && !i && Sg(e),
                o = !n && !i && !r && Rg(e),
                s = n || i || r || o,
                a = s ? hg(e.length, String) : [],
                l = a.length;
            for (var c in e) !t && !Tg.call(e, c) || s && ("length" == c || r && ("offset" == c || "parent" == c) || o && ("buffer" == c || "byteLength" == c || "byteOffset" == c) || zp(c, l)) || a.push(c);
            return a
        };
        var Dg = Object.prototype;
        const kg = function(e) {
            var t = e && e.constructor;
            return e === ("function" == typeof t && t.prototype || Dg)
        };
        const Lg = Pd(Object.keys, Object);
        var Kg = Object.prototype.hasOwnProperty;
        const Pg = function(e) {
            if (!kg(e)) return Lg(e);
            var t = [];
            for (var n in Object(e)) Kg.call(e, n) && "constructor" != n && t.push(n);
            return t
        };
        const Gg = function(e) {
            return null != e && vg(e.length) && !ku(e)
        };
        const Vg = function(e) {
            return Gg(e) ? Fg(e) : Pg(e)
        };
        const Og = function(e, t) {
            return e && Ag(t, Vg(t), e)
        };
        const Ng = function(e) {
            var t = [];
            if (null != e)
                for (var n in Object(e)) t.push(n);
            return t
        };
        var Hg = Object.prototype.hasOwnProperty;
        const qg = function(e) {
            if (!Du(e)) return Ng(e);
            var t = kg(e),
                n = [];
            for (var i in e)("constructor" != i || !t && Hg.call(e, i)) && n.push(i);
            return n
        };
        const jg = function(e) {
            return Gg(e) ? Fg(e, !0) : qg(e)
        };
        const Yg = function(e, t) {
            return e && Ag(t, jg(t), e)
        };
        var Jg = "object" == typeof exports && exports && !exports.nodeType && exports,
            Wg = Jg && "object" == typeof module && module && !module.nodeType && module,
            zg = Wg && Wg.exports === Jg ? zh.Buffer : void 0,
            Xg = zg ? zg.allocUnsafe : void 0;
        const Zg = function(e, t) {
            if (t) return e.slice();
            var n = e.length,
                i = Xg ? Xg(n) : new e.constructor(n);
            return e.copy(i), i
        };
        const _g = function(e, t) {
            var n = -1,
                i = e.length;
            for (t || (t = Array(i)); ++n < i;) t[n] = e[n];
            return t
        };
        const $g = function(e, t) {
            for (var n = -1, i = null == e ? 0 : e.length, r = 0, o = []; ++n < i;) {
                var s = e[n];
                t(s, n, e) && (o[r++] = s)
            }
            return o
        };
        const ef = function() {
            return []
        };
        var tf = Object.prototype.propertyIsEnumerable,
            nf = Object.getOwnPropertySymbols;
        const rf = nf ? function(e) {
            return null == e ? [] : (e = Object(e), $g(nf(e), (function(t) {
                return tf.call(e, t)
            })))
        } : ef;
        const of = function(e, t) {
            return Ag(e, rf(e), t)
        };
        const sf = function(e, t) {
            for (var n = -1, i = t.length, r = e.length; ++n < i;) e[r + n] = t[n];
            return e
        };
        const af = Object.getOwnPropertySymbols ? function(e) {
            for (var t = []; e;) sf(t, rf(e)), e = Gd(e);
            return t
        } : ef;
        const lf = function(e, t) {
            return Ag(e, af(e), t)
        };
        const cf = function(e, t, n) {
            var i = t(e);
            return _h(e) ? i : sf(i, n(e))
        };
        const Af = function(e) {
            return cf(e, Vg, rf)
        };
        const hf = function(e) {
            return cf(e, jg, af)
        };
        const uf = Xu(zh, "DataView");
        const df = Xu(zh, "Promise");
        const pf = Xu(zh, "Set");
        const gf = Xu(zh, "WeakMap");
        var ff = "[object Map]",
            mf = "[object Promise]",
            Ef = "[object Set]",
            Cf = "[object WeakMap]",
            If = "[object DataView]",
            Sf = Ou(uf),
            vf = Ou(md),
            Bf = Ou(df),
            xf = Ou(pf),
            yf = Ou(gf),
            wf = au;
        (uf && wf(new uf(new ArrayBuffer(1))) != If || md && wf(new md) != ff || df && wf(df.resolve()) != mf || pf && wf(new pf) != Ef || gf && wf(new gf) != Cf) && (wf = function(e) {
            var t = au(e),
                n = "[object Object]" == t ? e.constructor : void 0,
                i = n ? Ou(n) : "";
            if (i) switch (i) {
                case Sf:
                    return If;
                case vf:
                    return ff;
                case Bf:
                    return mf;
                case xf:
                    return Ef;
                case yf:
                    return Cf
            }
            return t
        });
        const bf = wf;
        var Qf = Object.prototype.hasOwnProperty;
        const Uf = function(e) {
            var t = e.length,
                n = new e.constructor(t);
            return t && "string" == typeof e[0] && Qf.call(e, "index") && (n.index = e.index, n.input = e.input), n
        };
        const Mf = zh.Uint8Array;
        const Rf = function(e) {
            var t = new e.constructor(e.byteLength);
            return new Mf(t).set(new Mf(e)), t
        };
        const Tf = function(e, t) {
            var n = t ? Rf(e.buffer) : e.buffer;
            return new e.constructor(n, e.byteOffset, e.byteLength)
        };
        var Ff = /\w*$/;
        const Df = function(e) {
            var t = new e.constructor(e.source, Ff.exec(e));
            return t.lastIndex = e.lastIndex, t
        };
        var kf = Xh ? Xh.prototype : void 0,
            Lf = kf ? kf.valueOf : void 0;
        const Kf = function(e) {
            return Lf ? Object(Lf.call(e)) : {}
        };
        const Pf = function(e, t) {
            var n = t ? Rf(e.buffer) : e.buffer;
            return new e.constructor(n, e.byteOffset, e.length)
        };
        const Gf = function(e, t, n) {
            var i = e.constructor;
            switch (t) {
                case "[object ArrayBuffer]":
                    return Rf(e);
                case "[object Boolean]":
                case "[object Date]":
                    return new i(+e);
                case "[object DataView]":
                    return Tf(e, n);
                case "[object Float32Array]":
                case "[object Float64Array]":
                case "[object Int8Array]":
                case "[object Int16Array]":
                case "[object Int32Array]":
                case "[object Uint8Array]":
                case "[object Uint8ClampedArray]":
                case "[object Uint16Array]":
                case "[object Uint32Array]":
                    return Pf(e, n);
                case "[object Map]":
                case "[object Set]":
                    return new i;
                case "[object Number]":
                case "[object String]":
                    return new i(e);
                case "[object RegExp]":
                    return Df(e);
                case "[object Symbol]":
                    return Kf(e)
            }
        };
        var Vf = Object.create;
        const Of = function() {
            function e() {}
            return function(t) {
                if (!Du(t)) return {};
                if (Vf) return Vf(t);
                e.prototype = t;
                var n = new e;
                return e.prototype = void 0, n
            }
        }();
        const Nf = function(e) {
            return "function" != typeof e.constructor || kg(e) ? {} : Of(Gd(e))
        };
        const Hf = function(e) {
            return lu(e) && "[object Map]" == bf(e)
        };
        var qf = Ug && Ug.isMap;
        const jf = qf ? yg(qf) : Hf;
        const Yf = function(e) {
            return lu(e) && "[object Set]" == bf(e)
        };
        var Jf = Ug && Ug.isSet;
        const Wf = Jf ? yg(Jf) : Yf;
        var zf = "[object Arguments]",
            Xf = "[object Function]",
            Zf = "[object Object]",
            _f = {};
        _f[zf] = _f["[object Array]"] = _f["[object ArrayBuffer]"] = _f["[object DataView]"] = _f["[object Boolean]"] = _f["[object Date]"] = _f["[object Float32Array]"] = _f["[object Float64Array]"] = _f["[object Int8Array]"] = _f["[object Int16Array]"] = _f["[object Int32Array]"] = _f["[object Map]"] = _f["[object Number]"] = _f[Zf] = _f["[object RegExp]"] = _f["[object Set]"] = _f["[object String]"] = _f["[object Symbol]"] = _f["[object Uint8Array]"] = _f["[object Uint8ClampedArray]"] = _f["[object Uint16Array]"] = _f["[object Uint32Array]"] = !0, _f["[object Error]"] = _f[Xf] = _f["[object WeakMap]"] = !1;
        const $f = function e(t, n, i, r, o, s) {
            var a, l = 1 & n,
                c = 2 & n,
                A = 4 & n;
            if (i && (a = o ? i(t, r, o, s) : i(t)), void 0 !== a) return a;
            if (!Du(t)) return t;
            var h = _h(t);
            if (h) {
                if (a = Uf(t), !l) return _g(t, a)
            } else {
                var u = bf(t),
                    d = u == Xf || "[object GeneratorFunction]" == u;
                if (Sg(t)) return Zg(t, l);
                if (u == Zf || u == zf || d && !o) {
                    if (a = c || d ? {} : Nf(t), !l) return c ? lf(t, Yg(a, t)) : of (t, Og(a, t))
                } else {
                    if (!_f[u]) return o ? t : {};
                    a = Gf(t, u, l)
                }
            }
            s || (s = new lg);
            var p = s.get(t);
            if (p) return p;
            s.set(t, a), Wf(t) ? t.forEach((function(r) {
                a.add(e(r, n, i, r, t, s))
            })) : jf(t) && t.forEach((function(r, o) {
                a.set(o, e(r, n, i, o, t, s))
            }));
            var g = h ? void 0 : (A ? c ? hf : Af : c ? jg : Vg)(t);
            return cg(g || t, (function(r, o) {
                g && (r = t[o = r]), Jp(a, o, e(r, n, i, o, t, s))
            })), a
        };
        const em = function(e) {
            return $f(e, 5)
        };

        function tm(e) {
            const t = new Map;
            return n => (t.has(n) || t.set(n, e(n)), t.get(n))
        }
        var nm;

        function im(e, t, n) {
            return Bp((() => {
                const i = Fp(t),
                    r = Bp.memo("driver", (() => i ? "BasicKeyframedTrack" === i.type ? function(e, t, n) {
                        return Bp((() => {
                            const e = Bp.ref("state", {
                                started: !1
                            });
                            let i = e.current;
                            const r = n.getValue();
                            return (!i.started || r < i.validFrom || i.validTo <= r) && (e.current = i = function(e, t, n) {
                                const i = nm.getSortedKeyframesCached(n.keyframes),
                                    r = t.getValue();
                                if (0 === i.length) return {
                                    started: !0,
                                    validFrom: -1 / 0,
                                    validTo: 1 / 0,
                                    der: rm
                                };
                                let o = 0;
                                for (;;) {
                                    const e = i[o];
                                    if (!e) return om.error;
                                    const n = o === i.length - 1;
                                    if (r < e.position) return 0 === o ? om.beforeFirstKeyframe(e) : om.error;
                                    if (e.position === r) return n ? om.lastKeyframe(e) : om.between(e, i[o + 1], t);
                                    if (o === i.length - 1) return om.lastKeyframe(e); {
                                        const n = o + 1;
                                        if (i[n].position <= r) {
                                            o = n;
                                            continue
                                        }
                                        return om.between(e, i[o + 1], t)
                                    }
                                }
                            }(0, n, t)), i.der.getValue()
                        }))
                    }(0, i, n) : (e.logger.error("Track type not yet supported."), Bp((() => {}))) : Bp((() => {}))), [i]);
                return r.getValue()
            }))
        }! function(e) {
            e.getSortedKeyframes = e => {
                const t = Object.values(e.byId);
                return t.sort(((e, t) => e.position - t.position)), em(t)
            }, e.getSortedKeyframesCached = tm(e.getSortedKeyframes), e.fromArray = e => {
                const t = {},
                    n = {};
                for (const i of e) t[i.id] = i, n[i.id] = !0;
                return em({
                    byId: t,
                    allIds: n
                })
            }, e.fromSortedKeyframesCached = tm(e.fromArray)
        }(nm || (nm = {}));
        const rm = Bp((() => {}));
        const om = {
            beforeFirstKeyframe: e => ({
                started: !0,
                validFrom: -1 / 0,
                validTo: e.position,
                der: Bp((() => ({
                    left: e.value,
                    progression: 0
                })))
            }),
            lastKeyframe: e => ({
                started: !0,
                validFrom: e.position,
                validTo: 1 / 0,
                der: Bp((() => ({
                    left: e.value,
                    progression: 0
                })))
            }),
            between(e, t, n) {
                if (!e.connectedRight) return {
                    started: !0,
                    validFrom: e.position,
                    validTo: t.position,
                    der: Bp((() => ({
                        left: e.value,
                        progression: 0
                    })))
                };
                const i = n => (n - e.position) / (t.position - e.position);
                if (!e.type || "bezier" === e.type) {
                    const r = new(tg())(e.handles[2], e.handles[3], t.handles[0], t.handles[1]),
                        o = Bp((() => {
                            const o = i(n.getValue()),
                                s = r.solveSimple(o);
                            return {
                                left: e.value,
                                right: t.value,
                                progression: s
                            }
                        }));
                    return {
                        started: !0,
                        validFrom: e.position,
                        validTo: t.position,
                        der: o
                    }
                }
                const r = Bp((() => {
                    const r = i(n.getValue()),
                        o = Math.floor(r);
                    return {
                        left: e.value,
                        right: t.value,
                        progression: o
                    }
                }));
                return {
                    started: !0,
                    validFrom: e.position,
                    validTo: t.position,
                    der: r
                }
            },
            error: {
                started: !0,
                validFrom: -1 / 0,
                validTo: 1 / 0,
                der: rm
            }
        };

        function sm(e, t, n) {
            const i = n.get(e);
            if (i && i.override === t) return i.merged;
            const r = Object.assign({}, e);
            for (const i of Object.keys(t)) {
                const o = t[i],
                    s = e[i];
                r[i] = "object" == typeof o && "object" == typeof s ? sm(s, o, n) : void 0 === o ? s : o
            }
            return n.set(e, {
                override: t,
                merged: r
            }), r
        }

        function am(e, t) {
            let n = e;
            for (const e of t) n = n[e];
            return n
        }
        const lm = function() {
            return zh.Date.now()
        };
        var cm = /\s/;
        const Am = function(e) {
            for (var t = e.length; t-- && cm.test(e.charAt(t)););
            return t
        };
        var hm = /^\s+/;
        const um = function(e) {
            return e ? e.slice(0, Am(e) + 1).replace(hm, "") : e
        };
        var dm = /^[-+]0x[0-9a-f]+$/i,
            pm = /^0b[01]+$/i,
            gm = /^0o[0-7]+$/i,
            fm = parseInt;
        const mm = function(e) {
            if ("number" == typeof e) return e;
            if (cu(e)) return NaN;
            if (Du(e)) {
                var t = "function" == typeof e.valueOf ? e.valueOf() : e;
                e = Du(t) ? t + "" : t
            }
            if ("string" != typeof e) return 0 === e ? e : +e;
            e = um(e);
            var n = pm.test(e);
            return n || gm.test(e) ? fm(e.slice(2), n ? 2 : 8) : dm.test(e) ? NaN : +e
        };
        var Em = Math.max,
            Cm = Math.min;
        const Im = function(e, t, n) {
            var i, r, o, s, a, l, c = 0,
                A = !1,
                h = !1,
                u = !0;
            if ("function" != typeof e) throw new TypeError("Expected a function");

            function d(t) {
                var n = i,
                    o = r;
                return i = r = void 0, c = t, s = e.apply(o, n)
            }

            function p(e) {
                var n = e - l;
                return void 0 === l || n >= t || n < 0 || h && e - c >= o
            }

            function g() {
                var e = lm();
                if (p(e)) return f(e);
                a = setTimeout(g, function(e) {
                    var n = t - (e - l);
                    return h ? Cm(n, o - (e - c)) : n
                }(e))
            }

            function f(e) {
                return a = void 0, u && i ? d(e) : (i = r = void 0, s)
            }

            function m() {
                var e = lm(),
                    n = p(e);
                if (i = arguments, r = this, l = e, n) {
                    if (void 0 === a) return function(e) {
                        return c = e, a = setTimeout(g, t), A ? d(e) : s
                    }(l);
                    if (h) return clearTimeout(a), a = setTimeout(g, t), d(l)
                }
                return void 0 === a && (a = setTimeout(g, t)), s
            }
            return t = mm(t) || 0, Du(n) && (A = !!n.leading, o = (h = "maxWait" in n) ? Em(mm(n.maxWait) || 0, t) : o, u = "trailing" in n ? !!n.trailing : u), m.cancel = function() {
                void 0 !== a && clearTimeout(a), c = 0, i = l = r = a = void 0
            }, m.flush = function() {
                return void 0 === a ? s : f(lm())
            }, m
        };
        class Sm {
            get type() {
                return "Theatre_SheetObject_PublicAPI"
            }
            constructor(e) {
                this._cache = new Hp, this._keepHotUntapDebounce = void 0, Vp(this, e)
            }
            get props() {
                return Gp(this).propsP
            }
            get sheet() {
                return Gp(this).sheet.publicApi
            }
            get project() {
                return Gp(this).sheet.project.publicApi
            }
            get address() {
                return Object.assign({}, Gp(this).address)
            }
            _valuesPrism() {
                return this._cache.get("_valuesPrism", (() => {
                    const e = Gp(this);
                    return Bp((() => Fp(e.getValues().getValue())))
                }))
            }
            onValuesChange(e, t) {
                return function(e, t, n) {
                    const i = n ? Gp(n).ticker : nC();
                    if (tp(e)) {
                        return Tp(e).onChange(i, t, !0)
                    }
                    if (Mp(e)) return e.onChange(i, t, !0);
                    throw new Error("Called onChange(p) where p is neither a pointer nor a prism.")
                }(this._valuesPrism(), e, t)
            }
            get value() {
                const e = this._valuesPrism();
                if (!e.isHot) {
                    null != this._keepHotUntapDebounce && this._keepHotUntapDebounce.flush();
                    const t = e.keepHot();
                    this._keepHotUntapDebounce = Im((() => {
                        t(), this._keepHotUntapDebounce = void 0
                    }), 5e3)
                }
                return this._keepHotUntapDebounce && this._keepHotUntapDebounce(), e.getValue()
            }
            set initialValue(e) {
                Gp(this).setInitialValue(e)
            }
        }

        function vm(e) {
            return "compound" === e.type || "enum" === e.type
        }

        function Bm(e, t) {
            if (!e) return;
            const [n, ...i] = t;
            if (void 0 === n) return e;
            if (!vm(e)) return;
            return Bm("enum" === e.type ? e.cases[n] : e.props[n], i)
        }
        const xm = tm((e => {
            if ("enum" === e.type) throw new Error("Not implemented yet for enums");
            for (const t in e.props) {
                const n = e.props[t];
                if (!vm(n)) return !0;
                if (xm(n)) return !0
            }
            return !1
        }));
        class ym {
            get type() {
                return "Theatre_SheetObject"
            }
            constructor(e, t, n) {
                this.sheet = e, this.template = t, this.nativeObject = n, this.$$isPointerToPrismProvider = !0, this._initialValue = new Up({}), this._cache = new Hp, this._logger = e._logger.named("SheetObject", t.address.objectKey), this._logger._trace("creating object"), this._internalUtilCtx = {
                    logger: this._logger.utilFor.internal()
                }, this.address = Object.assign(Object.assign({}, t.address), {
                    sheetInstanceId: e.address.sheetInstanceId
                }), this.publicApi = new Sm(this)
            }
            getValues() {
                return this._cache.get("getValues()", (() => Bp((() => {
                    const e = sm(Fp(this.template.getDefaultValues()), Fp(this._initialValue.pointer), Bp.memo("withInitialCache", (() => new WeakMap), []));
                    let t, n = sm(e, Fp(this.template.getStaticValues()), Bp.memo("withStatics", (() => new WeakMap), [])); {
                        const e = Bp.memo("seq", (() => this.getSequencedValues()), []),
                            i = Bp.memo("withSeqsCache", (() => new WeakMap), []);
                        t = Fp(Fp(e));
                        n = sm(n, t, i)
                    }
                    return ((e, t) => {
                        const n = Bp.memo(e, (() => new Up(t)), []);
                        return n.set(t), n
                    })("finalAtom", n).pointer
                }))))
            }
            getValueByPointer(e) {
                const t = Fp(this.getValues()),
                    {
                        path: n
                    } = _d(e);
                return Fp(am(t, n))
            }
            pointerToPrism(e) {
                const {
                    path: t
                } = _d(e);
                return Bp((() => {
                    const e = Fp(this.getValues());
                    return Fp(am(e, t))
                }))
            }
            getSequencedValues() {
                return Bp((() => {
                    const e = Bp.memo("tracksToProcess", (() => this.template.getArrayOfValidSequenceTracks()), []),
                        t = Fp(e),
                        n = new Up({}),
                        i = Fp(this.template.configPointer);
                    return Bp.effect("processTracks", (() => {
                        const e = [];
                        for (const {
                                trackId: r,
                                pathToProp: o
                            } of t) {
                            const t = this._trackIdToPrism(r),
                                s = Bm(i, o),
                                a = s.deserializeAndSanitize,
                                l = s.interpolate,
                                c = () => {
                                    const e = t.getValue();
                                    if (!e) return n.setByPointer((e => am(e, o)), void 0);
                                    const i = a(e.left),
                                        r = void 0 === i ? s.default : i;
                                    if (void 0 === e.right) return n.setByPointer((e => am(e, o)), r);
                                    const c = a(e.right),
                                        A = void 0 === c ? s.default : c;
                                    return n.setByPointer((e => am(e, o)), l(r, A, e.progression))
                                },
                                A = t.onStale(c);
                            c(), e.push(A)
                        }
                        return () => {
                            for (const t of e) t()
                        }
                    }), [i, ...t]), n.pointer
                }))
            }
            _trackIdToPrism(e) {
                const t = this.template.project.pointers.historic.sheetsById[this.address.sheetId].sequence.tracksByObject[this.address.objectKey].trackData[e],
                    n = this.sheet.getSequence().positionPrism;
                return im(this._internalUtilCtx, t, n)
            }
            get propsP() {
                return this._cache.get("propsP", (() => ep({
                    root: this,
                    path: []
                })))
            }
            validateValue(e, t) {}
            setInitialValue(e) {
                this.validateValue(this.propsP, e), this._initialValue.set(e)
            }
        }

        function wm(e) {
            return function(t, n) {
                return e(t, n())
            }
        }
        var bm, Qm, Um, Mm;
        ! function(e) {
            e[e.GENERAL = 1] = "GENERAL", e[e.TODO = 2] = "TODO", e[e.TROUBLESHOOTING = 4] = "TROUBLESHOOTING"
        }(bm || (bm = {})),
        function(e) {
            e[e.INTERNAL = 8] = "INTERNAL", e[e.DEV = 16] = "DEV", e[e.PUBLIC = 32] = "PUBLIC"
        }(Qm || (Qm = {})),
        function(e) {
            e[e.TRACE = 64] = "TRACE", e[e.DEBUG = 128] = "DEBUG", e[e.WARN = 256] = "WARN", e[e.ERROR = 512] = "ERROR"
        }(Um || (Um = {})),
        function(e) {
            e[e.ERROR_PUBLIC = 545] = "ERROR_PUBLIC", e[e.ERROR_DEV = 529] = "ERROR_DEV", e[e._HMM = 524] = "_HMM", e[e._TODO = 522] = "_TODO", e[e._ERROR = 521] = "_ERROR", e[e.WARN_PUBLIC = 289] = "WARN_PUBLIC", e[e.WARN_DEV = 273] = "WARN_DEV", e[e._KAPOW = 268] = "_KAPOW", e[e._WARN = 265] = "_WARN", e[e.DEBUG_DEV = 145] = "DEBUG_DEV", e[e._DEBUG = 137] = "_DEBUG", e[e.TRACE_DEV = 81] = "TRACE_DEV", e[e._TRACE = 73] = "_TRACE"
        }(Mm || (Mm = {}));
        const Rm = {
            _hmm: Tm(Mm._HMM),
            _todo: Tm(Mm._TODO),
            _error: Tm(Mm._ERROR),
            errorDev: Tm(Mm.ERROR_DEV),
            errorPublic: Tm(Mm.ERROR_PUBLIC),
            _kapow: Tm(Mm._KAPOW),
            _warn: Tm(Mm._WARN),
            warnDev: Tm(Mm.WARN_DEV),
            warnPublic: Tm(Mm.WARN_PUBLIC),
            _debug: Tm(Mm._DEBUG),
            debugDev: Tm(Mm.DEBUG_DEV),
            _trace: Tm(Mm._TRACE),
            traceDev: Tm(Mm.TRACE_DEV)
        };

        function Tm(e) {
            return Object.freeze({
                audience: Fm(e, Qm.INTERNAL) ? "internal" : Fm(e, Qm.DEV) ? "dev" : "public",
                category: Fm(e, bm.TROUBLESHOOTING) ? "troubleshooting" : Fm(e, bm.TODO) ? "todo" : "general",
                level: Fm(e, Um.ERROR) ? Um.ERROR : Fm(e, Um.WARN) ? Um.WARN : Fm(e, Um.DEBUG) ? Um.DEBUG : Um.TRACE
            })
        }

        function Fm(e, t) {
            return (e & t) === t
        }

        function Dm(e, t) {
            return ((t & Qm.PUBLIC) === Qm.PUBLIC || ((t & Qm.DEV) === Qm.DEV ? e.dev : (t & Qm.INTERNAL) === Qm.INTERNAL && e.internal)) && e.min <= t
        }
        const km = {
            loggingConsoleStyle: !0,
            loggerConsoleStyle: !0,
            includes: Object.freeze({
                internal: !1,
                dev: !1,
                min: Um.WARN
            }),
            filtered: function() {},
            include: function() {
                return {}
            },
            create: null,
            creatExt: null,
            named(e, t, n) {
                return this.create({
                    names: [...e.names, {
                        name: t,
                        key: n
                    }]
                })
            },
            style: {
                bold: void 0,
                italic: void 0,
                cssMemo: new Map([
                    ["", ""]
                ]),
                collapseOnRE: /[a-z- ]+/g,
                color: void 0,
                collapsed(e) {
                    if (e.length < 5) return e;
                    const t = e.replace(this.collapseOnRE, "");
                    return this.cssMemo.has(t) || this.cssMemo.set(t, this.css(e)), t
                },
                css(e) {
                    var t, n, i, r;
                    const o = this.cssMemo.get(e);
                    if (o) return o;
                    let s = `color:${null!==(n=null===(t=this.color)||void 0===t?void 0:t.call(this,e))&&void 0!==n?n:`hsl(${(e.charCodeAt(0)+e.charCodeAt(e.length-1))%360}, 100%, 60%)`}`;
                    return (null === (i = this.bold) || void 0 === i ? void 0 : i.test(e)) && (s += ";font-weight:600"), (null === (r = this.italic) || void 0 === r ? void 0 : r.test(e)) && (s += ";font-style:italic"), this.cssMemo.set(e, s), s
                }
            }
        };

        function Lm(e = console, t = {}) {
            const n = Object.assign(Object.assign({}, km), {
                    includes: Object.assign({}, km.includes)
                }),
                i = {
                    styled: Gm.bind(n, e),
                    noStyle: Vm.bind(n, e)
                },
                r = Pm.bind(n);

            function o() {
                return n.loggingConsoleStyle && n.loggerConsoleStyle ? i.styled : i.noStyle
            }
            return n.create = o(), {
                configureLogger(e) {
                    var t;
                    "console" === e ? (n.loggerConsoleStyle = km.loggerConsoleStyle, n.create = o()) : "console" === e.type ? (n.loggerConsoleStyle = null !== (t = e.style) && void 0 !== t ? t : km.loggerConsoleStyle, n.create = o()) : "keyed" === e.type ? (n.creatExt = t => e.keyed(t.names), n.create = r) : "named" === e.type && (n.creatExt = Km.bind(null, e.named), n.create = r)
                },
                configureLogging(e) {
                    var t, i, r, s, a;
                    n.includes.dev = null !== (t = e.dev) && void 0 !== t ? t : km.includes.dev, n.includes.internal = null !== (i = e.internal) && void 0 !== i ? i : km.includes.internal, n.includes.min = null !== (r = e.min) && void 0 !== r ? r : km.includes.min, n.include = null !== (s = e.include) && void 0 !== s ? s : km.include, n.loggingConsoleStyle = null !== (a = e.consoleStyle) && void 0 !== a ? a : km.loggingConsoleStyle, n.create = o()
                },
                getLogger: () => n.create({
                    names: []
                })
            }
        }

        function Km(e, t) {
            const n = [];
            for (let {
                    name: e,
                    key: i
                } of t.names) n.push(null == i ? e : `${e} (${i})`);
            return e(n)
        }

        function Pm(e) {
            const t = Object.assign(Object.assign({}, this.includes), this.include(e)),
                n = this.filtered,
                i = this.named.bind(this, e),
                r = this.creatExt(e),
                o = Dm(t, Mm._HMM),
                s = Dm(t, Mm._TODO),
                a = Dm(t, Mm._ERROR),
                l = Dm(t, Mm.ERROR_DEV),
                c = Dm(t, Mm.ERROR_PUBLIC),
                A = Dm(t, Mm._WARN),
                h = Dm(t, Mm._KAPOW),
                u = Dm(t, Mm.WARN_DEV),
                d = Dm(t, Mm.WARN_PUBLIC),
                p = Dm(t, Mm._DEBUG),
                g = Dm(t, Mm.DEBUG_DEV),
                f = Dm(t, Mm._TRACE),
                m = Dm(t, Mm.TRACE_DEV),
                E = o ? r.error.bind(r, Rm._hmm) : n.bind(e, Mm._HMM),
                C = s ? r.error.bind(r, Rm._todo) : n.bind(e, Mm._TODO),
                I = a ? r.error.bind(r, Rm._error) : n.bind(e, Mm._ERROR),
                S = l ? r.error.bind(r, Rm.errorDev) : n.bind(e, Mm.ERROR_DEV),
                v = c ? r.error.bind(r, Rm.errorPublic) : n.bind(e, Mm.ERROR_PUBLIC),
                B = h ? r.warn.bind(r, Rm._kapow) : n.bind(e, Mm._KAPOW),
                x = A ? r.warn.bind(r, Rm._warn) : n.bind(e, Mm._WARN),
                y = u ? r.warn.bind(r, Rm.warnDev) : n.bind(e, Mm.WARN_DEV),
                w = d ? r.warn.bind(r, Rm.warnPublic) : n.bind(e, Mm.WARN_DEV),
                b = p ? r.debug.bind(r, Rm._debug) : n.bind(e, Mm._DEBUG),
                Q = g ? r.debug.bind(r, Rm.debugDev) : n.bind(e, Mm.DEBUG_DEV),
                U = f ? r.trace.bind(r, Rm._trace) : n.bind(e, Mm._TRACE),
                M = m ? r.trace.bind(r, Rm.traceDev) : n.bind(e, Mm.TRACE_DEV),
                R = {
                    _hmm: E,
                    _todo: C,
                    _error: I,
                    errorDev: S,
                    errorPublic: v,
                    _kapow: B,
                    _warn: x,
                    warnDev: y,
                    warnPublic: w,
                    _debug: b,
                    debugDev: Q,
                    _trace: U,
                    traceDev: M,
                    lazy: {
                        _hmm: o ? wm(E) : E,
                        _todo: s ? wm(C) : C,
                        _error: a ? wm(I) : I,
                        errorDev: l ? wm(S) : S,
                        errorPublic: c ? wm(v) : v,
                        _kapow: h ? wm(B) : B,
                        _warn: A ? wm(x) : x,
                        warnDev: u ? wm(y) : y,
                        warnPublic: d ? wm(w) : w,
                        _debug: p ? wm(b) : b,
                        debugDev: g ? wm(Q) : Q,
                        _trace: f ? wm(U) : U,
                        traceDev: m ? wm(M) : M
                    },
                    named: i,
                    utilFor: {
                        internal: () => ({
                            debug: R._debug,
                            error: R._error,
                            warn: R._warn,
                            trace: R._trace,
                            named: (e, t) => R.named(e, t).utilFor.internal()
                        }),
                        dev: () => ({
                            debug: R.debugDev,
                            error: R.errorDev,
                            warn: R.warnDev,
                            trace: R.traceDev,
                            named: (e, t) => R.named(e, t).utilFor.dev()
                        }),
                        public: () => ({
                            error: R.errorPublic,
                            warn: R.warnPublic,
                            debug(e, t) {
                                R._warn(`(public "debug" filtered out) ${e}`, t)
                            },
                            trace(e, t) {
                                R._warn(`(public "trace" filtered out) ${e}`, t)
                            },
                            named: (e, t) => R.named(e, t).utilFor.public()
                        })
                    }
                };
            return R
        }

        function Gm(e, t) {
            const n = Object.assign(Object.assign({}, this.includes), this.include(t)),
                i = [];
            let r = "";
            for (let e = 0; e < t.names.length; e++) {
                const {
                    name: n,
                    key: o
                } = t.names[e];
                if (r += ` %c${n}`, i.push(this.style.css(n)), null != o) {
                    const e = `%c#${o}`;
                    r += e, i.push(this.style.css(e))
                }
            }
            const o = this.filtered,
                s = this.named.bind(this, t),
                a = [r, ...i];
            return Om(o, t, n, e, a, function(e) {
                const t = e.slice(0);
                for (let e = 1; e < t.length; e++) t[e] += ";background-color:#e0005a;padding:2px;color:white";
                return t
            }(a), s)
        }

        function Vm(e, t) {
            const n = Object.assign(Object.assign({}, this.includes), this.include(t));
            let i = "";
            for (let e = 0; e < t.names.length; e++) {
                const {
                    name: n,
                    key: r
                } = t.names[e];
                i += ` ${n}`, null != r && (i += `#${r}`)
            }
            const r = [i];
            return Om(this.filtered, t, n, e, r, r, this.named.bind(this, t))
        }

        function Om(e, t, n, i, r, o, s) {
            const a = Dm(n, Mm._HMM),
                l = Dm(n, Mm._TODO),
                c = Dm(n, Mm._ERROR),
                A = Dm(n, Mm.ERROR_DEV),
                h = Dm(n, Mm.ERROR_PUBLIC),
                u = Dm(n, Mm._WARN),
                d = Dm(n, Mm._KAPOW),
                p = Dm(n, Mm.WARN_DEV),
                g = Dm(n, Mm.WARN_PUBLIC),
                f = Dm(n, Mm._DEBUG),
                m = Dm(n, Mm.DEBUG_DEV),
                E = Dm(n, Mm._TRACE),
                C = Dm(n, Mm.TRACE_DEV),
                I = a ? i.error.bind(i, ...r) : e.bind(t, Mm._HMM),
                S = l ? i.error.bind(i, ...r) : e.bind(t, Mm._TODO),
                v = c ? i.error.bind(i, ...r) : e.bind(t, Mm._ERROR),
                B = A ? i.error.bind(i, ...r) : e.bind(t, Mm.ERROR_DEV),
                x = h ? i.error.bind(i, ...r) : e.bind(t, Mm.ERROR_PUBLIC),
                y = d ? i.warn.bind(i, ...o) : e.bind(t, Mm._KAPOW),
                w = u ? i.warn.bind(i, ...r) : e.bind(t, Mm._WARN),
                b = p ? i.warn.bind(i, ...r) : e.bind(t, Mm.WARN_DEV),
                Q = g ? i.warn.bind(i, ...r) : e.bind(t, Mm.WARN_DEV),
                U = f ? i.info.bind(i, ...r) : e.bind(t, Mm._DEBUG),
                M = m ? i.info.bind(i, ...r) : e.bind(t, Mm.DEBUG_DEV),
                R = E ? i.debug.bind(i, ...r) : e.bind(t, Mm._TRACE),
                T = C ? i.debug.bind(i, ...r) : e.bind(t, Mm.TRACE_DEV),
                F = {
                    _hmm: I,
                    _todo: S,
                    _error: v,
                    errorDev: B,
                    errorPublic: x,
                    _kapow: y,
                    _warn: w,
                    warnDev: b,
                    warnPublic: Q,
                    _debug: U,
                    debugDev: M,
                    _trace: R,
                    traceDev: T,
                    lazy: {
                        _hmm: a ? wm(I) : I,
                        _todo: l ? wm(S) : S,
                        _error: c ? wm(v) : v,
                        errorDev: A ? wm(B) : B,
                        errorPublic: h ? wm(x) : x,
                        _kapow: d ? wm(y) : y,
                        _warn: u ? wm(w) : w,
                        warnDev: p ? wm(b) : b,
                        warnPublic: g ? wm(Q) : Q,
                        _debug: f ? wm(U) : U,
                        debugDev: m ? wm(M) : M,
                        _trace: E ? wm(R) : R,
                        traceDev: C ? wm(T) : T
                    },
                    named: s,
                    utilFor: {
                        internal: () => ({
                            debug: F._debug,
                            error: F._error,
                            warn: F._warn,
                            trace: F._trace,
                            named: (e, t) => F.named(e, t).utilFor.internal()
                        }),
                        dev: () => ({
                            debug: F.debugDev,
                            error: F.errorDev,
                            warn: F.warnDev,
                            trace: F.traceDev,
                            named: (e, t) => F.named(e, t).utilFor.dev()
                        }),
                        public: () => ({
                            error: F.errorPublic,
                            warn: F.warnPublic,
                            debug(e, t) {
                                F._warn(`(public "debug" filtered out) ${e}`, t)
                            },
                            trace(e, t) {
                                F._warn(`(public "trace" filtered out) ${e}`, t)
                            },
                            named: (e, t) => F.named(e, t).utilFor.public()
                        })
                    }
                };
            return F
        }
        const Nm = Lm(console, {
            _debug: function() {},
            _error: function() {}
        });
        Nm.configureLogging({
            dev: !0,
            min: Um.TRACE
        });
        const Hm = Nm.getLogger().named("Theatre.js (default logger)").utilFor.dev(),
            qm = new WeakMap;

        function jm(e, t, n) {
            for (const [i, r] of Object.entries(t.props))
                if (!vm(r)) {
                    const t = [...e, i];
                    n.set(JSON.stringify(t), n.size), Ym(t, r, n)
                }
            for (const [i, r] of Object.entries(t.props))
                if (vm(r)) {
                    const t = [...e, i];
                    n.set(JSON.stringify(t), n.size), Ym(t, r, n)
                }
        }

        function Ym(e, t, n) {
            if ("compound" === t.type) jm(e, t, n);
            else {
                if ("enum" === t.type) throw new Error("Enums aren't supported yet");
                n.set(JSON.stringify(e), n.size)
            }
        }
        const Jm = function(e, t, n) {
            var i = -1,
                r = e.length;
            t < 0 && (t = -t > r ? 0 : r + t), (n = n > r ? r : n) < 0 && (n += r), r = t > n ? 0 : n - t >>> 0, t >>>= 0;
            for (var o = Array(r); ++i < r;) o[i] = e[i + t];
            return o
        };
        const Wm = function(e, t) {
            return t.length < 2 ? e : Ld(e, Jm(t, 0, -1))
        };
        const zm = function(e, t) {
            return t = Dd(t, e), null == (e = Wm(e, t)) || delete e[kd(Yd(t))]
        };
        const Xm = function(e, t) {
            return null == e || zm(e, t)
        };

        function Zm(e) {
            return "object" == typeof e && null !== e && 0 === Object.keys(e).length
        }
        class _m {
            get staticConfig() {
                return this._config.get()
            }
            get configPointer() {
                return this._config.pointer
            }
            get _temp_actions() {
                return this._temp_actions_atom.get()
            }
            get _temp_actionsPointer() {
                return this._temp_actions_atom.pointer
            }
            constructor(e, t, n, i, r) {
                this.sheetTemplate = e, this.type = "Theatre_SheetObjectTemplate", this._cache = new Hp, this.address = Object.assign(Object.assign({}, e.address), {
                    objectKey: t
                }), this._config = new Up(i), this._temp_actions_atom = new Up(r), this.project = e.project, this.pointerToSheetState = this.sheetTemplate.project.pointers.historic.sheetsById[this.address.sheetId], this.pointerToStaticOverrides = this.pointerToSheetState.staticOverrides.byObject[this.address.objectKey]
            }
            createInstance(e, t, n) {
                return this._config.set(n), new ym(e, this, t)
            }
            reconfigure(e) {
                this._config.set(e)
            }
            _temp_setActions(e) {
                this._temp_actions_atom.set(e)
            }
            getDefaultValues() {
                return this._cache.get("getDefaultValues()", (() => Bp((() => function(e) {
                    return $p(e)
                }(Fp(this.configPointer))))))
            }
            getStaticValues() {
                return this._cache.get("getStaticValues", (() => Bp((() => {
                    var e;
                    const t = null !== (e = Fp(this.pointerToStaticOverrides)) && void 0 !== e ? e : {};
                    return Fp(this.configPointer).deserializeAndSanitize(t) || {}
                }))))
            }
            getArrayOfValidSequenceTracks() {
                return this._cache.get("getArrayOfValidSequenceTracks", (() => Bp((() => {
                    const e = this.project.pointers.historic.sheetsById[this.address.sheetId],
                        t = Fp(e.sequence.tracksByObject[this.address.objectKey].trackIdByPropPath);
                    if (!t) return Op;
                    const n = [];
                    if (!t) return Op;
                    const i = Fp(this.configPointer),
                        r = Object.entries(t);
                    for (const [e, t] of r) {
                        const r = $m(e);
                        if (!r) continue;
                        const o = Bm(i, r);
                        o && !vm(o) && n.push({
                            pathToProp: r,
                            trackId: t
                        })
                    }
                    const o = function(e) {
                        const t = qm.get(e);
                        if (t) return t;
                        const n = new Map;
                        return qm.set(e, n), jm([], e, n), n
                    }(i);
                    return n.sort(((e, t) => {
                        const n = e.pathToProp,
                            i = t.pathToProp;
                        return o.get(JSON.stringify(n)) > o.get(JSON.stringify(i)) ? 1 : -1
                    })), 0 === n.length ? Op : n
                }))))
            }
            getMapOfValidSequenceTracks_forStudio() {
                return this._cache.get("getMapOfValidSequenceTracks_forStudio", (() => Bp((() => {
                    const e = Fp(this.getArrayOfValidSequenceTracks()),
                        t = {};
                    for (const {
                            pathToProp: n,
                            trackId: i
                        } of e) Zp(t, n, i);
                    return t
                }))))
            }
            getStaticButNotSequencedOverrides() {
                return this._cache.get("getStaticButNotSequencedOverrides", (() => Bp((() => {
                    const e = Fp(this.getStaticValues()),
                        t = Fp(this.getArrayOfValidSequenceTracks()),
                        n = em(e);
                    for (const {
                            pathToProp: e
                        } of t) {
                        Xm(n, e);
                        let t = e.slice(0, -1);
                        for (; t.length > 0;) {
                            if (!Zm(Np(n, t))) break;
                            Xm(n, t), t = t.slice(0, -1)
                        }
                    }
                    return Zm(n) ? void 0 : n
                }))))
            }
            getDefaultsAtPointer(e) {
                const {
                    path: t
                } = _d(e);
                return Np(this.getDefaultValues().getValue(), t)
            }
        }

        function $m(e) {
            try {
                return JSON.parse(e)
            } catch (t) {
                return void Hm.warn(`property ${JSON.stringify(e)} cannot be parsed. Skipping.`)
            }
        }
        const eE = tm((e => JSON.stringify(e)));
        tm((e => JSON.parse(e)));
        n(722);
        class tE extends Error {}
        class nE extends tE {}
        var iE = Math.floor;
        const rE = function(e, t) {
            var n = "";
            if (!e || t < 1 || t > 9007199254740991) return n;
            do {
                t % 2 && (n += e), (t = iE(t / 2)) && (e += e)
            } while (t);
            return n
        };
        const oE = function(e, t, n) {
            var i = e.length;
            return n = void 0 === n ? i : n, !t && n >= i ? e : Jm(e, t, n)
        };
        var sE = RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]");
        const aE = function(e) {
            return sE.test(e)
        };
        const lE = function(e) {
            return function(t) {
                return null == t ? void 0 : t[e]
            }
        };
        const cE = lE("length");
        var AE = "\\ud800-\\udfff",
            hE = "[" + AE + "]",
            uE = "[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]",
            dE = "\\ud83c[\\udffb-\\udfff]",
            pE = "[^" + AE + "]",
            gE = "(?:\\ud83c[\\udde6-\\uddff]){2}",
            fE = "[\\ud800-\\udbff][\\udc00-\\udfff]",
            mE = "(?:" + uE + "|" + dE + ")" + "?",
            EE = "[\\ufe0e\\ufe0f]?",
            CE = EE + mE + ("(?:\\u200d(?:" + [pE, gE, fE].join("|") + ")" + EE + mE + ")*"),
            IE = "(?:" + [pE + uE + "?", uE, gE, fE, hE].join("|") + ")",
            SE = RegExp(dE + "(?=" + dE + ")|" + IE + CE, "g");
        const vE = function(e) {
            for (var t = SE.lastIndex = 0; SE.test(e);) ++t;
            return t
        };
        const BE = function(e) {
            return aE(e) ? vE(e) : cE(e)
        };
        const xE = function(e) {
            return e.split("")
        };
        var yE = "\\ud800-\\udfff",
            wE = "[" + yE + "]",
            bE = "[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]",
            QE = "\\ud83c[\\udffb-\\udfff]",
            UE = "[^" + yE + "]",
            ME = "(?:\\ud83c[\\udde6-\\uddff]){2}",
            RE = "[\\ud800-\\udbff][\\udc00-\\udfff]",
            TE = "(?:" + bE + "|" + QE + ")" + "?",
            FE = "[\\ufe0e\\ufe0f]?",
            DE = FE + TE + ("(?:\\u200d(?:" + [UE, ME, RE].join("|") + ")" + FE + TE + ")*"),
            kE = "(?:" + [UE + bE + "?", bE, ME, RE, wE].join("|") + ")",
            LE = RegExp(QE + "(?=" + QE + ")|" + kE + DE, "g");
        const KE = function(e) {
            return e.match(LE) || []
        };
        const PE = function(e) {
            return aE(e) ? KE(e) : xE(e)
        };
        var GE = Math.ceil;
        const VE = function(e, t) {
            var n = (t = void 0 === t ? " " : uu(t)).length;
            if (n < 2) return n ? rE(t, e) : t;
            var i = rE(t, GE(e / BE(t)));
            return aE(t) ? oE(PE(i), 0, e).join("") : i.slice(0, e)
        };
        var OE = 1 / 0;
        const NE = function(e) {
            return e ? (e = mm(e)) === OE || e === -1 / 0 ? 17976931348623157e292 * (e < 0 ? -1 : 1) : e == e ? e : 0 : 0 === e ? e : 0
        };
        const HE = function(e) {
            var t = NE(e),
                n = t % 1;
            return t == t ? n ? t - n : t : 0
        };
        const qE = function(e, t, n) {
            e = du(e);
            var i = (t = HE(t)) ? BE(e) : 0;
            return t && i < t ? VE(t - i, n) + e : e
        };

        function jE() {
            let e, t;
            const n = new Promise(((n, r) => {
                    e = e => {
                        n(e), i.status = "resolved"
                    }, t = e => {
                        r(e), i.status = "rejected"
                    }
                })),
                i = {
                    resolve: e,
                    reject: t,
                    promise: n,
                    status: "pending"
                };
            return i
        }
        const YE = () => {};
        class JE {
            constructor() {
                this._stopPlayCallback = YE, this._state = new Up({
                    position: 0,
                    playing: !1
                }), this.statePointer = this._state.pointer
            }
            destroy() {}
            pause() {
                this._stopPlayCallback(), this.playing = !1, this._stopPlayCallback = YE
            }
            gotoPosition(e) {
                this._updatePositionInState(e)
            }
            _updatePositionInState(e) {
                this._state.setByPointer((e => e.position), e)
            }
            getCurrentPosition() {
                return this._state.get().position
            }
            get playing() {
                return this._state.get().playing
            }
            set playing(e) {
                this._state.setByPointer((e => e.playing), e)
            }
            play(e, t, n, i, r) {
                this.playing && this.pause(), this.playing = !0;
                const o = t[1] - t[0]; {
                    const e = this.getCurrentPosition();
                    e < t[0] || e > t[1] ? "normal" === i || "alternate" === i ? this._updatePositionInState(t[0]) : "reverse" !== i && "alternateReverse" !== i || this._updatePositionInState(t[1]) : "normal" === i || "alternate" === i ? e === t[1] && this._updatePositionInState(t[0]) : e === t[0] && this._updatePositionInState(t[1])
                }
                const s = jE(),
                    a = r.time,
                    l = o * e;
                let c = this.getCurrentPosition() - t[0];
                "reverse" !== i && "alternateReverse" !== i || (c = t[1] - this.getCurrentPosition());
                const A = r => {
                    const A = Math.max(r - a, 0) / 1e3,
                        u = Math.min(A * n + c, l);
                    if (u !== l) {
                        const e = Math.floor(u / o);
                        let n = u / o % 1 * o;
                        if ("normal" !== i)
                            if ("reverse" === i) n = o - n;
                            else {
                                const t = e % 2 == 0;
                                "alternate" === i ? t || (n = o - n) : t && (n = o - n)
                            }
                        this._updatePositionInState(n + t[0]), h()
                    } else {
                        if ("normal" === i) this._updatePositionInState(t[1]);
                        else if ("reverse" === i) this._updatePositionInState(t[0]);
                        else {
                            const n = (e - 1) % 2 == 0;
                            "alternate" === i ? n ? this._updatePositionInState(t[1]) : this._updatePositionInState(t[0]) : n ? this._updatePositionInState(t[0]) : this._updatePositionInState(t[1])
                        }
                        this.playing = !1, s.resolve(!0)
                    }
                };
                this._stopPlayCallback = () => {
                    r.offThisOrNextTick(A), r.offNextTick(A), this.playing && s.resolve(!1)
                };
                const h = () => r.onNextTick(A);
                return r.onThisOrNextTick(A), s.promise
            }
            playDynamicRange(e, t) {
                this.playing && this.pause(), this.playing = !0;
                const n = jE(),
                    i = e.keepHot();
                n.promise.then(i, i);
                let r = t.time;
                const o = t => {
                    const n = Math.max(t - r, 0);
                    r = t;
                    const i = n / 1e3,
                        o = this.getCurrentPosition(),
                        a = e.getValue();
                    if (o < a[0] || o > a[1]) this.gotoPosition(a[0]);
                    else {
                        let e = o + i;
                        e > a[1] && (e = a[0] + (e - a[1])), this.gotoPosition(e)
                    }
                    s()
                };
                this._stopPlayCallback = () => {
                    t.offThisOrNextTick(o), t.offNextTick(o), n.resolve(!1)
                };
                const s = () => t.onNextTick(o);
                return t.onThisOrNextTick(o), n.promise
            }
        }
        const WE = "__TheatreJS_CoreBundle",
            zE = e => (...t) => {
                var n;
                switch (e) {
                    case "success":
                    case "info":
                        Hm.debug(t.slice(0, 2).join("\n"));
                        break;
                    case "warning":
                        Hm.warn(t.slice(0, 2).join("\n"))
                }
                return "undefined" != typeof window ? null === (n = window.__TheatreJS_Notifications) || void 0 === n ? void 0 : n.notify[e](...t) : void 0
            },
            XE = {
                warning: zE("warning"),
                success: zE("success"),
                info: zE("info"),
                error: zE("error")
            };
        "undefined" != typeof window && (window.addEventListener("error", (e => {
            XE.error("An error occurred", `<pre>${e.message}</pre>\n\nSee **console** for details.`)
        })), window.addEventListener("unhandledrejection", (e => {
            XE.error("An error occurred", `<pre>${e.reason}</pre>\n\nSee **console** for details.`)
        })));
        class ZE {
            constructor(e, t, n) {
                this._decodedBuffer = e, this._audioContext = t, this._nodeDestination = n, this._state = new Up({
                    position: 0,
                    playing: !1
                }), this._stopPlayCallback = YE, this.statePointer = this._state.pointer, this._mainGain = this._audioContext.createGain(), this._mainGain.connect(this._nodeDestination)
            }
            playDynamicRange(e, t) {
                const n = jE();
                let i;
                this._playing && this.pause(), this._playing = !0;
                const r = () => {
                        null == i || i(), i = this._loopInRange(e.getValue(), t).stop
                    },
                    o = e.onStale(r);
                return r(), this._stopPlayCallback = () => {
                    null == i || i(), o(), n.resolve(!1)
                }, n.promise
            }
            _loopInRange(e, t) {
                let n = this.getCurrentPosition();
                const i = e[1] - e[0];
                (n < e[0] || n > e[1] || n === e[1]) && this._updatePositionInState(e[0]), n = this.getCurrentPosition();
                const r = this._audioContext.createBufferSource();
                r.buffer = this._decodedBuffer, r.connect(this._mainGain), r.playbackRate.value = 1, r.loop = !0, r.loopStart = e[0], r.loopEnd = e[1];
                const o = t.time;
                let s = n - e[0];
                r.start(0, n);
                const a = t => {
                        let n = (1 * (Math.max(t - o, 0) / 1e3) + s) / i % 1 * i;
                        this._updatePositionInState(n + e[0]), l()
                    },
                    l = () => t.onNextTick(a);
                t.onThisOrNextTick(a);
                return {
                    stop: () => {
                        r.stop(), r.disconnect(), t.offThisOrNextTick(a), t.offNextTick(a)
                    }
                }
            }
            get _playing() {
                return this._state.get().playing
            }
            set _playing(e) {
                this._state.setByPointer((e => e.playing), e)
            }
            destroy() {}
            pause() {
                this._stopPlayCallback(), this._playing = !1, this._stopPlayCallback = YE
            }
            gotoPosition(e) {
                this._updatePositionInState(e)
            }
            _updatePositionInState(e) {
                this._state.reduce((t => Object.assign(Object.assign({}, t), {
                    position: e
                })))
            }
            getCurrentPosition() {
                return this._state.get().position
            }
            play(e, t, n, i, r) {
                this._playing && this.pause(), this._playing = !0;
                let o = this.getCurrentPosition();
                const s = t[1] - t[0];
                if ("normal" !== i) throw new nE(`Audio-controlled sequences can only be played in the "normal" direction. '${i}' given.`);
                (o < t[0] || o > t[1] || o === t[1]) && this._updatePositionInState(t[0]), o = this.getCurrentPosition();
                const a = jE(),
                    l = this._audioContext.createBufferSource();
                l.buffer = this._decodedBuffer, l.connect(this._mainGain), l.playbackRate.value = n, e > 1e3 && (XE.warning("Can't play sequences with audio more than 1000 times", `The sequence will still play, but only 1000 times. The \`iterationCount: ${e}\` provided to \`sequence.play()\`\nis too high for a sequence with audio.\n\nTo fix this, either set \`iterationCount\` to a lower value, or remove the audio from the sequence.`, [{
                    url: "https://www.theatrejs.com/docs/latest/manual/audio",
                    title: "Using Audio"
                }, {
                    url: "https://www.theatrejs.com/docs/latest/api/core#sequence.attachaudio",
                    title: "Audio API"
                }]), e = 1e3), e > 1 && (l.loop = !0, l.loopStart = t[0], l.loopEnd = t[1]);
                const c = r.time;
                let A = o - t[0];
                const h = s * e;
                l.start(0, o, h - A);
                const u = e => {
                        const i = Math.max(e - c, 0) / 1e3,
                            r = Math.min(i * n + A, h);
                        if (r !== h) {
                            let e = r / s % 1 * s;
                            this._updatePositionInState(e + t[0]), p()
                        } else this._updatePositionInState(t[1]), this._playing = !1, d(), a.resolve(!0)
                    },
                    d = () => {
                        l.stop(), l.disconnect()
                    };
                this._stopPlayCallback = () => {
                    d(), r.offThisOrNextTick(u), r.offNextTick(u), this._playing && a.resolve(!1)
                };
                const p = () => r.onNextTick(u);
                return r.onThisOrNextTick(u), a.promise
            }
        }
        let _E, $E = 0;

        function eC() {
            let e = null;
            const t = function(e) {
                var t;
                const n = new Dp({
                        onActive() {
                            var t;
                            null === (t = null == e ? void 0 : e.start) || void 0 === t || t.call(e)
                        },
                        onDormant() {
                            var t;
                            null === (t = null == e ? void 0 : e.stop) || void 0 === t || t.call(e)
                        }
                    }),
                    i = {
                        tick: e => {
                            n.tick(e)
                        },
                        id: $E++,
                        name: null !== (t = null == e ? void 0 : e.name) && void 0 !== t ? t : `CustomRafDriver-${$E}`,
                        type: "Theatre_RafDriver_PublicAPI"
                    };
                return Vp(i, {
                    type: "Theatre_RafDriver_PrivateAPI",
                    publicApi: i,
                    ticker: n,
                    start: null == e ? void 0 : e.start,
                    stop: null == e ? void 0 : e.stop
                }), i
            }({
                name: "DefaultCoreRafDriver",
                start: () => {
                    if ("undefined" != typeof window) {
                        const n = i => {
                            t.tick(i), e = window.requestAnimationFrame(n)
                        };
                        e = window.requestAnimationFrame(n)
                    } else t.tick(0), setTimeout((() => t.tick(1)), 0)
                },
                stop: () => {
                    "undefined" != typeof window && null !== e && window.cancelAnimationFrame(e)
                }
            });
            return t
        }

        function tC() {
            return _E || function(e) {
                if (_E) throw new Error("`setCoreRafDriver()` is already called.");
                const t = Gp(e);
                _E = t
            }(eC()), _E
        }

        function nC() {
            return tC().ticker
        }
        var iC = function(e, t, n, i) {
            return new(n || (n = Promise))((function(r, o) {
                function s(e) {
                    try {
                        l(i.next(e))
                    } catch (e) {
                        o(e)
                    }
                }

                function a(e) {
                    try {
                        l(i.throw(e))
                    } catch (e) {
                        o(e)
                    }
                }

                function l(e) {
                    var t;
                    e.done ? r(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(s, a)
                }
                l((i = i.apply(e, t || [])).next())
            }))
        };
        class rC {
            get type() {
                return "Theatre_Sequence_PublicAPI"
            }
            constructor(e) {
                Vp(this, e)
            }
            play(e) {
                const t = Gp(this);
                if (t._project.isReady()) {
                    const n = (null == e ? void 0 : e.rafDriver) ? Gp(e.rafDriver).ticker : nC();
                    return t.play(null != e ? e : {}, n)
                } {
                    0;
                    const e = jE();
                    return e.resolve(!0), e.promise
                }
            }
            pause() {
                Gp(this).pause()
            }
            get position() {
                return Gp(this).position
            }
            set position(e) {
                Gp(this).position = e
            }
            __experimental_getKeyframes(e) {
                return Gp(this).getKeyframesOfSimpleProp(e)
            }
            attachAudio(e) {
                return iC(this, void 0, void 0, (function*() {
                    const {
                        audioContext: t,
                        destinationNode: n,
                        decodedBuffer: i,
                        gainNode: r
                    } = yield function(e) {
                        return iC(this, void 0, void 0, (function*() {
                            function t() {
                                if (e.audioContext) return Promise.resolve(e.audioContext);
                                const t = new AudioContext;
                                return "running" === t.state || "undefined" == typeof window ? Promise.resolve(t) : new Promise((e => {
                                    const n = () => {
                                            t.resume().catch((e => {
                                                console.error(e)
                                            }))
                                        },
                                        i = ["mousedown", "keydown", "touchstart"],
                                        r = {
                                            capture: !0,
                                            passive: !1
                                        };
                                    i.forEach((e => {
                                        window.addEventListener(e, n, r)
                                    })), t.addEventListener("statechange", (() => {
                                        "running" === t.state && (i.forEach((e => {
                                            window.removeEventListener(e, n, r)
                                        })), e(t))
                                    }))
                                }))
                            }

                            function n() {
                                return iC(this, void 0, void 0, (function*() {
                                    if (e.source instanceof AudioBuffer) return e.source;
                                    const t = jE();
                                    if ("string" != typeof e.source) throw new Error("Error validating arguments to sequence.attachAudio(). args.source must either be a string or an instance of AudioBuffer.");
                                    let n, r;
                                    try {
                                        n = yield fetch(e.source)
                                    } catch (t) {
                                        throw console.error(t), new Error(`Could not fetch '${e.source}'. Network error logged above.`)
                                    }
                                    try {
                                        r = yield n.arrayBuffer()
                                    } catch (t) {
                                        throw console.error(t), new Error(`Could not read '${e.source}' as an arrayBuffer.`)
                                    }
                                    let o;
                                    (yield i).decodeAudioData(r, t.resolve, t.reject);
                                    try {
                                        o = yield t.promise
                                    } catch (t) {
                                        throw console.error(t), new Error(`Could not decode ${e.source} as an audio file.`)
                                    }
                                    return o
                                }))
                            }
                            const i = t(),
                                r = n(),
                                [o, s] = yield Promise.all([i, r]), a = e.destinationNode || o.destination, l = o.createGain();
                            return l.connect(a), {
                                audioContext: o,
                                decodedBuffer: s,
                                gainNode: l,
                                destinationNode: a
                            }
                        }))
                    }(e), o = new ZE(i, t, r);
                    return Gp(this).replacePlaybackController(o), {
                        audioContext: t,
                        destinationNode: n,
                        decodedBuffer: i,
                        gainNode: r
                    }
                }))
            }
            get pointer() {
                return Gp(this).pointer
            }
        }
        sC("Theatre_Project"), sC("Theatre_Sheet"), sC("Theatre_SheetTemplate");
        const oC = sC("Theatre_SheetObject");
        sC("Theatre_SheetObjectTemplate"), sC("Theatre_Project_PublicAPI"), sC("Theatre_Sheet_PublicAPI"), sC("Theatre_SheetObject_PublicAPI");

        function sC(e) {
            return t => "object" == typeof t && !!t && t.type === e
        }
        var aC = function(e, t, n, i) {
            return new(n || (n = Promise))((function(r, o) {
                function s(e) {
                    try {
                        l(i.next(e))
                    } catch (e) {
                        o(e)
                    }
                }

                function a(e) {
                    try {
                        l(i.throw(e))
                    } catch (e) {
                        o(e)
                    }
                }

                function l(e) {
                    var t;
                    e.done ? r(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(s, a)
                }
                l((i = i.apply(e, t || [])).next())
            }))
        };
        class lC {
            constructor(e, t, n, i, r) {
                this._project = e, this._sheet = t, this._lengthD = n, this._subUnitsPerUnitD = i, this.pointer = ep({
                    root: this,
                    path: []
                }), this.$$isPointerToPrismProvider = !0, this.closestGridPosition = e => {
                    const t = 1 / this.subUnitsPerUnit;
                    return parseFloat((Math.round(e / t) * t).toFixed(3))
                }, this._logger = e._logger.named("Sheet", t.address.sheetId).named("Instance", t.address.sheetInstanceId), this.address = Object.assign(Object.assign({}, this._sheet.address), {
                    sequenceName: "default"
                }), this.publicApi = new rC(this), this._playbackControllerBox = new Up(null != r ? r : new JE), this._prismOfStatePointer = Bp((() => this._playbackControllerBox.prism.getValue().statePointer)), this._positionD = Bp((() => {
                    const e = this._prismOfStatePointer.getValue();
                    return Fp(e.position)
                })), this._positionFormatterD = Bp((() => {
                    const e = Fp(this._subUnitsPerUnitD);
                    return new cC(e)
                }))
            }
            pointerToPrism(e) {
                const {
                    path: t
                } = _d(e);
                if (0 === t.length) return Bp((() => ({
                    length: Fp(this.pointer.length),
                    playing: Fp(this.pointer.playing),
                    position: Fp(this.pointer.position)
                })));
                if (t.length > 1) return Bp((() => {}));
                const [n] = t;
                return "length" === n ? this._lengthD : "position" === n ? this._positionD : Bp("playing" === n ? () => Fp(this._prismOfStatePointer.getValue().playing) : () => {})
            }
            getKeyframesOfSimpleProp(e) {
                const {
                    path: t,
                    root: n
                } = _d(e);
                if (!oC(n)) throw new nE("Argument prop must be a pointer to a SheetObject property");
                const i = Fp(this._project.pointers.historic.sheetsById[this._sheet.address.sheetId].sequence.tracksByObject[n.address.objectKey]);
                if (!i) return [];
                const {
                    trackData: r,
                    trackIdByPropPath: o
                } = i, s = o[eE(t)];
                if (!s) return [];
                const a = r[s];
                return a ? nm.getSortedKeyframesCached(a.keyframes) : []
            }
            get positionFormatter() {
                return this._positionFormatterD.getValue()
            }
            get prismOfStatePointer() {
                return this._prismOfStatePointer
            }
            get length() {
                return this._lengthD.getValue()
            }
            get positionPrism() {
                return this._positionD
            }
            get position() {
                return this._playbackControllerBox.get().getCurrentPosition()
            }
            get subUnitsPerUnit() {
                return this._subUnitsPerUnitD.getValue()
            }
            get positionSnappedToGrid() {
                return this.closestGridPosition(this.position)
            }
            set position(e) {
                let t = e;
                this.pause(), t > this.length && (t = this.length);
                const n = this.length;
                this._playbackControllerBox.get().gotoPosition(t > n ? n : t)
            }
            getDurationCold() {
                return this._lengthD.getValue()
            }
            get playing() {
                return Fp(this._playbackControllerBox.get().statePointer.playing)
            }
            _makeRangeFromSequenceTemplate() {
                return Bp((() => [0, Fp(this._lengthD)]))
            }
            playDynamicRange(e, t) {
                return this._playbackControllerBox.get().playDynamicRange(e, t)
            }
            play(e, t) {
                return aC(this, void 0, void 0, (function*() {
                    const n = this.length,
                        i = e && e.range ? e.range : [0, n];
                    const r = e && "number" == typeof e.iterationCount ? e.iterationCount : 1;
                    const o = e && void 0 !== e.rate ? e.rate : 1;
                    const s = e && e.direction ? e.direction : "normal";
                    return yield this._play(r, [i[0], i[1]], o, s, t)
                }))
            }
            _play(e, t, n, i, r) {
                return this._playbackControllerBox.get().play(e, t, n, i, r)
            }
            pause() {
                this._playbackControllerBox.get().pause()
            }
            replacePlaybackController(e) {
                this.pause();
                const t = this._playbackControllerBox.get();
                this._playbackControllerBox.set(e);
                const n = t.getCurrentPosition();
                t.destroy(), e.gotoPosition(n)
            }
        }
        class cC {
            constructor(e) {
                this._fps = e
            }
            formatSubUnitForGrid(e) {
                const t = e % 1,
                    n = 1 / this._fps;
                return Math.round(t / n) + "f"
            }
            formatFullUnitForGrid(e) {
                let t = e,
                    n = "";
                if (t >= uC) {
                    n += Math.floor(t / uC) + "h", t %= uC
                }
                if (t >= hC) {
                    n += Math.floor(t / hC) + "m", t %= hC
                }
                if (t >= AC) {
                    n += Math.floor(t / AC) + "s", t %= AC
                }
                const i = 1 / this._fps;
                if (t >= i) {
                    n += Math.floor(t / i) + "f", t %= i
                }
                return 0 === n.length ? "0s" : n
            }
            formatForPlayhead(e) {
                let t = e,
                    n = "";
                if (t >= uC) {
                    const e = Math.floor(t / uC);
                    n += qE(e.toString(), 2, "0") + "h", t %= uC
                }
                if (t >= hC) {
                    const e = Math.floor(t / hC);
                    n += qE(e.toString(), 2, "0") + "m", t %= hC
                } else n.length > 0 && (n += "00m");
                if (t >= AC) {
                    const e = Math.floor(t / AC);
                    n += qE(e.toString(), 2, "0") + "s", t %= AC
                } else n += "00s";
                const i = 1 / this._fps;
                if (t >= i) {
                    const e = Math.round(t / i);
                    n += qE(e.toString(), 2, "0") + "f", t %= i
                } else if (t / i > .98) {
                    n += qE(1..toString(), 2, "0") + "f", t %= i
                } else n += "00f";
                return 0 === n.length ? "00s00f" : n
            }
            formatBasic(e) {
                return e.toFixed(2) + "s"
            }
        }
        const AC = 1,
            hC = 60 * AC,
            uC = 60 * hC;
        const dC = function(e, t, n) {
            return e == e && (void 0 !== n && (e = e <= n ? e : n), void 0 !== t && (e = e >= t ? e : t)), e
        };
        const pC = function(e, t, n) {
            return void 0 === n && (n = t, t = void 0), void 0 !== n && (n = (n = mm(n)) == n ? n : 0), void 0 !== t && (t = (t = mm(t)) == t ? t : 0), dC(mm(e), t, n)
        };

        function gC(e, {
            removeAlphaIfOpaque: t = !1
        } = {}) {
            const n = (255 * e.a | 256).toString(16).slice(1);
            return `#${(255*e.r|256).toString(16).slice(1)+(255*e.g|256).toString(16).slice(1)+(255*e.b|256).toString(16).slice(1)+(t&&"ff"===n?"":n)}`
        }
        const fC = tm((e => {
            const t = Object.assign({}, e);
            return Object.defineProperty(t, "toString", {
                value: () => gC(e),
                enumerable: !1,
                writable: !1,
                configurable: !1
            }), t
        }));

        function mC(e) {
            function t(e) {
                return e >= .0031308 ? 1.055 * Math.pow(e, 1 / 2.4) - .055 : 12.92 * e
            }
            return function(e) {
                return Object.fromEntries(Object.entries(e).map((([e, t]) => [e, pC(t, 0, 1)])))
            }({
                r: t(e.r),
                g: t(e.g),
                b: t(e.b),
                a: e.a
            })
        }

        function EC(e) {
            function t(e) {
                return e >= .04045 ? Math.pow((e + .055) / 1.055, 2.4) : e / 12.92
            }
            return {
                r: t(e.r),
                g: t(e.g),
                b: t(e.b),
                a: e.a
            }
        }

        function CC(e) {
            let t = .4122214708 * e.r + .5363325363 * e.g + .0514459929 * e.b,
                n = .2119034982 * e.r + .6806995451 * e.g + .1073969566 * e.b,
                i = .0883024619 * e.r + .2817188376 * e.g + .6299787005 * e.b,
                r = Math.cbrt(t),
                o = Math.cbrt(n),
                s = Math.cbrt(i);
            return {
                L: .2104542553 * r + .793617785 * o - .0040720468 * s,
                a: 1.9779984951 * r - 2.428592205 * o + .4505937099 * s,
                b: .0259040371 * r + .7827717662 * o - .808675766 * s,
                alpha: e.a
            }
        }
        const IC = function(e) {
            return function(t, n, i) {
                for (var r = -1, o = Object(t), s = i(t), a = s.length; a--;) {
                    var l = s[e ? a : ++r];
                    if (!1 === n(o[l], l, o)) break
                }
                return t
            }
        }();
        const SC = function(e, t) {
            return e && IC(e, t, Vg)
        };
        const vC = function(e) {
            return this.__data__.set(e, "__lodash_hash_undefined__"), this
        };
        const BC = function(e) {
            return this.__data__.has(e)
        };

        function xC(e) {
            var t = -1,
                n = null == e ? 0 : e.length;
            for (this.__data__ = new wd; ++t < n;) this.add(e[t])
        }
        xC.prototype.add = xC.prototype.push = vC, xC.prototype.has = BC;
        const yC = xC;
        const wC = function(e, t) {
            for (var n = -1, i = null == e ? 0 : e.length; ++n < i;)
                if (t(e[n], n, e)) return !0;
            return !1
        };
        const bC = function(e, t) {
            return e.has(t)
        };
        const QC = function(e, t, n, i, r, o) {
            var s = 1 & n,
                a = e.length,
                l = t.length;
            if (a != l && !(s && l > a)) return !1;
            var c = o.get(e),
                A = o.get(t);
            if (c && A) return c == t && A == e;
            var h = -1,
                u = !0,
                d = 2 & n ? new yC : void 0;
            for (o.set(e, t), o.set(t, e); ++h < a;) {
                var p = e[h],
                    g = t[h];
                if (i) var f = s ? i(g, p, h, t, e, o) : i(p, g, h, e, t, o);
                if (void 0 !== f) {
                    if (f) continue;
                    u = !1;
                    break
                }
                if (d) {
                    if (!wC(t, (function(e, t) {
                            if (!bC(d, t) && (p === e || r(p, e, n, i, o))) return d.push(t)
                        }))) {
                        u = !1;
                        break
                    }
                } else if (p !== g && !r(p, g, n, i, o)) {
                    u = !1;
                    break
                }
            }
            return o.delete(e), o.delete(t), u
        };
        const UC = function(e) {
            var t = -1,
                n = Array(e.size);
            return e.forEach((function(e, i) {
                n[++t] = [i, e]
            })), n
        };
        const MC = function(e) {
            var t = -1,
                n = Array(e.size);
            return e.forEach((function(e) {
                n[++t] = e
            })), n
        };
        var RC = Xh ? Xh.prototype : void 0,
            TC = RC ? RC.valueOf : void 0;
        const FC = function(e, t, n, i, r, o, s) {
            switch (n) {
                case "[object DataView]":
                    if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset) return !1;
                    e = e.buffer, t = t.buffer;
                case "[object ArrayBuffer]":
                    return !(e.byteLength != t.byteLength || !o(new Mf(e), new Mf(t)));
                case "[object Boolean]":
                case "[object Date]":
                case "[object Number]":
                    return ld(+e, +t);
                case "[object Error]":
                    return e.name == t.name && e.message == t.message;
                case "[object RegExp]":
                case "[object String]":
                    return e == t + "";
                case "[object Map]":
                    var a = UC;
                case "[object Set]":
                    var l = 1 & i;
                    if (a || (a = MC), e.size != t.size && !l) return !1;
                    var c = s.get(e);
                    if (c) return c == t;
                    i |= 2, s.set(e, t);
                    var A = QC(a(e), a(t), i, r, o, s);
                    return s.delete(e), A;
                case "[object Symbol]":
                    if (TC) return TC.call(e) == TC.call(t)
            }
            return !1
        };
        var DC = Object.prototype.hasOwnProperty;
        const kC = function(e, t, n, i, r, o) {
            var s = 1 & n,
                a = Af(e),
                l = a.length;
            if (l != Af(t).length && !s) return !1;
            for (var c = l; c--;) {
                var A = a[c];
                if (!(s ? A in t : DC.call(t, A))) return !1
            }
            var h = o.get(e),
                u = o.get(t);
            if (h && u) return h == t && u == e;
            var d = !0;
            o.set(e, t), o.set(t, e);
            for (var p = s; ++c < l;) {
                var g = e[A = a[c]],
                    f = t[A];
                if (i) var m = s ? i(f, g, A, t, e, o) : i(g, f, A, e, t, o);
                if (!(void 0 === m ? g === f || r(g, f, n, i, o) : m)) {
                    d = !1;
                    break
                }
                p || (p = "constructor" == A)
            }
            if (d && !p) {
                var E = e.constructor,
                    C = t.constructor;
                E == C || !("constructor" in e) || !("constructor" in t) || "function" == typeof E && E instanceof E && "function" == typeof C && C instanceof C || (d = !1)
            }
            return o.delete(e), o.delete(t), d
        };
        var LC = "[object Arguments]",
            KC = "[object Array]",
            PC = "[object Object]",
            GC = Object.prototype.hasOwnProperty;
        const VC = function(e, t, n, i, r, o) {
            var s = _h(e),
                a = _h(t),
                l = s ? KC : bf(e),
                c = a ? KC : bf(t),
                A = (l = l == LC ? PC : l) == PC,
                h = (c = c == LC ? PC : c) == PC,
                u = l == c;
            if (u && Sg(e)) {
                if (!Sg(t)) return !1;
                s = !0, A = !1
            }
            if (u && !A) return o || (o = new lg), s || Rg(e) ? QC(e, t, n, i, r, o) : FC(e, t, l, n, i, r, o);
            if (!(1 & n)) {
                var d = A && GC.call(e, "__wrapped__"),
                    p = h && GC.call(t, "__wrapped__");
                if (d || p) {
                    var g = d ? e.value() : e,
                        f = p ? t.value() : t;
                    return o || (o = new lg), r(g, f, n, i, o)
                }
            }
            return !!u && (o || (o = new lg), kC(e, t, n, i, r, o))
        };
        const OC = function e(t, n, i, r, o) {
            return t === n || (null == t || null == n || !lu(t) && !lu(n) ? t != t && n != n : VC(t, n, i, r, e, o))
        };
        const NC = function(e, t, n, i) {
            var r = n.length,
                o = r,
                s = !i;
            if (null == e) return !o;
            for (e = Object(e); r--;) {
                var a = n[r];
                if (s && a[2] ? a[1] !== e[a[0]] : !(a[0] in e)) return !1
            }
            for (; ++r < o;) {
                var l = (a = n[r])[0],
                    c = e[l],
                    A = a[1];
                if (s && a[2]) {
                    if (void 0 === c && !(l in e)) return !1
                } else {
                    var h = new lg;
                    if (i) var u = i(c, A, l, e, t, h);
                    if (!(void 0 === u ? OC(A, c, 3, i, h) : u)) return !1
                }
            }
            return !0
        };
        const HC = function(e) {
            return e == e && !Du(e)
        };
        const qC = function(e) {
            for (var t = Vg(e), n = t.length; n--;) {
                var i = t[n],
                    r = e[i];
                t[n] = [i, r, HC(r)]
            }
            return t
        };
        const jC = function(e, t) {
            return function(n) {
                return null != n && (n[e] === t && (void 0 !== t || e in Object(n)))
            }
        };
        const YC = function(e) {
            var t = qC(e);
            return 1 == t.length && t[0][2] ? jC(t[0][0], t[0][1]) : function(n) {
                return n === e || NC(n, e, t)
            }
        };
        const JC = function(e, t) {
            return null != e && t in Object(e)
        };
        const WC = function(e, t, n) {
            for (var i = -1, r = (t = Dd(t, e)).length, o = !1; ++i < r;) {
                var s = kd(t[i]);
                if (!(o = null != e && n(e, s))) break;
                e = e[s]
            }
            return o || ++i != r ? o : !!(r = null == e ? 0 : e.length) && vg(r) && zp(s, r) && (_h(e) || fg(e))
        };
        const zC = function(e, t) {
            return null != e && WC(e, t, JC)
        };
        const XC = function(e, t) {
            return Fu(e) && HC(t) ? jC(kd(e), t) : function(n) {
                var i = Kd(n, e);
                return void 0 === i && i === t ? zC(n, e) : OC(t, i, 3)
            }
        };
        const ZC = function(e) {
            return e
        };
        const _C = function(e) {
            return function(t) {
                return Ld(t, e)
            }
        };
        const $C = function(e) {
            return Fu(e) ? lE(kd(e)) : _C(e)
        };
        const eI = function(e) {
            return "function" == typeof e ? e : null == e ? ZC : "object" == typeof e ? _h(e) ? XC(e[0], e[1]) : YC(e) : $C(e)
        };
        const tI = function(e, t) {
            var n = {};
            return t = eI(t, 3), SC(e, (function(e, i, r) {
                jp(n, i, t(e, i, r))
            })), n
        };

        function nI(e, t) {
            return e.length <= t ? e : e.substr(0, t - 3) + "..."
        }
        const iI = e => "string" == typeof e ? `string("${nI(e,10)}")` : "number" == typeof e ? `number(${nI(String(e),10)})` : null === e ? "null" : void 0 === e ? "undefined" : "boolean" == typeof e ? String(e) : Array.isArray(e) ? "array" : "object" == typeof e ? "object" : "unknown",
            rI = Symbol("TheatrePropType_Basic");

        function oI(e) {
            return "object" == typeof e && !!e && "TheatrePropType" === e[rI]
        }

        function sI(e) {
            if ("number" == typeof e) return lI(e);
            if ("boolean" == typeof e) return gI(e);
            if ("string" == typeof e) return EI(e);
            if ("object" == typeof e && e) {
                if (oI(e)) return e;
                if (jd(e)) return aI(e);
                throw new nE(`This value is not a valid prop type: ${iI(e)}`)
            }
            throw new nE(`This value is not a valid prop type: ${iI(e)}`)
        }
        const aI = (e, t = {}) => {
                const n = function(e) {
                        const t = {};
                        for (const n of Object.keys(e)) {
                            const i = e[n];
                            oI(i) ? t[n] = i : t[n] = sI(i)
                        }
                        return t
                    }(e),
                    i = new WeakMap,
                    r = {
                        type: "compound",
                        props: n,
                        valueType: null,
                        [rI]: "TheatrePropType",
                        label: t.label,
                        default: tI(n, (e => e.default)),
                        deserializeAndSanitize: e => {
                            if ("object" != typeof e || !e) return;
                            if (i.has(e)) return i.get(e);
                            const t = {};
                            let r = !1;
                            for (const [i, o] of Object.entries(n))
                                if (Object.prototype.hasOwnProperty.call(e, i)) {
                                    const n = o.deserializeAndSanitize(e[i]);
                                    null != n && (r = !0, t[i] = n)
                                }
                            return i.set(e, t), r ? t : void 0
                        }
                    };
                return r
            },
            lI = (e, t = {}) => {
                var n;
                return Object.assign(Object.assign({
                    type: "number",
                    valueType: 0,
                    default: e,
                    [rI]: "TheatrePropType"
                }, t || {}), {
                    label: t.label,
                    nudgeFn: null !== (n = t.nudgeFn) && void 0 !== n ? n : II,
                    nudgeMultiplier: "number" == typeof t.nudgeMultiplier ? t.nudgeMultiplier : void 0,
                    interpolate: hI,
                    deserializeAndSanitize: cI(t.range)
                })
            },
            cI = e => e ? t => {
                if ("number" == typeof t && isFinite(t)) return pC(t, e[0], e[1])
            } : AI,
            AI = e => "number" == typeof e && isFinite(e) ? e : void 0,
            hI = (e, t, n) => e + n * (t - e),
            uI = (e = {
                r: 0,
                g: 0,
                b: 0,
                a: 1
            }, t = {}) => {
                const n = {};
                for (const t of ["r", "g", "b", "a"]) n[t] = Math.min(Math.max(e[t], 0), 1);
                return {
                    type: "rgba",
                    valueType: null,
                    default: fC(n),
                    [rI]: "TheatrePropType",
                    label: t.label,
                    interpolate: pI,
                    deserializeAndSanitize: dI
                }
            },
            dI = e => {
                if (!e) return;
                let t = !0;
                for (const n of ["r", "g", "b", "a"]) Object.prototype.hasOwnProperty.call(e, n) && "number" == typeof e[n] || (t = !1);
                if (!t) return;
                const n = {};
                for (const t of ["r", "g", "b", "a"]) n[t] = Math.min(Math.max(e[t], 0), 1);
                return fC(n)
            },
            pI = (e, t, n) => {
                const i = CC(EC(e)),
                    r = CC(EC(t)),
                    o = mC(function(e) {
                        let t = e.L + .3963377774 * e.a + .2158037573 * e.b,
                            n = e.L - .1055613458 * e.a - .0638541728 * e.b,
                            i = e.L - .0894841775 * e.a - 1.291485548 * e.b,
                            r = t * t * t,
                            o = n * n * n,
                            s = i * i * i;
                        return {
                            r: 4.0767416621 * r - 3.3077115913 * o + .2309699292 * s,
                            g: -1.2684380046 * r + 2.6097574011 * o - .3413193965 * s,
                            b: -.0041960863 * r - .7034186147 * o + 1.707614701 * s,
                            a: e.alpha
                        }
                    }({
                        L: (1 - n) * i.L + n * r.L,
                        a: (1 - n) * i.a + n * r.a,
                        b: (1 - n) * i.b + n * r.b,
                        alpha: (1 - n) * i.alpha + n * r.alpha
                    }));
                return fC(o)
            },
            gI = (e, t = {}) => {
                var n;
                return {
                    type: "boolean",
                    default: e,
                    valueType: null,
                    [rI]: "TheatrePropType",
                    label: t.label,
                    interpolate: null !== (n = t.interpolate) && void 0 !== n ? n : mI,
                    deserializeAndSanitize: fI
                }
            },
            fI = e => "boolean" == typeof e ? e : void 0;

        function mI(e) {
            return e
        }
        const EI = (e, t = {}) => {
            var n;
            return {
                type: "string",
                default: e,
                valueType: null,
                [rI]: "TheatrePropType",
                label: t.label,
                interpolate: null !== (n = t.interpolate) && void 0 !== n ? n : mI,
                deserializeAndSanitize: CI
            }
        };

        function CI(e) {
            return "string" == typeof e ? e : void 0
        }
        const II = ({
            config: e,
            deltaX: t,
            deltaFraction: n,
            magnitude: i
        }) => {
            var r;
            const {
                range: o
            } = e;
            return e.nudgeMultiplier || !o || o.includes(1 / 0) || o.includes(-1 / 0) ? t * i * (null !== (r = e.nudgeMultiplier) && void 0 !== r ? r : 1) : n * (o[1] - o[0]) * i
        };

        function SI(e, t, n) {
            const i = (e => e.replace(/^[\s\/]*/, "").replace(/[\s\/]*$/, "").replace(/\s*\/\s*/g, " / "))(e);
            return i
        }
        new WeakMap;
        class vI {
            get type() {
                return "Theatre_Sheet_PublicAPI"
            }
            constructor(e) {
                Vp(this, e)
            }
            object(e, t, n) {
                const i = Gp(this),
                    r = SI(e, 0, XE.warning),
                    o = i.getObject(r),
                    s = null == n ? void 0 : n.__actions__THIS_API_IS_UNSTABLE_AND_WILL_CHANGE_IN_THE_NEXT_VERSION;
                if (o) return s && o.template._temp_setActions(s), o.publicApi; {
                    const e = aI(t);
                    return i.createObject(r, null, e, s).publicApi
                }
            }
            get sequence() {
                return Gp(this).getSequence().publicApi
            }
            get project() {
                return Gp(this).project.publicApi
            }
            get address() {
                return Object.assign({}, Gp(this).address)
            }
            detachObject(e) {
                const t = Gp(this),
                    n = SI(e, 0, XE.warning);
                if (!t.getObject(n)) return XE.warning(`Couldn't delete object "${n}"`, `There is no object with key "${n}".\n\nTo fix this, make sure you are calling \`sheet.deleteObject("${n}")\` with the correct key.`), void console.warn(`Object key "${n}" does not exist.`);
                t.deleteObject(n)
            }
        }
        const BI = function(e) {
            return "number" == typeof e && e == HE(e)
        };
        class xI {
            constructor(e, t) {
                this.template = e, this.instanceId = t, this._objects = new Up({}), this.objectsP = this._objects.pointer, this.type = "Theatre_Sheet", this._logger = e.project._logger.named("Sheet", t), this._logger._trace("creating sheet"), this.project = e.project, this.address = Object.assign(Object.assign({}, e.address), {
                    sheetInstanceId: this.instanceId
                }), this.publicApi = new vI(this)
            }
            createObject(e, t, n, i = {}) {
                const r = this.template.getObjectTemplate(e, t, n, i).createInstance(this, t, n);
                return this._objects.setByPointer((t => t[e]), r), r
            }
            getObject(e) {
                return this._objects.get()[e]
            }
            deleteObject(e) {
                this._objects.reduce((t => {
                    const n = Object.assign({}, t);
                    return delete n[e], n
                }))
            }
            getSequence() {
                if (!this._sequence) {
                    const e = Bp((() => {
                            const e = Fp(this.project.pointers.historic.sheetsById[this.address.sheetId].sequence.length);
                            return yI(e)
                        })),
                        t = Bp((() => {
                            const e = Fp(this.project.pointers.historic.sheetsById[this.address.sheetId].sequence.subUnitsPerUnit);
                            return wI(e)
                        }));
                    this._sequence = new lC(this.template.project, this, e, t)
                }
                return this._sequence
            }
        }
        const yI = e => "number" == typeof e && isFinite(e) && e > 0 ? e : 10,
            wI = e => "number" == typeof e && BI(e) && e >= 1 && e <= 1e3 ? e : 30;
        class bI {
            constructor(e, t) {
                this.project = e, this.type = "Theatre_SheetTemplate", this._instances = new Up({}), this.instancesP = this._instances.pointer, this._objectTemplates = new Up({}), this.objectTemplatesP = this._objectTemplates.pointer, this.address = Object.assign(Object.assign({}, e.address), {
                    sheetId: t
                })
            }
            getInstance(e) {
                let t = this._instances.get()[e];
                return t || (t = new xI(this, e), this._instances.setByPointer((t => t[e]), t)), t
            }
            getObjectTemplate(e, t, n, i) {
                let r = this._objectTemplates.get()[e];
                return r || (r = new _m(this, e, t, n, i), this._objectTemplates.setByPointer((t => t[e]), r)), r
            }
        }
        const QI = {
            currentProjectStateDefinitionVersion: "0.4.0"
        };

        function UI() {}

        function MI(e) {
            var t, n;
            const i = (null === (t = null == e ? void 0 : e.logging) || void 0 === t ? void 0 : t.internal) ? null !== (n = e.logging.min) && void 0 !== n ? n : Um.WARN : 1 / 0,
                r = i <= Um.DEBUG,
                o = i <= Um.ERROR,
                s = Lm(void 0, {
                    _debug: r ? console.debug.bind(console, "_coreLogger(TheatreInternalLogger) debug") : UI,
                    _error: o ? console.error.bind(console, "_coreLogger(TheatreInternalLogger) error") : UI
                });
            if (e) {
                const {
                    logger: t,
                    logging: n
                } = e;
                t && s.configureLogger(t), n ? s.configureLogging(n) : s.configureLogging({
                    dev: !1
                })
            }
            return s.getLogger().named("Theatre")
        }
        class RI {
            constructor(e, t = {}, n) {
                var i;
                this.config = t, this.publicApi = n, this._sheetTemplates = new Up({}), this.sheetTemplatesP = this._sheetTemplates.pointer, this.type = "Theatre_Project", this._logger = MI({
                    logging: {
                        dev: !0
                    }
                }).named("Project", e), this._logger.traceDev("creating project"), this.address = {
                    projectId: e
                };
                const r = new Up({
                    loadingState: {
                        type: "loaded"
                    },
                    lastExportedObject: null
                });
                t.state && Object.values(t.state.sheetsById).forEach((e => Object.values(e.sequence.tracksByObject).forEach((e => Object.values(e.trackData).forEach((e => {
                    e.keyframes = nm.fromArray(e.keyframes)
                }))))));
                const o = new Up({
                    historic: null !== (i = t.state) && void 0 !== i ? i : {
                        sheetsById: {},
                        definitionVersion: QI.currentProjectStateDefinitionVersion,
                        revisionHistory: []
                    }
                });
                this.diskStateAtom = o, this._assetStorageReadyDeferred = jE(), this.assetStorage = {
                    getAssetUrl: e => {
                        var n;
                        return `${null===(n=t.assets)||void 0===n?void 0:n.baseUrl}/${e}`
                    },
                    createAsset: () => {
                        throw new Error("Please wait for Project.ready to use assets.")
                    }
                }, this._pointerProxies = {
                    historic: new kp(o.pointer.historic),
                    ephemeral: new kp(r.pointer)
                }, this.pointers = {
                    historic: this._pointerProxies.historic.pointer,
                    ephemeral: this._pointerProxies.ephemeral.pointer
                }, Kp.add(e, this), this._studioReadyDeferred = jE(), this._studioReadyDeferred.resolve(void 0), this._assetStorageReadyDeferred.resolve(void 0), this._readyPromise = Promise.all([this._studioReadyDeferred.promise, this._assetStorageReadyDeferred.promise]).then((() => {})), t.state || "undefined" == typeof window && console.error(`Argument config.state in Theatre.getProject("${e}", config) is empty. You can safely ignore this message if you're developing a Next.js/Remix project in development mode. But if you are shipping to your end-users, then you need to set config.state, otherwise your project's state will be empty and nothing will animate. Learn more at https://www.theatrejs.com/docs/latest/manual/projects#state`)
            }
            attachToStudio() {
                throw new Error("Studio has been removed! This function should not be called anymore")
            }
            get isAttachedToStudio() {
                return console.error("Studio has been removed! This function shouldn't be called anymore"), !1
            }
            get ready() {
                return this._readyPromise
            }
            isReady() {
                return "resolved" === this._studioReadyDeferred.status && "resolved" === this._assetStorageReadyDeferred.status
            }
            getOrCreateSheet(e, t = "default") {
                let n = this._sheetTemplates.get()[e];
                return n || (n = new bI(this, e), this._sheetTemplates.reduce((t => Object.assign(Object.assign({}, t), {
                    [e]: n
                })))), n.getInstance(t)
            }
        }
        class TI {
            get type() {
                return "Theatre_Project_PublicAPI"
            }
            constructor(e, t = {}) {
                Vp(this, new RI(e, t, this))
            }
            get ready() {
                return Gp(this).ready
            }
            get isReady() {
                return Gp(this).isReady()
            }
            get address() {
                return Object.assign({}, Gp(this).address)
            }
            getAssetUrl(e) {
                if (this.isReady) return e.id ? Gp(this).assetStorage.getAssetUrl(e.id) : void 0;
                console.error("Calling `project.getAssetUrl()` before `project.ready` is resolved, will always return `undefined`. Either use `project.ready.then(() => project.getAssetUrl())` or `await project.ready` before calling `project.getAssetUrl()`.")
            }
            sheet(e, t = "default") {
                const n = SI(e, 0, XE.warning);
                return Gp(this).getOrCreateSheet(n, t).publicApi
            }
            setState(e) {
                Gp(this).diskStateAtom.setByPointer(Gp(this).diskStateAtom.pointer.historic.sheetsById, e)
            }
        }
        n(792);
        const FI = (e, t) => {
            ((e, t) => {
                if (Array.isArray(t) || null == t || t.definitionVersion !== QI.currentProjectStateDefinitionVersion) throw new nE(`Error validating conf.state in Theatre.getProject(${JSON.stringify(e)}, conf). The state seems to be formatted in a way that is unreadable to Theatre.js. Read more at https://www.theatrejs.com/docs/latest/manual/projects#state`)
            })(e, t)
        };
        class DI {
            constructor() {}
            get type() {
                return "Theatre_CoreBundle"
            }
            get version() {
                return process.env.THEATRE_VERSION
            }
            getBitsForStudio(e, t) {
                throw new Error("Studio has been removed! This function shouldn't be called anymore")
            }
        }

        function kI(e) {
            return `${e.uuid}`
        }! function() {
            if ("undefined" == typeof window && !0 !== n.g.__THEATREJS__FORCE_CONNECT_CORE_AND_STUDIO) return;
            const e = "undefined" != typeof window ? window : n.g,
                t = e[WE];
            if (void 0 !== t) {
                if ("object" == typeof t && t && "string" == typeof t.version) throw new Error("It seems that the module '@theatre-local/core' is loaded more than once. This could have two possible causes:\n1. You might have two separate versions of Theatre.js in node_modules.\n2. Or this might be a bundling misconfiguration, in case you're using a bundler like Webpack/ESBuild/Rollup.\n\nNote that it **is okay** to import '@theatre-local/core' multiple times. But those imports should point to the same module.");
                console.warn(`The variable window.${WE} seems to be already set by a module other than @theatre-local/core.`)
            }
            const i = new DI;
            e[WE] = i
        }();
        const LI = "DEFAULT_ANIMATION_SHEET_NAME",
            KI = 10,
            PI = -911231231231232,
            GI = {
                r: 0,
                g: 0,
                b: 0,
                a: .5
            };

        function VI(e, t) {
            let n = !0;
            const i = function(e, t = {}) {
                    const n = Kp.get(e);
                    if (n) return n.publicApi;
                    const i = MI().named("Project", e);
                    return t.state ? (FI(e, t.state), i._debug("deep validated config.state on disk")) : i._debug("no config.state"), new TI(e, t)
                }(e, {
                    state: t
                }),
                r = new Map;
            return {
                getAnimation: function(e) {
                    const t = i.sheet(e);
                    return {
                        play: function() {
                            t.sequence.play({
                                rate: 1 / KI
                            })
                        },
                        pause: function() {
                            t.sequence.pause()
                        },
                        setPosition: function(e) {
                            t.sequence.position = e
                        },
                        animateObject3D: function(e) {
                            if (r.has(e.uuid)) return;

                            function i(e, t) {
                                t.x !== PI && (e.x = t.x), t.y !== PI && (e.y = t.y), t.z !== PI && (e.z = t.z)
                            }
                            const o = t.object(kI(e), {
                                position: aI({
                                    x: lI(PI),
                                    y: lI(PI),
                                    z: lI(PI)
                                }),
                                rotation: aI({
                                    x: lI(PI),
                                    y: lI(PI),
                                    z: lI(PI)
                                }),
                                scale: aI({
                                    x: lI(PI),
                                    y: lI(PI),
                                    z: lI(PI)
                                })
                            }).onValuesChange((t => {
                                n && (i(e.position, t.position), i(e.rotation, t.rotation), i(e.scale, t.scale))
                            }));
                            r.set(e.uuid, o)
                        },
                        animateMaterial: function(e) {
                            if (r.has(e.uuid)) return;
                            const i = t.object(kI(e), {
                                color: uI(GI),
                                metalness: lI(PI),
                                opacity: lI(PI),
                                roughness: lI(PI),
                                emissive: uI(GI),
                                emissiveIntensity: lI(PI),
                                displacementScale: lI(PI)
                            }).onValuesChange((t => {
                                function i(n, i) {
                                    const r = e instanceof Ar && "metalness" === n ? "reflectivity" : n;
                                    t[n] !== PI && void 0 !== e[r] && (e[r] = i || t[n])
                                }

                                function r(e) {
                                    t[e].a !== GI.a && i(e, new sr(String(gC(t[e])).slice(0, -2)))
                                }
                                n && (i("opacity"), i("metalness"), i("roughness"), i("emissiveIntensity"), i("displacementScale"), r("color"), r("emissive"))
                            }));
                            r.set(e.uuid, i)
                        },
                        removeObjectAnimation: function(e) {
                            const n = r.get(e.uuid);
                            n && (n(), t.detachObject(kI(e)), r.delete(e.uuid))
                        },
                        animationSheet: t
                    }
                },
                setState: function(e) {
                    i.setState(e)
                },
                setActive: function(e) {
                    if (n = e, e) {
                        const e = i.sheet(LI).sequence.position;
                        i.sheet(LI).sequence.position += e > 1e-5 ? -1e-5 : 1e-5, setTimeout((() => {
                            i.sheet(LI).sequence.position = e
                        }))
                    }
                }
            }
        }
        var OI, NI, HI;

        function qI(e, t) {
            return {
                set: (n, i, r) => {
                    const o = n[i] !== r,
                        s = Reflect.set(n, i, r);
                    return e.includes(i) && o && t(i), s
                }
            }
        }

        function jI(e) {
            const t = e;

            function n(e, n) {
                const i = t[e],
                    r = new Proxy(i, qI(["x", "y", "z", "_x", "_y", "_z"], (e => {
                        t.dispatchEvent({
                            type: n,
                            target: t,
                            property: e
                        })
                    })));
                ! function(e, t, n) {
                    Reflect.deleteProperty(e, t), Reflect.defineProperty(e, t, {
                        value: n,
                        configurable: !1,
                        enumerable: !0,
                        writable: !1
                    })
                }(t, e, r)
            }
            return n("position", NI.UpdatePosition), n("rotation", NI.UpdateRotation), n("scale", NI.UpdateScale), t
        }

        function YI(e) {
            var t, n, i, r, o, s, a, l, c, A, h, u, d, p;
            e instanceof Lc && (null === (t = e.alphaMap) || void 0 === t || t.dispose(), null === (n = e.aoMap) || void 0 === n || n.dispose(), null === (i = e.emissiveMap) || void 0 === i || i.dispose(), null === (r = e.aoMap) || void 0 === r || r.dispose(), null === (o = e.map) || void 0 === o || o.dispose(), null === (s = e.normalMap) || void 0 === s || s.dispose(), null === (a = e.metalnessMap) || void 0 === a || a.dispose(), null === (l = e.roughnessMap) || void 0 === l || l.dispose(), null === (c = e.displacementMap) || void 0 === c || c.dispose()), e instanceof Ar && (null === (A = e.alphaMap) || void 0 === A || A.dispose(), null === (h = e.aoMap) || void 0 === h || h.dispose(), null === (u = e.aoMap) || void 0 === u || u.dispose(), null === (d = e.specularMap) || void 0 === d || d.dispose(), null === (p = e.map) || void 0 === p || p.dispose()), e.dispose()
        }

        function JI(e) {
            return e ? e.userData.isPwObject ? e : JI(e.parent) : null
        }

        function WI(e, t) {
            return t ? e.set(t.x, t.y, t.z) : e.set(0, 0, 0)
        }! function(e) {
            e.MouseDown = "MOUSE_DOWN", e.MouseUp = "MOUSE_UP", e.MouseMove = "MOUSE_MOVE", e.Loaded = "LOADED", e.ResourcesLoaded = "RESOURCES_LOADED", e.SceneReady = "SCENE_READY"
        }(OI || (OI = {})),
        function(e) {
            e.UpdatePosition = "UPDATE_POSITION", e.UpdateRotation = "UPDATE_ROTATION", e.UpdateScale = "UPDATE_SCALE"
        }(NI || (NI = {})),
        function(e) {
            e.Update = "UPDATE"
        }(HI || (HI = {}));
        const zI = new On;

        function XI(e) {
            const t = new Map;
            return e.traverse((e => {
                (e instanceof Jr || e instanceof Dl) && t.set(e.material.uuid, e.material)
            })), Array.from(t.values())
        }
        new qn;
        var ZI = function(e, t, n, i) {
            return new(n || (n = Promise))((function(r, o) {
                function s(e) {
                    try {
                        l(i.next(e))
                    } catch (e) {
                        o(e)
                    }
                }

                function a(e) {
                    try {
                        l(i.throw(e))
                    } catch (e) {
                        o(e)
                    }
                }

                function l(e) {
                    var t;
                    e.done ? r(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(s, a)
                }
                l((i = i.apply(e, t || [])).next())
            }))
        };
        class _I {
            constructor(e, t) {
                this.usedBy = new Set;
                const {
                    assetType: n,
                    assetUrl: i
                } = e;
                this.loaded = !1, this.assetUrl = i, this.assetType = n, this.loader = t
            }
            getData() {
                return ZI(this, void 0, void 0, (function*() {
                    if (this.loaded && this.data) return this.data;
                    const e = window._pwLoadFileFromCache ? yield window._pwLoadFileFromCache(this.assetUrl): this.assetUrl;
                    if (!e) throw new Error(`Failed to load file "${this.assetUrl}".`);
                    const t = yield this.loadAssetData(this.assetType, e);
                    return this.data = t, this.loaded = !0, this.data
                }))
            }
            loadAssetData(e, t) {
                return ZI(this, void 0, void 0, (function*() {
                    return yield this.loader.loadAsync(e, t)
                }))
            }
            dispose() {
                if (this.data) switch (this.assetType) {
                    case d.Texture:
                    case d.HDRTexture:
                    case d.EXRTexture:
                        this.data.dispose();
                        break;
                    case d.Gltf:
                        this.data.scenes.forEach((e => {
                            e.traverse((function(e) {
                                e instanceof Jr && (e.geometry.dispose(), YI(e.material))
                            }))
                        }));
                        break;
                    case d.FBX:
                    case d.Obj:
                        this.data.traverse((function(e) {
                            e instanceof Jr && (e.geometry.dispose(), YI(e.material))
                        }))
                }
            }
        }

        function $I(e) {
            const t = new Map,
                n = new Map,
                i = e.clone();
            return eS(e, i, (function(e, i) {
                t.set(i, e), n.set(e, i)
            })), i.traverse((function(e) {
                if (!e.isSkinnedMesh) return;
                const i = e,
                    r = t.get(e),
                    o = r.skeleton.bones;
                i.skeleton = r.skeleton.clone(), i.bindMatrix.copy(r.bindMatrix), i.skeleton.bones = o.map((function(e) {
                    return n.get(e)
                })), i.bind(i.skeleton, i.bindMatrix)
            })), i
        }

        function eS(e, t, n) {
            n(e, t);
            for (let i = 0; i < e.children.length; i++) eS(e.children[i], t.children[i], n)
        }
        const tS = {
                [g.Clamp]: Ze,
                [g.Repeat]: Xe,
                [g.MirroredRepeat]: _e
            },
            nS = [d.Texture, d.HDRTexture, d.EXRTexture, d.Gltf, d.Obj, d.FBX, d.VideoTexture];
        class iS {
            constructor(e, t) {
                const {
                    uuid: n,
                    assetUrl: i
                } = e;
                if (this.uuid = n, this.assetUrl = i, t.usedBy.add(n), !nS.includes(e.assetType)) throw new Error(`Asset type ${e.assetType} is not supported!`);
                this.assetInstance = t.getData().then((t => {
                    switch (e.assetType) {
                        case d.Texture:
                            {
                                const {
                                    center: n,
                                    offset: i,
                                    repeat: r,
                                    wrapS: o = g.Clamp,
                                    wrapT: s = g.Clamp
                                } = e,
                                a = t.clone();
                                return a.center = new dn(n.x, n.y),
                                a.offset = new dn(i.x, i.y),
                                a.repeat = new dn(r.x, r.y),
                                a.wrapS = tS[o],
                                a.wrapT = tS[s],
                                a.colorSpace = Ot,
                                a.needsUpdate = !0,
                                a
                            }
                        case d.VideoTexture:
                            {
                                const {
                                    center: t,
                                    offset: n,
                                    repeat: r,
                                    wrapS: o = g.Clamp,
                                    wrapT: s = g.Clamp,
                                    loop: a
                                } = e,
                                l = document.createElement("video");l.setAttribute("id", "video"),
                                l.crossOrigin = "anonymous",
                                l.style.display = "none",
                                l.playsInline = !0,
                                l.autoplay = !0,
                                l.muted = !0,
                                l.loop = a,
                                l.src = i,
                                document.body.append(l),
                                l.load(),
                                l.play();
                                const c = new nc(l);
                                return c.center = new dn(t.x, t.y),
                                c.offset = new dn(n.x, n.y),
                                c.repeat = new dn(r.x, r.y),
                                c.wrapS = tS[o],
                                c.wrapT = tS[s],
                                c.colorSpace = Ot,
                                c.needsUpdate = !0,
                                new Promise((e => {
                                    l.oncanplay = () => {
                                        e(c)
                                    }
                                }))
                            }
                        case d.HDRTexture:
                        case d.EXRTexture:
                            {
                                const e = t.clone();
                                return e.mapping = Je,
                                e.needsUpdate = !0,
                                e
                            }
                        case d.Gltf:
                            {
                                const e = new Xa,
                                    n = t;
                                return n.scenes.forEach((t => {
                                    e.add($I(t))
                                })),
                                e.userData = {
                                    isGLTF: !0
                                },
                                {
                                    model: e,
                                    animations: n.animations.map((e => e.clone())),
                                    materials: XI(e)
                                }
                            }
                        case d.Obj:
                            {
                                const e = t.clone();
                                return {
                                    model: e,
                                    materials: XI(e)
                                }
                            }
                        case d.FBX:
                            {
                                const e = $I(t);
                                return {
                                    model: e,
                                    materials: XI(e)
                                }
                            }
                        default:
                            throw new Error("Resource type should be checked before the async code, otherwise error can't be caught!")
                    }
                }))
            }
            dispose() {
                this.assetInstance.then((e => {
                    if (e instanceof nc && (document.body.removeChild(e.source.data), e.dispose()), e instanceof Dn && e.dispose(), e instanceof Xa) {
                        e.traverse((function(e) {
                            e instanceof Jr && (e.geometry.dispose(), YI(e.material))
                        }))
                    }
                }))
            }
        }

        function rS(e, t) {
            const n = new Map,
                i = new Map,
                r = new Set;
            let o = !1;

            function s() {
                r.size > 0 || o || (o = !0, t.dispatchEvent({
                    type: OI.ResourcesLoaded
                }))
            }

            function a(t) {
                const i = new _I(t, e);
                return n.set(t.assetUrl, i), i
            }
            return {
                createResource: function(e) {
                    const t = new iS(e, n.get(e.assetUrl) || a(e));
                    return r.add(t), i.set(e.uuid, t), t.assetInstance.finally((() => {
                        r.delete(t), s()
                    })), t
                },
                createAsset: a,
                getAsset: n.get.bind(n),
                deleteResource: function(e) {
                    const t = i.get(e);
                    if (!t) return;
                    t.dispose(), i.delete(e);
                    const r = n.get(t.assetUrl);
                    r && (r.usedBy.delete(t.uuid), 0 === r.usedBy.size && (n.delete(t.assetUrl), r.dispose()))
                },
                dispose: function() {
                    n.forEach((e => {
                        e.dispose()
                    })), i.forEach((e => {
                        e.dispose()
                    })), i.clear(), n.clear()
                },
                getResource: i.get.bind(i),
                checkIfResourceLoadingFinished: s
            }
        }
        const oS = new WeakMap;
        class sS extends lA {
            constructor(e) {
                super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
                    position: "POSITION",
                    normal: "NORMAL",
                    color: "COLOR",
                    uv: "TEX_COORD"
                }, this.defaultAttributeTypes = {
                    position: "Float32Array",
                    normal: "Float32Array",
                    color: "Float32Array",
                    uv: "Float32Array"
                }
            }
            setDecoderPath(e) {
                return this.decoderPath = e, this
            }
            setDecoderConfig(e) {
                return this.decoderConfig = e, this
            }
            setWorkerLimit(e) {
                return this.workerLimit = e, this
            }
            load(e, t, n, i) {
                const r = new hA(this.manager);
                r.setPath(this.path), r.setResponseType("arraybuffer"), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials), r.load(e, (e => {
                    this.parse(e, t, i)
                }), n, i)
            }
            parse(e, t, n = (() => {})) {
                this.decodeDracoFile(e, t, null, null, Ot).catch(n)
            }
            decodeDracoFile(e, t, n, i, r = Nt, o = (() => {})) {
                const s = {
                    attributeIDs: n || this.defaultAttributeIDs,
                    attributeTypes: i || this.defaultAttributeTypes,
                    useUniqueIDs: !!n,
                    vertexColorSpace: r
                };
                return this.decodeGeometry(e, s).then(t).catch(o)
            }
            decodeGeometry(e, t) {
                const n = JSON.stringify(t);
                if (oS.has(e)) {
                    const t = oS.get(e);
                    if (t.key === n) return t.promise;
                    if (0 === e.byteLength) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
                }
                let i;
                const r = this.workerNextTaskID++,
                    o = e.byteLength,
                    s = this._getWorker(r, o).then((n => (i = n, new Promise(((n, o) => {
                        i._callbacks[r] = {
                            resolve: n,
                            reject: o
                        }, i.postMessage({
                            type: "decode",
                            id: r,
                            taskConfig: t,
                            buffer: e
                        }, [e])
                    }))))).then((e => this._createGeometry(e.geometry)));
                return s.catch((() => !0)).then((() => {
                    i && r && this._releaseTask(i, r)
                })), oS.set(e, {
                    key: n,
                    promise: s
                }), s
            }
            _createGeometry(e) {
                const t = new Ur;
                e.index && t.setIndex(new Er(e.index.array, 1));
                for (let n = 0; n < e.attributes.length; n++) {
                    const i = e.attributes[n],
                        r = i.name,
                        o = i.array,
                        s = i.itemSize,
                        a = new Er(o, s);
                    "color" === r && (this._assignVertexColorSpace(a, i.vertexColorSpace), a.normalized = o instanceof Float32Array == !1), t.setAttribute(r, a)
                }
                return t
            }
            _assignVertexColorSpace(e, t) {
                if (t !== Ot) return;
                const n = new sr;
                for (let t = 0, i = e.count; t < i; t++) n.fromBufferAttribute(e, t).convertSRGBToLinear(), e.setXYZ(t, n.r, n.g, n.b)
            }
            _loadLibrary(e, t) {
                const n = new hA(this.manager);
                return n.setPath(this.decoderPath), n.setResponseType(t), n.setWithCredentials(this.withCredentials), new Promise(((t, i) => {
                    n.load(e, t, void 0, i)
                }))
            }
            preload() {
                return this._initDecoder(), this
            }
            _initDecoder() {
                if (this.decoderPending) return this.decoderPending;
                const e = "object" != typeof WebAssembly || "js" === this.decoderConfig.type,
                    t = [];
                return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then((t => {
                    const n = t[0];
                    e || (this.decoderConfig.wasmBinary = t[1]);
                    const i = aS.toString(),
                        r = ["/* draco decoder */", n, "", "/* worker */", i.substring(i.indexOf("{") + 1, i.lastIndexOf("}"))].join("\n");
                    this.workerSourceURL = URL.createObjectURL(new Blob([r]))
                })), this.decoderPending
            }
            _getWorker(e, t) {
                return this._initDecoder().then((() => {
                    if (this.workerPool.length < this.workerLimit) {
                        const e = new Worker(this.workerSourceURL);
                        e._callbacks = {}, e._taskCosts = {}, e._taskLoad = 0, e.postMessage({
                            type: "init",
                            decoderConfig: this.decoderConfig
                        }), e.onmessage = function(t) {
                            const n = t.data;
                            switch (n.type) {
                                case "decode":
                                    e._callbacks[n.id].resolve(n);
                                    break;
                                case "error":
                                    e._callbacks[n.id].reject(n);
                                    break;
                                default:
                                    console.error('THREE.DRACOLoader: Unexpected message, "' + n.type + '"')
                            }
                        }, this.workerPool.push(e)
                    } else this.workerPool.sort((function(e, t) {
                        return e._taskLoad > t._taskLoad ? -1 : 1
                    }));
                    const n = this.workerPool[this.workerPool.length - 1];
                    return n._taskCosts[e] = t, n._taskLoad += t, n
                }))
            }
            _releaseTask(e, t) {
                e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t]
            }
            debug() {
                console.log("Task load: ", this.workerPool.map((e => e._taskLoad)))
            }
            dispose() {
                for (let e = 0; e < this.workerPool.length; ++e) this.workerPool[e].terminate();
                return this.workerPool.length = 0, "" !== this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), this
            }
        }

        function aS() {
            let e, t;

            function n(e, t, n, i, r, o) {
                const s = o.num_components(),
                    a = n.num_points() * s,
                    l = a * r.BYTES_PER_ELEMENT,
                    c = function(e, t) {
                        switch (t) {
                            case Float32Array:
                                return e.DT_FLOAT32;
                            case Int8Array:
                                return e.DT_INT8;
                            case Int16Array:
                                return e.DT_INT16;
                            case Int32Array:
                                return e.DT_INT32;
                            case Uint8Array:
                                return e.DT_UINT8;
                            case Uint16Array:
                                return e.DT_UINT16;
                            case Uint32Array:
                                return e.DT_UINT32
                        }
                    }(e, r),
                    A = e._malloc(l);
                t.GetAttributeDataArrayForAllPoints(n, o, c, l, A);
                const h = new r(e.HEAPF32.buffer, A, a).slice();
                return e._free(A), {
                    name: i,
                    array: h,
                    itemSize: s
                }
            }
            onmessage = function(i) {
                const r = i.data;
                switch (r.type) {
                    case "init":
                        e = r.decoderConfig, t = new Promise((function(t) {
                            e.onModuleLoaded = function(e) {
                                t({
                                    draco: e
                                })
                            }, DracoDecoderModule(e)
                        }));
                        break;
                    case "decode":
                        const i = r.buffer,
                            o = r.taskConfig;
                        t.then((e => {
                            const t = e.draco,
                                s = new t.Decoder;
                            try {
                                const e = function(e, t, i, r) {
                                        const o = r.attributeIDs,
                                            s = r.attributeTypes;
                                        let a, l;
                                        const c = t.GetEncodedGeometryType(i);
                                        if (c === e.TRIANGULAR_MESH) a = new e.Mesh, l = t.DecodeArrayToMesh(i, i.byteLength, a);
                                        else {
                                            if (c !== e.POINT_CLOUD) throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
                                            a = new e.PointCloud, l = t.DecodeArrayToPointCloud(i, i.byteLength, a)
                                        }
                                        if (!l.ok() || 0 === a.ptr) throw new Error("THREE.DRACOLoader: Decoding failed: " + l.error_msg());
                                        const A = {
                                            index: null,
                                            attributes: []
                                        };
                                        for (const i in o) {
                                            const l = self[s[i]];
                                            let c, h;
                                            if (r.useUniqueIDs) h = o[i], c = t.GetAttributeByUniqueId(a, h);
                                            else {
                                                if (h = t.GetAttributeId(a, e[o[i]]), -1 === h) continue;
                                                c = t.GetAttribute(a, h)
                                            }
                                            const u = n(e, t, a, i, l, c);
                                            "color" === i && (u.vertexColorSpace = r.vertexColorSpace), A.attributes.push(u)
                                        }
                                        c === e.TRIANGULAR_MESH && (A.index = function(e, t, n) {
                                            const i = n.num_faces(),
                                                r = 3 * i,
                                                o = 4 * r,
                                                s = e._malloc(o);
                                            t.GetTrianglesUInt32Array(n, o, s);
                                            const a = new Uint32Array(e.HEAPF32.buffer, s, r).slice();
                                            return e._free(s), {
                                                array: a,
                                                itemSize: 1
                                            }
                                        }(e, t, a));
                                        return e.destroy(a), A
                                    }(t, s, new Int8Array(i), o),
                                    a = e.attributes.map((e => e.array.buffer));
                                e.index && a.push(e.index.array.buffer), self.postMessage({
                                    type: "decode",
                                    id: r.id,
                                    geometry: e
                                }, a)
                            } catch (e) {
                                console.error(e), self.postMessage({
                                    type: "error",
                                    id: r.id,
                                    error: e.message
                                })
                            } finally {
                                t.destroy(s)
                            }
                        }))
                }
            }
        }

        function lS(e, t) {
            if (0 === t) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), e;
            if (2 === t || 1 === t) {
                let n = e.getIndex();
                if (null === n) {
                    const t = [],
                        i = e.getAttribute("position");
                    if (void 0 === i) return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), e;
                    for (let e = 0; e < i.count; e++) t.push(e);
                    e.setIndex(t), n = e.getIndex()
                }
                const i = n.count - 2,
                    r = [];
                if (2 === t)
                    for (let e = 1; e <= i; e++) r.push(n.getX(0)), r.push(n.getX(e)), r.push(n.getX(e + 1));
                else
                    for (let e = 0; e < i; e++) e % 2 == 0 ? (r.push(n.getX(e)), r.push(n.getX(e + 1)), r.push(n.getX(e + 2))) : (r.push(n.getX(e + 2)), r.push(n.getX(e + 1)), r.push(n.getX(e)));
                r.length / 3 !== i && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
                const o = e.clone();
                return o.setIndex(r), o.clearGroups(), o
            }
            return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", t), e
        }
        class cS extends lA {
            constructor(e) {
                super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register((function(e) {
                    return new gS(e)
                })), this.register((function(e) {
                    return new fS(e)
                })), this.register((function(e) {
                    return new yS(e)
                })), this.register((function(e) {
                    return new wS(e)
                })), this.register((function(e) {
                    return new bS(e)
                })), this.register((function(e) {
                    return new ES(e)
                })), this.register((function(e) {
                    return new CS(e)
                })), this.register((function(e) {
                    return new IS(e)
                })), this.register((function(e) {
                    return new SS(e)
                })), this.register((function(e) {
                    return new pS(e)
                })), this.register((function(e) {
                    return new vS(e)
                })), this.register((function(e) {
                    return new mS(e)
                })), this.register((function(e) {
                    return new xS(e)
                })), this.register((function(e) {
                    return new BS(e)
                })), this.register((function(e) {
                    return new uS(e)
                })), this.register((function(e) {
                    return new QS(e)
                })), this.register((function(e) {
                    return new US(e)
                }))
            }
            load(e, t, n, i) {
                const r = this;
                let o;
                if ("" !== this.resourcePath) o = this.resourcePath;
                else if ("" !== this.path) {
                    const t = MA.extractUrlBase(e);
                    o = MA.resolveURL(t, this.path)
                } else o = MA.extractUrlBase(e);
                this.manager.itemStart(e);
                const s = function(t) {
                        i ? i(t) : console.error(t), r.manager.itemError(e), r.manager.itemEnd(e)
                    },
                    a = new hA(this.manager);
                a.setPath(this.path), a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, (function(n) {
                    try {
                        r.parse(n, o, (function(n) {
                            t(n), r.manager.itemEnd(e)
                        }), s)
                    } catch (e) {
                        s(e)
                    }
                }), n, s)
            }
            setDRACOLoader(e) {
                return this.dracoLoader = e, this
            }
            setDDSLoader() {
                throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
            }
            setKTX2Loader(e) {
                return this.ktx2Loader = e, this
            }
            setMeshoptDecoder(e) {
                return this.meshoptDecoder = e, this
            }
            register(e) {
                return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this
            }
            unregister(e) {
                return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this
            }
            parse(e, t, n, i) {
                let r;
                const o = {},
                    s = {},
                    a = new TextDecoder;
                if ("string" == typeof e) r = JSON.parse(e);
                else if (e instanceof ArrayBuffer) {
                    if (a.decode(new Uint8Array(e, 0, 4)) === MS) {
                        try {
                            o[hS.KHR_BINARY_GLTF] = new FS(e)
                        } catch (e) {
                            return void(i && i(e))
                        }
                        r = JSON.parse(o[hS.KHR_BINARY_GLTF].content)
                    } else r = JSON.parse(a.decode(e))
                } else r = e;
                if (void 0 === r.asset || r.asset.version[0] < 2) return void(i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
                const l = new ov(r, {
                    path: t || this.resourcePath || "",
                    crossOrigin: this.crossOrigin,
                    requestHeader: this.requestHeader,
                    manager: this.manager,
                    ktx2Loader: this.ktx2Loader,
                    meshoptDecoder: this.meshoptDecoder
                });
                l.fileLoader.setRequestHeader(this.requestHeader);
                for (let e = 0; e < this.pluginCallbacks.length; e++) {
                    const t = this.pluginCallbacks[e](l);
                    t.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), s[t.name] = t, o[t.name] = !0
                }
                if (r.extensionsUsed)
                    for (let e = 0; e < r.extensionsUsed.length; ++e) {
                        const t = r.extensionsUsed[e],
                            n = r.extensionsRequired || [];
                        switch (t) {
                            case hS.KHR_MATERIALS_UNLIT:
                                o[t] = new dS;
                                break;
                            case hS.KHR_DRACO_MESH_COMPRESSION:
                                o[t] = new DS(r, this.dracoLoader);
                                break;
                            case hS.KHR_TEXTURE_TRANSFORM:
                                o[t] = new kS;
                                break;
                            case hS.KHR_MESH_QUANTIZATION:
                                o[t] = new LS;
                                break;
                            default:
                                n.indexOf(t) >= 0 && void 0 === s[t] && console.warn('THREE.GLTFLoader: Unknown extension "' + t + '".')
                        }
                    }
                l.setExtensions(o), l.setPlugins(s), l.parse(n, i)
            }
            parseAsync(e, t) {
                const n = this;
                return new Promise((function(i, r) {
                    n.parse(e, t, i, r)
                }))
            }
        }

        function AS() {
            let e = {};
            return {
                get: function(t) {
                    return e[t]
                },
                add: function(t, n) {
                    e[t] = n
                },
                remove: function(t) {
                    delete e[t]
                },
                removeAll: function() {
                    e = {}
                }
            }
        }
        const hS = {
            KHR_BINARY_GLTF: "KHR_binary_glTF",
            KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
            KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
            KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
            KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
            KHR_MATERIALS_IOR: "KHR_materials_ior",
            KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
            KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
            KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
            KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
            KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
            KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
            KHR_MATERIALS_VOLUME: "KHR_materials_volume",
            KHR_TEXTURE_BASISU: "KHR_texture_basisu",
            KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
            KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
            KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
            EXT_MATERIALS_BUMP: "EXT_materials_bump",
            EXT_TEXTURE_WEBP: "EXT_texture_webp",
            EXT_TEXTURE_AVIF: "EXT_texture_avif",
            EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
            EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
        };
        class uS {
            constructor(e) {
                this.parser = e, this.name = hS.KHR_LIGHTS_PUNCTUAL, this.cache = {
                    refs: {},
                    uses: {}
                }
            }
            _markDefs() {
                const e = this.parser,
                    t = this.parser.json.nodes || [];
                for (let n = 0, i = t.length; n < i; n++) {
                    const i = t[n];
                    i.extensions && i.extensions[this.name] && void 0 !== i.extensions[this.name].light && e._addNodeRef(this.cache, i.extensions[this.name].light)
                }
            }
            _loadLight(e) {
                const t = this.parser,
                    n = "light:" + e;
                let i = t.cache.get(n);
                if (i) return i;
                const r = t.json,
                    o = ((r.extensions && r.extensions[this.name] || {}).lights || [])[e];
                let s;
                const a = new sr(16777215);
                void 0 !== o.color && a.setRGB(o.color[0], o.color[1], o.color[2], Nt);
                const l = void 0 !== o.range ? o.range : 0;
                switch (o.type) {
                    case "directional":
                        s = new QA(a), s.target.position.set(0, 0, -1), s.add(s.target);
                        break;
                    case "point":
                        s = new wA(a), s.distance = l;
                        break;
                    case "spot":
                        s = new SA(a), s.distance = l, o.spot = o.spot || {}, o.spot.innerConeAngle = void 0 !== o.spot.innerConeAngle ? o.spot.innerConeAngle : 0, o.spot.outerConeAngle = void 0 !== o.spot.outerConeAngle ? o.spot.outerConeAngle : Math.PI / 4, s.angle = o.spot.outerConeAngle, s.penumbra = 1 - o.spot.innerConeAngle / o.spot.outerConeAngle, s.target.position.set(0, 0, -1), s.add(s.target);
                        break;
                    default:
                        throw new Error("THREE.GLTFLoader: Unexpected light type: " + o.type)
                }
                return s.position.set(0, 0, 0), s.decay = 2, $S(s, o), void 0 !== o.intensity && (s.intensity = o.intensity), s.name = t.createUniqueName(o.name || "light_" + e), i = Promise.resolve(s), t.cache.add(n, i), i
            }
            getDependency(e, t) {
                if ("light" === e) return this._loadLight(t)
            }
            createNodeAttachment(e) {
                const t = this,
                    n = this.parser,
                    i = n.json.nodes[e],
                    r = (i.extensions && i.extensions[this.name] || {}).light;
                return void 0 === r ? null : this._loadLight(r).then((function(e) {
                    return n._getNodeRef(t.cache, r, e)
                }))
            }
        }
        class dS {
            constructor() {
                this.name = hS.KHR_MATERIALS_UNLIT
            }
            getMaterialType() {
                return Ar
            }
            extendParams(e, t, n) {
                const i = [];
                e.color = new sr(1, 1, 1), e.opacity = 1;
                const r = t.pbrMetallicRoughness;
                if (r) {
                    if (Array.isArray(r.baseColorFactor)) {
                        const t = r.baseColorFactor;
                        e.color.setRGB(t[0], t[1], t[2], Nt), e.opacity = t[3]
                    }
                    void 0 !== r.baseColorTexture && i.push(n.assignTexture(e, "map", r.baseColorTexture, Ot))
                }
                return Promise.all(i)
            }
        }
        class pS {
            constructor(e) {
                this.parser = e, this.name = hS.KHR_MATERIALS_EMISSIVE_STRENGTH
            }
            extendMaterialParams(e, t) {
                const n = this.parser.json.materials[e];
                if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
                const i = n.extensions[this.name].emissiveStrength;
                return void 0 !== i && (t.emissiveIntensity = i), Promise.resolve()
            }
        }
        class gS {
            constructor(e) {
                this.parser = e, this.name = hS.KHR_MATERIALS_CLEARCOAT
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? Kc : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser,
                    i = n.json.materials[e];
                if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                const r = [],
                    o = i.extensions[this.name];
                if (void 0 !== o.clearcoatFactor && (t.clearcoat = o.clearcoatFactor), void 0 !== o.clearcoatTexture && r.push(n.assignTexture(t, "clearcoatMap", o.clearcoatTexture)), void 0 !== o.clearcoatRoughnessFactor && (t.clearcoatRoughness = o.clearcoatRoughnessFactor), void 0 !== o.clearcoatRoughnessTexture && r.push(n.assignTexture(t, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)), void 0 !== o.clearcoatNormalTexture && (r.push(n.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)), void 0 !== o.clearcoatNormalTexture.scale)) {
                    const e = o.clearcoatNormalTexture.scale;
                    t.clearcoatNormalScale = new dn(e, e)
                }
                return Promise.all(r)
            }
        }
        class fS {
            constructor(e) {
                this.parser = e, this.name = hS.KHR_MATERIALS_DISPERSION
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? Kc : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser.json.materials[e];
                if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
                const i = n.extensions[this.name];
                return t.dispersion = void 0 !== i.dispersion ? i.dispersion : 0, Promise.resolve()
            }
        }
        class mS {
            constructor(e) {
                this.parser = e, this.name = hS.KHR_MATERIALS_IRIDESCENCE
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? Kc : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser,
                    i = n.json.materials[e];
                if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                const r = [],
                    o = i.extensions[this.name];
                return void 0 !== o.iridescenceFactor && (t.iridescence = o.iridescenceFactor), void 0 !== o.iridescenceTexture && r.push(n.assignTexture(t, "iridescenceMap", o.iridescenceTexture)), void 0 !== o.iridescenceIor && (t.iridescenceIOR = o.iridescenceIor), void 0 === t.iridescenceThicknessRange && (t.iridescenceThicknessRange = [100, 400]), void 0 !== o.iridescenceThicknessMinimum && (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum), void 0 !== o.iridescenceThicknessMaximum && (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum), void 0 !== o.iridescenceThicknessTexture && r.push(n.assignTexture(t, "iridescenceThicknessMap", o.iridescenceThicknessTexture)), Promise.all(r)
            }
        }
        class ES {
            constructor(e) {
                this.parser = e, this.name = hS.KHR_MATERIALS_SHEEN
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? Kc : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser,
                    i = n.json.materials[e];
                if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                const r = [];
                t.sheenColor = new sr(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
                const o = i.extensions[this.name];
                if (void 0 !== o.sheenColorFactor) {
                    const e = o.sheenColorFactor;
                    t.sheenColor.setRGB(e[0], e[1], e[2], Nt)
                }
                return void 0 !== o.sheenRoughnessFactor && (t.sheenRoughness = o.sheenRoughnessFactor), void 0 !== o.sheenColorTexture && r.push(n.assignTexture(t, "sheenColorMap", o.sheenColorTexture, Ot)), void 0 !== o.sheenRoughnessTexture && r.push(n.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)), Promise.all(r)
            }
        }
        class CS {
            constructor(e) {
                this.parser = e, this.name = hS.KHR_MATERIALS_TRANSMISSION
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? Kc : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser,
                    i = n.json.materials[e];
                if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                const r = [],
                    o = i.extensions[this.name];
                return void 0 !== o.transmissionFactor && (t.transmission = o.transmissionFactor), void 0 !== o.transmissionTexture && r.push(n.assignTexture(t, "transmissionMap", o.transmissionTexture)), Promise.all(r)
            }
        }
        class IS {
            constructor(e) {
                this.parser = e, this.name = hS.KHR_MATERIALS_VOLUME
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? Kc : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser,
                    i = n.json.materials[e];
                if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                const r = [],
                    o = i.extensions[this.name];
                t.thickness = void 0 !== o.thicknessFactor ? o.thicknessFactor : 0, void 0 !== o.thicknessTexture && r.push(n.assignTexture(t, "thicknessMap", o.thicknessTexture)), t.attenuationDistance = o.attenuationDistance || 1 / 0;
                const s = o.attenuationColor || [1, 1, 1];
                return t.attenuationColor = (new sr).setRGB(s[0], s[1], s[2], Nt), Promise.all(r)
            }
        }
        class SS {
            constructor(e) {
                this.parser = e, this.name = hS.KHR_MATERIALS_IOR
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? Kc : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser.json.materials[e];
                if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
                const i = n.extensions[this.name];
                return t.ior = void 0 !== i.ior ? i.ior : 1.5, Promise.resolve()
            }
        }
        class vS {
            constructor(e) {
                this.parser = e, this.name = hS.KHR_MATERIALS_SPECULAR
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? Kc : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser,
                    i = n.json.materials[e];
                if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                const r = [],
                    o = i.extensions[this.name];
                t.specularIntensity = void 0 !== o.specularFactor ? o.specularFactor : 1, void 0 !== o.specularTexture && r.push(n.assignTexture(t, "specularIntensityMap", o.specularTexture));
                const s = o.specularColorFactor || [1, 1, 1];
                return t.specularColor = (new sr).setRGB(s[0], s[1], s[2], Nt), void 0 !== o.specularColorTexture && r.push(n.assignTexture(t, "specularColorMap", o.specularColorTexture, Ot)), Promise.all(r)
            }
        }
        class BS {
            constructor(e) {
                this.parser = e, this.name = hS.EXT_MATERIALS_BUMP
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? Kc : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser,
                    i = n.json.materials[e];
                if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                const r = [],
                    o = i.extensions[this.name];
                return t.bumpScale = void 0 !== o.bumpFactor ? o.bumpFactor : 1, void 0 !== o.bumpTexture && r.push(n.assignTexture(t, "bumpMap", o.bumpTexture)), Promise.all(r)
            }
        }
        class xS {
            constructor(e) {
                this.parser = e, this.name = hS.KHR_MATERIALS_ANISOTROPY
            }
            getMaterialType(e) {
                const t = this.parser.json.materials[e];
                return t.extensions && t.extensions[this.name] ? Kc : null
            }
            extendMaterialParams(e, t) {
                const n = this.parser,
                    i = n.json.materials[e];
                if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
                const r = [],
                    o = i.extensions[this.name];
                return void 0 !== o.anisotropyStrength && (t.anisotropy = o.anisotropyStrength), void 0 !== o.anisotropyRotation && (t.anisotropyRotation = o.anisotropyRotation), void 0 !== o.anisotropyTexture && r.push(n.assignTexture(t, "anisotropyMap", o.anisotropyTexture)), Promise.all(r)
            }
        }
        class yS {
            constructor(e) {
                this.parser = e, this.name = hS.KHR_TEXTURE_BASISU
            }
            loadTexture(e) {
                const t = this.parser,
                    n = t.json,
                    i = n.textures[e];
                if (!i.extensions || !i.extensions[this.name]) return null;
                const r = i.extensions[this.name],
                    o = t.options.ktx2Loader;
                if (!o) {
                    if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                    return null
                }
                return t.loadTextureImage(e, r.source, o)
            }
        }
        class wS {
            constructor(e) {
                this.parser = e, this.name = hS.EXT_TEXTURE_WEBP, this.isSupported = null
            }
            loadTexture(e) {
                const t = this.name,
                    n = this.parser,
                    i = n.json,
                    r = i.textures[e];
                if (!r.extensions || !r.extensions[t]) return null;
                const o = r.extensions[t],
                    s = i.images[o.source];
                let a = n.textureLoader;
                if (s.uri) {
                    const e = n.options.manager.getHandler(s.uri);
                    null !== e && (a = e)
                }
                return this.detectSupport().then((function(r) {
                    if (r) return n.loadTextureImage(e, o.source, a);
                    if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                    return n.loadTexture(e)
                }))
            }
            detectSupport() {
                return this.isSupported || (this.isSupported = new Promise((function(e) {
                    const t = new Image;
                    t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
                        e(1 === t.height)
                    }
                }))), this.isSupported
            }
        }
        class bS {
            constructor(e) {
                this.parser = e, this.name = hS.EXT_TEXTURE_AVIF, this.isSupported = null
            }
            loadTexture(e) {
                const t = this.name,
                    n = this.parser,
                    i = n.json,
                    r = i.textures[e];
                if (!r.extensions || !r.extensions[t]) return null;
                const o = r.extensions[t],
                    s = i.images[o.source];
                let a = n.textureLoader;
                if (s.uri) {
                    const e = n.options.manager.getHandler(s.uri);
                    null !== e && (a = e)
                }
                return this.detectSupport().then((function(r) {
                    if (r) return n.loadTextureImage(e, o.source, a);
                    if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
                    return n.loadTexture(e)
                }))
            }
            detectSupport() {
                return this.isSupported || (this.isSupported = new Promise((function(e) {
                    const t = new Image;
                    t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function() {
                        e(1 === t.height)
                    }
                }))), this.isSupported
            }
        }
        class QS {
            constructor(e) {
                this.name = hS.EXT_MESHOPT_COMPRESSION, this.parser = e
            }
            loadBufferView(e) {
                const t = this.parser.json,
                    n = t.bufferViews[e];
                if (n.extensions && n.extensions[this.name]) {
                    const e = n.extensions[this.name],
                        i = this.parser.getDependency("buffer", e.buffer),
                        r = this.parser.options.meshoptDecoder;
                    if (!r || !r.supported) {
                        if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                        return null
                    }
                    return i.then((function(t) {
                        const n = e.byteOffset || 0,
                            i = e.byteLength || 0,
                            o = e.count,
                            s = e.byteStride,
                            a = new Uint8Array(t, n, i);
                        return r.decodeGltfBufferAsync ? r.decodeGltfBufferAsync(o, s, a, e.mode, e.filter).then((function(e) {
                            return e.buffer
                        })) : r.ready.then((function() {
                            const t = new ArrayBuffer(o * s);
                            return r.decodeGltfBuffer(new Uint8Array(t), o, s, a, e.mode, e.filter), t
                        }))
                    }))
                }
                return null
            }
        }
        class US {
            constructor(e) {
                this.name = hS.EXT_MESH_GPU_INSTANCING, this.parser = e
            }
            createNodeMesh(e) {
                const t = this.parser.json,
                    n = t.nodes[e];
                if (!n.extensions || !n.extensions[this.name] || void 0 === n.mesh) return null;
                const i = t.meshes[n.mesh];
                for (const e of i.primitives)
                    if (e.mode !== VS.TRIANGLES && e.mode !== VS.TRIANGLE_STRIP && e.mode !== VS.TRIANGLE_FAN && void 0 !== e.mode) return null;
                const r = n.extensions[this.name].attributes,
                    o = [],
                    s = {};
                for (const e in r) o.push(this.parser.getDependency("accessor", r[e]).then((t => (s[e] = t, s[e]))));
                return o.length < 1 ? null : (o.push(this.parser.createNodeMesh(e)), Promise.all(o).then((e => {
                    const t = e.pop(),
                        n = t.isGroup ? t.children : [t],
                        i = e[0].count,
                        r = [];
                    for (const e of n) {
                        const t = new mi,
                            n = new On,
                            o = new Vn,
                            a = new On(1, 1, 1),
                            l = new Dl(e.geometry, e.material, i);
                        for (let e = 0; e < i; e++) s.TRANSLATION && n.fromBufferAttribute(s.TRANSLATION, e), s.ROTATION && o.fromBufferAttribute(s.ROTATION, e), s.SCALE && a.fromBufferAttribute(s.SCALE, e), l.setMatrixAt(e, t.compose(n, o, a));
                        for (const t in s)
                            if ("_COLOR_0" === t) {
                                const e = s[t];
                                l.instanceColor = new wl(e.array, e.itemSize, e.normalized)
                            } else "TRANSLATION" !== t && "ROTATION" !== t && "SCALE" !== t && e.geometry.setAttribute(t, s[t]);
                        qi.prototype.copy.call(l, e), this.parser.assignFinalMaterial(l), r.push(l)
                    }
                    return t.isGroup ? (t.clear(), t.add(...r), t) : r[0]
                })))
            }
        }
        const MS = "glTF",
            RS = 1313821514,
            TS = 5130562;
        class FS {
            constructor(e) {
                this.name = hS.KHR_BINARY_GLTF, this.content = null, this.body = null;
                const t = new DataView(e, 0, 12),
                    n = new TextDecoder;
                if (this.header = {
                        magic: n.decode(new Uint8Array(e.slice(0, 4))),
                        version: t.getUint32(4, !0),
                        length: t.getUint32(8, !0)
                    }, this.header.magic !== MS) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
                if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
                const i = this.header.length - 12,
                    r = new DataView(e, 12);
                let o = 0;
                for (; o < i;) {
                    const t = r.getUint32(o, !0);
                    o += 4;
                    const i = r.getUint32(o, !0);
                    if (o += 4, i === RS) {
                        const i = new Uint8Array(e, 12 + o, t);
                        this.content = n.decode(i)
                    } else if (i === TS) {
                        const n = 12 + o;
                        this.body = e.slice(n, n + t)
                    }
                    o += t
                }
                if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.")
            }
        }
        class DS {
            constructor(e, t) {
                if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
                this.name = hS.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload()
            }
            decodePrimitive(e, t) {
                const n = this.json,
                    i = this.dracoLoader,
                    r = e.extensions[this.name].bufferView,
                    o = e.extensions[this.name].attributes,
                    s = {},
                    a = {},
                    l = {};
                for (const e in o) {
                    const t = jS[e] || e.toLowerCase();
                    s[t] = o[e]
                }
                for (const t in e.attributes) {
                    const i = jS[t] || t.toLowerCase();
                    if (void 0 !== o[t]) {
                        const r = n.accessors[e.attributes[t]],
                            o = OS[r.componentType];
                        l[i] = o.name, a[i] = !0 === r.normalized
                    }
                }
                return t.getDependency("bufferView", r).then((function(e) {
                    return new Promise((function(t, n) {
                        i.decodeDracoFile(e, (function(e) {
                            for (const t in e.attributes) {
                                const n = e.attributes[t],
                                    i = a[t];
                                void 0 !== i && (n.normalized = i)
                            }
                            t(e)
                        }), s, l, Nt, n)
                    }))
                }))
            }
        }
        class kS {
            constructor() {
                this.name = hS.KHR_TEXTURE_TRANSFORM
            }
            extendTexture(e, t) {
                return void 0 !== t.texCoord && t.texCoord !== e.channel || void 0 !== t.offset || void 0 !== t.rotation || void 0 !== t.scale ? (e = e.clone(), void 0 !== t.texCoord && (e.channel = t.texCoord), void 0 !== t.offset && e.offset.fromArray(t.offset), void 0 !== t.rotation && (e.rotation = t.rotation), void 0 !== t.scale && e.repeat.fromArray(t.scale), e.needsUpdate = !0, e) : e
            }
        }
        class LS {
            constructor() {
                this.name = hS.KHR_MESH_QUANTIZATION
            }
        }
        class KS extends jc {
            constructor(e, t, n, i) {
                super(e, t, n, i)
            }
            copySampleValue_(e) {
                const t = this.resultBuffer,
                    n = this.sampleValues,
                    i = this.valueSize,
                    r = e * i * 3 + i;
                for (let e = 0; e !== i; e++) t[e] = n[r + e];
                return t
            }
            interpolate_(e, t, n, i) {
                const r = this.resultBuffer,
                    o = this.sampleValues,
                    s = this.valueSize,
                    a = 2 * s,
                    l = 3 * s,
                    c = i - t,
                    A = (n - t) / c,
                    h = A * A,
                    u = h * A,
                    d = e * l,
                    p = d - l,
                    g = -2 * u + 3 * h,
                    f = u - h,
                    m = 1 - g,
                    E = f - h + A;
                for (let e = 0; e !== s; e++) {
                    const t = o[p + e + s],
                        n = o[p + e + a] * c,
                        i = o[d + e + s],
                        l = o[d + e] * c;
                    r[e] = m * t + E * n + g * i + f * l
                }
                return r
            }
        }
        const PS = new Vn;
        class GS extends KS {
            interpolate_(e, t, n, i) {
                const r = super.interpolate_(e, t, n, i);
                return PS.fromArray(r).normalize().toArray(r), r
            }
        }
        const VS = {
                FLOAT: 5126,
                FLOAT_MAT3: 35675,
                FLOAT_MAT4: 35676,
                FLOAT_VEC2: 35664,
                FLOAT_VEC3: 35665,
                FLOAT_VEC4: 35666,
                LINEAR: 9729,
                REPEAT: 10497,
                SAMPLER_2D: 35678,
                POINTS: 0,
                LINES: 1,
                LINE_LOOP: 2,
                LINE_STRIP: 3,
                TRIANGLES: 4,
                TRIANGLE_STRIP: 5,
                TRIANGLE_FAN: 6,
                UNSIGNED_BYTE: 5121,
                UNSIGNED_SHORT: 5123
            },
            OS = {
                5120: Int8Array,
                5121: Uint8Array,
                5122: Int16Array,
                5123: Uint16Array,
                5125: Uint32Array,
                5126: Float32Array
            },
            NS = {
                9728: $e,
                9729: nt,
                9984: et,
                9985: it,
                9986: tt,
                9987: rt
            },
            HS = {
                33071: Ze,
                33648: _e,
                10497: Xe
            },
            qS = {
                SCALAR: 1,
                VEC2: 2,
                VEC3: 3,
                VEC4: 4,
                MAT2: 4,
                MAT3: 9,
                MAT4: 16
            },
            jS = {
                POSITION: "position",
                NORMAL: "normal",
                TANGENT: "tangent",
                TEXCOORD_0: "uv",
                TEXCOORD_1: "uv1",
                TEXCOORD_2: "uv2",
                TEXCOORD_3: "uv3",
                COLOR_0: "color",
                WEIGHTS_0: "skinWeight",
                JOINTS_0: "skinIndex"
            },
            YS = {
                scale: "scale",
                translation: "position",
                rotation: "quaternion",
                weights: "morphTargetInfluences"
            },
            JS = {
                CUBICSPLINE: void 0,
                LINEAR: Tt,
                STEP: Rt
            },
            WS = "OPAQUE",
            zS = "MASK",
            XS = "BLEND";

        function ZS(e) {
            return void 0 === e.DefaultMaterial && (e.DefaultMaterial = new Lc({
                color: 16777215,
                emissive: 0,
                metalness: 1,
                roughness: 1,
                transparent: !1,
                depthTest: !0,
                side: Ue
            })), e.DefaultMaterial
        }

        function _S(e, t, n) {
            for (const i in n.extensions) void 0 === e[i] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[i] = n.extensions[i])
        }

        function $S(e, t) {
            void 0 !== t.extras && ("object" == typeof t.extras ? Object.assign(e.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras))
        }

        function ev(e, t) {
            if (e.updateMorphTargets(), void 0 !== t.weights)
                for (let n = 0, i = t.weights.length; n < i; n++) e.morphTargetInfluences[n] = t.weights[n];
            if (t.extras && Array.isArray(t.extras.targetNames)) {
                const n = t.extras.targetNames;
                if (e.morphTargetInfluences.length === n.length) {
                    e.morphTargetDictionary = {};
                    for (let t = 0, i = n.length; t < i; t++) e.morphTargetDictionary[n[t]] = t
                } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
            }
        }

        function tv(e) {
            let t;
            const n = e.extensions && e.extensions[hS.KHR_DRACO_MESH_COMPRESSION];
            if (t = n ? "draco:" + n.bufferView + ":" + n.indices + ":" + nv(n.attributes) : e.indices + ":" + nv(e.attributes) + ":" + e.mode, void 0 !== e.targets)
                for (let n = 0, i = e.targets.length; n < i; n++) t += ":" + nv(e.targets[n]);
            return t
        }

        function nv(e) {
            let t = "";
            const n = Object.keys(e).sort();
            for (let i = 0, r = n.length; i < r; i++) t += n[i] + ":" + e[n[i]] + ";";
            return t
        }

        function iv(e) {
            switch (e) {
                case Int8Array:
                    return 1 / 127;
                case Uint8Array:
                    return 1 / 255;
                case Int16Array:
                    return 1 / 32767;
                case Uint16Array:
                    return 1 / 65535;
                default:
                    throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
            }
        }
        const rv = new mi;
        class ov {
            constructor(e = {}, t = {}) {
                this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new AS, this.associations = new Map, this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = {
                    refs: {},
                    uses: {}
                }, this.cameraCache = {
                    refs: {},
                    uses: {}
                }, this.lightCache = {
                    refs: {},
                    uses: {}
                }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
                let n = !1,
                    i = !1,
                    r = -1;
                "undefined" != typeof navigator && (n = !0 === /^((?!chrome|android).)*safari/i.test(navigator.userAgent), i = navigator.userAgent.indexOf("Firefox") > -1, r = i ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), "undefined" == typeof createImageBitmap || n || i && r < 98 ? this.textureLoader = new pA(this.options.manager) : this.textureLoader = new RA(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new hA(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
            }
            setExtensions(e) {
                this.extensions = e
            }
            setPlugins(e) {
                this.plugins = e
            }
            parse(e, t) {
                const n = this,
                    i = this.json,
                    r = this.extensions;
                this.cache.removeAll(), this.nodeCache = {}, this._invokeAll((function(e) {
                    return e._markDefs && e._markDefs()
                })), Promise.all(this._invokeAll((function(e) {
                    return e.beforeRoot && e.beforeRoot()
                }))).then((function() {
                    return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
                })).then((function(t) {
                    const o = {
                        scene: t[0][i.scene || 0],
                        scenes: t[0],
                        animations: t[1],
                        cameras: t[2],
                        asset: i.asset,
                        parser: n,
                        userData: {}
                    };
                    return _S(r, o, i), $S(o, i), Promise.all(n._invokeAll((function(e) {
                        return e.afterRoot && e.afterRoot(o)
                    }))).then((function() {
                        for (const e of o.scenes) e.updateMatrixWorld();
                        e(o)
                    }))
                })).catch(t)
            }
            _markDefs() {
                const e = this.json.nodes || [],
                    t = this.json.skins || [],
                    n = this.json.meshes || [];
                for (let n = 0, i = t.length; n < i; n++) {
                    const i = t[n].joints;
                    for (let t = 0, n = i.length; t < n; t++) e[i[t]].isBone = !0
                }
                for (let t = 0, i = e.length; t < i; t++) {
                    const i = e[t];
                    void 0 !== i.mesh && (this._addNodeRef(this.meshCache, i.mesh), void 0 !== i.skin && (n[i.mesh].isSkinnedMesh = !0)), void 0 !== i.camera && this._addNodeRef(this.cameraCache, i.camera)
                }
            }
            _addNodeRef(e, t) {
                void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++)
            }
            _getNodeRef(e, t, n) {
                if (e.refs[t] <= 1) return n;
                const i = n.clone(),
                    r = (e, t) => {
                        const n = this.associations.get(e);
                        null != n && this.associations.set(t, n);
                        for (const [n, i] of e.children.entries()) r(i, t.children[n])
                    };
                return r(n, i), i.name += "_instance_" + e.uses[t]++, i
            }
            _invokeOne(e) {
                const t = Object.values(this.plugins);
                t.push(this);
                for (let n = 0; n < t.length; n++) {
                    const i = e(t[n]);
                    if (i) return i
                }
                return null
            }
            _invokeAll(e) {
                const t = Object.values(this.plugins);
                t.unshift(this);
                const n = [];
                for (let i = 0; i < t.length; i++) {
                    const r = e(t[i]);
                    r && n.push(r)
                }
                return n
            }
            getDependency(e, t) {
                const n = e + ":" + t;
                let i = this.cache.get(n);
                if (!i) {
                    switch (e) {
                        case "scene":
                            i = this.loadScene(t);
                            break;
                        case "node":
                            i = this._invokeOne((function(e) {
                                return e.loadNode && e.loadNode(t)
                            }));
                            break;
                        case "mesh":
                            i = this._invokeOne((function(e) {
                                return e.loadMesh && e.loadMesh(t)
                            }));
                            break;
                        case "accessor":
                            i = this.loadAccessor(t);
                            break;
                        case "bufferView":
                            i = this._invokeOne((function(e) {
                                return e.loadBufferView && e.loadBufferView(t)
                            }));
                            break;
                        case "buffer":
                            i = this.loadBuffer(t);
                            break;
                        case "material":
                            i = this._invokeOne((function(e) {
                                return e.loadMaterial && e.loadMaterial(t)
                            }));
                            break;
                        case "texture":
                            i = this._invokeOne((function(e) {
                                return e.loadTexture && e.loadTexture(t)
                            }));
                            break;
                        case "skin":
                            i = this.loadSkin(t);
                            break;
                        case "animation":
                            i = this._invokeOne((function(e) {
                                return e.loadAnimation && e.loadAnimation(t)
                            }));
                            break;
                        case "camera":
                            i = this.loadCamera(t);
                            break;
                        default:
                            if (i = this._invokeOne((function(n) {
                                    return n != this && n.getDependency && n.getDependency(e, t)
                                })), !i) throw new Error("Unknown type: " + e)
                    }
                    this.cache.add(n, i)
                }
                return i
            }
            getDependencies(e) {
                let t = this.cache.get(e);
                if (!t) {
                    const n = this,
                        i = this.json[e + ("mesh" === e ? "es" : "s")] || [];
                    t = Promise.all(i.map((function(t, i) {
                        return n.getDependency(e, i)
                    }))), this.cache.add(e, t)
                }
                return t
            }
            loadBuffer(e) {
                const t = this.json.buffers[e],
                    n = this.fileLoader;
                if (t.type && "arraybuffer" !== t.type) throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
                if (void 0 === t.uri && 0 === e) return Promise.resolve(this.extensions[hS.KHR_BINARY_GLTF].body);
                const i = this.options;
                return new Promise((function(e, r) {
                    n.load(MA.resolveURL(t.uri, i.path), e, void 0, (function() {
                        r(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
                    }))
                }))
            }
            loadBufferView(e) {
                const t = this.json.bufferViews[e];
                return this.getDependency("buffer", t.buffer).then((function(e) {
                    const n = t.byteLength || 0,
                        i = t.byteOffset || 0;
                    return e.slice(i, i + n)
                }))
            }
            loadAccessor(e) {
                const t = this,
                    n = this.json,
                    i = this.json.accessors[e];
                if (void 0 === i.bufferView && void 0 === i.sparse) {
                    const e = qS[i.type],
                        t = OS[i.componentType],
                        n = !0 === i.normalized,
                        r = new t(i.count * e);
                    return Promise.resolve(new Er(r, e, n))
                }
                const r = [];
                return void 0 !== i.bufferView ? r.push(this.getDependency("bufferView", i.bufferView)) : r.push(null), void 0 !== i.sparse && (r.push(this.getDependency("bufferView", i.sparse.indices.bufferView)), r.push(this.getDependency("bufferView", i.sparse.values.bufferView))), Promise.all(r).then((function(e) {
                    const r = e[0],
                        o = qS[i.type],
                        s = OS[i.componentType],
                        a = s.BYTES_PER_ELEMENT,
                        l = a * o,
                        c = i.byteOffset || 0,
                        A = void 0 !== i.bufferView ? n.bufferViews[i.bufferView].byteStride : void 0,
                        h = !0 === i.normalized;
                    let u, d;
                    if (A && A !== l) {
                        const e = Math.floor(c / A),
                            n = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + e + ":" + i.count;
                        let l = t.cache.get(n);
                        l || (u = new s(r, e * A, i.count * A / a), l = new ll(u, A / a), t.cache.add(n, l)), d = new Al(l, o, c % A / a, h)
                    } else u = null === r ? new s(i.count * o) : new s(r, c, i.count * o), d = new Er(u, o, h);
                    if (void 0 !== i.sparse) {
                        const t = qS.SCALAR,
                            n = OS[i.sparse.indices.componentType],
                            a = i.sparse.indices.byteOffset || 0,
                            l = i.sparse.values.byteOffset || 0,
                            c = new n(e[1], a, i.sparse.count * t),
                            A = new s(e[2], l, i.sparse.count * o);
                        null !== r && (d = new Er(d.array.slice(), d.itemSize, d.normalized));
                        for (let e = 0, t = c.length; e < t; e++) {
                            const t = c[e];
                            if (d.setX(t, A[e * o]), o >= 2 && d.setY(t, A[e * o + 1]), o >= 3 && d.setZ(t, A[e * o + 2]), o >= 4 && d.setW(t, A[e * o + 3]), o >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                        }
                    }
                    return d
                }))
            }
            loadTexture(e) {
                const t = this.json,
                    n = this.options,
                    i = t.textures[e].source,
                    r = t.images[i];
                let o = this.textureLoader;
                if (r.uri) {
                    const e = n.manager.getHandler(r.uri);
                    null !== e && (o = e)
                }
                return this.loadTextureImage(e, i, o)
            }
            loadTextureImage(e, t, n) {
                const i = this,
                    r = this.json,
                    o = r.textures[e],
                    s = r.images[t],
                    a = (s.uri || s.bufferView) + ":" + o.sampler;
                if (this.textureCache[a]) return this.textureCache[a];
                const l = this.loadImageSource(t, n).then((function(t) {
                    t.flipY = !1, t.name = o.name || s.name || "", "" === t.name && "string" == typeof s.uri && !1 === s.uri.startsWith("data:image/") && (t.name = s.uri);
                    const n = (r.samplers || {})[o.sampler] || {};
                    return t.magFilter = NS[n.magFilter] || nt, t.minFilter = NS[n.minFilter] || rt, t.wrapS = HS[n.wrapS] || Xe, t.wrapT = HS[n.wrapT] || Xe, i.associations.set(t, {
                        textures: e
                    }), t
                })).catch((function() {
                    return null
                }));
                return this.textureCache[a] = l, l
            }
            loadImageSource(e, t) {
                const n = this,
                    i = this.json,
                    r = this.options;
                if (void 0 !== this.sourceCache[e]) return this.sourceCache[e].then((e => e.clone()));
                const o = i.images[e],
                    s = self.URL || self.webkitURL;
                let a = o.uri || "",
                    l = !1;
                if (void 0 !== o.bufferView) a = n.getDependency("bufferView", o.bufferView).then((function(e) {
                    l = !0;
                    const t = new Blob([e], {
                        type: o.mimeType
                    });
                    return a = s.createObjectURL(t), a
                }));
                else if (void 0 === o.uri) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
                const c = Promise.resolve(a).then((function(e) {
                    return new Promise((function(n, i) {
                        let o = n;
                        !0 === t.isImageBitmapLoader && (o = function(e) {
                            const t = new Dn(e);
                            t.needsUpdate = !0, n(t)
                        }), t.load(MA.resolveURL(e, r.path), o, void 0, i)
                    }))
                })).then((function(e) {
                    var t;
                    return !0 === l && s.revokeObjectURL(a), e.userData.mimeType = o.mimeType || ((t = o.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/) ? "image/jpeg" : t.search(/\.webp($|\?)/i) > 0 || 0 === t.search(/^data\:image\/webp/) ? "image/webp" : "image/png"), e
                })).catch((function(e) {
                    throw console.error("THREE.GLTFLoader: Couldn't load texture", a), e
                }));
                return this.sourceCache[e] = c, c
            }
            assignTexture(e, t, n, i) {
                const r = this;
                return this.getDependency("texture", n.index).then((function(o) {
                    if (!o) return null;
                    if (void 0 !== n.texCoord && n.texCoord > 0 && ((o = o.clone()).channel = n.texCoord), r.extensions[hS.KHR_TEXTURE_TRANSFORM]) {
                        const e = void 0 !== n.extensions ? n.extensions[hS.KHR_TEXTURE_TRANSFORM] : void 0;
                        if (e) {
                            const t = r.associations.get(o);
                            o = r.extensions[hS.KHR_TEXTURE_TRANSFORM].extendTexture(o, e), r.associations.set(o, t)
                        }
                    }
                    return void 0 !== i && (o.colorSpace = i), e[t] = o, o
                }))
            }
            assignFinalMaterial(e) {
                const t = e.geometry;
                let n = e.material;
                const i = void 0 === t.attributes.tangent,
                    r = void 0 !== t.attributes.color,
                    o = void 0 === t.attributes.normal;
                if (e.isPoints) {
                    const e = "PointsMaterial:" + n.uuid;
                    let t = this.cache.get(e);
                    t || (t = new zl, cr.prototype.copy.call(t, n), t.color.copy(n.color), t.map = n.map, t.sizeAttenuation = !1, this.cache.add(e, t)), n = t
                } else if (e.isLine) {
                    const e = "LineBasicMaterial:" + n.uuid;
                    let t = this.cache.get(e);
                    t || (t = new kl, cr.prototype.copy.call(t, n), t.color.copy(n.color), t.map = n.map, this.cache.add(e, t)), n = t
                }
                if (i || r || o) {
                    let e = "ClonedMaterial:" + n.uuid + ":";
                    i && (e += "derivative-tangents:"), r && (e += "vertex-colors:"), o && (e += "flat-shading:");
                    let t = this.cache.get(e);
                    t || (t = n.clone(), r && (t.vertexColors = !0), o && (t.flatShading = !0), i && (t.normalScale && (t.normalScale.y *= -1), t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)), this.cache.add(e, t), this.associations.set(t, this.associations.get(n))), n = t
                }
                e.material = n
            }
            getMaterialType() {
                return Lc
            }
            loadMaterial(e) {
                const t = this,
                    n = this.json,
                    i = this.extensions,
                    r = n.materials[e];
                let o;
                const s = {},
                    a = [];
                if ((r.extensions || {})[hS.KHR_MATERIALS_UNLIT]) {
                    const e = i[hS.KHR_MATERIALS_UNLIT];
                    o = e.getMaterialType(), a.push(e.extendParams(s, r, t))
                } else {
                    const n = r.pbrMetallicRoughness || {};
                    if (s.color = new sr(1, 1, 1), s.opacity = 1, Array.isArray(n.baseColorFactor)) {
                        const e = n.baseColorFactor;
                        s.color.setRGB(e[0], e[1], e[2], Nt), s.opacity = e[3]
                    }
                    void 0 !== n.baseColorTexture && a.push(t.assignTexture(s, "map", n.baseColorTexture, Ot)), s.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1, s.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1, void 0 !== n.metallicRoughnessTexture && (a.push(t.assignTexture(s, "metalnessMap", n.metallicRoughnessTexture)), a.push(t.assignTexture(s, "roughnessMap", n.metallicRoughnessTexture))), o = this._invokeOne((function(t) {
                        return t.getMaterialType && t.getMaterialType(e)
                    })), a.push(Promise.all(this._invokeAll((function(t) {
                        return t.extendMaterialParams && t.extendMaterialParams(e, s)
                    }))))
                }!0 === r.doubleSided && (s.side = Re);
                const l = r.alphaMode || WS;
                if (l === XS ? (s.transparent = !0, s.depthWrite = !1) : (s.transparent = !1, l === zS && (s.alphaTest = void 0 !== r.alphaCutoff ? r.alphaCutoff : .5)), void 0 !== r.normalTexture && o !== Ar && (a.push(t.assignTexture(s, "normalMap", r.normalTexture)), s.normalScale = new dn(1, 1), void 0 !== r.normalTexture.scale)) {
                    const e = r.normalTexture.scale;
                    s.normalScale.set(e, e)
                }
                if (void 0 !== r.occlusionTexture && o !== Ar && (a.push(t.assignTexture(s, "aoMap", r.occlusionTexture)), void 0 !== r.occlusionTexture.strength && (s.aoMapIntensity = r.occlusionTexture.strength)), void 0 !== r.emissiveFactor && o !== Ar) {
                    const e = r.emissiveFactor;
                    s.emissive = (new sr).setRGB(e[0], e[1], e[2], Nt)
                }
                return void 0 !== r.emissiveTexture && o !== Ar && a.push(t.assignTexture(s, "emissiveMap", r.emissiveTexture, Ot)), Promise.all(a).then((function() {
                    const n = new o(s);
                    return r.name && (n.name = r.name), $S(n, r), t.associations.set(n, {
                        materials: e
                    }), r.extensions && _S(i, n, r), n
                }))
            }
            createUniqueName(e) {
                const t = OA.sanitizeNodeName(e || "");
                return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t)
            }
            loadGeometries(e) {
                const t = this,
                    n = this.extensions,
                    i = this.primitiveCache;

                function r(e) {
                    return n[hS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then((function(n) {
                        return sv(n, e, t)
                    }))
                }
                const o = [];
                for (let n = 0, s = e.length; n < s; n++) {
                    const s = e[n],
                        a = tv(s),
                        l = i[a];
                    if (l) o.push(l.promise);
                    else {
                        let e;
                        e = s.extensions && s.extensions[hS.KHR_DRACO_MESH_COMPRESSION] ? r(s) : sv(new Ur, s, t), i[a] = {
                            primitive: s,
                            promise: e
                        }, o.push(e)
                    }
                }
                return Promise.all(o)
            }
            loadMesh(e) {
                const t = this,
                    n = this.json,
                    i = this.extensions,
                    r = n.meshes[e],
                    o = r.primitives,
                    s = [];
                for (let e = 0, t = o.length; e < t; e++) {
                    const t = void 0 === o[e].material ? ZS(this.cache) : this.getDependency("material", o[e].material);
                    s.push(t)
                }
                return s.push(t.loadGeometries(o)), Promise.all(s).then((function(n) {
                    const s = n.slice(0, n.length - 1),
                        a = n[n.length - 1],
                        l = [];
                    for (let n = 0, c = a.length; n < c; n++) {
                        const c = a[n],
                            A = o[n];
                        let h;
                        const u = s[n];
                        if (A.mode === VS.TRIANGLES || A.mode === VS.TRIANGLE_STRIP || A.mode === VS.TRIANGLE_FAN || void 0 === A.mode) h = !0 === r.isSkinnedMesh ? new Il(c, u) : new Jr(c, u), !0 === h.isSkinnedMesh && h.normalizeSkinWeights(), A.mode === VS.TRIANGLE_STRIP ? h.geometry = lS(h.geometry, 1) : A.mode === VS.TRIANGLE_FAN && (h.geometry = lS(h.geometry, 2));
                        else if (A.mode === VS.LINES) h = new Jl(c, u);
                        else if (A.mode === VS.LINE_STRIP) h = new Hl(c, u);
                        else if (A.mode === VS.LINE_LOOP) h = new Wl(c, u);
                        else {
                            if (A.mode !== VS.POINTS) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + A.mode);
                            h = new ec(c, u)
                        }
                        Object.keys(h.geometry.morphAttributes).length > 0 && ev(h, r), h.name = t.createUniqueName(r.name || "mesh_" + e), $S(h, r), A.extensions && _S(i, h, A), t.assignFinalMaterial(h), l.push(h)
                    }
                    for (let n = 0, i = l.length; n < i; n++) t.associations.set(l[n], {
                        meshes: e,
                        primitives: n
                    });
                    if (1 === l.length) return r.extensions && _S(i, l[0], r), l[0];
                    const c = new Xa;
                    r.extensions && _S(i, c, r), t.associations.set(c, {
                        meshes: e
                    });
                    for (let e = 0, t = l.length; e < t; e++) c.add(l[e]);
                    return c
                }))
            }
            loadCamera(e) {
                let t;
                const n = this.json.cameras[e],
                    i = n[n.type];
                if (i) return "perspective" === n.type ? t = new oo(un.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6) : "orthographic" === n.type && (t = new Fo(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), n.name && (t.name = this.createUniqueName(n.name)), $S(t, n), Promise.resolve(t);
                console.warn("THREE.GLTFLoader: Missing camera parameters.")
            }
            loadSkin(e) {
                const t = this.json.skins[e],
                    n = [];
                for (let e = 0, i = t.joints.length; e < i; e++) n.push(this._loadNodeShallow(t.joints[e]));
                return void 0 !== t.inverseBindMatrices ? n.push(this.getDependency("accessor", t.inverseBindMatrices)) : n.push(null), Promise.all(n).then((function(e) {
                    const n = e.pop(),
                        i = e,
                        r = [],
                        o = [];
                    for (let e = 0, s = i.length; e < s; e++) {
                        const s = i[e];
                        if (s) {
                            r.push(s);
                            const t = new mi;
                            null !== n && t.fromArray(n.array, 16 * e), o.push(t)
                        } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[e])
                    }
                    return new yl(r, o)
                }))
            }
            loadAnimation(e) {
                const t = this.json,
                    n = this,
                    i = t.animations[e],
                    r = i.name ? i.name : "animation_" + e,
                    o = [],
                    s = [],
                    a = [],
                    l = [],
                    c = [];
                for (let e = 0, t = i.channels.length; e < t; e++) {
                    const t = i.channels[e],
                        n = i.samplers[t.sampler],
                        r = t.target,
                        A = r.node,
                        h = void 0 !== i.parameters ? i.parameters[n.input] : n.input,
                        u = void 0 !== i.parameters ? i.parameters[n.output] : n.output;
                    void 0 !== r.node && (o.push(this.getDependency("node", A)), s.push(this.getDependency("accessor", h)), a.push(this.getDependency("accessor", u)), l.push(n), c.push(r))
                }
                return Promise.all([Promise.all(o), Promise.all(s), Promise.all(a), Promise.all(l), Promise.all(c)]).then((function(e) {
                    const t = e[0],
                        i = e[1],
                        o = e[2],
                        s = e[3],
                        a = e[4],
                        l = [];
                    for (let e = 0, r = t.length; e < r; e++) {
                        const r = t[e],
                            c = i[e],
                            A = o[e],
                            h = s[e],
                            u = a[e];
                        if (void 0 === r) continue;
                        r.updateMatrix && r.updateMatrix();
                        const d = n._createAnimationTracks(r, c, A, h, u);
                        if (d)
                            for (let e = 0; e < d.length; e++) l.push(d[e])
                    }
                    return new iA(r, void 0, l)
                }))
            }
            createNodeMesh(e) {
                const t = this.json,
                    n = this,
                    i = t.nodes[e];
                return void 0 === i.mesh ? null : n.getDependency("mesh", i.mesh).then((function(e) {
                    const t = n._getNodeRef(n.meshCache, i.mesh, e);
                    return void 0 !== i.weights && t.traverse((function(e) {
                        if (e.isMesh)
                            for (let t = 0, n = i.weights.length; t < n; t++) e.morphTargetInfluences[t] = i.weights[t]
                    })), t
                }))
            }
            loadNode(e) {
                const t = this,
                    n = this.json.nodes[e],
                    i = t._loadNodeShallow(e),
                    r = [],
                    o = n.children || [];
                for (let e = 0, n = o.length; e < n; e++) r.push(t.getDependency("node", o[e]));
                const s = void 0 === n.skin ? Promise.resolve(null) : t.getDependency("skin", n.skin);
                return Promise.all([i, Promise.all(r), s]).then((function(e) {
                    const t = e[0],
                        n = e[1],
                        i = e[2];
                    null !== i && t.traverse((function(e) {
                        e.isSkinnedMesh && e.bind(i, rv)
                    }));
                    for (let e = 0, i = n.length; e < i; e++) t.add(n[e]);
                    return t
                }))
            }
            _loadNodeShallow(e) {
                const t = this.json,
                    n = this.extensions,
                    i = this;
                if (void 0 !== this.nodeCache[e]) return this.nodeCache[e];
                const r = t.nodes[e],
                    o = r.name ? i.createUniqueName(r.name) : "",
                    s = [],
                    a = i._invokeOne((function(t) {
                        return t.createNodeMesh && t.createNodeMesh(e)
                    }));
                return a && s.push(a), void 0 !== r.camera && s.push(i.getDependency("camera", r.camera).then((function(e) {
                    return i._getNodeRef(i.cameraCache, r.camera, e)
                }))), i._invokeAll((function(t) {
                    return t.createNodeAttachment && t.createNodeAttachment(e)
                })).forEach((function(e) {
                    s.push(e)
                })), this.nodeCache[e] = Promise.all(s).then((function(t) {
                    let s;
                    if (s = !0 === r.isBone ? new Sl : t.length > 1 ? new Xa : 1 === t.length ? t[0] : new qi, s !== t[0])
                        for (let e = 0, n = t.length; e < n; e++) s.add(t[e]);
                    if (r.name && (s.userData.name = r.name, s.name = o), $S(s, r), r.extensions && _S(n, s, r), void 0 !== r.matrix) {
                        const e = new mi;
                        e.fromArray(r.matrix), s.applyMatrix4(e)
                    } else void 0 !== r.translation && s.position.fromArray(r.translation), void 0 !== r.rotation && s.quaternion.fromArray(r.rotation), void 0 !== r.scale && s.scale.fromArray(r.scale);
                    return i.associations.has(s) || i.associations.set(s, {}), i.associations.get(s).nodes = e, s
                })), this.nodeCache[e]
            }
            loadScene(e) {
                const t = this.extensions,
                    n = this.json.scenes[e],
                    i = this,
                    r = new Xa;
                n.name && (r.name = i.createUniqueName(n.name)), $S(r, n), n.extensions && _S(t, r, n);
                const o = n.nodes || [],
                    s = [];
                for (let e = 0, t = o.length; e < t; e++) s.push(i.getDependency("node", o[e]));
                return Promise.all(s).then((function(e) {
                    for (let t = 0, n = e.length; t < n; t++) r.add(e[t]);
                    return i.associations = (e => {
                        const t = new Map;
                        for (const [e, n] of i.associations)(e instanceof cr || e instanceof Dn) && t.set(e, n);
                        return e.traverse((e => {
                            const n = i.associations.get(e);
                            null != n && t.set(e, n)
                        })), t
                    })(r), r
                }))
            }
            _createAnimationTracks(e, t, n, i, r) {
                const o = [],
                    s = e.name ? e.name : e.uuid,
                    a = [];
                let l;
                switch (YS[r.path] === YS.weights ? e.traverse((function(e) {
                    e.morphTargetInfluences && a.push(e.name ? e.name : e.uuid)
                })) : a.push(s), YS[r.path]) {
                    case YS.weights:
                        l = _c;
                        break;
                    case YS.rotation:
                        l = eA;
                        break;
                    case YS.position:
                    case YS.scale:
                        l = nA;
                        break;
                    default:
                        if (1 === n.itemSize) l = _c;
                        else l = nA
                }
                const c = void 0 !== i.interpolation ? JS[i.interpolation] : Tt,
                    A = this._getArrayFromAccessor(n);
                for (let e = 0, n = a.length; e < n; e++) {
                    const n = new l(a[e] + "." + YS[r.path], t.array, A, c);
                    "CUBICSPLINE" === i.interpolation && this._createCubicSplineTrackInterpolant(n), o.push(n)
                }
                return o
            }
            _getArrayFromAccessor(e) {
                let t = e.array;
                if (e.normalized) {
                    const e = iv(t.constructor),
                        n = new Float32Array(t.length);
                    for (let i = 0, r = t.length; i < r; i++) n[i] = t[i] * e;
                    t = n
                }
                return t
            }
            _createCubicSplineTrackInterpolant(e) {
                e.createInterpolant = function(e) {
                    return new(this instanceof eA ? GS : KS)(this.times, this.values, this.getValueSize() / 3, e)
                }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0
            }
        }

        function sv(e, t, n) {
            const i = t.attributes,
                r = [];

            function o(t, i) {
                return n.getDependency("accessor", t).then((function(t) {
                    e.setAttribute(i, t)
                }))
            }
            for (const t in i) {
                const n = jS[t] || t.toLowerCase();
                n in e.attributes || r.push(o(i[t], n))
            }
            if (void 0 !== t.indices && !e.index) {
                const i = n.getDependency("accessor", t.indices).then((function(t) {
                    e.setIndex(t)
                }));
                r.push(i)
            }
            return yn.workingColorSpace !== Nt && "COLOR_0" in i && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${yn.workingColorSpace}" not supported.`), $S(e, t),
                function(e, t, n) {
                    const i = t.attributes,
                        r = new qn;
                    if (void 0 === i.POSITION) return; {
                        const e = n.json.accessors[i.POSITION],
                            t = e.min,
                            o = e.max;
                        if (void 0 === t || void 0 === o) return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
                        if (r.set(new On(t[0], t[1], t[2]), new On(o[0], o[1], o[2])), e.normalized) {
                            const t = iv(OS[e.componentType]);
                            r.min.multiplyScalar(t), r.max.multiplyScalar(t)
                        }
                    }
                    const o = t.targets;
                    if (void 0 !== o) {
                        const e = new On,
                            t = new On;
                        for (let i = 0, r = o.length; i < r; i++) {
                            const r = o[i];
                            if (void 0 !== r.POSITION) {
                                const i = n.json.accessors[r.POSITION],
                                    o = i.min,
                                    s = i.max;
                                if (void 0 !== o && void 0 !== s) {
                                    if (t.setX(Math.max(Math.abs(o[0]), Math.abs(s[0]))), t.setY(Math.max(Math.abs(o[1]), Math.abs(s[1]))), t.setZ(Math.max(Math.abs(o[2]), Math.abs(s[2]))), i.normalized) {
                                        const e = iv(OS[i.componentType]);
                                        t.multiplyScalar(e)
                                    }
                                    e.max(t)
                                } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                            }
                        }
                        r.expandByVector(e)
                    }
                    e.boundingBox = r;
                    const s = new li;
                    r.getCenter(s.center), s.radius = r.min.distanceTo(r.max) / 2, e.boundingSphere = s
                }(e, t, n), Promise.all(r).then((function() {
                    return void 0 !== t.targets ? function(e, t, n) {
                        let i = !1,
                            r = !1,
                            o = !1;
                        for (let e = 0, n = t.length; e < n; e++) {
                            const n = t[e];
                            if (void 0 !== n.POSITION && (i = !0), void 0 !== n.NORMAL && (r = !0), void 0 !== n.COLOR_0 && (o = !0), i && r && o) break
                        }
                        if (!i && !r && !o) return Promise.resolve(e);
                        const s = [],
                            a = [],
                            l = [];
                        for (let c = 0, A = t.length; c < A; c++) {
                            const A = t[c];
                            if (i) {
                                const t = void 0 !== A.POSITION ? n.getDependency("accessor", A.POSITION) : e.attributes.position;
                                s.push(t)
                            }
                            if (r) {
                                const t = void 0 !== A.NORMAL ? n.getDependency("accessor", A.NORMAL) : e.attributes.normal;
                                a.push(t)
                            }
                            if (o) {
                                const t = void 0 !== A.COLOR_0 ? n.getDependency("accessor", A.COLOR_0) : e.attributes.color;
                                l.push(t)
                            }
                        }
                        return Promise.all([Promise.all(s), Promise.all(a), Promise.all(l)]).then((function(t) {
                            const n = t[0],
                                s = t[1],
                                a = t[2];
                            return i && (e.morphAttributes.position = n), r && (e.morphAttributes.normal = s), o && (e.morphAttributes.color = a), e.morphTargetsRelative = !0, e
                        }))
                    }(e, t.targets, n) : e
                }))
        }
        class av extends dA {
            constructor(e) {
                super(e), this.type = ct
            }
            parse(e) {
                const t = function(e, t) {
                        switch (e) {
                            case 1:
                                throw new Error("THREE.RGBELoader: Read Error: " + (t || ""));
                            case 2:
                                throw new Error("THREE.RGBELoader: Write Error: " + (t || ""));
                            case 3:
                                throw new Error("THREE.RGBELoader: Bad File Format: " + (t || ""));
                            default:
                                throw new Error("THREE.RGBELoader: Memory Error: " + (t || ""))
                        }
                    },
                    n = function(e, t, n) {
                        t = t || 1024;
                        let i = e.pos,
                            r = -1,
                            o = 0,
                            s = "",
                            a = String.fromCharCode.apply(null, new Uint16Array(e.subarray(i, i + 128)));
                        for (; 0 > (r = a.indexOf("\n")) && o < t && i < e.byteLength;) s += a, o += a.length, i += 128, a += String.fromCharCode.apply(null, new Uint16Array(e.subarray(i, i + 128)));
                        return -1 < r && (!1 !== n && (e.pos += o + r + 1), s + a.slice(0, r))
                    },
                    i = function(e, t, n, i) {
                        const r = e[t + 3],
                            o = Math.pow(2, r - 128) / 255;
                        n[i + 0] = e[t + 0] * o, n[i + 1] = e[t + 1] * o, n[i + 2] = e[t + 2] * o, n[i + 3] = 1
                    },
                    r = function(e, t, n, i) {
                        const r = e[t + 3],
                            o = Math.pow(2, r - 128) / 255;
                        n[i + 0] = gr.toHalfFloat(Math.min(e[t + 0] * o, 65504)), n[i + 1] = gr.toHalfFloat(Math.min(e[t + 1] * o, 65504)), n[i + 2] = gr.toHalfFloat(Math.min(e[t + 2] * o, 65504)), n[i + 3] = gr.toHalfFloat(1)
                    },
                    o = new Uint8Array(e);
                o.pos = 0;
                const s = function(e) {
                        const i = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
                            r = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
                            o = /^\s*FORMAT=(\S+)\s*$/,
                            s = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
                            a = {
                                valid: 0,
                                string: "",
                                comments: "",
                                programtype: "RGBE",
                                format: "",
                                gamma: 1,
                                exposure: 1,
                                width: 0,
                                height: 0
                            };
                        let l, c;
                        for ((e.pos >= e.byteLength || !(l = n(e))) && t(1, "no header found"), (c = l.match(/^#\?(\S+)/)) || t(3, "bad initial token"), a.valid |= 1, a.programtype = c[1], a.string += l + "\n"; l = n(e), !1 !== l;)
                            if (a.string += l + "\n", "#" !== l.charAt(0)) {
                                if ((c = l.match(i)) && (a.gamma = parseFloat(c[1])), (c = l.match(r)) && (a.exposure = parseFloat(c[1])), (c = l.match(o)) && (a.valid |= 2, a.format = c[1]), (c = l.match(s)) && (a.valid |= 4, a.height = parseInt(c[1], 10), a.width = parseInt(c[2], 10)), 2 & a.valid && 4 & a.valid) break
                            } else a.comments += l + "\n";
                        return 2 & a.valid || t(3, "missing format specifier"), 4 & a.valid || t(3, "missing image size specifier"), a
                    }(o),
                    a = s.width,
                    l = s.height,
                    c = function(e, n, i) {
                        const r = n;
                        if (r < 8 || r > 32767 || 2 !== e[0] || 2 !== e[1] || 128 & e[2]) return new Uint8Array(e);
                        r !== (e[2] << 8 | e[3]) && t(3, "wrong scanline width");
                        const o = new Uint8Array(4 * n * i);
                        o.length || t(4, "unable to allocate buffer space");
                        let s = 0,
                            a = 0;
                        const l = 4 * r,
                            c = new Uint8Array(4),
                            A = new Uint8Array(l);
                        let h = i;
                        for (; h > 0 && a < e.byteLength;) {
                            a + 4 > e.byteLength && t(1), c[0] = e[a++], c[1] = e[a++], c[2] = e[a++], c[3] = e[a++], 2 == c[0] && 2 == c[1] && (c[2] << 8 | c[3]) == r || t(3, "bad rgbe scanline format");
                            let n, i = 0;
                            for (; i < l && a < e.byteLength;) {
                                n = e[a++];
                                const r = n > 128;
                                if (r && (n -= 128), (0 === n || i + n > l) && t(3, "bad scanline data"), r) {
                                    const t = e[a++];
                                    for (let e = 0; e < n; e++) A[i++] = t
                                } else A.set(e.subarray(a, a + n), i), i += n, a += n
                            }
                            const u = r;
                            for (let e = 0; e < u; e++) {
                                let t = 0;
                                o[s] = A[e + t], t += r, o[s + 1] = A[e + t], t += r, o[s + 2] = A[e + t], t += r, o[s + 3] = A[e + t], s += 4
                            }
                            h--
                        }
                        return o
                    }(o.subarray(o.pos), a, l);
                let A, h, u;
                switch (this.type) {
                    case lt:
                        u = c.length / 4;
                        const e = new Float32Array(4 * u);
                        for (let t = 0; t < u; t++) i(c, 4 * t, e, 4 * t);
                        A = e, h = lt;
                        break;
                    case ct:
                        u = c.length / 4;
                        const t = new Uint16Array(4 * u);
                        for (let e = 0; e < u; e++) r(c, 4 * e, t, 4 * e);
                        A = t, h = ct;
                        break;
                    default:
                        throw new Error("THREE.RGBELoader: Unsupported type: " + this.type)
                }
                return {
                    width: a,
                    height: l,
                    data: A,
                    header: s.string,
                    gamma: s.gamma,
                    exposure: s.exposure,
                    type: h
                }
            }
            setDataType(e) {
                return this.type = e, this
            }
            load(e, t, n, i) {
                return super.load(e, (function(e, n) {
                    switch (e.type) {
                        case lt:
                        case ct:
                            e.colorSpace = Nt, e.minFilter = nt, e.magFilter = nt, e.generateMipmaps = !1, e.flipY = !0
                    }
                    t && t(e, n)
                }), n, i)
            }
        }
        var lv = Uint8Array,
            cv = Uint16Array,
            Av = Int32Array,
            hv = new lv([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]),
            uv = new lv([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]),
            dv = new lv([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
            pv = function(e, t) {
                for (var n = new cv(31), i = 0; i < 31; ++i) n[i] = t += 1 << e[i - 1];
                var r = new Av(n[30]);
                for (i = 1; i < 30; ++i)
                    for (var o = n[i]; o < n[i + 1]; ++o) r[o] = o - n[i] << 5 | i;
                return {
                    b: n,
                    r
                }
            },
            gv = pv(hv, 2),
            fv = gv.b,
            mv = gv.r;
        fv[28] = 258, mv[258] = 28;
        for (var Ev = pv(uv, 0), Cv = Ev.b, Iv = (Ev.r, new cv(32768)), Sv = 0; Sv < 32768; ++Sv) {
            var vv = (43690 & Sv) >> 1 | (21845 & Sv) << 1;
            vv = (61680 & (vv = (52428 & vv) >> 2 | (13107 & vv) << 2)) >> 4 | (3855 & vv) << 4, Iv[Sv] = ((65280 & vv) >> 8 | (255 & vv) << 8) >> 1
        }
        var Bv = function(e, t, n) {
                for (var i = e.length, r = 0, o = new cv(t); r < i; ++r) e[r] && ++o[e[r] - 1];
                var s, a = new cv(t);
                for (r = 1; r < t; ++r) a[r] = a[r - 1] + o[r - 1] << 1;
                if (n) {
                    s = new cv(1 << t);
                    var l = 15 - t;
                    for (r = 0; r < i; ++r)
                        if (e[r])
                            for (var c = r << 4 | e[r], A = t - e[r], h = a[e[r] - 1]++ << A, u = h | (1 << A) - 1; h <= u; ++h) s[Iv[h] >> l] = c
                } else
                    for (s = new cv(i), r = 0; r < i; ++r) e[r] && (s[r] = Iv[a[e[r] - 1]++] >> 15 - e[r]);
                return s
            },
            xv = new lv(288);
        for (Sv = 0; Sv < 144; ++Sv) xv[Sv] = 8;
        for (Sv = 144; Sv < 256; ++Sv) xv[Sv] = 9;
        for (Sv = 256; Sv < 280; ++Sv) xv[Sv] = 7;
        for (Sv = 280; Sv < 288; ++Sv) xv[Sv] = 8;
        var yv = new lv(32);
        for (Sv = 0; Sv < 32; ++Sv) yv[Sv] = 5;
        var wv = Bv(xv, 9, 1),
            bv = Bv(yv, 5, 1),
            Qv = function(e) {
                for (var t = e[0], n = 1; n < e.length; ++n) e[n] > t && (t = e[n]);
                return t
            },
            Uv = function(e, t, n) {
                var i = t / 8 | 0;
                return (e[i] | e[i + 1] << 8) >> (7 & t) & n
            },
            Mv = function(e, t) {
                var n = t / 8 | 0;
                return (e[n] | e[n + 1] << 8 | e[n + 2] << 16) >> (7 & t)
            },
            Rv = function(e) {
                return (e + 7) / 8 | 0
            },
            Tv = function(e, t, n) {
                return (null == t || t < 0) && (t = 0), (null == n || n > e.length) && (n = e.length), new lv(e.subarray(t, n))
            },
            Fv = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"],
            Dv = function(e, t, n) {
                var i = new Error(t || Fv[e]);
                if (i.code = e, Error.captureStackTrace && Error.captureStackTrace(i, Dv), !n) throw i;
                return i
            },
            kv = function(e, t, n, i) {
                var r = e.length,
                    o = i ? i.length : 0;
                if (!r || t.f && !t.l) return n || new lv(0);
                var s = !n,
                    a = s || 2 != t.i,
                    l = t.i;
                s && (n = new lv(3 * r));
                var c = function(e) {
                        var t = n.length;
                        if (e > t) {
                            var i = new lv(Math.max(2 * t, e));
                            i.set(n), n = i
                        }
                    },
                    A = t.f || 0,
                    h = t.p || 0,
                    u = t.b || 0,
                    d = t.l,
                    p = t.d,
                    g = t.m,
                    f = t.n,
                    m = 8 * r;
                do {
                    if (!d) {
                        A = Uv(e, h, 1);
                        var E = Uv(e, h + 1, 3);
                        if (h += 3, !E) {
                            var C = e[(M = Rv(h) + 4) - 4] | e[M - 3] << 8,
                                I = M + C;
                            if (I > r) {
                                l && Dv(0);
                                break
                            }
                            a && c(u + C), n.set(e.subarray(M, I), u), t.b = u += C, t.p = h = 8 * I, t.f = A;
                            continue
                        }
                        if (1 == E) d = wv, p = bv, g = 9, f = 5;
                        else if (2 == E) {
                            var S = Uv(e, h, 31) + 257,
                                v = Uv(e, h + 10, 15) + 4,
                                B = S + Uv(e, h + 5, 31) + 1;
                            h += 14;
                            for (var x = new lv(B), y = new lv(19), w = 0; w < v; ++w) y[dv[w]] = Uv(e, h + 3 * w, 7);
                            h += 3 * v;
                            var b = Qv(y),
                                Q = (1 << b) - 1,
                                U = Bv(y, b, 1);
                            for (w = 0; w < B;) {
                                var M, R = U[Uv(e, h, Q)];
                                if (h += 15 & R, (M = R >> 4) < 16) x[w++] = M;
                                else {
                                    var T = 0,
                                        F = 0;
                                    for (16 == M ? (F = 3 + Uv(e, h, 3), h += 2, T = x[w - 1]) : 17 == M ? (F = 3 + Uv(e, h, 7), h += 3) : 18 == M && (F = 11 + Uv(e, h, 127), h += 7); F--;) x[w++] = T
                                }
                            }
                            var D = x.subarray(0, S),
                                k = x.subarray(S);
                            g = Qv(D), f = Qv(k), d = Bv(D, g, 1), p = Bv(k, f, 1)
                        } else Dv(1);
                        if (h > m) {
                            l && Dv(0);
                            break
                        }
                    }
                    a && c(u + 131072);
                    for (var L = (1 << g) - 1, K = (1 << f) - 1, P = h;; P = h) {
                        var G = (T = d[Mv(e, h) & L]) >> 4;
                        if ((h += 15 & T) > m) {
                            l && Dv(0);
                            break
                        }
                        if (T || Dv(2), G < 256) n[u++] = G;
                        else {
                            if (256 == G) {
                                P = h, d = null;
                                break
                            }
                            var V = G - 254;
                            if (G > 264) {
                                var O = hv[w = G - 257];
                                V = Uv(e, h, (1 << O) - 1) + fv[w], h += O
                            }
                            var N = p[Mv(e, h) & K],
                                H = N >> 4;
                            N || Dv(3), h += 15 & N;
                            k = Cv[H];
                            if (H > 3) {
                                O = uv[H];
                                k += Mv(e, h) & (1 << O) - 1, h += O
                            }
                            if (h > m) {
                                l && Dv(0);
                                break
                            }
                            a && c(u + 131072);
                            var q = u + V;
                            if (u < k) {
                                var j = o - k,
                                    Y = Math.min(k, q);
                                for (j + u < 0 && Dv(3); u < Y; ++u) n[u] = i[j + u]
                            }
                            for (; u < q; ++u) n[u] = n[u - k]
                        }
                    }
                    t.l = d, t.p = P, t.b = u, t.f = A, d && (A = 1, t.m = g, t.d = p, t.n = f)
                } while (!A);
                return u != n.length && s ? Tv(n, 0, u) : n.subarray(0, u)
            },
            Lv = new lv(0),
            Kv = function(e, t) {
                return (8 != (15 & e[0]) || e[0] >> 4 > 7 || (e[0] << 8 | e[1]) % 31) && Dv(6, "invalid zlib data"), (e[1] >> 5 & 1) == +!t && Dv(6, "invalid zlib data: " + (32 & e[1] ? "need" : "unexpected") + " dictionary"), 2 + (e[1] >> 3 & 4)
            };

        function Pv(e, t) {
            return kv(e.subarray(Kv(e, t && t.dictionary), -4), {
                i: 2
            }, t && t.out, t && t.dictionary)
        }
        var Gv = "undefined" != typeof TextDecoder && new TextDecoder;
        try {
            Gv.decode(Lv, {
                stream: !0
            }), 1
        } catch (e) {}
        "function" == typeof queueMicrotask ? queueMicrotask : "function" == typeof setTimeout && setTimeout;
        class Vv extends dA {
            constructor(e) {
                super(e), this.type = ct
            }
            parse(e) {
                const t = 65536,
                    n = 14,
                    i = 65537,
                    r = 16384,
                    o = Math.pow(2.7182818, 2.2);
                const s = {
                    l: 0,
                    c: 0,
                    lc: 0
                };

                function a(e, t, n, i, r) {
                    for (; n < e;) t = t << 8 | O(i, r), n += 8;
                    n -= e, s.l = t >> n & (1 << e) - 1, s.c = t, s.lc = n
                }
                const l = new Array(59);

                function c(e, t, n, r, o, c) {
                    const A = t;
                    let h = 0,
                        u = 0;
                    for (; r <= o; r++) {
                        if (A.value - t.value > n) return !1;
                        a(6, h, u, e, A);
                        const i = s.l;
                        if (h = s.c, u = s.lc, c[r] = i, 63 == i) {
                            if (A.value - t.value > n) throw new Error("Something wrong with hufUnpackEncTable");
                            a(8, h, u, e, A);
                            let i = s.l + 6;
                            if (h = s.c, u = s.lc, r + i > o + 1) throw new Error("Something wrong with hufUnpackEncTable");
                            for (; i--;) c[r++] = 0;
                            r--
                        } else if (i >= 59) {
                            let e = i - 59 + 2;
                            if (r + e > o + 1) throw new Error("Something wrong with hufUnpackEncTable");
                            for (; e--;) c[r++] = 0;
                            r--
                        }
                    }! function(e) {
                        for (let e = 0; e <= 58; ++e) l[e] = 0;
                        for (let t = 0; t < i; ++t) l[e[t]] += 1;
                        let t = 0;
                        for (let e = 58; e > 0; --e) {
                            const n = t + l[e] >> 1;
                            l[e] = t, t = n
                        }
                        for (let t = 0; t < i; ++t) {
                            const n = e[t];
                            n > 0 && (e[t] = n | l[n]++ << 6)
                        }
                    }(c)
                }

                function A(e) {
                    return 63 & e
                }

                function h(e) {
                    return e >> 6
                }
                const u = {
                    c: 0,
                    lc: 0
                };

                function d(e, t, n, i) {
                    e = e << 8 | O(n, i), t += 8, u.c = e, u.lc = t
                }
                const p = {
                    c: 0,
                    lc: 0
                };

                function g(e, t, n, i, r, o, s, a, l) {
                    if (e == t) {
                        i < 8 && (d(n, i, r, o), n = u.c, i = u.lc);
                        let e = n >> (i -= 8);
                        if (e = new Uint8Array([e])[0], a.value + e > l) return !1;
                        const t = s[a.value - 1];
                        for (; e-- > 0;) s[a.value++] = t
                    } else {
                        if (!(a.value < l)) return !1;
                        s[a.value++] = e
                    }
                    p.c = n, p.lc = i
                }

                function f(e) {
                    return 65535 & e
                }

                function m(e) {
                    const t = f(e);
                    return t > 32767 ? t - 65536 : t
                }
                const E = {
                    a: 0,
                    b: 0
                };

                function C(e, t) {
                    const n = m(e),
                        i = m(t),
                        r = n + (1 & i) + (i >> 1),
                        o = r,
                        s = r - i;
                    E.a = o, E.b = s
                }

                function I(e, t) {
                    const n = f(e),
                        i = f(t),
                        r = n - (i >> 1) & 65535,
                        o = i + r - 32768 & 65535;
                    E.a = o, E.b = r
                }

                function S(e, t, n, i, r, o, s) {
                    const a = s < 16384,
                        l = n > r ? r : n;
                    let c, A, h = 1;
                    for (; h <= l;) h <<= 1;
                    for (h >>= 1, c = h, h >>= 1; h >= 1;) {
                        A = 0;
                        const s = A + o * (r - c),
                            l = o * h,
                            u = o * c,
                            d = i * h,
                            p = i * c;
                        let g, f, m, S;
                        for (; A <= s; A += u) {
                            let r = A;
                            const o = A + i * (n - c);
                            for (; r <= o; r += p) {
                                const n = r + d,
                                    i = r + l,
                                    o = i + d;
                                a ? (C(e[r + t], e[i + t]), g = E.a, m = E.b, C(e[n + t], e[o + t]), f = E.a, S = E.b, C(g, f), e[r + t] = E.a, e[n + t] = E.b, C(m, S), e[i + t] = E.a, e[o + t] = E.b) : (I(e[r + t], e[i + t]), g = E.a, m = E.b, I(e[n + t], e[o + t]), f = E.a, S = E.b, I(g, f), e[r + t] = E.a, e[n + t] = E.b, I(m, S), e[i + t] = E.a, e[o + t] = E.b)
                            }
                            if (n & h) {
                                const n = r + l;
                                a ? C(e[r + t], e[n + t]) : I(e[r + t], e[n + t]), g = E.a, e[n + t] = E.b, e[r + t] = g
                            }
                        }
                        if (r & h) {
                            let r = A;
                            const o = A + i * (n - c);
                            for (; r <= o; r += p) {
                                const n = r + d;
                                a ? C(e[r + t], e[n + t]) : I(e[r + t], e[n + t]), g = E.a, e[n + t] = E.b, e[r + t] = g
                            }
                        }
                        c = h, h >>= 1
                    }
                    return A
                }

                function v(e, t, o, s, a, l) {
                    const f = o.value,
                        m = V(t, o),
                        E = V(t, o);
                    o.value += 4;
                    const C = V(t, o);
                    if (o.value += 4, m < 0 || m >= i || E < 0 || E >= i) throw new Error("Something wrong with HUF_ENCSIZE");
                    const I = new Array(i),
                        S = new Array(r);
                    ! function(e) {
                        for (let t = 0; t < r; t++) e[t] = {}, e[t].len = 0, e[t].lit = 0, e[t].p = null
                    }(S);
                    if (c(e, o, s - (o.value - f), m, E, I), C > 8 * (s - (o.value - f))) throw new Error("Something wrong with hufUncompress");
                    ! function(e, t, i, r) {
                        for (; t <= i; t++) {
                            const i = h(e[t]),
                                o = A(e[t]);
                            if (i >> o) throw new Error("Invalid table entry");
                            if (o > n) {
                                const e = r[i >> o - n];
                                if (e.len) throw new Error("Invalid table entry");
                                if (e.lit++, e.p) {
                                    const t = e.p;
                                    e.p = new Array(e.lit);
                                    for (let n = 0; n < e.lit - 1; ++n) e.p[n] = t[n]
                                } else e.p = new Array(1);
                                e.p[e.lit - 1] = t
                            } else if (o) {
                                let e = 0;
                                for (let s = 1 << n - o; s > 0; s--) {
                                    const s = r[(i << n - o) + e];
                                    if (s.len || s.p) throw new Error("Invalid table entry");
                                    s.len = o, s.lit = t, e++
                                }
                            }
                        }
                    }(I, m, E, S),
                    function(e, t, i, r, o, s, a, l, c) {
                        let f = 0,
                            m = 0;
                        const E = a,
                            C = Math.trunc(r.value + (o + 7) / 8);
                        for (; r.value < C;)
                            for (d(f, m, i, r), f = u.c, m = u.lc; m >= n;) {
                                const o = t[f >> m - n & 16383];
                                if (o.len) m -= o.len, g(o.lit, s, f, m, i, r, l, c, E), f = p.c, m = p.lc;
                                else {
                                    if (!o.p) throw new Error("hufDecode issues");
                                    let t;
                                    for (t = 0; t < o.lit; t++) {
                                        const n = A(e[o.p[t]]);
                                        for (; m < n && r.value < C;) d(f, m, i, r), f = u.c, m = u.lc;
                                        if (m >= n && h(e[o.p[t]]) == (f >> m - n & (1 << n) - 1)) {
                                            m -= n, g(o.p[t], s, f, m, i, r, l, c, E), f = p.c, m = p.lc;
                                            break
                                        }
                                    }
                                    if (t == o.lit) throw new Error("hufDecode issues")
                                }
                            }
                        const I = 8 - o & 7;
                        for (f >>= I, m -= I; m > 0;) {
                            const e = t[f << n - m & 16383];
                            if (!e.len) throw new Error("hufDecode issues");
                            m -= e.len, g(e.lit, s, f, m, i, r, l, c, E), f = p.c, m = p.lc
                        }
                    }(I, S, e, o, C, E, l, a, {
                        value: 0
                    })
                }

                function B(e) {
                    for (let t = 1; t < e.length; t++) {
                        const n = e[t - 1] + e[t] - 128;
                        e[t] = n
                    }
                }

                function x(e, t) {
                    let n = 0,
                        i = Math.floor((e.length + 1) / 2),
                        r = 0;
                    const o = e.length - 1;
                    for (; !(r > o || (t[r++] = e[n++], r > o));) t[r++] = e[i++]
                }

                function y(e) {
                    let t = e.byteLength;
                    const n = new Array;
                    let i = 0;
                    const r = new DataView(e);
                    for (; t > 0;) {
                        const e = r.getInt8(i++);
                        if (e < 0) {
                            const o = -e;
                            t -= o + 1;
                            for (let e = 0; e < o; e++) n.push(r.getUint8(i++))
                        } else {
                            const o = e;
                            t -= 2;
                            const s = r.getUint8(i++);
                            for (let e = 0; e < o + 1; e++) n.push(s)
                        }
                    }
                    return n
                }

                function w(e, t, n) {
                    let i, r = 1;
                    for (; r < 64;) i = t[e.value], 65280 == i ? r = 64 : i >> 8 == 255 ? r += 255 & i : (n[r] = i, r++), e.value++
                }

                function b(e, t) {
                    t[0] = Y(e[0]), t[1] = Y(e[1]), t[2] = Y(e[5]), t[3] = Y(e[6]), t[4] = Y(e[14]), t[5] = Y(e[15]), t[6] = Y(e[27]), t[7] = Y(e[28]), t[8] = Y(e[2]), t[9] = Y(e[4]), t[10] = Y(e[7]), t[11] = Y(e[13]), t[12] = Y(e[16]), t[13] = Y(e[26]), t[14] = Y(e[29]), t[15] = Y(e[42]), t[16] = Y(e[3]), t[17] = Y(e[8]), t[18] = Y(e[12]), t[19] = Y(e[17]), t[20] = Y(e[25]), t[21] = Y(e[30]), t[22] = Y(e[41]), t[23] = Y(e[43]), t[24] = Y(e[9]), t[25] = Y(e[11]), t[26] = Y(e[18]), t[27] = Y(e[24]), t[28] = Y(e[31]), t[29] = Y(e[40]), t[30] = Y(e[44]), t[31] = Y(e[53]), t[32] = Y(e[10]), t[33] = Y(e[19]), t[34] = Y(e[23]), t[35] = Y(e[32]), t[36] = Y(e[39]), t[37] = Y(e[45]), t[38] = Y(e[52]), t[39] = Y(e[54]), t[40] = Y(e[20]), t[41] = Y(e[22]), t[42] = Y(e[33]), t[43] = Y(e[38]), t[44] = Y(e[46]), t[45] = Y(e[51]), t[46] = Y(e[55]), t[47] = Y(e[60]), t[48] = Y(e[21]), t[49] = Y(e[34]), t[50] = Y(e[37]), t[51] = Y(e[47]), t[52] = Y(e[50]), t[53] = Y(e[56]), t[54] = Y(e[59]), t[55] = Y(e[61]), t[56] = Y(e[35]), t[57] = Y(e[36]), t[58] = Y(e[48]), t[59] = Y(e[49]), t[60] = Y(e[57]), t[61] = Y(e[58]), t[62] = Y(e[62]), t[63] = Y(e[63])
                }

                function Q(e) {
                    const t = .5 * Math.cos(.7853975),
                        n = .5 * Math.cos(3.14159 / 16),
                        i = .5 * Math.cos(3.14159 / 8),
                        r = .5 * Math.cos(3 * 3.14159 / 16),
                        o = .5 * Math.cos(.981746875),
                        s = .5 * Math.cos(3 * 3.14159 / 8),
                        a = .5 * Math.cos(1.374445625),
                        l = new Array(4),
                        c = new Array(4),
                        A = new Array(4),
                        h = new Array(4);
                    for (let u = 0; u < 8; ++u) {
                        const d = 8 * u;
                        l[0] = i * e[d + 2], l[1] = s * e[d + 2], l[2] = i * e[d + 6], l[3] = s * e[d + 6], c[0] = n * e[d + 1] + r * e[d + 3] + o * e[d + 5] + a * e[d + 7], c[1] = r * e[d + 1] - a * e[d + 3] - n * e[d + 5] - o * e[d + 7], c[2] = o * e[d + 1] - n * e[d + 3] + a * e[d + 5] + r * e[d + 7], c[3] = a * e[d + 1] - o * e[d + 3] + r * e[d + 5] - n * e[d + 7], A[0] = t * (e[d + 0] + e[d + 4]), A[3] = t * (e[d + 0] - e[d + 4]), A[1] = l[0] + l[3], A[2] = l[1] - l[2], h[0] = A[0] + A[1], h[1] = A[3] + A[2], h[2] = A[3] - A[2], h[3] = A[0] - A[1], e[d + 0] = h[0] + c[0], e[d + 1] = h[1] + c[1], e[d + 2] = h[2] + c[2], e[d + 3] = h[3] + c[3], e[d + 4] = h[3] - c[3], e[d + 5] = h[2] - c[2], e[d + 6] = h[1] - c[1], e[d + 7] = h[0] - c[0]
                    }
                    for (let u = 0; u < 8; ++u) l[0] = i * e[16 + u], l[1] = s * e[16 + u], l[2] = i * e[48 + u], l[3] = s * e[48 + u], c[0] = n * e[8 + u] + r * e[24 + u] + o * e[40 + u] + a * e[56 + u], c[1] = r * e[8 + u] - a * e[24 + u] - n * e[40 + u] - o * e[56 + u], c[2] = o * e[8 + u] - n * e[24 + u] + a * e[40 + u] + r * e[56 + u], c[3] = a * e[8 + u] - o * e[24 + u] + r * e[40 + u] - n * e[56 + u], A[0] = t * (e[u] + e[32 + u]), A[3] = t * (e[u] - e[32 + u]), A[1] = l[0] + l[3], A[2] = l[1] - l[2], h[0] = A[0] + A[1], h[1] = A[3] + A[2], h[2] = A[3] - A[2], h[3] = A[0] - A[1], e[0 + u] = h[0] + c[0], e[8 + u] = h[1] + c[1], e[16 + u] = h[2] + c[2], e[24 + u] = h[3] + c[3], e[32 + u] = h[3] - c[3], e[40 + u] = h[2] - c[2], e[48 + u] = h[1] - c[1], e[56 + u] = h[0] - c[0]
                }

                function U(e) {
                    for (let t = 0; t < 64; ++t) {
                        const n = e[0][t],
                            i = e[1][t],
                            r = e[2][t];
                        e[0][t] = n + 1.5747 * r, e[1][t] = n - .1873 * i - .4682 * r, e[2][t] = n + 1.8556 * i
                    }
                }

                function M(e, t, n) {
                    for (let i = 0; i < 64; ++i) t[n + i] = gr.toHalfFloat(R(e[i]))
                }

                function R(e) {
                    return e <= 1 ? Math.sign(e) * Math.pow(Math.abs(e), 2.2) : Math.sign(e) * Math.pow(o, Math.abs(e) - 1)
                }

                function T(e) {
                    return new DataView(e.array.buffer, e.offset.value, e.size)
                }

                function F(e) {
                    const t = e.viewer.buffer.slice(e.offset.value, e.offset.value + e.size),
                        n = new Uint8Array(y(t)),
                        i = new Uint8Array(n.length);
                    return B(n), x(n, i), new DataView(i.buffer)
                }

                function D(e) {
                    const t = Pv(e.array.slice(e.offset.value, e.offset.value + e.size)),
                        n = new Uint8Array(t.length);
                    return B(t), x(t, n), new DataView(n.buffer)
                }

                function k(e) {
                    const n = e.viewer,
                        i = {
                            value: e.offset.value
                        },
                        r = new Uint16Array(e.columns * e.lines * (e.inputChannels.length * e.type)),
                        o = new Uint8Array(8192);
                    let s = 0;
                    const a = new Array(e.inputChannels.length);
                    for (let t = 0, n = e.inputChannels.length; t < n; t++) a[t] = {}, a[t].start = s, a[t].end = a[t].start, a[t].nx = e.columns, a[t].ny = e.lines, a[t].size = e.type, s += a[t].nx * a[t].ny * a[t].size;
                    const l = J(n, i),
                        c = J(n, i);
                    if (c >= 8192) throw new Error("Something is wrong with PIZ_COMPRESSION BITMAP_SIZE");
                    if (l <= c)
                        for (let e = 0; e < c - l + 1; e++) o[e + l] = N(n, i);
                    const A = new Uint16Array(t),
                        h = function(e, n) {
                            let i = 0;
                            for (let r = 0; r < t; ++r)(0 == r || e[r >> 3] & 1 << (7 & r)) && (n[i++] = r);
                            const r = i - 1;
                            for (; i < t;) n[i++] = 0;
                            return r
                        }(o, A),
                        u = V(n, i);
                    v(e.array, n, i, u, r, s);
                    for (let t = 0; t < e.inputChannels.length; ++t) {
                        const e = a[t];
                        for (let n = 0; n < a[t].size; ++n) S(r, e.start + n, e.nx, e.size, e.ny, e.nx * e.size, h)
                    }! function(e, t, n) {
                        for (let i = 0; i < n; ++i) t[i] = e[t[i]]
                    }(A, r, s);
                    let d = 0;
                    const p = new Uint8Array(r.buffer.byteLength);
                    for (let t = 0; t < e.lines; t++)
                        for (let t = 0; t < e.inputChannels.length; t++) {
                            const e = a[t],
                                n = e.nx * e.size,
                                i = new Uint8Array(r.buffer, 2 * e.end, 2 * n);
                            p.set(i, d), d += 2 * n, e.end += n
                        }
                    return new DataView(p.buffer)
                }

                function L(e) {
                    const t = Pv(e.array.slice(e.offset.value, e.offset.value + e.size)),
                        n = e.inputChannels.length * e.lines * e.columns * e.totalBytes,
                        i = new ArrayBuffer(n),
                        r = new DataView(i);
                    let o = 0,
                        s = 0;
                    const a = new Array(4);
                    for (let n = 0; n < e.lines; n++)
                        for (let n = 0; n < e.inputChannels.length; n++) {
                            let i = 0;
                            switch (e.inputChannels[n].pixelType) {
                                case 1:
                                    a[0] = o, a[1] = a[0] + e.columns, o = a[1] + e.columns;
                                    for (let n = 0; n < e.columns; ++n) {
                                        i += t[a[0]++] << 8 | t[a[1]++], r.setUint16(s, i, !0), s += 2
                                    }
                                    break;
                                case 2:
                                    a[0] = o, a[1] = a[0] + e.columns, a[2] = a[1] + e.columns, o = a[2] + e.columns;
                                    for (let n = 0; n < e.columns; ++n) {
                                        i += t[a[0]++] << 24 | t[a[1]++] << 16 | t[a[2]++] << 8, r.setUint32(s, i, !0), s += 4
                                    }
                            }
                        }
                    return r
                }

                function K(e) {
                    const t = e.viewer,
                        n = {
                            value: e.offset.value
                        },
                        i = new Uint8Array(e.columns * e.lines * (e.inputChannels.length * e.type * 2)),
                        r = {
                            version: H(t, n),
                            unknownUncompressedSize: H(t, n),
                            unknownCompressedSize: H(t, n),
                            acCompressedSize: H(t, n),
                            dcCompressedSize: H(t, n),
                            rleCompressedSize: H(t, n),
                            rleUncompressedSize: H(t, n),
                            rleRawSize: H(t, n),
                            totalAcUncompressedCount: H(t, n),
                            totalDcUncompressedCount: H(t, n),
                            acCompression: H(t, n)
                        };
                    if (r.version < 2) throw new Error("EXRLoader.parse: " + ie.compression + " version " + r.version + " is unsupported");
                    const o = new Array;
                    let s = J(t, n) - 2;
                    for (; s > 0;) {
                        const e = P(t.buffer, n),
                            i = N(t, n),
                            r = i >> 2 & 3,
                            a = new Int8Array([(i >> 4) - 1])[0],
                            l = N(t, n);
                        o.push({
                            name: e,
                            index: a,
                            type: l,
                            compression: r
                        }), s -= e.length + 3
                    }
                    const a = ie.channels,
                        l = new Array(e.inputChannels.length);
                    for (let t = 0; t < e.inputChannels.length; ++t) {
                        const n = l[t] = {},
                            i = a[t];
                        n.name = i.name, n.compression = 0, n.decoded = !1, n.type = i.pixelType, n.pLinear = i.pLinear, n.width = e.columns, n.height = e.lines
                    }
                    const c = {
                        idx: new Array(3)
                    };
                    for (let t = 0; t < e.inputChannels.length; ++t) {
                        const e = l[t];
                        for (let n = 0; n < o.length; ++n) {
                            const i = o[n];
                            e.name == i.name && (e.compression = i.compression, i.index >= 0 && (c.idx[i.index] = t), e.offset = t)
                        }
                    }
                    let A, h, u;
                    if (r.acCompressedSize > 0) switch (r.acCompression) {
                        case 0:
                            A = new Uint16Array(r.totalAcUncompressedCount), v(e.array, t, n, r.acCompressedSize, A, r.totalAcUncompressedCount);
                            break;
                        case 1:
                            const i = Pv(e.array.slice(n.value, n.value + r.totalAcUncompressedCount));
                            A = new Uint16Array(i.buffer), n.value += r.totalAcUncompressedCount
                    }
                    if (r.dcCompressedSize > 0) {
                        const t = {
                            array: e.array,
                            offset: n,
                            size: r.dcCompressedSize
                        };
                        h = new Uint16Array(D(t).buffer), n.value += r.dcCompressedSize
                    }
                    if (r.rleRawSize > 0) {
                        u = y(Pv(e.array.slice(n.value, n.value + r.rleCompressedSize)).buffer), n.value += r.rleCompressedSize
                    }
                    let d = 0;
                    const p = new Array(l.length);
                    for (let e = 0; e < p.length; ++e) p[e] = new Array;
                    for (let t = 0; t < e.lines; ++t)
                        for (let t = 0; t < l.length; ++t) p[t].push(d), d += l[t].width * e.type * 2;
                    ! function(e, t, n, i, r, o) {
                        let s = new DataView(o.buffer);
                        const a = n[e.idx[0]].width,
                            l = n[e.idx[0]].height,
                            c = Math.floor(a / 8),
                            A = Math.ceil(a / 8),
                            h = Math.ceil(l / 8),
                            u = a - 8 * (A - 1),
                            d = l - 8 * (h - 1),
                            p = {
                                value: 0
                            },
                            g = new Array(3),
                            f = new Array(3),
                            m = new Array(3),
                            E = new Array(3),
                            C = new Array(3);
                        for (let n = 0; n < 3; ++n) C[n] = t[e.idx[n]], g[n] = n < 1 ? 0 : g[n - 1] + A * h, f[n] = new Float32Array(64), m[n] = new Uint16Array(64), E[n] = new Uint16Array(64 * A);
                        for (let t = 0; t < h; ++t) {
                            let o = 8;
                            t == h - 1 && (o = d);
                            let a = 8;
                            for (let e = 0; e < A; ++e) {
                                e == A - 1 && (a = u);
                                for (let e = 0; e < 3; ++e) m[e].fill(0), m[e][0] = r[g[e]++], w(p, i, m[e]), b(m[e], f[e]), Q(f[e]);
                                U(f);
                                for (let t = 0; t < 3; ++t) M(f[t], E[t], 64 * e)
                            }
                            let l = 0;
                            for (let i = 0; i < 3; ++i) {
                                const r = n[e.idx[i]].type;
                                for (let e = 8 * t; e < 8 * t + o; ++e) {
                                    l = C[i][e];
                                    for (let t = 0; t < c; ++t) {
                                        const n = 64 * t + 8 * (7 & e);
                                        s.setUint16(l + 0 * r, E[i][n + 0], !0), s.setUint16(l + 2 * r, E[i][n + 1], !0), s.setUint16(l + 4 * r, E[i][n + 2], !0), s.setUint16(l + 6 * r, E[i][n + 3], !0), s.setUint16(l + 8 * r, E[i][n + 4], !0), s.setUint16(l + 10 * r, E[i][n + 5], !0), s.setUint16(l + 12 * r, E[i][n + 6], !0), s.setUint16(l + 14 * r, E[i][n + 7], !0), l += 16 * r
                                    }
                                }
                                if (c != A)
                                    for (let e = 8 * t; e < 8 * t + o; ++e) {
                                        const t = C[i][e] + 8 * c * 2 * r,
                                            n = 64 * c + 8 * (7 & e);
                                        for (let e = 0; e < a; ++e) s.setUint16(t + 2 * e * r, E[i][n + e], !0)
                                    }
                            }
                        }
                        const I = new Uint16Array(a);
                        s = new DataView(o.buffer);
                        for (let t = 0; t < 3; ++t) {
                            n[e.idx[t]].decoded = !0;
                            const i = n[e.idx[t]].type;
                            if (2 == n[t].type)
                                for (let e = 0; e < l; ++e) {
                                    const n = C[t][e];
                                    for (let e = 0; e < a; ++e) I[e] = s.getUint16(n + 2 * e * i, !0);
                                    for (let e = 0; e < a; ++e) s.setFloat32(n + 2 * e * i, Y(I[e]), !0)
                                }
                        }
                    }(c, p, l, A, h, i);
                    for (let t = 0; t < l.length; ++t) {
                        const n = l[t];
                        if (!n.decoded) {
                            if (2 !== n.compression) throw new Error("EXRLoader.parse: unsupported channel compression"); {
                                let r = 0,
                                    o = 0;
                                for (let s = 0; s < e.lines; ++s) {
                                    let e = p[t][r];
                                    for (let t = 0; t < n.width; ++t) {
                                        for (let t = 0; t < 2 * n.type; ++t) i[e++] = u[o + t * n.width * n.height];
                                        o++
                                    }
                                    r++
                                }
                            }
                        }
                    }
                    return new DataView(i.buffer)
                }

                function P(e, t) {
                    const n = new Uint8Array(e);
                    let i = 0;
                    for (; 0 != n[t.value + i];) i += 1;
                    const r = (new TextDecoder).decode(n.slice(t.value, t.value + i));
                    return t.value = t.value + i + 1, r
                }

                function G(e, t) {
                    const n = e.getInt32(t.value, !0);
                    return t.value = t.value + 4, n
                }

                function V(e, t) {
                    const n = e.getUint32(t.value, !0);
                    return t.value = t.value + 4, n
                }

                function O(e, t) {
                    const n = e[t.value];
                    return t.value = t.value + 1, n
                }

                function N(e, t) {
                    const n = e.getUint8(t.value);
                    return t.value = t.value + 1, n
                }
                const H = function(e, t) {
                    let n;
                    return n = "getBigInt64" in DataView.prototype ? Number(e.getBigInt64(t.value, !0)) : e.getUint32(t.value + 4, !0) + Number(e.getUint32(t.value, !0) << 32), t.value += 8, n
                };

                function q(e, t) {
                    const n = e.getFloat32(t.value, !0);
                    return t.value += 4, n
                }

                function j(e, t) {
                    return gr.toHalfFloat(q(e, t))
                }

                function Y(e) {
                    const t = (31744 & e) >> 10,
                        n = 1023 & e;
                    return (e >> 15 ? -1 : 1) * (t ? 31 === t ? n ? NaN : 1 / 0 : Math.pow(2, t - 15) * (1 + n / 1024) : n / 1024 * 6103515625e-14)
                }

                function J(e, t) {
                    const n = e.getUint16(t.value, !0);
                    return t.value += 2, n
                }

                function W(e, t) {
                    return Y(J(e, t))
                }

                function z(e, t, n, i, r) {
                    return "string" === i || "stringvector" === i || "iccProfile" === i ? function(e, t, n) {
                        const i = (new TextDecoder).decode(new Uint8Array(e).slice(t.value, t.value + n));
                        return t.value = t.value + n, i
                    }(t, n, r) : "chlist" === i ? function(e, t, n, i) {
                        const r = n.value,
                            o = [];
                        for (; n.value < r + i - 1;) {
                            const i = P(t, n),
                                r = G(e, n),
                                s = N(e, n);
                            n.value += 3;
                            const a = G(e, n),
                                l = G(e, n);
                            o.push({
                                name: i,
                                pixelType: r,
                                pLinear: s,
                                xSampling: a,
                                ySampling: l
                            })
                        }
                        return n.value += 1, o
                    }(e, t, n, r) : "chromaticities" === i ? function(e, t) {
                        return {
                            redX: q(e, t),
                            redY: q(e, t),
                            greenX: q(e, t),
                            greenY: q(e, t),
                            blueX: q(e, t),
                            blueY: q(e, t),
                            whiteX: q(e, t),
                            whiteY: q(e, t)
                        }
                    }(e, n) : "compression" === i ? function(e, t) {
                        return ["NO_COMPRESSION", "RLE_COMPRESSION", "ZIPS_COMPRESSION", "ZIP_COMPRESSION", "PIZ_COMPRESSION", "PXR24_COMPRESSION", "B44_COMPRESSION", "B44A_COMPRESSION", "DWAA_COMPRESSION", "DWAB_COMPRESSION"][N(e, t)]
                    }(e, n) : "box2i" === i ? function(e, t) {
                        return {
                            xMin: G(e, t),
                            yMin: G(e, t),
                            xMax: G(e, t),
                            yMax: G(e, t)
                        }
                    }(e, n) : "envmap" === i ? function(e, t) {
                        return ["ENVMAP_LATLONG", "ENVMAP_CUBE"][N(e, t)]
                    }(e, n) : "tiledesc" === i ? function(e, t) {
                        const n = V(e, t),
                            i = V(e, t),
                            r = N(e, t);
                        return {
                            xSize: n,
                            ySize: i,
                            levelMode: ["ONE_LEVEL", "MIPMAP_LEVELS", "RIPMAP_LEVELS"][15 & r],
                            roundingMode: ["ROUND_DOWN", "ROUND_UP"][r >> 4]
                        }
                    }(e, n) : "lineOrder" === i ? function(e, t) {
                        return ["INCREASING_Y", "DECREASING_Y", "RANDOM_Y"][N(e, t)]
                    }(e, n) : "float" === i ? q(e, n) : "v2f" === i ? function(e, t) {
                        return [q(e, t), q(e, t)]
                    }(e, n) : "v3f" === i ? function(e, t) {
                        return [q(e, t), q(e, t), q(e, t)]
                    }(e, n) : "int" === i ? G(e, n) : "rational" === i ? function(e, t) {
                        return [G(e, t), V(e, t)]
                    }(e, n) : "timecode" === i ? function(e, t) {
                        return [V(e, t), V(e, t)]
                    }(e, n) : "preview" === i ? (n.value += r, "skipped") : void(n.value += r)
                }

                function X(e, t, n) {
                    let i = 0;
                    switch (e.levelMode) {
                        case "ONE_LEVEL":
                            i = 1;
                            break;
                        case "MIPMAP_LEVELS":
                            i = function(e, t) {
                                const n = Math.log2(e);
                                return "ROUND_DOWN" == t ? Math.floor(n) : Math.ceil(n)
                            }(Math.max(t, n), e.roundingMode) + 1;
                            break;
                        case "RIPMAP_LEVELS":
                            throw new Error("THREE.EXRLoader: RIPMAP_LEVELS tiles currently unsupported.")
                    }
                    return i
                }

                function Z(e, t, n, i) {
                    const r = new Array(e);
                    for (let o = 0; o < e; o++) {
                        const e = 1 << o;
                        let s = t / e | 0;
                        "ROUND_UP" == i && s * e < t && (s += 1);
                        const a = Math.max(s, 1);
                        r[o] = (a + n - 1) / n | 0
                    }
                    return r
                }

                function _() {
                    const e = this,
                        t = e.offset,
                        n = {
                            value: 0
                        };
                    for (let i = 0; i < e.tileCount; i++) {
                        const i = G(e.viewer, t),
                            r = G(e.viewer, t);
                        t.value += 8, e.size = V(e.viewer, t);
                        const o = i * e.blockWidth,
                            s = r * e.blockHeight;
                        e.columns = o + e.blockWidth > e.width ? e.width - o : e.blockWidth, e.lines = s + e.blockHeight > e.height ? e.height - s : e.blockHeight;
                        const a = e.columns * e.totalBytes,
                            l = e.size < e.lines * a ? e.uncompress(e) : T(e);
                        t.value += e.size;
                        for (let t = 0; t < e.lines; t++) {
                            const i = t * e.columns * e.totalBytes;
                            for (let r = 0; r < e.inputChannels.length; r++) {
                                const a = ie.channels[r].name,
                                    c = e.channelByteOffsets[a] * e.columns,
                                    A = e.decodeChannels[a];
                                if (void 0 === A) continue;
                                n.value = i + c;
                                const h = (e.height - (1 + s + t)) * e.outLineWidth;
                                for (let t = 0; t < e.columns; t++) {
                                    const i = h + (t + o) * e.outputChannels + A;
                                    e.byteArray[i] = e.getter(l, n)
                                }
                            }
                        }
                    }
                }

                function $() {
                    const e = this,
                        t = e.offset,
                        n = {
                            value: 0
                        };
                    for (let i = 0; i < e.height / e.blockHeight; i++) {
                        const r = G(e.viewer, t) - ie.dataWindow.yMin;
                        e.size = V(e.viewer, t), e.lines = r + e.blockHeight > e.height ? e.height - r : e.blockHeight;
                        const o = e.columns * e.totalBytes,
                            s = e.size < e.lines * o ? e.uncompress(e) : T(e);
                        t.value += e.size;
                        for (let t = 0; t < e.blockHeight; t++) {
                            const r = i * e.blockHeight,
                                a = t + e.scanOrder(r);
                            if (a >= e.height) continue;
                            const l = t * o,
                                c = (e.height - 1 - a) * e.outLineWidth;
                            for (let t = 0; t < e.inputChannels.length; t++) {
                                const i = ie.channels[t].name,
                                    r = e.channelByteOffsets[i] * e.columns,
                                    o = e.decodeChannels[i];
                                if (void 0 !== o) {
                                    n.value = l + r;
                                    for (let t = 0; t < e.columns; t++) {
                                        const i = c + t * e.outputChannels + o;
                                        e.byteArray[i] = e.getter(s, n)
                                    }
                                }
                            }
                        }
                    }
                }
                const ee = {
                        value: 0
                    },
                    te = new DataView(e),
                    ne = new Uint8Array(e),
                    ie = function(e, t, n) {
                        const i = {};
                        if (20000630 != e.getUint32(0, !0)) throw new Error("THREE.EXRLoader: Provided file doesn't appear to be in OpenEXR format.");
                        i.version = e.getUint8(4);
                        const r = e.getUint8(5);
                        i.spec = {
                            singleTile: !!(2 & r),
                            longName: !!(4 & r),
                            deepFormat: !!(8 & r),
                            multiPart: !!(16 & r)
                        }, n.value = 8;
                        let o = !0;
                        for (; o;) {
                            const r = P(t, n);
                            if (0 == r) o = !1;
                            else {
                                const o = P(t, n),
                                    s = z(e, t, n, o, V(e, n));
                                void 0 === s ? console.warn(`THREE.EXRLoader: Skipped unknown header attribute type '${o}'.`) : i[r] = s
                            }
                        }
                        if (-7 & r) throw console.error("THREE.EXRHeader:", i), new Error("THREE.EXRLoader: Provided file is currently unsupported.");
                        return i
                    }(te, e, ee),
                    re = function(e, t, n, i, r) {
                        const o = {
                            size: 0,
                            viewer: t,
                            array: n,
                            offset: i,
                            width: e.dataWindow.xMax - e.dataWindow.xMin + 1,
                            height: e.dataWindow.yMax - e.dataWindow.yMin + 1,
                            inputChannels: e.channels,
                            channelByteOffsets: {},
                            scanOrder: null,
                            totalBytes: null,
                            columns: null,
                            lines: null,
                            type: null,
                            uncompress: null,
                            getter: null,
                            format: null,
                            colorSpace: Nt
                        };
                        switch (e.compression) {
                            case "NO_COMPRESSION":
                                o.blockHeight = 1, o.uncompress = T;
                                break;
                            case "RLE_COMPRESSION":
                                o.blockHeight = 1, o.uncompress = F;
                                break;
                            case "ZIPS_COMPRESSION":
                                o.blockHeight = 1, o.uncompress = D;
                                break;
                            case "ZIP_COMPRESSION":
                                o.blockHeight = 16, o.uncompress = D;
                                break;
                            case "PIZ_COMPRESSION":
                                o.blockHeight = 32, o.uncompress = k;
                                break;
                            case "PXR24_COMPRESSION":
                                o.blockHeight = 16, o.uncompress = L;
                                break;
                            case "DWAA_COMPRESSION":
                                o.blockHeight = 32, o.uncompress = K;
                                break;
                            case "DWAB_COMPRESSION":
                                o.blockHeight = 256, o.uncompress = K;
                                break;
                            default:
                                throw new Error("EXRLoader.parse: " + e.compression + " is unsupported")
                        }
                        const s = {};
                        for (const t of e.channels) switch (t.name) {
                            case "Y":
                            case "R":
                            case "G":
                            case "B":
                            case "A":
                                s[t.name] = !0, o.type = t.pixelType
                        }
                        let a = !1;
                        if (s.R && s.G && s.B) a = !s.A, o.outputChannels = 4, o.decodeChannels = {
                            R: 0,
                            G: 1,
                            B: 2,
                            A: 3
                        };
                        else {
                            if (!s.Y) throw new Error("EXRLoader.parse: file contains unsupported data channels.");
                            o.outputChannels = 1, o.decodeChannels = {
                                Y: 0
                            }
                        }
                        if (1 == o.type) switch (r) {
                            case lt:
                                o.getter = W;
                                break;
                            case ct:
                                o.getter = J
                        } else {
                            if (2 != o.type) throw new Error("EXRLoader.parse: unsupported pixelType " + o.type + " for " + e.compression + ".");
                            switch (r) {
                                case lt:
                                    o.getter = q;
                                    break;
                                case ct:
                                    o.getter = j
                            }
                        }
                        o.columns = o.width;
                        const l = o.width * o.height * o.outputChannels;
                        switch (r) {
                            case lt:
                                o.byteArray = new Float32Array(l), a && o.byteArray.fill(1, 0, l);
                                break;
                            case ct:
                                o.byteArray = new Uint16Array(l), a && o.byteArray.fill(15360, 0, l);
                                break;
                            default:
                                console.error("THREE.EXRLoader: unsupported type: ", r)
                        }
                        let c = 0;
                        for (const t of e.channels) void 0 !== o.decodeChannels[t.name] && (o.channelByteOffsets[t.name] = c), c += 2 * t.pixelType;
                        if (o.totalBytes = c, o.outLineWidth = o.width * o.outputChannels, "INCREASING_Y" === e.lineOrder ? o.scanOrder = e => e : o.scanOrder = e => o.height - 1 - e, 4 == o.outputChannels ? (o.format = ht, o.colorSpace = Nt) : (o.format = gt, o.colorSpace = Vt), e.spec.singleTile) {
                            o.blockHeight = e.tiles.ySize, o.blockWidth = e.tiles.xSize;
                            const n = X(e.tiles, o.width, o.height),
                                r = Z(n, o.width, e.tiles.xSize, e.tiles.roundingMode),
                                s = Z(n, o.height, e.tiles.ySize, e.tiles.roundingMode);
                            o.tileCount = r[0] * s[0];
                            for (let e = 0; e < n; e++)
                                for (let n = 0; n < s[e]; n++)
                                    for (let n = 0; n < r[e]; n++) H(t, i);
                            o.decode = _.bind(o)
                        } else {
                            o.blockWidth = o.width;
                            const e = Math.ceil(o.height / o.blockHeight);
                            for (let n = 0; n < e; n++) H(t, i);
                            o.decode = $.bind(o)
                        }
                        return o
                    }(ie, te, ne, ee, this.type);
                return re.decode(), {
                    header: ie,
                    width: re.width,
                    height: re.height,
                    data: re.byteArray,
                    format: re.format,
                    colorSpace: re.colorSpace,
                    type: this.type
                }
            }
            setDataType(e) {
                return this.type = e, this
            }
            load(e, t, n, i) {
                return super.load(e, (function(e, n) {
                    e.colorSpace = n.colorSpace, e.minFilter = nt, e.magFilter = nt, e.generateMipmaps = !1, e.flipY = !1, t && t(e, n)
                }), n, i)
            }
        }
        const Ov = /^[og]\s*(.+)?/,
            Nv = /^mtllib /,
            Hv = /^usemtl /,
            qv = /^usemap /,
            jv = /\s+/,
            Yv = new On,
            Jv = new On,
            Wv = new On,
            zv = new On,
            Xv = new On,
            Zv = new sr;

        function _v() {
            const e = {
                objects: [],
                object: {},
                vertices: [],
                normals: [],
                colors: [],
                uvs: [],
                materials: {},
                materialLibraries: [],
                startObject: function(e, t) {
                    if (this.object && !1 === this.object.fromDeclaration) return this.object.name = e, void(this.object.fromDeclaration = !1 !== t);
                    const n = this.object && "function" == typeof this.object.currentMaterial ? this.object.currentMaterial() : void 0;
                    if (this.object && "function" == typeof this.object._finalize && this.object._finalize(!0), this.object = {
                            name: e || "",
                            fromDeclaration: !1 !== t,
                            geometry: {
                                vertices: [],
                                normals: [],
                                colors: [],
                                uvs: [],
                                hasUVIndices: !1
                            },
                            materials: [],
                            smooth: !0,
                            startMaterial: function(e, t) {
                                const n = this._finalize(!1);
                                n && (n.inherited || n.groupCount <= 0) && this.materials.splice(n.index, 1);
                                const i = {
                                    index: this.materials.length,
                                    name: e || "",
                                    mtllib: Array.isArray(t) && t.length > 0 ? t[t.length - 1] : "",
                                    smooth: void 0 !== n ? n.smooth : this.smooth,
                                    groupStart: void 0 !== n ? n.groupEnd : 0,
                                    groupEnd: -1,
                                    groupCount: -1,
                                    inherited: !1,
                                    clone: function(e) {
                                        const t = {
                                            index: "number" == typeof e ? e : this.index,
                                            name: this.name,
                                            mtllib: this.mtllib,
                                            smooth: this.smooth,
                                            groupStart: 0,
                                            groupEnd: -1,
                                            groupCount: -1,
                                            inherited: !1
                                        };
                                        return t.clone = this.clone.bind(t), t
                                    }
                                };
                                return this.materials.push(i), i
                            },
                            currentMaterial: function() {
                                if (this.materials.length > 0) return this.materials[this.materials.length - 1]
                            },
                            _finalize: function(e) {
                                const t = this.currentMaterial();
                                if (t && -1 === t.groupEnd && (t.groupEnd = this.geometry.vertices.length / 3, t.groupCount = t.groupEnd - t.groupStart, t.inherited = !1), e && this.materials.length > 1)
                                    for (let e = this.materials.length - 1; e >= 0; e--) this.materials[e].groupCount <= 0 && this.materials.splice(e, 1);
                                return e && 0 === this.materials.length && this.materials.push({
                                    name: "",
                                    smooth: this.smooth
                                }), t
                            }
                        }, n && n.name && "function" == typeof n.clone) {
                        const e = n.clone(0);
                        e.inherited = !0, this.object.materials.push(e)
                    }
                    this.objects.push(this.object)
                },
                finalize: function() {
                    this.object && "function" == typeof this.object._finalize && this.object._finalize(!0)
                },
                parseVertexIndex: function(e, t) {
                    const n = parseInt(e, 10);
                    return 3 * (n >= 0 ? n - 1 : n + t / 3)
                },
                parseNormalIndex: function(e, t) {
                    const n = parseInt(e, 10);
                    return 3 * (n >= 0 ? n - 1 : n + t / 3)
                },
                parseUVIndex: function(e, t) {
                    const n = parseInt(e, 10);
                    return 2 * (n >= 0 ? n - 1 : n + t / 2)
                },
                addVertex: function(e, t, n) {
                    const i = this.vertices,
                        r = this.object.geometry.vertices;
                    r.push(i[e + 0], i[e + 1], i[e + 2]), r.push(i[t + 0], i[t + 1], i[t + 2]), r.push(i[n + 0], i[n + 1], i[n + 2])
                },
                addVertexPoint: function(e) {
                    const t = this.vertices;
                    this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2])
                },
                addVertexLine: function(e) {
                    const t = this.vertices;
                    this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2])
                },
                addNormal: function(e, t, n) {
                    const i = this.normals,
                        r = this.object.geometry.normals;
                    r.push(i[e + 0], i[e + 1], i[e + 2]), r.push(i[t + 0], i[t + 1], i[t + 2]), r.push(i[n + 0], i[n + 1], i[n + 2])
                },
                addFaceNormal: function(e, t, n) {
                    const i = this.vertices,
                        r = this.object.geometry.normals;
                    Yv.fromArray(i, e), Jv.fromArray(i, t), Wv.fromArray(i, n), Xv.subVectors(Wv, Jv), zv.subVectors(Yv, Jv), Xv.cross(zv), Xv.normalize(), r.push(Xv.x, Xv.y, Xv.z), r.push(Xv.x, Xv.y, Xv.z), r.push(Xv.x, Xv.y, Xv.z)
                },
                addColor: function(e, t, n) {
                    const i = this.colors,
                        r = this.object.geometry.colors;
                    void 0 !== i[e] && r.push(i[e + 0], i[e + 1], i[e + 2]), void 0 !== i[t] && r.push(i[t + 0], i[t + 1], i[t + 2]), void 0 !== i[n] && r.push(i[n + 0], i[n + 1], i[n + 2])
                },
                addUV: function(e, t, n) {
                    const i = this.uvs,
                        r = this.object.geometry.uvs;
                    r.push(i[e + 0], i[e + 1]), r.push(i[t + 0], i[t + 1]), r.push(i[n + 0], i[n + 1])
                },
                addDefaultUV: function() {
                    const e = this.object.geometry.uvs;
                    e.push(0, 0), e.push(0, 0), e.push(0, 0)
                },
                addUVLine: function(e) {
                    const t = this.uvs;
                    this.object.geometry.uvs.push(t[e + 0], t[e + 1])
                },
                addFace: function(e, t, n, i, r, o, s, a, l) {
                    const c = this.vertices.length;
                    let A = this.parseVertexIndex(e, c),
                        h = this.parseVertexIndex(t, c),
                        u = this.parseVertexIndex(n, c);
                    if (this.addVertex(A, h, u), this.addColor(A, h, u), void 0 !== s && "" !== s) {
                        const e = this.normals.length;
                        A = this.parseNormalIndex(s, e), h = this.parseNormalIndex(a, e), u = this.parseNormalIndex(l, e), this.addNormal(A, h, u)
                    } else this.addFaceNormal(A, h, u);
                    if (void 0 !== i && "" !== i) {
                        const e = this.uvs.length;
                        A = this.parseUVIndex(i, e), h = this.parseUVIndex(r, e), u = this.parseUVIndex(o, e), this.addUV(A, h, u), this.object.geometry.hasUVIndices = !0
                    } else this.addDefaultUV()
                },
                addPointGeometry: function(e) {
                    this.object.geometry.type = "Points";
                    const t = this.vertices.length;
                    for (let n = 0, i = e.length; n < i; n++) {
                        const i = this.parseVertexIndex(e[n], t);
                        this.addVertexPoint(i), this.addColor(i)
                    }
                },
                addLineGeometry: function(e, t) {
                    this.object.geometry.type = "Line";
                    const n = this.vertices.length,
                        i = this.uvs.length;
                    for (let t = 0, i = e.length; t < i; t++) this.addVertexLine(this.parseVertexIndex(e[t], n));
                    for (let e = 0, n = t.length; e < n; e++) this.addUVLine(this.parseUVIndex(t[e], i))
                }
            };
            return e.startObject("", !1), e
        }
        class $v extends lA {
            constructor(e) {
                super(e), this.materials = null
            }
            load(e, t, n, i) {
                const r = this,
                    o = new hA(this.manager);
                o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, (function(n) {
                    try {
                        t(r.parse(n))
                    } catch (t) {
                        i ? i(t) : console.error(t), r.manager.itemError(e)
                    }
                }), n, i)
            }
            setMaterials(e) {
                return this.materials = e, this
            }
            parse(e) {
                const t = new _v; - 1 !== e.indexOf("\r\n") && (e = e.replace(/\r\n/g, "\n")), -1 !== e.indexOf("\\\n") && (e = e.replace(/\\\n/g, ""));
                const n = e.split("\n");
                let i = [];
                for (let e = 0, r = n.length; e < r; e++) {
                    const r = n[e].trimStart();
                    if (0 === r.length) continue;
                    const o = r.charAt(0);
                    if ("#" !== o)
                        if ("v" === o) {
                            const e = r.split(jv);
                            switch (e[0]) {
                                case "v":
                                    t.vertices.push(parseFloat(e[1]), parseFloat(e[2]), parseFloat(e[3])), e.length >= 7 ? (Zv.setRGB(parseFloat(e[4]), parseFloat(e[5]), parseFloat(e[6])).convertSRGBToLinear(), t.colors.push(Zv.r, Zv.g, Zv.b)) : t.colors.push(void 0, void 0, void 0);
                                    break;
                                case "vn":
                                    t.normals.push(parseFloat(e[1]), parseFloat(e[2]), parseFloat(e[3]));
                                    break;
                                case "vt":
                                    t.uvs.push(parseFloat(e[1]), parseFloat(e[2]))
                            }
                        } else if ("f" === o) {
                        const e = r.slice(1).trim().split(jv),
                            n = [];
                        for (let t = 0, i = e.length; t < i; t++) {
                            const i = e[t];
                            if (i.length > 0) {
                                const e = i.split("/");
                                n.push(e)
                            }
                        }
                        const i = n[0];
                        for (let e = 1, r = n.length - 1; e < r; e++) {
                            const r = n[e],
                                o = n[e + 1];
                            t.addFace(i[0], r[0], o[0], i[1], r[1], o[1], i[2], r[2], o[2])
                        }
                    } else if ("l" === o) {
                        const e = r.substring(1).trim().split(" ");
                        let n = [];
                        const i = [];
                        if (-1 === r.indexOf("/")) n = e;
                        else
                            for (let t = 0, r = e.length; t < r; t++) {
                                const r = e[t].split("/");
                                "" !== r[0] && n.push(r[0]), "" !== r[1] && i.push(r[1])
                            }
                        t.addLineGeometry(n, i)
                    } else if ("p" === o) {
                        const e = r.slice(1).trim().split(" ");
                        t.addPointGeometry(e)
                    } else if (null !== (i = Ov.exec(r))) {
                        const e = (" " + i[0].slice(1).trim()).slice(1);
                        t.startObject(e)
                    } else if (Hv.test(r)) t.object.startMaterial(r.substring(7).trim(), t.materialLibraries);
                    else if (Nv.test(r)) t.materialLibraries.push(r.substring(7).trim());
                    else if (qv.test(r)) console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');
                    else if ("s" === o) {
                        if (i = r.split(" "), i.length > 1) {
                            const e = i[1].trim().toLowerCase();
                            t.object.smooth = "0" !== e && "off" !== e
                        } else t.object.smooth = !0;
                        const e = t.object.currentMaterial();
                        e && (e.smooth = t.object.smooth)
                    } else {
                        if ("\0" === r) continue;
                        console.warn('THREE.OBJLoader: Unexpected line: "' + r + '"')
                    }
                }
                t.finalize();
                const r = new Xa;
                r.materialLibraries = [].concat(t.materialLibraries);
                if (!0 === !(1 === t.objects.length && 0 === t.objects[0].geometry.vertices.length))
                    for (let e = 0, n = t.objects.length; e < n; e++) {
                        const n = t.objects[e],
                            i = n.geometry,
                            o = n.materials,
                            s = "Line" === i.type,
                            a = "Points" === i.type;
                        let l = !1;
                        if (0 === i.vertices.length) continue;
                        const c = new Ur;
                        c.setAttribute("position", new Sr(i.vertices, 3)), i.normals.length > 0 && c.setAttribute("normal", new Sr(i.normals, 3)), i.colors.length > 0 && (l = !0, c.setAttribute("color", new Sr(i.colors, 3))), !0 === i.hasUVIndices && c.setAttribute("uv", new Sr(i.uvs, 2));
                        const A = [];
                        for (let e = 0, n = o.length; e < n; e++) {
                            const n = o[e],
                                i = n.name + "_" + n.smooth + "_" + l;
                            let r = t.materials[i];
                            if (null !== this.materials)
                                if (r = this.materials.create(n.name), !s || !r || r instanceof kl) {
                                    if (a && r && !(r instanceof zl)) {
                                        const e = new zl({
                                            size: 10,
                                            sizeAttenuation: !1
                                        });
                                        cr.prototype.copy.call(e, r), e.color.copy(r.color), e.map = r.map, r = e
                                    }
                                } else {
                                    const e = new kl;
                                    cr.prototype.copy.call(e, r), e.color.copy(r.color), r = e
                                }
                            void 0 === r && (r = s ? new kl : a ? new zl({
                                size: 1,
                                sizeAttenuation: !1
                            }) : new Pc, r.name = n.name, r.flatShading = !n.smooth, r.vertexColors = l, t.materials[i] = r), A.push(r)
                        }
                        let h;
                        if (A.length > 1) {
                            for (let e = 0, t = o.length; e < t; e++) {
                                const t = o[e];
                                c.addGroup(t.groupStart, t.groupCount, e)
                            }
                            h = s ? new Jl(c, A) : a ? new ec(c, A) : new Jr(c, A)
                        } else h = s ? new Jl(c, A[0]) : a ? new ec(c, A[0]) : new Jr(c, A[0]);
                        h.name = n.name, r.add(h)
                    } else if (t.vertices.length > 0) {
                        const e = new zl({
                                size: 1,
                                sizeAttenuation: !1
                            }),
                            n = new Ur;
                        n.setAttribute("position", new Sr(t.vertices, 3)), t.colors.length > 0 && void 0 !== t.colors[0] && (n.setAttribute("color", new Sr(t.colors, 3)), e.vertexColors = !0);
                        const i = new ec(n, e);
                        r.add(i)
                    }
                return r
            }
        }

        function eB(e, t, n) {
            const i = n.length - e - 1;
            if (t >= n[i]) return i - 1;
            if (t <= n[e]) return e;
            let r = e,
                o = i,
                s = Math.floor((r + o) / 2);
            for (; t < n[s] || t >= n[s + 1];) t < n[s] ? o = s : r = s, s = Math.floor((r + o) / 2);
            return s
        }

        function tB(e, t, n, i) {
            const r = [],
                o = [],
                s = [];
            r[0] = 1;
            for (let a = 1; a <= n; ++a) {
                o[a] = t - i[e + 1 - a], s[a] = i[e + a] - t;
                let n = 0;
                for (let e = 0; e < a; ++e) {
                    const t = s[e + 1],
                        i = o[a - e],
                        l = r[e] / (t + i);
                    r[e] = n + t * l, n = i * l
                }
                r[a] = n
            }
            return r
        }

        function nB(e, t) {
            let n = 1;
            for (let t = 2; t <= e; ++t) n *= t;
            let i = 1;
            for (let e = 2; e <= t; ++e) i *= e;
            for (let n = 2; n <= e - t; ++n) i *= n;
            return n / i
        }

        function iB(e, t, n, i, r) {
            const o = function(e, t, n, i, r) {
                const o = r < e ? r : e,
                    s = [],
                    a = eB(e, i, t),
                    l = function(e, t, n, i, r) {
                        const o = [];
                        for (let e = 0; e <= n; ++e) o[e] = 0;
                        const s = [];
                        for (let e = 0; e <= i; ++e) s[e] = o.slice(0);
                        const a = [];
                        for (let e = 0; e <= n; ++e) a[e] = o.slice(0);
                        a[0][0] = 1;
                        const l = o.slice(0),
                            c = o.slice(0);
                        for (let i = 1; i <= n; ++i) {
                            l[i] = t - r[e + 1 - i], c[i] = r[e + i] - t;
                            let n = 0;
                            for (let e = 0; e < i; ++e) {
                                const t = c[e + 1],
                                    r = l[i - e];
                                a[i][e] = t + r;
                                const o = a[e][i - 1] / a[i][e];
                                a[e][i] = n + t * o, n = r * o
                            }
                            a[i][i] = n
                        }
                        for (let e = 0; e <= n; ++e) s[0][e] = a[e][n];
                        for (let e = 0; e <= n; ++e) {
                            let t = 0,
                                r = 1;
                            const l = [];
                            for (let e = 0; e <= n; ++e) l[e] = o.slice(0);
                            l[0][0] = 1;
                            for (let o = 1; o <= i; ++o) {
                                let i = 0;
                                const c = e - o,
                                    A = n - o;
                                e >= o && (l[r][0] = l[t][0] / a[A + 1][c], i = l[r][0] * a[c][A]);
                                const h = e - 1 <= A ? o - 1 : n - e;
                                for (let e = c >= -1 ? 1 : -c; e <= h; ++e) l[r][e] = (l[t][e] - l[t][e - 1]) / a[A + 1][c + e], i += l[r][e] * a[c + e][A];
                                e <= A && (l[r][o] = -l[t][o - 1] / a[A + 1][e], i += l[r][o] * a[e][A]), s[o][e] = i;
                                const u = t;
                                t = r, r = u
                            }
                        }
                        let A = n;
                        for (let e = 1; e <= i; ++e) {
                            for (let t = 0; t <= n; ++t) s[e][t] *= A;
                            A *= n - e
                        }
                        return s
                    }(a, i, e, o, t),
                    c = [];
                for (let e = 0; e < n.length; ++e) {
                    const t = n[e].clone(),
                        i = t.w;
                    t.x *= i, t.y *= i, t.z *= i, c[e] = t
                }
                for (let t = 0; t <= o; ++t) {
                    const n = c[a - e].clone().multiplyScalar(l[t][0]);
                    for (let i = 1; i <= e; ++i) n.add(c[a - e + i].clone().multiplyScalar(l[t][i]));
                    s[t] = n
                }
                for (let e = o + 1; e <= r + 1; ++e) s[e] = new kn(0, 0, 0);
                return s
            }(e, t, n, i, r);
            return function(e) {
                const t = e.length,
                    n = [],
                    i = [];
                for (let r = 0; r < t; ++r) {
                    const t = e[r];
                    n[r] = new On(t.x, t.y, t.z), i[r] = t.w
                }
                const r = [];
                for (let e = 0; e < t; ++e) {
                    const t = n[e].clone();
                    for (let n = 1; n <= e; ++n) t.sub(r[e - n].clone().multiplyScalar(nB(e, n) * i[n]));
                    r[e] = t.divideScalar(i[0])
                }
                return r
            }(o)
        }
        class rB extends sc {
            constructor(e, t, n, i, r) {
                super(), this.degree = e, this.knots = t, this.controlPoints = [], this.startKnot = i || 0, this.endKnot = r || this.knots.length - 1;
                for (let e = 0; e < n.length; ++e) {
                    const t = n[e];
                    this.controlPoints[e] = new kn(t.x, t.y, t.z, t.w)
                }
            }
            getPoint(e, t = new On) {
                const n = t,
                    i = this.knots[this.startKnot] + e * (this.knots[this.endKnot] - this.knots[this.startKnot]),
                    r = function(e, t, n, i) {
                        const r = eB(e, i, t),
                            o = tB(r, i, e, t),
                            s = new kn(0, 0, 0, 0);
                        for (let t = 0; t <= e; ++t) {
                            const i = n[r - e + t],
                                a = o[t],
                                l = i.w * a;
                            s.x += i.x * l, s.y += i.y * l, s.z += i.z * l, s.w += i.w * a
                        }
                        return s
                    }(this.degree, this.knots, this.controlPoints, i);
                return 1 !== r.w && r.divideScalar(r.w), n.set(r.x, r.y, r.z)
            }
            getTangent(e, t = new On) {
                const n = t,
                    i = this.knots[0] + e * (this.knots[this.knots.length - 1] - this.knots[0]),
                    r = iB(this.degree, this.knots, this.controlPoints, i, 1);
                return n.copy(r[1]).normalize(), n
            }
        }
        let oB, sB, aB;
        class lB extends lA {
            constructor(e) {
                super(e)
            }
            load(e, t, n, i) {
                const r = this,
                    o = "" === r.path ? MA.extractUrlBase(e) : r.path,
                    s = new hA(this.manager);
                s.setPath(r.path), s.setResponseType("arraybuffer"), s.setRequestHeader(r.requestHeader), s.setWithCredentials(r.withCredentials), s.load(e, (function(n) {
                    try {
                        t(r.parse(n, o))
                    } catch (t) {
                        i ? i(t) : console.error(t), r.manager.itemError(e)
                    }
                }), n, i)
            }
            parse(e, t) {
                if (function(e) {
                        const t = "Kaydara FBX Binary  \0";
                        return e.byteLength >= t.length && t === yB(e, 0, t.length)
                    }(e)) oB = (new dB).parse(e);
                else {
                    const t = yB(e);
                    if (! function(e) {
                            const t = ["K", "a", "y", "d", "a", "r", "a", "\\", "F", "B", "X", "\\", "B", "i", "n", "a", "r", "y", "\\", "\\"];
                            let n = 0;

                            function i(t) {
                                const i = e[t - 1];
                                return e = e.slice(n + t), n++, i
                            }
                            for (let e = 0; e < t.length; ++e) {
                                if (i(1) === t[e]) return !1
                            }
                            return !0
                        }(t)) throw new Error("THREE.FBXLoader: Unknown format.");
                    if (fB(t) < 7e3) throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + fB(t));
                    oB = (new uB).parse(t)
                }
                const n = new pA(this.manager).setPath(this.resourcePath || t).setCrossOrigin(this.crossOrigin);
                return new cB(n, this.manager).parse(oB)
            }
        }
        class cB {
            constructor(e, t) {
                this.textureLoader = e, this.manager = t
            }
            parse() {
                sB = this.parseConnections();
                const e = this.parseImages(),
                    t = this.parseTextures(e),
                    n = this.parseMaterials(t),
                    i = this.parseDeformers(),
                    r = (new AB).parse(i);
                return this.parseScene(i, r, n), aB
            }
            parseConnections() {
                const e = new Map;
                if ("Connections" in oB) {
                    oB.Connections.connections.forEach((function(t) {
                        const n = t[0],
                            i = t[1],
                            r = t[2];
                        e.has(n) || e.set(n, {
                            parents: [],
                            children: []
                        });
                        const o = {
                            ID: i,
                            relationship: r
                        };
                        e.get(n).parents.push(o), e.has(i) || e.set(i, {
                            parents: [],
                            children: []
                        });
                        const s = {
                            ID: n,
                            relationship: r
                        };
                        e.get(i).children.push(s)
                    }))
                }
                return e
            }
            parseImages() {
                const e = {},
                    t = {};
                if ("Video" in oB.Objects) {
                    const n = oB.Objects.Video;
                    for (const i in n) {
                        const r = n[i];
                        if (e[parseInt(i)] = r.RelativeFilename || r.Filename, "Content" in r) {
                            const e = r.Content instanceof ArrayBuffer && r.Content.byteLength > 0,
                                o = "string" == typeof r.Content && "" !== r.Content;
                            if (e || o) {
                                const e = this.parseImage(n[i]);
                                t[r.RelativeFilename || r.Filename] = e
                            }
                        }
                    }
                }
                for (const n in e) {
                    const i = e[n];
                    void 0 !== t[i] ? e[n] = t[i] : e[n] = e[n].split("\\").pop()
                }
                return e
            }
            parseImage(e) {
                const t = e.Content,
                    n = e.RelativeFilename || e.Filename,
                    i = n.slice(n.lastIndexOf(".") + 1).toLowerCase();
                let r;
                switch (i) {
                    case "bmp":
                        r = "image/bmp";
                        break;
                    case "jpg":
                    case "jpeg":
                        r = "image/jpeg";
                        break;
                    case "png":
                        r = "image/png";
                        break;
                    case "tif":
                        r = "image/tiff";
                        break;
                    case "tga":
                        null === this.manager.getHandler(".tga") && console.warn("FBXLoader: TGA loader not found, skipping ", n), r = "image/tga";
                        break;
                    default:
                        return void console.warn('FBXLoader: Image type "' + i + '" is not supported.')
                }
                if ("string" == typeof t) return "data:" + r + ";base64," + t; {
                    const e = new Uint8Array(t);
                    return window.URL.createObjectURL(new Blob([e], {
                        type: r
                    }))
                }
            }
            parseTextures(e) {
                const t = new Map;
                if ("Texture" in oB.Objects) {
                    const n = oB.Objects.Texture;
                    for (const i in n) {
                        const r = this.parseTexture(n[i], e);
                        t.set(parseInt(i), r)
                    }
                }
                return t
            }
            parseTexture(e, t) {
                const n = this.loadTexture(e, t);
                n.ID = e.id, n.name = e.attrName;
                const i = e.WrapModeU,
                    r = e.WrapModeV,
                    o = void 0 !== i ? i.value : 0,
                    s = void 0 !== r ? r.value : 0;
                if (n.wrapS = 0 === o ? Xe : Ze, n.wrapT = 0 === s ? Xe : Ze, "Scaling" in e) {
                    const t = e.Scaling.value;
                    n.repeat.x = t[0], n.repeat.y = t[1]
                }
                if ("Translation" in e) {
                    const t = e.Translation.value;
                    n.offset.x = t[0], n.offset.y = t[1]
                }
                return n
            }
            loadTexture(e, t) {
                let n;
                const i = this.textureLoader.path,
                    r = sB.get(e.id).children;
                let o;
                void 0 !== r && r.length > 0 && void 0 !== t[r[0].ID] && (n = t[r[0].ID], 0 !== n.indexOf("blob:") && 0 !== n.indexOf("data:") || this.textureLoader.setPath(void 0));
                const s = e.FileName.slice(-3).toLowerCase();
                if ("tga" === s) {
                    const t = this.manager.getHandler(".tga");
                    null === t ? (console.warn("FBXLoader: TGA loader not found, creating placeholder texture for", e.RelativeFilename), o = new Dn) : (t.setPath(this.textureLoader.path), o = t.load(n))
                } else if ("dds" === s) {
                    const t = this.manager.getHandler(".dds");
                    null === t ? (console.warn("FBXLoader: DDS loader not found, creating placeholder texture for", e.RelativeFilename), o = new Dn) : (t.setPath(this.textureLoader.path), o = t.load(n))
                } else "psd" === s ? (console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for", e.RelativeFilename), o = new Dn) : o = this.textureLoader.load(n);
                return this.textureLoader.setPath(i), o
            }
            parseMaterials(e) {
                const t = new Map;
                if ("Material" in oB.Objects) {
                    const n = oB.Objects.Material;
                    for (const i in n) {
                        const r = this.parseMaterial(n[i], e);
                        null !== r && t.set(parseInt(i), r)
                    }
                }
                return t
            }
            parseMaterial(e, t) {
                const n = e.id,
                    i = e.attrName;
                let r = e.ShadingModel;
                if ("object" == typeof r && (r = r.value), !sB.has(n)) return null;
                const o = this.parseParameters(e, t, n);
                let s;
                switch (r.toLowerCase()) {
                    case "phong":
                        s = new Pc;
                        break;
                    case "lambert":
                        s = new Gc;
                        break;
                    default:
                        console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', r), s = new Pc
                }
                return s.setValues(o), s.name = i, s
            }
            parseParameters(e, t, n) {
                const i = {};
                e.BumpFactor && (i.bumpScale = e.BumpFactor.value), e.Diffuse ? i.color = (new sr).fromArray(e.Diffuse.value).convertSRGBToLinear() : !e.DiffuseColor || "Color" !== e.DiffuseColor.type && "ColorRGB" !== e.DiffuseColor.type || (i.color = (new sr).fromArray(e.DiffuseColor.value).convertSRGBToLinear()), e.DisplacementFactor && (i.displacementScale = e.DisplacementFactor.value), e.Emissive ? i.emissive = (new sr).fromArray(e.Emissive.value).convertSRGBToLinear() : !e.EmissiveColor || "Color" !== e.EmissiveColor.type && "ColorRGB" !== e.EmissiveColor.type || (i.emissive = (new sr).fromArray(e.EmissiveColor.value).convertSRGBToLinear()), e.EmissiveFactor && (i.emissiveIntensity = parseFloat(e.EmissiveFactor.value)), e.Opacity && (i.opacity = parseFloat(e.Opacity.value)), i.opacity < 1 && (i.transparent = !0), e.ReflectionFactor && (i.reflectivity = e.ReflectionFactor.value), e.Shininess && (i.shininess = e.Shininess.value), e.Specular ? i.specular = (new sr).fromArray(e.Specular.value).convertSRGBToLinear() : e.SpecularColor && "Color" === e.SpecularColor.type && (i.specular = (new sr).fromArray(e.SpecularColor.value).convertSRGBToLinear());
                const r = this;
                return sB.get(n).children.forEach((function(e) {
                    const n = e.relationship;
                    switch (n) {
                        case "Bump":
                            i.bumpMap = r.getTexture(t, e.ID);
                            break;
                        case "Maya|TEX_ao_map":
                            i.aoMap = r.getTexture(t, e.ID);
                            break;
                        case "DiffuseColor":
                        case "Maya|TEX_color_map":
                            i.map = r.getTexture(t, e.ID), void 0 !== i.map && (i.map.colorSpace = Ot);
                            break;
                        case "DisplacementColor":
                            i.displacementMap = r.getTexture(t, e.ID);
                            break;
                        case "EmissiveColor":
                            i.emissiveMap = r.getTexture(t, e.ID), void 0 !== i.emissiveMap && (i.emissiveMap.colorSpace = Ot);
                            break;
                        case "NormalMap":
                        case "Maya|TEX_normal_map":
                            i.normalMap = r.getTexture(t, e.ID);
                            break;
                        case "ReflectionColor":
                            i.envMap = r.getTexture(t, e.ID), void 0 !== i.envMap && (i.envMap.mapping = Je, i.envMap.colorSpace = Ot);
                            break;
                        case "SpecularColor":
                            i.specularMap = r.getTexture(t, e.ID), void 0 !== i.specularMap && (i.specularMap.colorSpace = Ot);
                            break;
                        case "TransparentColor":
                        case "TransparencyFactor":
                            i.alphaMap = r.getTexture(t, e.ID), i.transparent = !0;
                            break;
                        default:
                            console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.", n)
                    }
                })), i
            }
            getTexture(e, t) {
                return "LayeredTexture" in oB.Objects && t in oB.Objects.LayeredTexture && (console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."), t = sB.get(t).children[0].ID), e.get(t)
            }
            parseDeformers() {
                const e = {},
                    t = {};
                if ("Deformer" in oB.Objects) {
                    const n = oB.Objects.Deformer;
                    for (const i in n) {
                        const r = n[i],
                            o = sB.get(parseInt(i));
                        if ("Skin" === r.attrType) {
                            const t = this.parseSkeleton(o, n);
                            t.ID = i, o.parents.length > 1 && console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."), t.geometryID = o.parents[0].ID, e[i] = t
                        } else if ("BlendShape" === r.attrType) {
                            const e = {
                                id: i
                            };
                            e.rawTargets = this.parseMorphTargets(o, n), e.id = i, o.parents.length > 1 && console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."), t[i] = e
                        }
                    }
                }
                return {
                    skeletons: e,
                    morphTargets: t
                }
            }
            parseSkeleton(e, t) {
                const n = [];
                return e.children.forEach((function(e) {
                    const i = t[e.ID];
                    if ("Cluster" !== i.attrType) return;
                    const r = {
                        ID: e.ID,
                        indices: [],
                        weights: [],
                        transformLink: (new mi).fromArray(i.TransformLink.a)
                    };
                    "Indexes" in i && (r.indices = i.Indexes.a, r.weights = i.Weights.a), n.push(r)
                })), {
                    rawBones: n,
                    bones: []
                }
            }
            parseMorphTargets(e, t) {
                const n = [];
                for (let i = 0; i < e.children.length; i++) {
                    const r = e.children[i],
                        o = t[r.ID],
                        s = {
                            name: o.attrName,
                            initialWeight: o.DeformPercent,
                            id: o.id,
                            fullWeights: o.FullWeights.a
                        };
                    if ("BlendShapeChannel" !== o.attrType) return;
                    s.geoID = sB.get(parseInt(r.ID)).children.filter((function(e) {
                        return void 0 === e.relationship
                    }))[0].ID, n.push(s)
                }
                return n
            }
            parseScene(e, t, n) {
                aB = new Xa;
                const i = this.parseModels(e.skeletons, t, n),
                    r = oB.Objects.Model,
                    o = this;
                i.forEach((function(e) {
                    const t = r[e.ID];
                    o.setLookAtProperties(e, t);
                    sB.get(e.ID).parents.forEach((function(t) {
                        const n = i.get(t.ID);
                        void 0 !== n && n.add(e)
                    })), null === e.parent && aB.add(e)
                })), this.bindSkeleton(e.skeletons, t, i), this.addGlobalSceneSettings(), aB.traverse((function(e) {
                    if (e.userData.transformData) {
                        e.parent && (e.userData.transformData.parentMatrix = e.parent.matrix, e.userData.transformData.parentMatrixWorld = e.parent.matrixWorld);
                        const t = vB(e.userData.transformData);
                        e.applyMatrix4(t), e.updateWorldMatrix()
                    }
                }));
                const s = (new hB).parse();
                1 === aB.children.length && aB.children[0].isGroup && (aB.children[0].animations = s, aB = aB.children[0]), aB.animations = s
            }
            parseModels(e, t, n) {
                const i = new Map,
                    r = oB.Objects.Model;
                for (const o in r) {
                    const s = parseInt(o),
                        a = r[o],
                        l = sB.get(s);
                    let c = this.buildSkeleton(l, e, s, a.attrName);
                    if (!c) {
                        switch (a.attrType) {
                            case "Camera":
                                c = this.createCamera(l);
                                break;
                            case "Light":
                                c = this.createLight(l);
                                break;
                            case "Mesh":
                                c = this.createMesh(l, t, n);
                                break;
                            case "NurbsCurve":
                                c = this.createCurve(l, t);
                                break;
                            case "LimbNode":
                            case "Root":
                                c = new Sl;
                                break;
                            default:
                                c = new Xa
                        }
                        c.name = a.attrName ? OA.sanitizeNodeName(a.attrName) : "", c.userData.originalName = a.attrName, c.ID = s
                    }
                    this.getTransformData(c, a), i.set(s, c)
                }
                return i
            }
            buildSkeleton(e, t, n, i) {
                let r = null;
                return e.parents.forEach((function(e) {
                    for (const o in t) {
                        const s = t[o];
                        s.rawBones.forEach((function(t, o) {
                            if (t.ID === e.ID) {
                                const e = r;
                                r = new Sl, r.matrixWorld.copy(t.transformLink), r.name = i ? OA.sanitizeNodeName(i) : "", r.userData.originalName = i, r.ID = n, s.bones[o] = r, null !== e && r.add(e)
                            }
                        }))
                    }
                })), r
            }
            createCamera(e) {
                let t, n;
                if (e.children.forEach((function(e) {
                        const t = oB.Objects.NodeAttribute[e.ID];
                        void 0 !== t && (n = t)
                    })), void 0 === n) t = new qi;
                else {
                    let e = 0;
                    void 0 !== n.CameraProjectionType && 1 === n.CameraProjectionType.value && (e = 1);
                    let i = 1;
                    void 0 !== n.NearPlane && (i = n.NearPlane.value / 1e3);
                    let r = 1e3;
                    void 0 !== n.FarPlane && (r = n.FarPlane.value / 1e3);
                    let o = window.innerWidth,
                        s = window.innerHeight;
                    void 0 !== n.AspectWidth && void 0 !== n.AspectHeight && (o = n.AspectWidth.value, s = n.AspectHeight.value);
                    const a = o / s;
                    let l = 45;
                    void 0 !== n.FieldOfView && (l = n.FieldOfView.value);
                    const c = n.FocalLength ? n.FocalLength.value : null;
                    switch (e) {
                        case 0:
                            t = new oo(l, a, i, r), null !== c && t.setFocalLength(c);
                            break;
                        case 1:
                            t = new Fo(-o / 2, o / 2, s / 2, -s / 2, i, r);
                            break;
                        default:
                            console.warn("THREE.FBXLoader: Unknown camera type " + e + "."), t = new qi
                    }
                }
                return t
            }
            createLight(e) {
                let t, n;
                if (e.children.forEach((function(e) {
                        const t = oB.Objects.NodeAttribute[e.ID];
                        void 0 !== t && (n = t)
                    })), void 0 === n) t = new qi;
                else {
                    let e;
                    e = void 0 === n.LightType ? 0 : n.LightType.value;
                    let i = 16777215;
                    void 0 !== n.Color && (i = (new sr).fromArray(n.Color.value).convertSRGBToLinear());
                    let r = void 0 === n.Intensity ? 1 : n.Intensity.value / 100;
                    void 0 !== n.CastLightOnObject && 0 === n.CastLightOnObject.value && (r = 0);
                    let o = 0;
                    void 0 !== n.FarAttenuationEnd && (o = void 0 !== n.EnableFarAttenuation && 0 === n.EnableFarAttenuation.value ? 0 : n.FarAttenuationEnd.value);
                    const s = 1;
                    switch (e) {
                        case 0:
                            t = new wA(i, r, o, s);
                            break;
                        case 1:
                            t = new QA(i, r);
                            break;
                        case 2:
                            let e = Math.PI / 3;
                            void 0 !== n.InnerAngle && (e = un.degToRad(n.InnerAngle.value));
                            let a = 0;
                            void 0 !== n.OuterAngle && (a = un.degToRad(n.OuterAngle.value), a = Math.max(a, 1)), t = new SA(i, r, o, e, a, s);
                            break;
                        default:
                            console.warn("THREE.FBXLoader: Unknown light type " + n.LightType.value + ", defaulting to a PointLight."), t = new wA(i, r)
                    }
                    void 0 !== n.CastShadows && 1 === n.CastShadows.value && (t.castShadow = !0)
                }
                return t
            }
            createMesh(e, t, n) {
                let i, r = null,
                    o = null;
                const s = [];
                return e.children.forEach((function(e) {
                    t.has(e.ID) && (r = t.get(e.ID)), n.has(e.ID) && s.push(n.get(e.ID))
                })), s.length > 1 ? o = s : s.length > 0 ? o = s[0] : (o = new Pc({
                    name: lA.DEFAULT_MATERIAL_NAME,
                    color: 13421772
                }), s.push(o)), "color" in r.attributes && s.forEach((function(e) {
                    e.vertexColors = !0
                })), r.FBX_Deformer ? (i = new Il(r, o), i.normalizeSkinWeights()) : i = new Jr(r, o), i
            }
            createCurve(e, t) {
                const n = e.children.reduce((function(e, n) {
                        return t.has(n.ID) && (e = t.get(n.ID)), e
                    }), null),
                    i = new kl({
                        name: lA.DEFAULT_MATERIAL_NAME,
                        color: 3342591,
                        linewidth: 1
                    });
                return new Hl(n, i)
            }
            getTransformData(e, t) {
                const n = {};
                "InheritType" in t && (n.inheritType = parseInt(t.InheritType.value)), n.eulerOrder = "RotationOrder" in t ? BB(t.RotationOrder.value) : "ZYX", "Lcl_Translation" in t && (n.translation = t.Lcl_Translation.value), "PreRotation" in t && (n.preRotation = t.PreRotation.value), "Lcl_Rotation" in t && (n.rotation = t.Lcl_Rotation.value), "PostRotation" in t && (n.postRotation = t.PostRotation.value), "Lcl_Scaling" in t && (n.scale = t.Lcl_Scaling.value), "ScalingOffset" in t && (n.scalingOffset = t.ScalingOffset.value), "ScalingPivot" in t && (n.scalingPivot = t.ScalingPivot.value), "RotationOffset" in t && (n.rotationOffset = t.RotationOffset.value), "RotationPivot" in t && (n.rotationPivot = t.RotationPivot.value), e.userData.transformData = n
            }
            setLookAtProperties(e, t) {
                if ("LookAtProperty" in t) {
                    sB.get(e.ID).children.forEach((function(t) {
                        if ("LookAtProperty" === t.relationship) {
                            const n = oB.Objects.Model[t.ID];
                            if ("Lcl_Translation" in n) {
                                const t = n.Lcl_Translation.value;
                                void 0 !== e.target ? (e.target.position.fromArray(t), aB.add(e.target)) : e.lookAt((new On).fromArray(t))
                            }
                        }
                    }))
                }
            }
            bindSkeleton(e, t, n) {
                const i = this.parsePoseNodes();
                for (const r in e) {
                    const o = e[r];
                    sB.get(parseInt(o.ID)).parents.forEach((function(e) {
                        if (t.has(e.ID)) {
                            const t = e.ID;
                            sB.get(t).parents.forEach((function(e) {
                                if (n.has(e.ID)) {
                                    n.get(e.ID).bind(new yl(o.bones), i[e.ID])
                                }
                            }))
                        }
                    }))
                }
            }
            parsePoseNodes() {
                const e = {};
                if ("Pose" in oB.Objects) {
                    const t = oB.Objects.Pose;
                    for (const n in t)
                        if ("BindPose" === t[n].attrType && t[n].NbPoseNodes > 0) {
                            const i = t[n].PoseNode;
                            Array.isArray(i) ? i.forEach((function(t) {
                                e[t.Node] = (new mi).fromArray(t.Matrix.a)
                            })) : e[i.Node] = (new mi).fromArray(i.Matrix.a)
                        }
                }
                return e
            }
            addGlobalSceneSettings() {
                if ("GlobalSettings" in oB) {
                    if ("AmbientColor" in oB.GlobalSettings) {
                        const e = oB.GlobalSettings.AmbientColor.value,
                            t = e[0],
                            n = e[1],
                            i = e[2];
                        if (0 !== t || 0 !== n || 0 !== i) {
                            const e = new sr(t, n, i).convertSRGBToLinear();
                            aB.add(new UA(e, 1))
                        }
                    }
                    "UnitScaleFactor" in oB.GlobalSettings && (aB.userData.unitScaleFactor = oB.GlobalSettings.UnitScaleFactor.value)
                }
            }
        }
        class AB {
            constructor() {
                this.negativeMaterialIndices = !1
            }
            parse(e) {
                const t = new Map;
                if ("Geometry" in oB.Objects) {
                    const n = oB.Objects.Geometry;
                    for (const i in n) {
                        const r = sB.get(parseInt(i)),
                            o = this.parseGeometry(r, n[i], e);
                        t.set(parseInt(i), o)
                    }
                }
                return !0 === this.negativeMaterialIndices && console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected."), t
            }
            parseGeometry(e, t, n) {
                switch (t.attrType) {
                    case "Mesh":
                        return this.parseMeshGeometry(e, t, n);
                    case "NurbsCurve":
                        return this.parseNurbsGeometry(t)
                }
            }
            parseMeshGeometry(e, t, n) {
                const i = n.skeletons,
                    r = [],
                    o = e.parents.map((function(e) {
                        return oB.Objects.Model[e.ID]
                    }));
                if (0 === o.length) return;
                const s = e.children.reduce((function(e, t) {
                    return void 0 !== i[t.ID] && (e = i[t.ID]), e
                }), null);
                e.children.forEach((function(e) {
                    void 0 !== n.morphTargets[e.ID] && r.push(n.morphTargets[e.ID])
                }));
                const a = o[0],
                    l = {};
                "RotationOrder" in a && (l.eulerOrder = BB(a.RotationOrder.value)), "InheritType" in a && (l.inheritType = parseInt(a.InheritType.value)), "GeometricTranslation" in a && (l.translation = a.GeometricTranslation.value), "GeometricRotation" in a && (l.rotation = a.GeometricRotation.value), "GeometricScaling" in a && (l.scale = a.GeometricScaling.value);
                const c = vB(l);
                return this.genGeometry(t, s, r, c)
            }
            genGeometry(e, t, n, i) {
                const r = new Ur;
                e.attrName && (r.name = e.attrName);
                const o = this.parseGeoNode(e, t),
                    s = this.genBuffers(o),
                    a = new Sr(s.vertex, 3);
                if (a.applyMatrix4(i), r.setAttribute("position", a), s.colors.length > 0 && r.setAttribute("color", new Sr(s.colors, 3)), t && (r.setAttribute("skinIndex", new Cr(s.weightsIndices, 4)), r.setAttribute("skinWeight", new Sr(s.vertexWeights, 4)), r.FBX_Deformer = t), s.normal.length > 0) {
                    const e = (new pn).getNormalMatrix(i),
                        t = new Sr(s.normal, 3);
                    t.applyNormalMatrix(e), r.setAttribute("normal", t)
                }
                if (s.uvs.forEach((function(e, t) {
                        const n = 0 === t ? "uv" : `uv${t}`;
                        r.setAttribute(n, new Sr(s.uvs[t], 2))
                    })), o.material && "AllSame" !== o.material.mappingType) {
                    let e = s.materialIndex[0],
                        t = 0;
                    if (s.materialIndex.forEach((function(n, i) {
                            n !== e && (r.addGroup(t, i - t, e), e = n, t = i)
                        })), r.groups.length > 0) {
                        const t = r.groups[r.groups.length - 1],
                            n = t.start + t.count;
                        n !== s.materialIndex.length && r.addGroup(n, s.materialIndex.length - n, e)
                    }
                    0 === r.groups.length && r.addGroup(0, s.materialIndex.length, s.materialIndex[0])
                }
                return this.addMorphTargets(r, e, n, i), r
            }
            parseGeoNode(e, t) {
                const n = {};
                if (n.vertexPositions = void 0 !== e.Vertices ? e.Vertices.a : [], n.vertexIndices = void 0 !== e.PolygonVertexIndex ? e.PolygonVertexIndex.a : [], e.LayerElementColor && (n.color = this.parseVertexColors(e.LayerElementColor[0])), e.LayerElementMaterial && (n.material = this.parseMaterialIndices(e.LayerElementMaterial[0])), e.LayerElementNormal && (n.normal = this.parseNormals(e.LayerElementNormal[0])), e.LayerElementUV) {
                    n.uv = [];
                    let t = 0;
                    for (; e.LayerElementUV[t];) e.LayerElementUV[t].UV && n.uv.push(this.parseUVs(e.LayerElementUV[t])), t++
                }
                return n.weightTable = {}, null !== t && (n.skeleton = t, t.rawBones.forEach((function(e, t) {
                    e.indices.forEach((function(i, r) {
                        void 0 === n.weightTable[i] && (n.weightTable[i] = []), n.weightTable[i].push({
                            id: t,
                            weight: e.weights[r]
                        })
                    }))
                }))), n
            }
            genBuffers(e) {
                const t = {
                    vertex: [],
                    normal: [],
                    colors: [],
                    uvs: [],
                    materialIndex: [],
                    vertexWeights: [],
                    weightsIndices: []
                };
                let n = 0,
                    i = 0,
                    r = !1,
                    o = [],
                    s = [],
                    a = [],
                    l = [],
                    c = [],
                    A = [];
                const h = this;
                return e.vertexIndices.forEach((function(u, d) {
                    let p, g = !1;
                    u < 0 && (u = ~u, g = !0);
                    let f = [],
                        m = [];
                    if (o.push(3 * u, 3 * u + 1, 3 * u + 2), e.color) {
                        const t = CB(d, n, u, e.color);
                        a.push(t[0], t[1], t[2])
                    }
                    if (e.skeleton) {
                        if (void 0 !== e.weightTable[u] && e.weightTable[u].forEach((function(e) {
                                m.push(e.weight), f.push(e.id)
                            })), m.length > 4) {
                            r || (console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."), r = !0);
                            const e = [0, 0, 0, 0],
                                t = [0, 0, 0, 0];
                            m.forEach((function(n, i) {
                                let r = n,
                                    o = f[i];
                                t.forEach((function(t, n, i) {
                                    if (r > t) {
                                        i[n] = r, r = t;
                                        const s = e[n];
                                        e[n] = o, o = s
                                    }
                                }))
                            })), f = e, m = t
                        }
                        for (; m.length < 4;) m.push(0), f.push(0);
                        for (let e = 0; e < 4; ++e) c.push(m[e]), A.push(f[e])
                    }
                    if (e.normal) {
                        const t = CB(d, n, u, e.normal);
                        s.push(t[0], t[1], t[2])
                    }
                    e.material && "AllSame" !== e.material.mappingType && (p = CB(d, n, u, e.material)[0], p < 0 && (h.negativeMaterialIndices = !0, p = 0)), e.uv && e.uv.forEach((function(e, t) {
                        const i = CB(d, n, u, e);
                        void 0 === l[t] && (l[t] = []), l[t].push(i[0]), l[t].push(i[1])
                    })), i++, g && (h.genFace(t, e, o, p, s, a, l, c, A, i), n++, i = 0, o = [], s = [], a = [], l = [], c = [], A = [])
                })), t
            }
            getNormalNewell(e) {
                const t = new On(0, 0, 0);
                for (let n = 0; n < e.length; n++) {
                    const i = e[n],
                        r = e[(n + 1) % e.length];
                    t.x += (i.y - r.y) * (i.z + r.z), t.y += (i.z - r.z) * (i.x + r.x), t.z += (i.x - r.x) * (i.y + r.y)
                }
                return t.normalize(), t
            }
            getNormalTangentAndBitangent(e) {
                const t = this.getNormalNewell(e),
                    n = (Math.abs(t.z) > .5 ? new On(0, 1, 0) : new On(0, 0, 1)).cross(t).normalize(),
                    i = t.clone().cross(n).normalize();
                return {
                    normal: t,
                    tangent: n,
                    bitangent: i
                }
            }
            flattenVertex(e, t, n) {
                return new dn(e.dot(t), e.dot(n))
            }
            genFace(e, t, n, i, r, o, s, a, l, c) {
                let A;
                if (c > 3) {
                    const e = [];
                    for (let i = 0; i < n.length; i += 3) e.push(new On(t.vertexPositions[n[i]], t.vertexPositions[n[i + 1]], t.vertexPositions[n[i + 2]]));
                    const {
                        tangent: i,
                        bitangent: r
                    } = this.getNormalTangentAndBitangent(e), o = [];
                    for (const t of e) o.push(this.flattenVertex(t, i, r));
                    A = Tc.triangulateShape(o, [])
                } else A = [
                    [0, 1, 2]
                ];
                for (const [c, h, u] of A) e.vertex.push(t.vertexPositions[n[3 * c]]), e.vertex.push(t.vertexPositions[n[3 * c + 1]]), e.vertex.push(t.vertexPositions[n[3 * c + 2]]), e.vertex.push(t.vertexPositions[n[3 * h]]), e.vertex.push(t.vertexPositions[n[3 * h + 1]]), e.vertex.push(t.vertexPositions[n[3 * h + 2]]), e.vertex.push(t.vertexPositions[n[3 * u]]), e.vertex.push(t.vertexPositions[n[3 * u + 1]]), e.vertex.push(t.vertexPositions[n[3 * u + 2]]), t.skeleton && (e.vertexWeights.push(a[4 * c]), e.vertexWeights.push(a[4 * c + 1]), e.vertexWeights.push(a[4 * c + 2]), e.vertexWeights.push(a[4 * c + 3]), e.vertexWeights.push(a[4 * h]), e.vertexWeights.push(a[4 * h + 1]), e.vertexWeights.push(a[4 * h + 2]), e.vertexWeights.push(a[4 * h + 3]), e.vertexWeights.push(a[4 * u]), e.vertexWeights.push(a[4 * u + 1]), e.vertexWeights.push(a[4 * u + 2]), e.vertexWeights.push(a[4 * u + 3]), e.weightsIndices.push(l[4 * c]), e.weightsIndices.push(l[4 * c + 1]), e.weightsIndices.push(l[4 * c + 2]), e.weightsIndices.push(l[4 * c + 3]), e.weightsIndices.push(l[4 * h]), e.weightsIndices.push(l[4 * h + 1]), e.weightsIndices.push(l[4 * h + 2]), e.weightsIndices.push(l[4 * h + 3]), e.weightsIndices.push(l[4 * u]), e.weightsIndices.push(l[4 * u + 1]), e.weightsIndices.push(l[4 * u + 2]), e.weightsIndices.push(l[4 * u + 3])), t.color && (e.colors.push(o[3 * c]), e.colors.push(o[3 * c + 1]), e.colors.push(o[3 * c + 2]), e.colors.push(o[3 * h]), e.colors.push(o[3 * h + 1]), e.colors.push(o[3 * h + 2]), e.colors.push(o[3 * u]), e.colors.push(o[3 * u + 1]), e.colors.push(o[3 * u + 2])), t.material && "AllSame" !== t.material.mappingType && (e.materialIndex.push(i), e.materialIndex.push(i), e.materialIndex.push(i)), t.normal && (e.normal.push(r[3 * c]), e.normal.push(r[3 * c + 1]), e.normal.push(r[3 * c + 2]), e.normal.push(r[3 * h]), e.normal.push(r[3 * h + 1]), e.normal.push(r[3 * h + 2]), e.normal.push(r[3 * u]), e.normal.push(r[3 * u + 1]), e.normal.push(r[3 * u + 2])), t.uv && t.uv.forEach((function(t, n) {
                    void 0 === e.uvs[n] && (e.uvs[n] = []), e.uvs[n].push(s[n][2 * c]), e.uvs[n].push(s[n][2 * c + 1]), e.uvs[n].push(s[n][2 * h]), e.uvs[n].push(s[n][2 * h + 1]), e.uvs[n].push(s[n][2 * u]), e.uvs[n].push(s[n][2 * u + 1])
                }))
            }
            addMorphTargets(e, t, n, i) {
                if (0 === n.length) return;
                e.morphTargetsRelative = !0, e.morphAttributes.position = [];
                const r = this;
                n.forEach((function(n) {
                    n.rawTargets.forEach((function(n) {
                        const o = oB.Objects.Geometry[n.geoID];
                        void 0 !== o && r.genMorphGeometry(e, t, o, i, n.name)
                    }))
                }))
            }
            genMorphGeometry(e, t, n, i, r) {
                const o = void 0 !== t.PolygonVertexIndex ? t.PolygonVertexIndex.a : [],
                    s = void 0 !== n.Vertices ? n.Vertices.a : [],
                    a = void 0 !== n.Indexes ? n.Indexes.a : [],
                    l = 3 * e.attributes.position.count,
                    c = new Float32Array(l);
                for (let e = 0; e < a.length; e++) {
                    const t = 3 * a[e];
                    c[t] = s[3 * e], c[t + 1] = s[3 * e + 1], c[t + 2] = s[3 * e + 2]
                }
                const A = {
                        vertexIndices: o,
                        vertexPositions: c
                    },
                    h = this.genBuffers(A),
                    u = new Sr(h.vertex, 3);
                u.name = r || n.attrName, u.applyMatrix4(i), e.morphAttributes.position.push(u)
            }
            parseNormals(e) {
                const t = e.MappingInformationType,
                    n = e.ReferenceInformationType,
                    i = e.Normals.a;
                let r = [];
                return "IndexToDirect" === n && ("NormalIndex" in e ? r = e.NormalIndex.a : "NormalsIndex" in e && (r = e.NormalsIndex.a)), {
                    dataSize: 3,
                    buffer: i,
                    indices: r,
                    mappingType: t,
                    referenceType: n
                }
            }
            parseUVs(e) {
                const t = e.MappingInformationType,
                    n = e.ReferenceInformationType,
                    i = e.UV.a;
                let r = [];
                return "IndexToDirect" === n && (r = e.UVIndex.a), {
                    dataSize: 2,
                    buffer: i,
                    indices: r,
                    mappingType: t,
                    referenceType: n
                }
            }
            parseVertexColors(e) {
                const t = e.MappingInformationType,
                    n = e.ReferenceInformationType,
                    i = e.Colors.a;
                let r = [];
                "IndexToDirect" === n && (r = e.ColorIndex.a);
                for (let e = 0, t = new sr; e < i.length; e += 4) t.fromArray(i, e).convertSRGBToLinear().toArray(i, e);
                return {
                    dataSize: 4,
                    buffer: i,
                    indices: r,
                    mappingType: t,
                    referenceType: n
                }
            }
            parseMaterialIndices(e) {
                const t = e.MappingInformationType,
                    n = e.ReferenceInformationType;
                if ("NoMappingInformation" === t) return {
                    dataSize: 1,
                    buffer: [0],
                    indices: [0],
                    mappingType: "AllSame",
                    referenceType: n
                };
                const i = e.Materials.a,
                    r = [];
                for (let e = 0; e < i.length; ++e) r.push(e);
                return {
                    dataSize: 1,
                    buffer: i,
                    indices: r,
                    mappingType: t,
                    referenceType: n
                }
            }
            parseNurbsGeometry(e) {
                const t = parseInt(e.Order);
                if (isNaN(t)) return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s", e.Order, e.id), new Ur;
                const n = t - 1,
                    i = e.KnotVector.a,
                    r = [],
                    o = e.Points.a;
                for (let e = 0, t = o.length; e < t; e += 4) r.push((new kn).fromArray(o, e));
                let s, a;
                if ("Closed" === e.Form) r.push(r[0]);
                else if ("Periodic" === e.Form) {
                    s = n, a = i.length - 1 - s;
                    for (let e = 0; e < n; ++e) r.push(r[e])
                }
                const l = new rB(n, i, r, s, a).getPoints(12 * r.length);
                return (new Ur).setFromPoints(l)
            }
        }
        class hB {
            parse() {
                const e = [],
                    t = this.parseClips();
                if (void 0 !== t)
                    for (const n in t) {
                        const i = t[n],
                            r = this.addClip(i);
                        e.push(r)
                    }
                return e
            }
            parseClips() {
                if (void 0 === oB.Objects.AnimationCurve) return;
                const e = this.parseAnimationCurveNodes();
                this.parseAnimationCurves(e);
                const t = this.parseAnimationLayers(e);
                return this.parseAnimStacks(t)
            }
            parseAnimationCurveNodes() {
                const e = oB.Objects.AnimationCurveNode,
                    t = new Map;
                for (const n in e) {
                    const i = e[n];
                    if (null !== i.attrName.match(/S|R|T|DeformPercent/)) {
                        const e = {
                            id: i.id,
                            attr: i.attrName,
                            curves: {}
                        };
                        t.set(e.id, e)
                    }
                }
                return t
            }
            parseAnimationCurves(e) {
                const t = oB.Objects.AnimationCurve;
                for (const n in t) {
                    const i = {
                            id: t[n].id,
                            times: t[n].KeyTime.a.map(mB),
                            values: t[n].KeyValueFloat.a
                        },
                        r = sB.get(i.id);
                    if (void 0 !== r) {
                        const t = r.parents[0].ID,
                            n = r.parents[0].relationship;
                        n.match(/X/) ? e.get(t).curves.x = i : n.match(/Y/) ? e.get(t).curves.y = i : n.match(/Z/) ? e.get(t).curves.z = i : n.match(/DeformPercent/) && e.has(t) && (e.get(t).curves.morph = i)
                    }
                }
            }
            parseAnimationLayers(e) {
                const t = oB.Objects.AnimationLayer,
                    n = new Map;
                for (const i in t) {
                    const t = [],
                        r = sB.get(parseInt(i));
                    if (void 0 !== r) {
                        r.children.forEach((function(n, i) {
                            if (e.has(n.ID)) {
                                const r = e.get(n.ID);
                                if (void 0 !== r.curves.x || void 0 !== r.curves.y || void 0 !== r.curves.z) {
                                    if (void 0 === t[i]) {
                                        const e = sB.get(n.ID).parents.filter((function(e) {
                                            return void 0 !== e.relationship
                                        }))[0].ID;
                                        if (void 0 !== e) {
                                            const r = oB.Objects.Model[e.toString()];
                                            if (void 0 === r) return void console.warn("THREE.FBXLoader: Encountered a unused curve.", n);
                                            const o = {
                                                modelName: r.attrName ? OA.sanitizeNodeName(r.attrName) : "",
                                                ID: r.id,
                                                initialPosition: [0, 0, 0],
                                                initialRotation: [0, 0, 0],
                                                initialScale: [1, 1, 1]
                                            };
                                            aB.traverse((function(e) {
                                                e.ID === r.id && (o.transform = e.matrix, e.userData.transformData && (o.eulerOrder = e.userData.transformData.eulerOrder))
                                            })), o.transform || (o.transform = new mi), "PreRotation" in r && (o.preRotation = r.PreRotation.value), "PostRotation" in r && (o.postRotation = r.PostRotation.value), t[i] = o
                                        }
                                    }
                                    t[i] && (t[i][r.attr] = r)
                                } else if (void 0 !== r.curves.morph) {
                                    if (void 0 === t[i]) {
                                        const e = sB.get(n.ID).parents.filter((function(e) {
                                                return void 0 !== e.relationship
                                            }))[0].ID,
                                            r = sB.get(e).parents[0].ID,
                                            o = sB.get(r).parents[0].ID,
                                            s = sB.get(o).parents[0].ID,
                                            a = oB.Objects.Model[s],
                                            l = {
                                                modelName: a.attrName ? OA.sanitizeNodeName(a.attrName) : "",
                                                morphName: oB.Objects.Deformer[e].attrName
                                            };
                                        t[i] = l
                                    }
                                    t[i][r.attr] = r
                                }
                            }
                        })), n.set(parseInt(i), t)
                    }
                }
                return n
            }
            parseAnimStacks(e) {
                const t = oB.Objects.AnimationStack,
                    n = {};
                for (const i in t) {
                    const r = sB.get(parseInt(i)).children;
                    r.length > 1 && console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");
                    const o = e.get(r[0].ID);
                    n[i] = {
                        name: t[i].attrName,
                        layer: o
                    }
                }
                return n
            }
            addClip(e) {
                let t = [];
                const n = this;
                return e.layer.forEach((function(e) {
                    t = t.concat(n.generateTracks(e))
                })), new iA(e.name, -1, t)
            }
            generateTracks(e) {
                const t = [];
                let n = new On,
                    i = new On;
                if (e.transform && e.transform.decompose(n, new Vn, i), n = n.toArray(), i = i.toArray(), void 0 !== e.T && Object.keys(e.T.curves).length > 0) {
                    const i = this.generateVectorTrack(e.modelName, e.T.curves, n, "position");
                    void 0 !== i && t.push(i)
                }
                if (void 0 !== e.R && Object.keys(e.R.curves).length > 0) {
                    const n = this.generateRotationTrack(e.modelName, e.R.curves, e.preRotation, e.postRotation, e.eulerOrder);
                    void 0 !== n && t.push(n)
                }
                if (void 0 !== e.S && Object.keys(e.S.curves).length > 0) {
                    const n = this.generateVectorTrack(e.modelName, e.S.curves, i, "scale");
                    void 0 !== n && t.push(n)
                }
                if (void 0 !== e.DeformPercent) {
                    const n = this.generateMorphTrack(e);
                    void 0 !== n && t.push(n)
                }
                return t
            }
            generateVectorTrack(e, t, n, i) {
                const r = this.getTimesForAllAxes(t),
                    o = this.getKeyframeTrackValues(r, t, n);
                return new nA(e + "." + i, r, o)
            }
            generateRotationTrack(e, t, n, i, r) {
                let o, s;
                if (void 0 !== t.x && void 0 !== t.y && void 0 !== t.z) {
                    const e = this.interpolateRotations(t.x, t.y, t.z, r);
                    o = e[0], s = e[1]
                }
                void 0 !== n && ((n = n.map(un.degToRad)).push(r), n = (new bi).fromArray(n), n = (new Vn).setFromEuler(n)), void 0 !== i && ((i = i.map(un.degToRad)).push(r), i = (new bi).fromArray(i), i = (new Vn).setFromEuler(i).invert());
                const a = new Vn,
                    l = new bi,
                    c = [];
                if (!s || !o) return new eA(e + ".quaternion", [0], [0]);
                for (let e = 0; e < s.length; e += 3) {
                    if (l.set(s[e], s[e + 1], s[e + 2], r), a.setFromEuler(l), void 0 !== n && a.premultiply(n), void 0 !== i && a.multiply(i), e > 2) {
                        (new Vn).fromArray(c, (e - 3) / 3 * 4).dot(a) < 0 && a.set(-a.x, -a.y, -a.z, -a.w)
                    }
                    a.toArray(c, e / 3 * 4)
                }
                return new eA(e + ".quaternion", o, c)
            }
            generateMorphTrack(e) {
                const t = e.DeformPercent.curves.morph,
                    n = t.values.map((function(e) {
                        return e / 100
                    })),
                    i = aB.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];
                return new _c(e.modelName + ".morphTargetInfluences[" + i + "]", t.times, n)
            }
            getTimesForAllAxes(e) {
                let t = [];
                if (void 0 !== e.x && (t = t.concat(e.x.times)), void 0 !== e.y && (t = t.concat(e.y.times)), void 0 !== e.z && (t = t.concat(e.z.times)), t = t.sort((function(e, t) {
                        return e - t
                    })), t.length > 1) {
                    let e = 1,
                        n = t[0];
                    for (let i = 1; i < t.length; i++) {
                        const r = t[i];
                        r !== n && (t[e] = r, n = r, e++)
                    }
                    t = t.slice(0, e)
                }
                return t
            }
            getKeyframeTrackValues(e, t, n) {
                const i = n,
                    r = [];
                let o = -1,
                    s = -1,
                    a = -1;
                return e.forEach((function(e) {
                    if (t.x && (o = t.x.times.indexOf(e)), t.y && (s = t.y.times.indexOf(e)), t.z && (a = t.z.times.indexOf(e)), -1 !== o) {
                        const e = t.x.values[o];
                        r.push(e), i[0] = e
                    } else r.push(i[0]);
                    if (-1 !== s) {
                        const e = t.y.values[s];
                        r.push(e), i[1] = e
                    } else r.push(i[1]);
                    if (-1 !== a) {
                        const e = t.z.values[a];
                        r.push(e), i[2] = e
                    } else r.push(i[2])
                })), r
            }
            interpolateRotations(e, t, n, i) {
                const r = [],
                    o = [];
                r.push(e.times[0]), o.push(un.degToRad(e.values[0])), o.push(un.degToRad(t.values[0])), o.push(un.degToRad(n.values[0]));
                for (let s = 1; s < e.values.length; s++) {
                    const a = [e.values[s - 1], t.values[s - 1], n.values[s - 1]];
                    if (isNaN(a[0]) || isNaN(a[1]) || isNaN(a[2])) continue;
                    const l = a.map(un.degToRad),
                        c = [e.values[s], t.values[s], n.values[s]];
                    if (isNaN(c[0]) || isNaN(c[1]) || isNaN(c[2])) continue;
                    const A = c.map(un.degToRad),
                        h = [c[0] - a[0], c[1] - a[1], c[2] - a[2]],
                        u = [Math.abs(h[0]), Math.abs(h[1]), Math.abs(h[2])];
                    if (u[0] >= 180 || u[1] >= 180 || u[2] >= 180) {
                        const t = Math.max(...u) / 180,
                            n = new bi(...l, i),
                            a = new bi(...A, i),
                            c = (new Vn).setFromEuler(n),
                            h = (new Vn).setFromEuler(a);
                        c.dot(h) && h.set(-h.x, -h.y, -h.z, -h.w);
                        const d = e.times[s - 1],
                            p = e.times[s] - d,
                            g = new Vn,
                            f = new bi;
                        for (let e = 0; e < 1; e += 1 / t) g.copy(c.clone().slerp(h.clone(), e)), r.push(d + e * p), f.setFromQuaternion(g, i), o.push(f.x), o.push(f.y), o.push(f.z)
                    } else r.push(e.times[s]), o.push(un.degToRad(e.values[s])), o.push(un.degToRad(t.values[s])), o.push(un.degToRad(n.values[s]))
                }
                return [r, o]
            }
        }
        class uB {
            getPrevNode() {
                return this.nodeStack[this.currentIndent - 2]
            }
            getCurrentNode() {
                return this.nodeStack[this.currentIndent - 1]
            }
            getCurrentProp() {
                return this.currentProp
            }
            pushStack(e) {
                this.nodeStack.push(e), this.currentIndent += 1
            }
            popStack() {
                this.nodeStack.pop(), this.currentIndent -= 1
            }
            setCurrentProp(e, t) {
                this.currentProp = e, this.currentPropName = t
            }
            parse(e) {
                this.currentIndent = 0, this.allNodes = new gB, this.nodeStack = [], this.currentProp = [], this.currentPropName = "";
                const t = this,
                    n = e.split(/[\r\n]+/);
                return n.forEach((function(e, i) {
                    const r = e.match(/^[\s\t]*;/),
                        o = e.match(/^[\s\t]*$/);
                    if (r || o) return;
                    const s = e.match("^\\t{" + t.currentIndent + "}(\\w+):(.*){", ""),
                        a = e.match("^\\t{" + t.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"),
                        l = e.match("^\\t{" + (t.currentIndent - 1) + "}}");
                    s ? t.parseNodeBegin(e, s) : a ? t.parseNodeProperty(e, a, n[++i]) : l ? t.popStack() : e.match(/^[^\s\t}]/) && t.parseNodePropertyContinued(e)
                })), this.allNodes
            }
            parseNodeBegin(e, t) {
                const n = t[1].trim().replace(/^"/, "").replace(/"$/, ""),
                    i = t[2].split(",").map((function(e) {
                        return e.trim().replace(/^"/, "").replace(/"$/, "")
                    })),
                    r = {
                        name: n
                    },
                    o = this.parseNodeAttr(i),
                    s = this.getCurrentNode();
                0 === this.currentIndent ? this.allNodes.add(n, r) : n in s ? ("PoseNode" === n ? s.PoseNode.push(r) : void 0 !== s[n].id && (s[n] = {}, s[n][s[n].id] = s[n]), "" !== o.id && (s[n][o.id] = r)) : "number" == typeof o.id ? (s[n] = {}, s[n][o.id] = r) : "Properties70" !== n && (s[n] = "PoseNode" === n ? [r] : r), "number" == typeof o.id && (r.id = o.id), "" !== o.name && (r.attrName = o.name), "" !== o.type && (r.attrType = o.type), this.pushStack(r)
            }
            parseNodeAttr(e) {
                let t = e[0];
                "" !== e[0] && (t = parseInt(e[0]), isNaN(t) && (t = e[0]));
                let n = "",
                    i = "";
                return e.length > 1 && (n = e[1].replace(/^(\w+)::/, ""), i = e[2]), {
                    id: t,
                    name: n,
                    type: i
                }
            }
            parseNodeProperty(e, t, n) {
                let i = t[1].replace(/^"/, "").replace(/"$/, "").trim(),
                    r = t[2].replace(/^"/, "").replace(/"$/, "").trim();
                "Content" === i && "," === r && (r = n.replace(/"/g, "").replace(/,$/, "").trim());
                const o = this.getCurrentNode();
                if ("Properties70" !== o.name) {
                    if ("C" === i) {
                        const e = r.split(",").slice(1),
                            t = parseInt(e[0]),
                            n = parseInt(e[1]);
                        let s = r.split(",").slice(3);
                        s = s.map((function(e) {
                                return e.trim().replace(/^"/, "")
                            })), i = "connections", r = [t, n],
                            function(e, t) {
                                for (let n = 0, i = e.length, r = t.length; n < r; n++, i++) e[i] = t[n]
                            }(r, s), void 0 === o[i] && (o[i] = [])
                    }
                    "Node" === i && (o.id = r), i in o && Array.isArray(o[i]) ? o[i].push(r) : "a" !== i ? o[i] = r : o.a = r, this.setCurrentProp(o, i), "a" === i && "," !== r.slice(-1) && (o.a = xB(r))
                } else this.parseNodeSpecialProperty(e, i, r)
            }
            parseNodePropertyContinued(e) {
                const t = this.getCurrentNode();
                t.a += e, "," !== e.slice(-1) && (t.a = xB(t.a))
            }
            parseNodeSpecialProperty(e, t, n) {
                const i = n.split('",').map((function(e) {
                        return e.trim().replace(/^\"/, "").replace(/\s/, "_")
                    })),
                    r = i[0],
                    o = i[1],
                    s = i[2],
                    a = i[3];
                let l = i[4];
                switch (o) {
                    case "int":
                    case "enum":
                    case "bool":
                    case "ULongLong":
                    case "double":
                    case "Number":
                    case "FieldOfView":
                        l = parseFloat(l);
                        break;
                    case "Color":
                    case "ColorRGB":
                    case "Vector3D":
                    case "Lcl_Translation":
                    case "Lcl_Rotation":
                    case "Lcl_Scaling":
                        l = xB(l)
                }
                this.getPrevNode()[r] = {
                    type: o,
                    type2: s,
                    flag: a,
                    value: l
                }, this.setCurrentProp(this.getPrevNode(), r)
            }
        }
        class dB {
            parse(e) {
                const t = new pB(e);
                t.skip(23);
                const n = t.getUint32();
                if (n < 6400) throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: " + n);
                const i = new gB;
                for (; !this.endOfContent(t);) {
                    const e = this.parseNode(t, n);
                    null !== e && i.add(e.name, e)
                }
                return i
            }
            endOfContent(e) {
                return e.size() % 16 == 0 ? (e.getOffset() + 160 + 16 & -16) >= e.size() : e.getOffset() + 160 + 16 >= e.size()
            }
            parseNode(e, t) {
                const n = {},
                    i = t >= 7500 ? e.getUint64() : e.getUint32(),
                    r = t >= 7500 ? e.getUint64() : e.getUint32();
                t >= 7500 ? e.getUint64() : e.getUint32();
                const o = e.getUint8(),
                    s = e.getString(o);
                if (0 === i) return null;
                const a = [];
                for (let t = 0; t < r; t++) a.push(this.parseProperty(e));
                const l = a.length > 0 ? a[0] : "",
                    c = a.length > 1 ? a[1] : "",
                    A = a.length > 2 ? a[2] : "";
                for (n.singleProperty = 1 === r && e.getOffset() === i; i > e.getOffset();) {
                    const i = this.parseNode(e, t);
                    null !== i && this.parseSubNode(s, n, i)
                }
                return n.propertyList = a, "number" == typeof l && (n.id = l), "" !== c && (n.attrName = c), "" !== A && (n.attrType = A), "" !== s && (n.name = s), n
            }
            parseSubNode(e, t, n) {
                if (!0 === n.singleProperty) {
                    const e = n.propertyList[0];
                    Array.isArray(e) ? (t[n.name] = n, n.a = e) : t[n.name] = e
                } else if ("Connections" === e && "C" === n.name) {
                    const e = [];
                    n.propertyList.forEach((function(t, n) {
                        0 !== n && e.push(t)
                    })), void 0 === t.connections && (t.connections = []), t.connections.push(e)
                } else if ("Properties70" === n.name) {
                    Object.keys(n).forEach((function(e) {
                        t[e] = n[e]
                    }))
                } else if ("Properties70" === e && "P" === n.name) {
                    let e = n.propertyList[0],
                        i = n.propertyList[1];
                    const r = n.propertyList[2],
                        o = n.propertyList[3];
                    let s;
                    0 === e.indexOf("Lcl ") && (e = e.replace("Lcl ", "Lcl_")), 0 === i.indexOf("Lcl ") && (i = i.replace("Lcl ", "Lcl_")), s = "Color" === i || "ColorRGB" === i || "Vector" === i || "Vector3D" === i || 0 === i.indexOf("Lcl_") ? [n.propertyList[4], n.propertyList[5], n.propertyList[6]] : n.propertyList[4], t[e] = {
                        type: i,
                        type2: r,
                        flag: o,
                        value: s
                    }
                } else void 0 === t[n.name] ? "number" == typeof n.id ? (t[n.name] = {}, t[n.name][n.id] = n) : t[n.name] = n : "PoseNode" === n.name ? (Array.isArray(t[n.name]) || (t[n.name] = [t[n.name]]), t[n.name].push(n)) : void 0 === t[n.name][n.id] && (t[n.name][n.id] = n)
            }
            parseProperty(e) {
                const t = e.getString(1);
                let n;
                switch (t) {
                    case "C":
                        return e.getBoolean();
                    case "D":
                        return e.getFloat64();
                    case "F":
                        return e.getFloat32();
                    case "I":
                        return e.getInt32();
                    case "L":
                        return e.getInt64();
                    case "R":
                        return n = e.getUint32(), e.getArrayBuffer(n);
                    case "S":
                        return n = e.getUint32(), e.getString(n);
                    case "Y":
                        return e.getInt16();
                    case "b":
                    case "c":
                    case "d":
                    case "f":
                    case "i":
                    case "l":
                        const i = e.getUint32(),
                            r = e.getUint32(),
                            o = e.getUint32();
                        if (0 === r) switch (t) {
                            case "b":
                            case "c":
                                return e.getBooleanArray(i);
                            case "d":
                                return e.getFloat64Array(i);
                            case "f":
                                return e.getFloat32Array(i);
                            case "i":
                                return e.getInt32Array(i);
                            case "l":
                                return e.getInt64Array(i)
                        }
                        const s = Pv(new Uint8Array(e.getArrayBuffer(o))),
                            a = new pB(s.buffer);
                        switch (t) {
                            case "b":
                            case "c":
                                return a.getBooleanArray(i);
                            case "d":
                                return a.getFloat64Array(i);
                            case "f":
                                return a.getFloat32Array(i);
                            case "i":
                                return a.getInt32Array(i);
                            case "l":
                                return a.getInt64Array(i)
                        }
                        break;
                    default:
                        throw new Error("THREE.FBXLoader: Unknown property type " + t)
                }
            }
        }
        class pB {
            constructor(e, t) {
                this.dv = new DataView(e), this.offset = 0, this.littleEndian = void 0 === t || t, this._textDecoder = new TextDecoder
            }
            getOffset() {
                return this.offset
            }
            size() {
                return this.dv.buffer.byteLength
            }
            skip(e) {
                this.offset += e
            }
            getBoolean() {
                return !(1 & ~this.getUint8())
            }
            getBooleanArray(e) {
                const t = [];
                for (let n = 0; n < e; n++) t.push(this.getBoolean());
                return t
            }
            getUint8() {
                const e = this.dv.getUint8(this.offset);
                return this.offset += 1, e
            }
            getInt16() {
                const e = this.dv.getInt16(this.offset, this.littleEndian);
                return this.offset += 2, e
            }
            getInt32() {
                const e = this.dv.getInt32(this.offset, this.littleEndian);
                return this.offset += 4, e
            }
            getInt32Array(e) {
                const t = [];
                for (let n = 0; n < e; n++) t.push(this.getInt32());
                return t
            }
            getUint32() {
                const e = this.dv.getUint32(this.offset, this.littleEndian);
                return this.offset += 4, e
            }
            getInt64() {
                let e, t;
                return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), 2147483648 & t ? (t = 4294967295 & ~t, e = 4294967295 & ~e, 4294967295 === e && (t = t + 1 & 4294967295), e = e + 1 & 4294967295, -(4294967296 * t + e)) : 4294967296 * t + e
            }
            getInt64Array(e) {
                const t = [];
                for (let n = 0; n < e; n++) t.push(this.getInt64());
                return t
            }
            getUint64() {
                let e, t;
                return this.littleEndian ? (e = this.getUint32(), t = this.getUint32()) : (t = this.getUint32(), e = this.getUint32()), 4294967296 * t + e
            }
            getFloat32() {
                const e = this.dv.getFloat32(this.offset, this.littleEndian);
                return this.offset += 4, e
            }
            getFloat32Array(e) {
                const t = [];
                for (let n = 0; n < e; n++) t.push(this.getFloat32());
                return t
            }
            getFloat64() {
                const e = this.dv.getFloat64(this.offset, this.littleEndian);
                return this.offset += 8, e
            }
            getFloat64Array(e) {
                const t = [];
                for (let n = 0; n < e; n++) t.push(this.getFloat64());
                return t
            }
            getArrayBuffer(e) {
                const t = this.dv.buffer.slice(this.offset, this.offset + e);
                return this.offset += e, t
            }
            getString(e) {
                const t = this.offset;
                let n = new Uint8Array(this.dv.buffer, t, e);
                this.skip(e);
                const i = n.indexOf(0);
                return i >= 0 && (n = new Uint8Array(this.dv.buffer, t, i)), this._textDecoder.decode(n)
            }
        }
        class gB {
            add(e, t) {
                this[e] = t
            }
        }

        function fB(e) {
            const t = e.match(/FBXVersion: (\d+)/);
            if (t) {
                return parseInt(t[1])
            }
            throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")
        }

        function mB(e) {
            return e / 46186158e3
        }
        const EB = [];

        function CB(e, t, n, i) {
            let r;
            switch (i.mappingType) {
                case "ByPolygonVertex":
                    r = e;
                    break;
                case "ByPolygon":
                    r = t;
                    break;
                case "ByVertice":
                    r = n;
                    break;
                case "AllSame":
                    r = i.indices[0];
                    break;
                default:
                    console.warn("THREE.FBXLoader: unknown attribute mapping type " + i.mappingType)
            }
            "IndexToDirect" === i.referenceType && (r = i.indices[r]);
            const o = r * i.dataSize,
                s = o + i.dataSize;
            return function(e, t, n, i) {
                for (let r = n, o = 0; r < i; r++, o++) e[o] = t[r];
                return e
            }(EB, i.buffer, o, s)
        }
        const IB = new bi,
            SB = new On;

        function vB(e) {
            const t = new mi,
                n = new mi,
                i = new mi,
                r = new mi,
                o = new mi,
                s = new mi,
                a = new mi,
                l = new mi,
                c = new mi,
                A = new mi,
                h = new mi,
                u = new mi,
                d = e.inheritType ? e.inheritType : 0;
            if (e.translation && t.setPosition(SB.fromArray(e.translation)), e.preRotation) {
                const t = e.preRotation.map(un.degToRad);
                t.push(e.eulerOrder || bi.DEFAULT_ORDER), n.makeRotationFromEuler(IB.fromArray(t))
            }
            if (e.rotation) {
                const t = e.rotation.map(un.degToRad);
                t.push(e.eulerOrder || bi.DEFAULT_ORDER), i.makeRotationFromEuler(IB.fromArray(t))
            }
            if (e.postRotation) {
                const t = e.postRotation.map(un.degToRad);
                t.push(e.eulerOrder || bi.DEFAULT_ORDER), r.makeRotationFromEuler(IB.fromArray(t)), r.invert()
            }
            e.scale && o.scale(SB.fromArray(e.scale)), e.scalingOffset && a.setPosition(SB.fromArray(e.scalingOffset)), e.scalingPivot && s.setPosition(SB.fromArray(e.scalingPivot)), e.rotationOffset && l.setPosition(SB.fromArray(e.rotationOffset)), e.rotationPivot && c.setPosition(SB.fromArray(e.rotationPivot)), e.parentMatrixWorld && (h.copy(e.parentMatrix), A.copy(e.parentMatrixWorld));
            const p = n.clone().multiply(i).multiply(r),
                g = new mi;
            g.extractRotation(A);
            const f = new mi;
            f.copyPosition(A);
            const m = f.clone().invert().multiply(A),
                E = g.clone().invert().multiply(m),
                C = o,
                I = new mi;
            if (0 === d) I.copy(g).multiply(p).multiply(E).multiply(C);
            else if (1 === d) I.copy(g).multiply(E).multiply(p).multiply(C);
            else {
                const e = (new mi).scale((new On).setFromMatrixScale(h)).clone().invert(),
                    t = E.clone().multiply(e);
                I.copy(g).multiply(p).multiply(t).multiply(C)
            }
            const S = c.clone().invert(),
                v = s.clone().invert();
            let B = t.clone().multiply(l).multiply(c).multiply(n).multiply(i).multiply(r).multiply(S).multiply(a).multiply(s).multiply(o).multiply(v);
            const x = (new mi).copyPosition(B),
                y = A.clone().multiply(x);
            return u.copyPosition(y), B = u.clone().multiply(I), B.premultiply(A.invert()), B
        }

        function BB(e) {
            const t = ["ZYX", "YZX", "XZY", "ZXY", "YXZ", "XYZ"];
            return 6 === (e = e || 0) ? (console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."), t[0]) : t[e]
        }

        function xB(e) {
            const t = e.split(",").map((function(e) {
                return parseFloat(e)
            }));
            return t
        }

        function yB(e, t, n) {
            return void 0 === t && (t = 0), void 0 === n && (n = e.byteLength), (new TextDecoder).decode(new Uint8Array(e, t, n))
        }
        class wB {
            constructor(e = 4) {
                this.pool = e, this.queue = [], this.workers = [], this.workersResolve = [], this.workerStatus = 0
            }
            _initWorker(e) {
                if (!this.workers[e]) {
                    const t = this.workerCreator();
                    t.addEventListener("message", this._onMessage.bind(this, e)), this.workers[e] = t
                }
            }
            _getIdleWorker() {
                for (let e = 0; e < this.pool; e++)
                    if (!(this.workerStatus & 1 << e)) return e;
                return -1
            }
            _onMessage(e, t) {
                const n = this.workersResolve[e];
                if (n && n(t), this.queue.length) {
                    const {
                        resolve: t,
                        msg: n,
                        transfer: i
                    } = this.queue.shift();
                    this.workersResolve[e] = t, this.workers[e].postMessage(n, i)
                } else this.workerStatus ^= 1 << e
            }
            setWorkerCreator(e) {
                this.workerCreator = e
            }
            setWorkerLimit(e) {
                this.pool = e
            }
            postMessage(e, t) {
                return new Promise((n => {
                    const i = this._getIdleWorker(); - 1 !== i ? (this._initWorker(i), this.workerStatus |= 1 << i, this.workersResolve[i] = n, this.workers[i].postMessage(e, t)) : this.queue.push({
                        resolve: n,
                        msg: e,
                        transfer: t
                    })
                }))
            }
            dispose() {
                this.workers.forEach((e => e.terminate())), this.workersResolve.length = 0, this.workers.length = 0, this.queue.length = 0, this.workerStatus = 0
            }
        }
        const bB = 2,
            QB = 0,
            UB = 1,
            MB = 10;
        class RB {
            constructor() {
                this.vkFormat = 0, this.typeSize = 1, this.pixelWidth = 0, this.pixelHeight = 0, this.pixelDepth = 0, this.layerCount = 0, this.faceCount = 1, this.supercompressionScheme = 0, this.levels = [], this.dataFormatDescriptor = [{
                    vendorId: 0,
                    descriptorType: 0,
                    descriptorBlockSize: 0,
                    versionNumber: 2,
                    colorModel: 0,
                    colorPrimaries: 1,
                    transferFunction: 2,
                    flags: 0,
                    texelBlockDimension: [0, 0, 0, 0],
                    bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0],
                    samples: []
                }], this.keyValue = {}, this.globalData = null
            }
        }
        class TB {
            constructor(e, t, n, i) {
                this._dataView = new DataView(e.buffer, e.byteOffset + t, n), this._littleEndian = i, this._offset = 0
            }
            _nextUint8() {
                const e = this._dataView.getUint8(this._offset);
                return this._offset += 1, e
            }
            _nextUint16() {
                const e = this._dataView.getUint16(this._offset, this._littleEndian);
                return this._offset += 2, e
            }
            _nextUint32() {
                const e = this._dataView.getUint32(this._offset, this._littleEndian);
                return this._offset += 4, e
            }
            _nextUint64() {
                const e = this._dataView.getUint32(this._offset, this._littleEndian) + 2 ** 32 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
                return this._offset += 8, e
            }
            _nextInt32() {
                const e = this._dataView.getInt32(this._offset, this._littleEndian);
                return this._offset += 4, e
            }
            _skip(e) {
                return this._offset += e, this
            }
            _scan(e, t = 0) {
                const n = this._offset;
                let i = 0;
                for (; this._dataView.getUint8(this._offset) !== t && i < e;) i++, this._offset++;
                return i < e && this._offset++, new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + n, i)
            }
        }
        new Uint8Array([0]);
        const FB = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];

        function DB(e) {
            return "undefined" != typeof TextDecoder ? (new TextDecoder).decode(e) : Buffer.from(e).toString("utf8")
        }
        let kB, LB, KB;
        const PB = {
            env: {
                emscripten_notify_memory_growth: function(e) {
                    KB = new Uint8Array(LB.exports.memory.buffer)
                }
            }
        };
        class GB {
            init() {
                return kB || (kB = "undefined" != typeof fetch ? fetch("data:application/wasm;base64," + VB).then((e => e.arrayBuffer())).then((e => WebAssembly.instantiate(e, PB))).then(this._init) : WebAssembly.instantiate(Buffer.from(VB, "base64"), PB).then(this._init), kB)
            }
            _init(e) {
                LB = e.instance, PB.env.emscripten_notify_memory_growth(0)
            }
            decode(e, t = 0) {
                if (!LB) throw new Error("ZSTDDecoder: Await .init() before decoding.");
                const n = e.byteLength,
                    i = LB.exports.malloc(n);
                KB.set(e, i), t = t || Number(LB.exports.ZSTD_findDecompressedSize(i, n));
                const r = LB.exports.malloc(t),
                    o = LB.exports.ZSTD_decompress(r, t, i, n),
                    s = KB.slice(r, r + o);
                return LB.exports.free(i), LB.exports.free(r), s
            }
        }
        const VB = "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IAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigC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C0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdB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IAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEE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",
            OB = new WeakMap;
        let NB, HB = 0;
        class qB extends lA {
            constructor(e) {
                super(e), this.transcoderPath = "", this.transcoderBinary = null, this.transcoderPending = null, this.workerPool = new wB, this.workerSourceURL = "", this.workerConfig = null, "undefined" != typeof MSC_TRANSCODER && console.warn('THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.')
            }
            setTranscoderPath(e) {
                return this.transcoderPath = e, this
            }
            setWorkerLimit(e) {
                return this.workerPool.setWorkerLimit(e), this
            }
            async detectSupportAsync(e) {
                return this.workerConfig = {
                    astcSupported: await e.hasFeatureAsync("texture-compression-astc"),
                    etc1Supported: await e.hasFeatureAsync("texture-compression-etc1"),
                    etc2Supported: await e.hasFeatureAsync("texture-compression-etc2"),
                    dxtSupported: await e.hasFeatureAsync("texture-compression-bc"),
                    bptcSupported: await e.hasFeatureAsync("texture-compression-bptc"),
                    pvrtcSupported: await e.hasFeatureAsync("texture-compression-pvrtc")
                }, this
            }
            detectSupport(e) {
                return !0 === e.isWebGPURenderer ? this.workerConfig = {
                    astcSupported: e.hasFeature("texture-compression-astc"),
                    etc1Supported: e.hasFeature("texture-compression-etc1"),
                    etc2Supported: e.hasFeature("texture-compression-etc2"),
                    dxtSupported: e.hasFeature("texture-compression-bc"),
                    bptcSupported: e.hasFeature("texture-compression-bptc"),
                    pvrtcSupported: e.hasFeature("texture-compression-pvrtc")
                } : this.workerConfig = {
                    astcSupported: e.extensions.has("WEBGL_compressed_texture_astc"),
                    etc1Supported: e.extensions.has("WEBGL_compressed_texture_etc1"),
                    etc2Supported: e.extensions.has("WEBGL_compressed_texture_etc"),
                    dxtSupported: e.extensions.has("WEBGL_compressed_texture_s3tc"),
                    bptcSupported: e.extensions.has("EXT_texture_compression_bptc"),
                    pvrtcSupported: e.extensions.has("WEBGL_compressed_texture_pvrtc") || e.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc")
                }, this
            }
            init() {
                if (!this.transcoderPending) {
                    const e = new hA(this.manager);
                    e.setPath(this.transcoderPath), e.setWithCredentials(this.withCredentials);
                    const t = e.loadAsync("basis_transcoder.js"),
                        n = new hA(this.manager);
                    n.setPath(this.transcoderPath), n.setResponseType("arraybuffer"), n.setWithCredentials(this.withCredentials);
                    const i = n.loadAsync("basis_transcoder.wasm");
                    this.transcoderPending = Promise.all([t, i]).then((([e, t]) => {
                        const n = qB.BasisWorker.toString(),
                            i = ["/* constants */", "let _EngineFormat = " + JSON.stringify(qB.EngineFormat), "let _TranscoderFormat = " + JSON.stringify(qB.TranscoderFormat), "let _BasisFormat = " + JSON.stringify(qB.BasisFormat), "/* basis_transcoder.js */", e, "/* worker */", n.substring(n.indexOf("{") + 1, n.lastIndexOf("}"))].join("\n");
                        this.workerSourceURL = URL.createObjectURL(new Blob([i])), this.transcoderBinary = t, this.workerPool.setWorkerCreator((() => {
                            const e = new Worker(this.workerSourceURL),
                                t = this.transcoderBinary.slice(0);
                            return e.postMessage({
                                type: "init",
                                config: this.workerConfig,
                                transcoderBinary: t
                            }, [t]), e
                        }))
                    })), HB > 0 && console.warn("THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."), HB++
                }
                return this.transcoderPending
            }
            load(e, t, n, i) {
                if (null === this.workerConfig) throw new Error("THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`.");
                const r = new hA(this.manager);
                r.setResponseType("arraybuffer"), r.setWithCredentials(this.withCredentials), r.load(e, (e => {
                    if (OB.has(e)) {
                        return OB.get(e).promise.then(t).catch(i)
                    }
                    this._createTexture(e).then((e => t ? t(e) : null)).catch(i)
                }), n, i)
            }
            _createTextureFrom(e, t) {
                const {
                    faces: n,
                    width: i,
                    height: r,
                    format: o,
                    type: s,
                    error: a,
                    dfdFlags: l
                } = e;
                if ("error" === s) return Promise.reject(a);
                let c;
                if (6 === t.faceCount) c = new oc(n, o, ot);
                else {
                    const e = n[0].mipmaps;
                    c = t.layerCount > 1 ? new rc(e, i, r, t.layerCount, o, ot) : new ic(e, i, r, o, ot)
                }
                return c.minFilter = 1 === n[0].mipmaps.length ? nt : rt, c.magFilter = nt, c.generateMipmaps = !1, c.needsUpdate = !0, c.colorSpace = WB(t), c.premultiplyAlpha = !!(1 & l), c
            }
            async _createTexture(e, t = {}) {
                const n = function(e) {
                    const t = new Uint8Array(e.buffer, e.byteOffset, FB.length);
                    if (t[0] !== FB[0] || t[1] !== FB[1] || t[2] !== FB[2] || t[3] !== FB[3] || t[4] !== FB[4] || t[5] !== FB[5] || t[6] !== FB[6] || t[7] !== FB[7] || t[8] !== FB[8] || t[9] !== FB[9] || t[10] !== FB[10] || t[11] !== FB[11]) throw new Error("Missing KTX 2.0 identifier.");
                    const n = new RB,
                        i = 17 * Uint32Array.BYTES_PER_ELEMENT,
                        r = new TB(e, FB.length, i, !0);
                    n.vkFormat = r._nextUint32(), n.typeSize = r._nextUint32(), n.pixelWidth = r._nextUint32(), n.pixelHeight = r._nextUint32(), n.pixelDepth = r._nextUint32(), n.layerCount = r._nextUint32(), n.faceCount = r._nextUint32();
                    const o = r._nextUint32();
                    n.supercompressionScheme = r._nextUint32();
                    const s = r._nextUint32(),
                        a = r._nextUint32(),
                        l = r._nextUint32(),
                        c = r._nextUint32(),
                        A = r._nextUint64(),
                        h = r._nextUint64(),
                        u = new TB(e, FB.length + i, 3 * o * 8, !0);
                    for (let t = 0; t < o; t++) n.levels.push({
                        levelData: new Uint8Array(e.buffer, e.byteOffset + u._nextUint64(), u._nextUint64()),
                        uncompressedByteLength: u._nextUint64()
                    });
                    const d = new TB(e, s, a, !0),
                        p = {
                            vendorId: d._skip(4)._nextUint16(),
                            descriptorType: d._nextUint16(),
                            versionNumber: d._nextUint16(),
                            descriptorBlockSize: d._nextUint16(),
                            colorModel: d._nextUint8(),
                            colorPrimaries: d._nextUint8(),
                            transferFunction: d._nextUint8(),
                            flags: d._nextUint8(),
                            texelBlockDimension: [d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8()],
                            bytesPlane: [d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8()],
                            samples: []
                        },
                        g = (p.descriptorBlockSize / 4 - 6) / 4;
                    for (let e = 0; e < g; e++) {
                        const t = {
                            bitOffset: d._nextUint16(),
                            bitLength: d._nextUint8(),
                            channelType: d._nextUint8(),
                            samplePosition: [d._nextUint8(), d._nextUint8(), d._nextUint8(), d._nextUint8()],
                            sampleLower: -1 / 0,
                            sampleUpper: 1 / 0
                        };
                        64 & t.channelType ? (t.sampleLower = d._nextInt32(), t.sampleUpper = d._nextInt32()) : (t.sampleLower = d._nextUint32(), t.sampleUpper = d._nextUint32()), p.samples[e] = t
                    }
                    n.dataFormatDescriptor.length = 0, n.dataFormatDescriptor.push(p);
                    const f = new TB(e, l, c, !0);
                    for (; f._offset < c;) {
                        const e = f._nextUint32(),
                            t = f._scan(e),
                            i = DB(t),
                            r = f._scan(e - t.byteLength);
                        n.keyValue[i] = i.match(/^ktx/i) ? DB(r) : r, f._offset % 4 && f._skip(4 - f._offset % 4)
                    }
                    if (h <= 0) return n;
                    const m = new TB(e, A, h, !0),
                        E = m._nextUint16(),
                        C = m._nextUint16(),
                        I = m._nextUint32(),
                        S = m._nextUint32(),
                        v = m._nextUint32(),
                        B = m._nextUint32(),
                        x = [];
                    for (let e = 0; e < o; e++) x.push({
                        imageFlags: m._nextUint32(),
                        rgbSliceByteOffset: m._nextUint32(),
                        rgbSliceByteLength: m._nextUint32(),
                        alphaSliceByteOffset: m._nextUint32(),
                        alphaSliceByteLength: m._nextUint32()
                    });
                    const y = A + m._offset,
                        w = y + I,
                        b = w + S,
                        Q = b + v,
                        U = new Uint8Array(e.buffer, e.byteOffset + y, I),
                        M = new Uint8Array(e.buffer, e.byteOffset + w, S),
                        R = new Uint8Array(e.buffer, e.byteOffset + b, v),
                        T = new Uint8Array(e.buffer, e.byteOffset + Q, B);
                    return n.globalData = {
                        endpointCount: E,
                        selectorCount: C,
                        imageDescs: x,
                        endpointsData: U,
                        selectorsData: M,
                        tablesData: R,
                        extendedData: T
                    }, n
                }(new Uint8Array(e));
                if (0 !== n.vkFormat) return async function(e) {
                    const {
                        vkFormat: t
                    } = e;
                    if (void 0 === YB[t]) throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");
                    let n;
                    2 === e.supercompressionScheme && (NB || (NB = new Promise((async e => {
                        const t = new GB;
                        await t.init(), e(t)
                    }))), n = await NB);
                    const i = [];
                    for (let r = 0; r < e.levels.length; r++) {
                        const o = Math.max(1, e.pixelWidth >> r),
                            s = Math.max(1, e.pixelHeight >> r),
                            a = e.pixelDepth ? Math.max(1, e.pixelDepth >> r) : 0,
                            l = e.levels[r];
                        let c, A;
                        if (0 === e.supercompressionScheme) c = l.levelData;
                        else {
                            if (2 !== e.supercompressionScheme) throw new Error("THREE.KTX2Loader: Unsupported supercompressionScheme.");
                            c = n.decode(l.levelData, l.uncompressedByteLength)
                        }
                        A = JB[t] === lt ? new Float32Array(c.buffer, c.byteOffset, c.byteLength / Float32Array.BYTES_PER_ELEMENT) : JB[t] === ct ? new Uint16Array(c.buffer, c.byteOffset, c.byteLength / Uint16Array.BYTES_PER_ELEMENT) : c, i.push({
                            data: A,
                            width: o,
                            height: s,
                            depth: a
                        })
                    }
                    let r;
                    if (jB.has(YB[t])) r = 0 === e.pixelDepth ? new vl(i[0].data, e.pixelWidth, e.pixelHeight) : new Gn(i[0].data, e.pixelWidth, e.pixelHeight, e.pixelDepth);
                    else {
                        if (e.pixelDepth > 0) throw new Error("THREE.KTX2Loader: Unsupported pixelDepth.");
                        r = new ic(i, e.pixelWidth, e.pixelHeight)
                    }
                    return r.mipmaps = i, r.type = JB[t], r.format = YB[t], r.colorSpace = WB(e), r.needsUpdate = !0, Promise.resolve(r)
                }(n);
                const i = t,
                    r = this.init().then((() => this.workerPool.postMessage({
                        type: "transcode",
                        buffer: e,
                        taskConfig: i
                    }, [e]))).then((e => this._createTextureFrom(e.data, n)));
                return OB.set(e, {
                    promise: r
                }), r
            }
            dispose() {
                return this.workerPool.dispose(), this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), HB--, this
            }
        }
        qB.BasisFormat = {
            ETC1S: 0,
            UASTC_4x4: 1
        }, qB.TranscoderFormat = {
            ETC1: 0,
            ETC2: 1,
            BC1: 2,
            BC3: 3,
            BC4: 4,
            BC5: 5,
            BC7_M6_OPAQUE_ONLY: 6,
            BC7_M5: 7,
            PVRTC1_4_RGB: 8,
            PVRTC1_4_RGBA: 9,
            ASTC_4x4: 10,
            ATC_RGB: 11,
            ATC_RGBA_INTERPOLATED_ALPHA: 12,
            RGBA32: 13,
            RGB565: 14,
            BGR565: 15,
            RGBA4444: 16
        }, qB.EngineFormat = {
            RGBAFormat: ht,
            RGBA_ASTC_4x4_Format: wt,
            RGBA_BPTC_Format: Qt,
            RGBA_ETC2_EAC_Format: yt,
            RGBA_PVRTC_4BPPV1_Format: vt,
            RGBA_S3TC_DXT5_Format: It,
            RGB_ETC1_Format: Bt,
            RGB_ETC2_Format: xt,
            RGB_PVRTC_4BPPV1_Format: St,
            RGBA_S3TC_DXT1_Format: Et
        }, qB.BasisWorker = function() {
            let e, t, n;
            const i = _EngineFormat,
                r = _TranscoderFormat,
                o = _BasisFormat;
            self.addEventListener("message", (function(s) {
                const h = s.data;
                switch (h.type) {
                    case "init":
                        e = h.config, u = h.transcoderBinary, t = new Promise((e => {
                            n = {
                                wasmBinary: u,
                                onRuntimeInitialized: e
                            }, BASIS(n)
                        })).then((() => {
                            n.initializeBasis(), void 0 === n.KTX2File && console.warn("THREE.KTX2Loader: Please update Basis Universal transcoder.")
                        }));
                        break;
                    case "transcode":
                        t.then((() => {
                            try {
                                const {
                                    faces: t,
                                    buffers: s,
                                    width: u,
                                    height: d,
                                    hasAlpha: p,
                                    format: g,
                                    dfdFlags: f
                                } = function(t) {
                                    const s = new n.KTX2File(new Uint8Array(t));

                                    function h() {
                                        s.close(), s.delete()
                                    }
                                    if (!s.isValid()) throw h(), new Error("THREE.KTX2Loader:\tInvalid or unsupported .ktx2 file");
                                    const u = s.isUASTC() ? o.UASTC_4x4 : o.ETC1S,
                                        d = s.getWidth(),
                                        p = s.getHeight(),
                                        g = s.getLayers() || 1,
                                        f = s.getLevels(),
                                        m = s.getFaces(),
                                        E = s.getHasAlpha(),
                                        C = s.getDFDFlags(),
                                        {
                                            transcoderFormat: I,
                                            engineFormat: S
                                        } = function(t, n, s, A) {
                                            let h, u;
                                            const d = t === o.ETC1S ? a : l;
                                            for (let i = 0; i < d.length; i++) {
                                                const r = d[i];
                                                if (e[r.if] && (r.basisFormat.includes(t) && !(A && r.transcoderFormat.length < 2) && (!r.needsPowerOfTwo || c(n) && c(s)))) return h = r.transcoderFormat[A ? 1 : 0], u = r.engineFormat[A ? 1 : 0], {
                                                    transcoderFormat: h,
                                                    engineFormat: u
                                                }
                                            }
                                            return console.warn("THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32."), h = r.RGBA32, u = i.RGBAFormat, {
                                                transcoderFormat: h,
                                                engineFormat: u
                                            }
                                        }(u, d, p, E);
                                    if (!d || !p || !f) throw h(), new Error("THREE.KTX2Loader:\tInvalid texture");
                                    if (!s.startTranscoding()) throw h(), new Error("THREE.KTX2Loader: .startTranscoding failed");
                                    const v = [],
                                        B = [];
                                    for (let e = 0; e < m; e++) {
                                        const t = [];
                                        for (let n = 0; n < f; n++) {
                                            const i = [];
                                            let r, o;
                                            for (let t = 0; t < g; t++) {
                                                const a = s.getImageLevelInfo(n, t, e);
                                                0 !== e || 0 !== n || 0 !== t || a.origWidth % 4 == 0 && a.origHeight % 4 == 0 || console.warn("THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions."), f > 1 ? (r = a.origWidth, o = a.origHeight) : (r = a.width, o = a.height);
                                                const l = new Uint8Array(s.getImageTranscodedSizeInBytes(n, t, 0, I));
                                                if (!s.transcodeImage(l, n, t, e, I, 0, -1, -1)) throw h(), new Error("THREE.KTX2Loader: .transcodeImage failed.");
                                                i.push(l)
                                            }
                                            const a = A(i);
                                            t.push({
                                                data: a,
                                                width: r,
                                                height: o
                                            }), B.push(a.buffer)
                                        }
                                        v.push({
                                            mipmaps: t,
                                            width: d,
                                            height: p,
                                            format: S
                                        })
                                    }
                                    return h(), {
                                        faces: v,
                                        buffers: B,
                                        width: d,
                                        height: p,
                                        hasAlpha: E,
                                        format: S,
                                        dfdFlags: C
                                    }
                                }(h.buffer);
                                self.postMessage({
                                    type: "transcode",
                                    id: h.id,
                                    faces: t,
                                    width: u,
                                    height: d,
                                    hasAlpha: p,
                                    format: g,
                                    dfdFlags: f
                                }, s)
                            } catch (e) {
                                console.error(e), self.postMessage({
                                    type: "error",
                                    id: h.id,
                                    error: e.message
                                })
                            }
                        }))
                }
                var u
            }));
            const s = [{
                    if: "astcSupported",
                    basisFormat: [o.UASTC_4x4],
                    transcoderFormat: [r.ASTC_4x4, r.ASTC_4x4],
                    engineFormat: [i.RGBA_ASTC_4x4_Format, i.RGBA_ASTC_4x4_Format],
                    priorityETC1S: 1 / 0,
                    priorityUASTC: 1,
                    needsPowerOfTwo: !1
                }, {
                    if: "bptcSupported",
                    basisFormat: [o.ETC1S, o.UASTC_4x4],
                    transcoderFormat: [r.BC7_M5, r.BC7_M5],
                    engineFormat: [i.RGBA_BPTC_Format, i.RGBA_BPTC_Format],
                    priorityETC1S: 3,
                    priorityUASTC: 2,
                    needsPowerOfTwo: !1
                }, {
                    if: "dxtSupported",
                    basisFormat: [o.ETC1S, o.UASTC_4x4],
                    transcoderFormat: [r.BC1, r.BC3],
                    engineFormat: [i.RGBA_S3TC_DXT1_Format, i.RGBA_S3TC_DXT5_Format],
                    priorityETC1S: 4,
                    priorityUASTC: 5,
                    needsPowerOfTwo: !1
                }, {
                    if: "etc2Supported",
                    basisFormat: [o.ETC1S, o.UASTC_4x4],
                    transcoderFormat: [r.ETC1, r.ETC2],
                    engineFormat: [i.RGB_ETC2_Format, i.RGBA_ETC2_EAC_Format],
                    priorityETC1S: 1,
                    priorityUASTC: 3,
                    needsPowerOfTwo: !1
                }, {
                    if: "etc1Supported",
                    basisFormat: [o.ETC1S, o.UASTC_4x4],
                    transcoderFormat: [r.ETC1],
                    engineFormat: [i.RGB_ETC1_Format],
                    priorityETC1S: 2,
                    priorityUASTC: 4,
                    needsPowerOfTwo: !1
                }, {
                    if: "pvrtcSupported",
                    basisFormat: [o.ETC1S, o.UASTC_4x4],
                    transcoderFormat: [r.PVRTC1_4_RGB, r.PVRTC1_4_RGBA],
                    engineFormat: [i.RGB_PVRTC_4BPPV1_Format, i.RGBA_PVRTC_4BPPV1_Format],
                    priorityETC1S: 5,
                    priorityUASTC: 6,
                    needsPowerOfTwo: !0
                }],
                a = s.sort((function(e, t) {
                    return e.priorityETC1S - t.priorityETC1S
                })),
                l = s.sort((function(e, t) {
                    return e.priorityUASTC - t.priorityUASTC
                }));

            function c(e) {
                return e <= 2 || !(e & e - 1) && 0 !== e
            }

            function A(e) {
                if (1 === e.length) return e[0];
                let t = 0;
                for (let n = 0; n < e.length; n++) {
                    t += e[n].byteLength
                }
                const n = new Uint8Array(t);
                let i = 0;
                for (let t = 0; t < e.length; t++) {
                    const r = e[t];
                    n.set(r, i), i += r.byteLength
                }
                return n
            }
        };
        const jB = new Set([ht, ft, gt]),
            YB = {
                109: ht,
                97: ht,
                37: ht,
                43: ht,
                103: ft,
                83: ft,
                16: ft,
                22: ft,
                100: gt,
                76: gt,
                15: gt,
                9: gt,
                166: bt,
                165: bt
            },
            JB = {
                109: lt,
                97: ct,
                37: ot,
                43: ot,
                103: lt,
                83: ct,
                16: ot,
                22: ot,
                100: lt,
                76: ct,
                15: ot,
                9: ot,
                166: ot,
                165: ot
            };

        function WB(e) {
            const t = e.dataFormatDescriptor[0];
            return t.colorPrimaries === UB ? t.transferFunction === bB ? Ot : Nt : t.colorPrimaries === MB ? t.transferFunction === bB ? Ht : qt : (t.colorPrimaries === QB || console.warn(`THREE.KTX2Loader: Unsupported color primaries, "${t.colorPrimaries}"`), Vt)
        }
        var zB = function() {
            var e = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]),
                t = new Uint8Array([32, 0, 65, 2, 1, 106, 34, 33, 3, 128, 11, 4, 13, 64, 6, 253, 10, 7, 15, 116, 127, 5, 8, 12, 40, 16, 19, 54, 20, 9, 27, 255, 113, 17, 42, 67, 24, 23, 146, 148, 18, 14, 22, 45, 70, 69, 56, 114, 101, 21, 25, 63, 75, 136, 108, 28, 118, 29, 73, 115]);
            if ("object" != typeof WebAssembly) return {
                supported: !1
            };
            var n, i = WebAssembly.validate(e) ? "b9H79TebbbeKl9Gbb9Gvuuuuueu9Giuuub9Geueuikqbbebeedddilve9Weeeviebeoweuec:q;Aekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbdY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVblE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtboK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbrL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbwl79IV9RbDq;t9tqlbzik9:evu8Jjjjjbcz9Rhbcbheincbhdcbhiinabcwfadfaicjuaead4ceGglE86bbaialfhiadcefgdcw9hmbkaec:q:yjjbfai86bbaecitc:q1jjbfab8Piw83ibaecefgecjd9hmbkk;h8JlHud97euo978Jjjjjbcj;kb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Rad;8qbbcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhwcbhDinaDae9pmeawaeaD9RaDawfae6Egqcsfgoc9WGgkci2hxakcethmaocl4cifcd4hPabaDad2fhscbhzdnincehHalhOcbhAdninaraO9RaP6miavcj;cbfaAak2fhCaOaPfhlcbhidnakc;ab6mbaral9Rc;Gb6mbcbhoinaCaofhidndndndndnaOaoco4fRbbgXciGPlbedibkaipxbbbbbbbbbbbbbbbbpklbxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklbalczfhlkdndndndndnaXcd4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklzxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklzalczfhlkdndndndndnaXcl4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklaxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklaalczfhlkdndndndndnaXco4Plbedibkaipxbbbbbbbbbbbbbbbbpkl8WxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalclfaYpQbfaXc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalcwfaYpQbfaXc:q:yjjbfRbbfhlxekaialpbbbpkl8Walczfhlkaoc;abfhiaocjefak0meaihoaral9Rc;Fb0mbkkdndnaiak9pmbaici4hoinaral9RcK6mdaCaifhXdndndndndnaOaico4fRbbaocoG4ciGPlbedibkaXpxbbbbbbbbbbbbbbbbpklbxikaXalpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaXalpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaXalpbbbpklbalczfhlkaocdfhoaiczfgiak6mbkkalTmbaAci6hHalhOaAcefgohAaoclSmdxekkcbhlaHceGmdkdnakTmbavcjdfazfhiavazfpbdbhYcbhXinaiavcj;cbfaXfgopblbgLcep9TaLpxeeeeeeeeeeeeeeeegQp9op9Hp9rgLaoakfpblbg8Acep9Ta8AaQp9op9Hp9rg8ApmbzeHdOiAlCvXoQrLgEaoamfpblbg3cep9Ta3aQp9op9Hp9rg3aoaxfpblbg5cep9Ta5aQp9op9Hp9rg5pmbzeHdOiAlCvXoQrLg8EpmbezHdiOAlvCXorQLgQaQpmbedibedibedibediaYp9UgYp9AdbbaiadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaEa8EpmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwKDYq8AkEx3m5P8Es8FgLa3a5pmwKDYq8AkEx3m5P8Es8Fg8ApmbezHdiOAlvCXorQLgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfhiaXczfgXak6mbkkazclfgzad6mbkasavcjdfaqad2;8qbbavavcjdfaqcufad2fad;8qbbaqaDfhDc9:hoalmexikkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;kbf8Kjjjjbaokwbz:bjjjbk;uzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecje;8kbavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:EPliuo97eue978Jjjjjbca9Rhidndnadcl9hmbdnaec98GglTmbcbhvabhdinadadpbbbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpkbbadczfhdavclfgval6mbkkalae9pmeaiaeciGgvcdtgdVcbczad9R;8kbaiabalcdtfglad;8qbbdnavTmbaiaipblbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpklbkalaiad;8qbbskdnaec98GgxTmbcbhvabhdinadczfglalpbbbgopxbbbbbbFFbbbbbbFFgkp9oadpbbbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpkbbadaDakp9oawaopmbezHdiOAlvCXorQLp9qpkbbadcafhdavclfgvax6mbkkaxae9pmbaiaeciGgvcitgdfcbcaad9R;8kbaiabaxcitfglad;8qbbdnavTmbaiaipblzgopxbbbbbbFFbbbbbbFFgkp9oaipblbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpklzaiaDakp9oawaopmbezHdiOAlvCXorQLp9qpklbkalaiad;8qbbkk;4wllue97euv978Jjjjjbc8W9Rhidnaec98GglTmbcbhvabhoinaiaopbbbgraoczfgwpbbbgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklbaopxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblbpEb:T:j83ibaocwfarp5eaipblbpEe:T:j83ibawaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblbpEd:T:j83ibaocKfakp5eaipblbpEi:T:j83ibaocafhoavclfgval6mbkkdnalae9pmbaiaeciGgvcitgofcbcaao9R;8kbaiabalcitfgwao;8qbbdnavTmbaiaipblbgraipblzgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklaaipxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblapEb:T:j83ibaiarp5eaipblapEe:T:j83iwaiaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblapEd:T:j83izaiakp5eaipblapEi:T:j83iKkawaiao;8qbbkk:Pddiue978Jjjjjbc;ab9Rhidnadcd4ae2glc98GgvTmbcbhdabheinaeaepbbbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepkbbaeczfheadclfgdav6mbkkdnaval9pmbaialciGgdcdtgeVcbc;abae9R;8kbaiabavcdtfgvae;8qbbdnadTmbaiaipblbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepklbkavaiae;8qbbkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaikkkebcjwklz9Tbb" : "b9H79Tebbbe8Fv9Gbb9Gvuuuuueu9Giuuub9Geueu9Giuuueuikqbeeedddillviebeoweuec:q;iekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbeY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVbdE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbiL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtblK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbol79IV9Rbrq:P8Yqdbk;3sezu8Jjjjjbcj;eb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Radz1jjjbhwcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhDcbhqinaqae9pmeaDaeaq9RaqaDfae6Egkcsfgocl4cifcd4hxdndndndnaoc9WGgmTmbcbhPcehsawcjdfhzalhHinaraH9Rax6midnaraHaxfgl9RcK6mbczhoinawcj;cbfaogifgoc9WfhOdndndndndnaHaic9WfgAco4fRbbaAci4coG4ciGPlbedibkaO9cb83ibaOcwf9cb83ibxikaOalRblalRbbgAco4gCaCciSgCE86bbaocGfalclfaCfgORbbaAcl4ciGgCaCciSgCE86bbaocVfaOaCfgORbbaAcd4ciGgCaCciSgCE86bbaoc7faOaCfgORbbaAciGgAaAciSgAE86bbaoctfaOaAfgARbbalRbegOco4gCaCciSgCE86bbaoc91faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc4faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc93faAaCfgARbbaOciGgOaOciSgOE86bbaoc94faAaOfgARbbalRbdgOco4gCaCciSgCE86bbaoc95faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc96faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc97faAaCfgARbbaOciGgOaOciSgOE86bbaoc98faAaOfgORbbalRbiglco4gAaAciSgAE86bbaoc99faOaAfgORbbalcl4ciGgAaAciSgAE86bbaoc9:faOaAfgORbbalcd4ciGgAaAciSgAE86bbaocufaOaAfgoRbbalciGglalciSglE86bbaoalfhlxdkaOalRbwalRbbgAcl4gCaCcsSgCE86bbaocGfalcwfaCfgORbbaAcsGgAaAcsSgAE86bbaocVfaOaAfgORbbalRbegAcl4gCaCcsSgCE86bbaoc7faOaCfgORbbaAcsGgAaAcsSgAE86bbaoctfaOaAfgORbbalRbdgAcl4gCaCcsSgCE86bbaoc91faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc4faOaAfgORbbalRbigAcl4gCaCcsSgCE86bbaoc93faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc94faOaAfgORbbalRblgAcl4gCaCcsSgCE86bbaoc95faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc96faOaAfgORbbalRbvgAcl4gCaCcsSgCE86bbaoc97faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc98faOaAfgORbbalRbogAcl4gCaCcsSgCE86bbaoc99faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc9:faOaAfgORbbalRbrglcl4gAaAcsSgAE86bbaocufaOaAfgoRbbalcsGglalcsSglE86bbaoalfhlxekaOal8Pbb83bbaOcwfalcwf8Pbb83bbalczfhlkdnaiam9pmbaiczfhoaral9RcL0mekkaiam6mialTmidnakTmbawaPfRbbhOcbhoazhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkkazcefhzaPcefgPad6hsalhHaPad9hmexvkkcbhlasceGmdxikalaxad2fhCdnakTmbcbhHcehsawcjdfhminaral9Rax6mialTmdalaxfhlawaHfRbbhOcbhoamhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkamcefhmaHcefgHad6hsaHad9hmbkaChlxikcbhocehsinaral9Rax6mdalTmealaxfhlaocefgoad6hsadao9hmbkaChlxdkcbhlasceGTmekc9:hoxikabaqad2fawcjdfakad2z1jjjb8Aawawcjdfakcufad2fadz1jjjb8Aakaqfhqalmbkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;ebf8Kjjjjbaok;yzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecjez:jjjjb8AavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:Lvoeue99dud99eud99dndnadcl9hmbaeTmeindndnabcdfgd8Sbb:Yab8Sbbgi:Ygl:l:tabcefgv8Sbbgo:Ygr:l:tgwJbb;:9cawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai86bbdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad86bbdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad86bbabclfhbaecufgembxdkkaeTmbindndnabclfgd8Ueb:Yab8Uebgi:Ygl:l:tabcdfgv8Uebgo:Ygr:l:tgwJb;:FSawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai87ebdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad87ebdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad87ebabcwfhbaecufgembkkk;siliui99iue99dnaeTmbcbhiabhlindndnJ;Zl81Zalcof8UebgvciV:Y:vgoal8Ueb:YNgrJb;:FSNJbbbZJbbb:;arJbbbb9GEMgw:lJbbb9p9DTmbaw:OhDxekcjjjj94hDkalclf8Uebhqalcdf8UebhkabavcefciGaiVcetfaD87ebdndnaoak:YNgwJb;:FSNJbbbZJbbb:;awJbbbb9GEMgx:lJbbb9p9DTmbax:Ohkxekcjjjj94hkkabavcdfciGaiVcetfak87ebdndnaoaq:YNgoJb;:FSNJbbbZJbbb:;aoJbbbb9GEMgx:lJbbb9p9DTmbax:Ohqxekcjjjj94hqkabavcufciGaiVcetfaq87ebdndnJbbjZararN:tawawN:taoaoN:tgrJbbbbarJbbbb9GE:rJb;:FSNJbbbZMgr:lJbbb9p9DTmbar:Ohqxekcjjjj94hqkabavciGaiVcetfaq87ebalcwfhlaiclfhiaecufgembkkk9mbdnadcd4ae2geTmbinababydbgdcwtcw91:Yadce91cjjj;8ifcjjj98G::NUdbabclfhbaecufgembkkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaik;LeeeudndnaeabVciGTmbabhixekdndnadcz9pmbabhixekabhiinaiaeydbBdbaiclfaeclfydbBdbaicwfaecwfydbBdbaicxfaecxfydbBdbaiczfhiaeczfheadc9Wfgdcs0mbkkadcl6mbinaiaeydbBdbaeclfheaiclfhiadc98fgdci0mbkkdnadTmbinaiaeRbb86bbaicefhiaecefheadcufgdmbkkabk;aeedudndnabciGTmbabhixekaecFeGc:b:c:ew2hldndnadcz9pmbabhixekabhiinaialBdbaicxfalBdbaicwfalBdbaiclfalBdbaiczfhiadc9Wfgdcs0mbkkadcl6mbinaialBdbaiclfhiadc98fgdci0mbkkdnadTmbinaiae86bbaicefhiadcufgdmbkkabkkkebcjwklz9Kbb",
                r = WebAssembly.instantiate(o(i), {}).then((function(e) {
                    (n = e.instance).exports.__wasm_call_ctors()
                }));

            function o(e) {
                for (var n = new Uint8Array(e.length), i = 0; i < e.length; ++i) {
                    var r = e.charCodeAt(i);
                    n[i] = r > 96 ? r - 97 : r > 64 ? r - 39 : r + 4
                }
                var o = 0;
                for (i = 0; i < e.length; ++i) n[o++] = n[i] < 60 ? t[n[i]] : 64 * (n[i] - 60) + n[++i];
                return n.buffer.slice(0, o)
            }

            function s(e, t, i, r, o, s) {
                var a = n.exports.sbrk,
                    l = i + 3 & -4,
                    c = a(l * r),
                    A = a(o.length),
                    h = new Uint8Array(n.exports.memory.buffer);
                h.set(o, A);
                var u = e(c, i, r, A, o.length);
                if (0 == u && s && s(c, l, r), t.set(h.subarray(c, c + i * r)), a(c - a(0)), 0 != u) throw new Error("Malformed buffer data: " + u)
            }
            var a = {
                    NONE: "",
                    OCTAHEDRAL: "meshopt_decodeFilterOct",
                    QUATERNION: "meshopt_decodeFilterQuat",
                    EXPONENTIAL: "meshopt_decodeFilterExp"
                },
                l = {
                    ATTRIBUTES: "meshopt_decodeVertexBuffer",
                    TRIANGLES: "meshopt_decodeIndexBuffer",
                    INDICES: "meshopt_decodeIndexSequence"
                },
                c = [],
                A = 0;

            function h(e) {
                var t = {
                    object: new Worker(e),
                    pending: 0,
                    requests: {}
                };
                return t.object.onmessage = function(e) {
                    var n = e.data;
                    t.pending -= n.count, t.requests[n.id][n.action](n.value), delete t.requests[n.id]
                }, t
            }

            function u(e) {
                for (var t = "var instance; var ready = WebAssembly.instantiate(new Uint8Array([" + new Uint8Array(o(i)) + "]), {}).then(function(result) { instance = result.instance; instance.exports.__wasm_call_ctors(); });self.onmessage = workerProcess;" + s.toString() + d.toString(), n = new Blob([t], {
                        type: "text/javascript"
                    }), r = URL.createObjectURL(n), a = 0; a < e; ++a) c[a] = h(r);
                URL.revokeObjectURL(r)
            }

            function d(e) {
                r.then((function() {
                    var t = e.data;
                    try {
                        var i = new Uint8Array(t.count * t.size);
                        s(n.exports[t.mode], i, t.count, t.size, t.source, n.exports[t.filter]), self.postMessage({
                            id: t.id,
                            count: t.count,
                            action: "resolve",
                            value: i
                        }, [i.buffer])
                    } catch (e) {
                        self.postMessage({
                            id: t.id,
                            count: t.count,
                            action: "reject",
                            value: e
                        })
                    }
                }))
            }
            return {
                ready: r,
                supported: !0,
                useWorkers: function(e) {
                    u(e)
                },
                decodeVertexBuffer: function(e, t, i, r, o) {
                    s(n.exports.meshopt_decodeVertexBuffer, e, t, i, r, n.exports[a[o]])
                },
                decodeIndexBuffer: function(e, t, i, r) {
                    s(n.exports.meshopt_decodeIndexBuffer, e, t, i, r)
                },
                decodeIndexSequence: function(e, t, i, r) {
                    s(n.exports.meshopt_decodeIndexSequence, e, t, i, r)
                },
                decodeGltfBuffer: function(e, t, i, r, o, c) {
                    s(n.exports[l[o]], e, t, i, r, n.exports[a[c]])
                },
                decodeGltfBufferAsync: function(e, t, i, o, h) {
                    return c.length > 0 ? function(e, t, n, i, r) {
                        for (var o = c[0], s = 1; s < c.length; ++s) c[s].pending < o.pending && (o = c[s]);
                        return new Promise((function(s, a) {
                            var l = new Uint8Array(n),
                                c = A++;
                            o.pending += e, o.requests[c] = {
                                resolve: s,
                                reject: a
                            }, o.object.postMessage({
                                id: c,
                                count: e,
                                size: t,
                                source: l,
                                mode: i,
                                filter: r
                            }, [l.buffer])
                        }))
                    }(e, t, i, l[o], a[h]) : r.then((function() {
                        var r = new Uint8Array(e * t);
                        return s(n.exports[l[o]], r, e, t, i, n.exports[a[h]]), r
                    }))
                }
            }
        }();
        class XB extends lA {
            loadAsync() {
                return Promise.resolve()
            }
            load() {}
        }
        var ZB = .001,
            _B = class {
                constructor() {
                    this.startTime = performance.now(), this.previousTime = 0, this.currentTime = 0, this._delta = 0, this._elapsed = 0, this._fixedDelta = 1e3 / 60, this.timescale = 1, this.useFixedDelta = !1, this._autoReset = !1
                }
                get autoReset() {
                    return this._autoReset
                }
                set autoReset(e) {
                    "undefined" != typeof document && void 0 !== document.hidden && (e ? document.addEventListener("visibilitychange", this) : document.removeEventListener("visibilitychange", this), this._autoReset = e)
                }
                get delta() {
                    return this._delta * ZB
                }
                get fixedDelta() {
                    return this._fixedDelta * ZB
                }
                set fixedDelta(e) {
                    this._fixedDelta = 1e3 * e
                }
                get elapsed() {
                    return this._elapsed * ZB
                }
                update(e) {
                    this.useFixedDelta ? this._delta = this.fixedDelta : (this.previousTime = this.currentTime, this.currentTime = (void 0 !== e ? e : performance.now()) - this.startTime, this._delta = this.currentTime - this.previousTime), this._delta *= this.timescale, this._elapsed += this._delta
                }
                reset() {
                    this._delta = 0, this._elapsed = 0, this.currentTime = performance.now() - this.startTime
                }
                getDelta() {
                    return this.delta
                }
                getElapsed() {
                    return this.elapsed
                }
                handleEvent(e) {
                    document.hidden || (this.currentTime = performance.now() - this.startTime)
                }
                dispose() {
                    this.autoReset = !1
                }
            },
            $B = new to,
            ex = null;
        var tx = class e {
                constructor(e = "Pass", t = new al, n = $B) {
                    this.name = e, this.renderer = null, this.scene = t, this.camera = n, this.screen = null, this.rtt = !0, this.needsSwap = !0, this.needsDepthTexture = !1, this.enabled = !0
                }
                get renderToScreen() {
                    return !this.rtt
                }
                set renderToScreen(e) {
                    if (this.rtt === e) {
                        const t = this.fullscreenMaterial;
                        null !== t && (t.needsUpdate = !0), this.rtt = !e
                    }
                }
                set mainScene(e) {}
                set mainCamera(e) {}
                setRenderer(e) {
                    this.renderer = e
                }
                isEnabled() {
                    return this.enabled
                }
                setEnabled(e) {
                    this.enabled = e
                }
                get fullscreenMaterial() {
                    return null !== this.screen ? this.screen.material : null
                }
                set fullscreenMaterial(e) {
                    let t = this.screen;
                    null !== t ? t.material = e : (t = new Jr(function() {
                        if (null === ex) {
                            const e = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]),
                                t = new Float32Array([0, 0, 2, 0, 0, 2]);
                            void 0 !== (ex = new Ur).setAttribute ? (ex.setAttribute("position", new Er(e, 3)), ex.setAttribute("uv", new Er(t, 2))) : (ex.addAttribute("position", new Er(e, 3)), ex.addAttribute("uv", new Er(t, 2)))
                        }
                        return ex
                    }(), e), t.frustumCulled = !1, null === this.scene && (this.scene = new al), this.scene.add(t), this.screen = t)
                }
                getFullscreenMaterial() {
                    return this.fullscreenMaterial
                }
                setFullscreenMaterial(e) {
                    this.fullscreenMaterial = e
                }
                getDepthTexture() {
                    return null
                }
                setDepthTexture(e, t = 3200) {}
                render(e, t, n, i, r) {
                    throw new Error("Render method not implemented!")
                }
                setSize(e, t) {}
                initialize(e, t, n) {}
                dispose() {
                    for (const t of Object.keys(this)) {
                        const n = this[t];
                        (n instanceof Kn || n instanceof cr || n instanceof Dn || n instanceof e) && this[t].dispose()
                    }
                }
            },
            nx = class extends tx {
                constructor() {
                    super("ClearMaskPass", null, null), this.needsSwap = !1
                }
                render(e, t, n, i, r) {
                    const o = e.state.buffers.stencil;
                    o.setLocked(!1), o.setTest(!1)
                }
            },
            ix = Number(ye.replace(/\D+/g, ""));

        function rx(e) {
            return ix < 154 ? e.replace("colorspace_fragment", "encodings_fragment") : e
        }
        var ox = "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}",
            sx = class extends eo {
                constructor() {
                    super({
                        name: "CopyMaterial",
                        uniforms: {
                            inputBuffer: new jA(null),
                            opacity: new jA(1)
                        },
                        blending: 0,
                        toneMapped: !1,
                        depthWrite: !1,
                        depthTest: !1,
                        fragmentShader: "#include <common>\n#include <dithering_pars_fragment>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;\n#include <colorspace_fragment>\n#include <dithering_fragment>\n}",
                        vertexShader: ox
                    }), this.fragmentShader = rx(this.fragmentShader)
                }
                set inputBuffer(e) {
                    this.uniforms.inputBuffer.value = e
                }
                setInputBuffer(e) {
                    this.uniforms.inputBuffer.value = e
                }
                getOpacity(e) {
                    return this.uniforms.opacity.value
                }
                setOpacity(e) {
                    this.uniforms.opacity.value = e
                }
            },
            ax = class extends tx {
                constructor(e, t = !0) {
                    super("CopyPass"), this.fullscreenMaterial = new sx, this.needsSwap = !1, this.renderTarget = e, void 0 === e && (this.renderTarget = new Kn(1, 1, {
                        minFilter: nt,
                        magFilter: nt,
                        stencilBuffer: !1,
                        depthBuffer: !1
                    }), this.renderTarget.texture.name = "CopyPass.Target"), this.autoResize = t
                }
                get resize() {
                    return this.autoResize
                }
                set resize(e) {
                    this.autoResize = e
                }
                get texture() {
                    return this.renderTarget.texture
                }
                getTexture() {
                    return this.renderTarget.texture
                }
                setAutoResizeEnabled(e) {
                    this.autoResize = e
                }
                render(e, t, n, i, r) {
                    this.fullscreenMaterial.inputBuffer = t.texture, e.setRenderTarget(this.renderToScreen ? null : this.renderTarget), e.render(this.scene, this.camera)
                }
                setSize(e, t) {
                    this.autoResize && this.renderTarget.setSize(e, t)
                }
                initialize(e, t, n) {
                    void 0 !== n && (this.renderTarget.texture.type = n, n !== ot ? this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1" : null !== e && e.outputColorSpace === Ot && (this.renderTarget.texture.colorSpace = Ot))
                }
            },
            lx = new sr,
            cx = class extends tx {
                constructor(e = !0, t = !0, n = !1) {
                    super("ClearPass", null, null), this.needsSwap = !1, this.color = e, this.depth = t, this.stencil = n, this.overrideClearColor = null, this.overrideClearAlpha = -1
                }
                setClearFlags(e, t, n) {
                    this.color = e, this.depth = t, this.stencil = n
                }
                getOverrideClearColor() {
                    return this.overrideClearColor
                }
                setOverrideClearColor(e) {
                    this.overrideClearColor = e
                }
                getOverrideClearAlpha() {
                    return this.overrideClearAlpha
                }
                setOverrideClearAlpha(e) {
                    this.overrideClearAlpha = e
                }
                render(e, t, n, i, r) {
                    const o = this.overrideClearColor,
                        s = this.overrideClearAlpha,
                        a = e.getClearAlpha(),
                        l = null !== o,
                        c = s >= 0;
                    l ? (e.getClearColor(lx), e.setClearColor(o, c ? s : a)) : c && e.setClearAlpha(s), e.setRenderTarget(this.renderToScreen ? null : t), e.clear(this.color, this.depth, this.stencil), l ? e.setClearColor(lx, a) : c && e.setClearAlpha(a)
                }
            },
            Ax = class extends tx {
                constructor(e, t) {
                    super("MaskPass", e, t), this.needsSwap = !1, this.clearPass = new cx(!1, !1, !0), this.inverse = !1
                }
                set mainScene(e) {
                    this.scene = e
                }
                set mainCamera(e) {
                    this.camera = e
                }
                get inverted() {
                    return this.inverse
                }
                set inverted(e) {
                    this.inverse = e
                }
                get clear() {
                    return this.clearPass.enabled
                }
                set clear(e) {
                    this.clearPass.enabled = e
                }
                getClearPass() {
                    return this.clearPass
                }
                isInverted() {
                    return this.inverted
                }
                setInverted(e) {
                    this.inverted = e
                }
                render(e, t, n, i, r) {
                    const o = e.getContext(),
                        s = e.state.buffers,
                        a = this.scene,
                        l = this.camera,
                        c = this.clearPass,
                        A = this.inverted ? 0 : 1,
                        h = 1 - A;
                    s.color.setMask(!1), s.depth.setMask(!1), s.color.setLocked(!0), s.depth.setLocked(!0), s.stencil.setTest(!0), s.stencil.setOp(o.REPLACE, o.REPLACE, o.REPLACE), s.stencil.setFunc(o.ALWAYS, A, 4294967295), s.stencil.setClear(h), s.stencil.setLocked(!0), this.clearPass.enabled && (this.renderToScreen ? c.render(e, null) : (c.render(e, t), c.render(e, n))), this.renderToScreen ? (e.setRenderTarget(null), e.render(a, l)) : (e.setRenderTarget(t), e.render(a, l), e.setRenderTarget(n), e.render(a, l)), s.color.setLocked(!1), s.depth.setLocked(!1), s.stencil.setLocked(!1), s.stencil.setFunc(o.EQUAL, 1, 4294967295), s.stencil.setOp(o.KEEP, o.KEEP, o.KEEP), s.stencil.setLocked(!0)
                }
            },
            hx = class {
                constructor(e = null, {
                    depthBuffer: t = !0,
                    stencilBuffer: n = !1,
                    multisampling: i = 0,
                    frameBufferType: r
                } = {}) {
                    this.renderer = null, this.inputBuffer = this.createBuffer(t, n, r, i), this.outputBuffer = this.inputBuffer.clone(), this.copyPass = new ax, this.depthTexture = null, this.passes = [], this.timer = new _B, this.autoRenderToScreen = !0, this.setRenderer(e)
                }
                get multisampling() {
                    return this.inputBuffer.samples || 0
                }
                set multisampling(e) {
                    const t = this.inputBuffer,
                        n = this.multisampling;
                    n > 0 && e > 0 ? (this.inputBuffer.samples = e, this.outputBuffer.samples = e, this.inputBuffer.dispose(), this.outputBuffer.dispose()) : n !== e && (this.inputBuffer.dispose(), this.outputBuffer.dispose(), this.inputBuffer = this.createBuffer(t.depthBuffer, t.stencilBuffer, t.texture.type, e), this.inputBuffer.depthTexture = this.depthTexture, this.outputBuffer = this.inputBuffer.clone())
                }
                getTimer() {
                    return this.timer
                }
                getRenderer() {
                    return this.renderer
                }
                setRenderer(e) {
                    if (this.renderer = e, null !== e) {
                        const t = e.getSize(new dn),
                            n = e.getContext().getContextAttributes().alpha,
                            i = this.inputBuffer.texture.type;
                        i === ot && e.outputColorSpace === Ot && (this.inputBuffer.texture.colorSpace = Ot, this.outputBuffer.texture.colorSpace = Ot, this.inputBuffer.dispose(), this.outputBuffer.dispose()), e.autoClear = !1, this.setSize(t.width, t.height);
                        for (const t of this.passes) t.initialize(e, n, i)
                    }
                }
                replaceRenderer(e, t = !0) {
                    const n = this.renderer,
                        i = n.domElement.parentNode;
                    return this.setRenderer(e), t && null !== i && (i.removeChild(n.domElement), i.appendChild(e.domElement)), n
                }
                createDepthTexture() {
                    const e = this.depthTexture = new rs;
                    return this.inputBuffer.depthTexture = e, this.inputBuffer.dispose(), this.inputBuffer.stencilBuffer ? (e.format = pt, e.type = At) : e.type = at, e
                }
                deleteDepthTexture() {
                    if (null !== this.depthTexture) {
                        this.depthTexture.dispose(), this.depthTexture = null, this.inputBuffer.depthTexture = null, this.inputBuffer.dispose();
                        for (const e of this.passes) e.setDepthTexture(null)
                    }
                }
                createBuffer(e, t, n, i) {
                    const r = this.renderer,
                        o = null === r ? new dn : r.getDrawingBufferSize(new dn),
                        s = {
                            minFilter: nt,
                            magFilter: nt,
                            stencilBuffer: t,
                            depthBuffer: e,
                            type: n
                        },
                        a = new Kn(o.width, o.height, s);
                    return i > 0 && (a.ignoreDepthForMultisampleCopy = !1, a.samples = i), n === ot && null !== r && r.outputColorSpace === Ot && (a.texture.colorSpace = Ot), a.texture.name = "EffectComposer.Buffer", a.texture.generateMipmaps = !1, a
                }
                setMainScene(e) {
                    for (const t of this.passes) t.mainScene = e
                }
                setMainCamera(e) {
                    for (const t of this.passes) t.mainCamera = e
                }
                addPass(e, t) {
                    const n = this.passes,
                        i = this.renderer,
                        r = i.getDrawingBufferSize(new dn),
                        o = i.getContext().getContextAttributes().alpha,
                        s = this.inputBuffer.texture.type;
                    if (e.setRenderer(i), e.setSize(r.width, r.height), e.initialize(i, o, s), this.autoRenderToScreen && (n.length > 0 && (n[n.length - 1].renderToScreen = !1), e.renderToScreen && (this.autoRenderToScreen = !1)), void 0 !== t ? n.splice(t, 0, e) : n.push(e), this.autoRenderToScreen && (n[n.length - 1].renderToScreen = !0), e.needsDepthTexture || null !== this.depthTexture)
                        if (null === this.depthTexture) {
                            const t = this.createDepthTexture();
                            for (e of n) e.setDepthTexture(t)
                        } else e.setDepthTexture(this.depthTexture)
                }
                removePass(e) {
                    const t = this.passes,
                        n = t.indexOf(e);
                    if (-1 !== n && t.splice(n, 1).length > 0) {
                        if (null !== this.depthTexture) {
                            const n = (e, t) => e || t.needsDepthTexture;
                            t.reduce(n, !1) || (e.getDepthTexture() === this.depthTexture && e.setDepthTexture(null), this.deleteDepthTexture())
                        }
                        this.autoRenderToScreen && n === t.length && (e.renderToScreen = !1, t.length > 0 && (t[t.length - 1].renderToScreen = !0))
                    }
                }
                removeAllPasses() {
                    const e = this.passes;
                    this.deleteDepthTexture(), e.length > 0 && (this.autoRenderToScreen && (e[e.length - 1].renderToScreen = !1), this.passes = [])
                }
                render(e) {
                    const t = this.renderer,
                        n = this.copyPass;
                    let i, r, o, s = this.inputBuffer,
                        a = this.outputBuffer,
                        l = !1;
                    void 0 === e && (this.timer.update(), e = this.timer.getDelta());
                    for (const c of this.passes) c.enabled && (c.render(t, s, a, e, l), c.needsSwap && (l && (n.renderToScreen = c.renderToScreen, i = t.getContext(), r = t.state.buffers.stencil, r.setFunc(i.NOTEQUAL, 1, 4294967295), n.render(t, s, a, e, l), r.setFunc(i.EQUAL, 1, 4294967295)), o = s, s = a, a = o), c instanceof Ax ? l = !0 : c instanceof nx && (l = !1))
                }
                setSize(e, t, n) {
                    const i = this.renderer,
                        r = i.getSize(new dn);
                    void 0 !== e && void 0 !== t || (e = r.width, t = r.height), r.width === e && r.height === t || i.setSize(e, t, n);
                    const o = i.getDrawingBufferSize(new dn);
                    this.inputBuffer.setSize(o.width, o.height), this.outputBuffer.setSize(o.width, o.height);
                    for (const e of this.passes) e.setSize(o.width, o.height)
                }
                reset() {
                    this.dispose(), this.autoRenderToScreen = !0
                }
                dispose() {
                    for (const e of this.passes) e.dispose();
                    this.passes = [], null !== this.inputBuffer && this.inputBuffer.dispose(), null !== this.outputBuffer && this.outputBuffer.dispose(), this.deleteDepthTexture(), this.copyPass.dispose(), this.timer.dispose()
                }
            },
            ux = {
                NONE: 0,
                DEPTH: 1,
                CONVOLUTION: 2
            },
            dx = {
                FRAGMENT_HEAD: "FRAGMENT_HEAD",
                FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV",
                FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE",
                VERTEX_HEAD: "VERTEX_HEAD",
                VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT"
            },
            px = class {
                constructor() {
                    this.shaderParts = new Map([
                        [dx.FRAGMENT_HEAD, null],
                        [dx.FRAGMENT_MAIN_UV, null],
                        [dx.FRAGMENT_MAIN_IMAGE, null],
                        [dx.VERTEX_HEAD, null],
                        [dx.VERTEX_MAIN_SUPPORT, null]
                    ]), this.defines = new Map, this.uniforms = new Map, this.blendModes = new Map, this.extensions = new Set, this.attributes = ux.NONE, this.varyings = new Set, this.uvTransformation = !1, this.readDepth = !1, this.colorSpace = Nt
                }
            };
        var gx = !1,
            fx = class {
                constructor(e = null) {
                    this.originalMaterials = new Map, this.material = null, this.materials = null, this.materialsBackSide = null, this.materialsDoubleSide = null, this.materialsFlatShaded = null, this.materialsFlatShadedBackSide = null, this.materialsFlatShadedDoubleSide = null, this.setMaterial(e), this.meshCount = 0, this.replaceMaterial = e => {
                        if (e.isMesh) {
                            let t;
                            if (e.material.flatShading) switch (e.material.side) {
                                case Re:
                                    t = this.materialsFlatShadedDoubleSide;
                                    break;
                                case Me:
                                    t = this.materialsFlatShadedBackSide;
                                    break;
                                default:
                                    t = this.materialsFlatShaded
                            } else switch (e.material.side) {
                                case Re:
                                    t = this.materialsDoubleSide;
                                    break;
                                case Me:
                                    t = this.materialsBackSide;
                                    break;
                                default:
                                    t = this.materials
                            }
                            this.originalMaterials.set(e, e.material), e.isSkinnedMesh ? e.material = t[2] : e.isInstancedMesh ? e.material = t[1] : e.material = t[0], ++this.meshCount
                        }
                    }
                }
                cloneMaterial(e) {
                    if (!(e instanceof eo)) return e.clone();
                    const t = e.uniforms,
                        n = new Map;
                    for (const e in t) {
                        const i = t[e].value;
                        i.isRenderTargetTexture && (t[e].value = null, n.set(e, i))
                    }
                    const i = e.clone();
                    for (const e of n) t[e[0]].value = e[1], i.uniforms[e[0]].value = e[1];
                    return i
                }
                setMaterial(e) {
                    if (this.disposeMaterials(), this.material = e, null !== e) {
                        const t = this.materials = [this.cloneMaterial(e), this.cloneMaterial(e), this.cloneMaterial(e)];
                        for (const n of t) n.uniforms = Object.assign({}, e.uniforms), n.side = Ue;
                        t[2].skinning = !0, this.materialsBackSide = t.map((t => {
                            const n = this.cloneMaterial(t);
                            return n.uniforms = Object.assign({}, e.uniforms), n.side = Me, n
                        })), this.materialsDoubleSide = t.map((t => {
                            const n = this.cloneMaterial(t);
                            return n.uniforms = Object.assign({}, e.uniforms), n.side = Re, n
                        })), this.materialsFlatShaded = t.map((t => {
                            const n = this.cloneMaterial(t);
                            return n.uniforms = Object.assign({}, e.uniforms), n.flatShading = !0, n
                        })), this.materialsFlatShadedBackSide = t.map((t => {
                            const n = this.cloneMaterial(t);
                            return n.uniforms = Object.assign({}, e.uniforms), n.flatShading = !0, n.side = Me, n
                        })), this.materialsFlatShadedDoubleSide = t.map((t => {
                            const n = this.cloneMaterial(t);
                            return n.uniforms = Object.assign({}, e.uniforms), n.flatShading = !0, n.side = Re, n
                        }))
                    }
                }
                render(e, t, n) {
                    const i = e.shadowMap.enabled;
                    if (e.shadowMap.enabled = !1, gx) {
                        const i = this.originalMaterials;
                        this.meshCount = 0, t.traverse(this.replaceMaterial), e.render(t, n);
                        for (const e of i) e[0].material = e[1];
                        this.meshCount !== i.size && i.clear()
                    } else {
                        const i = t.overrideMaterial;
                        t.overrideMaterial = this.material, e.render(t, n), t.overrideMaterial = i
                    }
                    e.shadowMap.enabled = i
                }
                disposeMaterials() {
                    if (null !== this.material) {
                        const e = this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);
                        for (const t of e) t.dispose()
                    }
                }
                dispose() {
                    this.originalMaterials.clear(), this.disposeMaterials()
                }
                static get workaroundEnabled() {
                    return gx
                }
                static set workaroundEnabled(e) {
                    gx = e
                }
            },
            mx = -1,
            Ex = class extends en {
                constructor(e, t = -1, n = -1, i = 1) {
                    super(), this.resizable = e, this.baseSize = new dn(1, 1), this.preferredSize = new dn(t, n), this.target = this.preferredSize, this.s = i, this.effectiveSize = new dn, this.addEventListener("change", (() => this.updateEffectiveSize())), this.updateEffectiveSize()
                }
                updateEffectiveSize() {
                    const e = this.baseSize,
                        t = this.preferredSize,
                        n = this.effectiveSize,
                        i = this.scale;
                    t.width !== mx ? n.width = t.width : t.height !== mx ? n.width = Math.round(t.height * (e.width / Math.max(e.height, 1))) : n.width = Math.round(e.width * i), t.height !== mx ? n.height = t.height : t.width !== mx ? n.height = Math.round(t.width / Math.max(e.width / Math.max(e.height, 1), 1)) : n.height = Math.round(e.height * i)
                }
                get width() {
                    return this.effectiveSize.width
                }
                set width(e) {
                    this.preferredWidth = e
                }
                get height() {
                    return this.effectiveSize.height
                }
                set height(e) {
                    this.preferredHeight = e
                }
                getWidth() {
                    return this.width
                }
                getHeight() {
                    return this.height
                }
                get scale() {
                    return this.s
                }
                set scale(e) {
                    this.s !== e && (this.s = e, this.preferredSize.setScalar(mx), this.dispatchEvent({
                        type: "change"
                    }), this.resizable.setSize(this.baseSize.width, this.baseSize.height))
                }
                getScale() {
                    return this.scale
                }
                setScale(e) {
                    this.scale = e
                }
                get baseWidth() {
                    return this.baseSize.width
                }
                set baseWidth(e) {
                    this.baseSize.width !== e && (this.baseSize.width = e, this.dispatchEvent({
                        type: "change"
                    }), this.resizable.setSize(this.baseSize.width, this.baseSize.height))
                }
                getBaseWidth() {
                    return this.baseWidth
                }
                setBaseWidth(e) {
                    this.baseWidth = e
                }
                get baseHeight() {
                    return this.baseSize.height
                }
                set baseHeight(e) {
                    this.baseSize.height !== e && (this.baseSize.height = e, this.dispatchEvent({
                        type: "change"
                    }), this.resizable.setSize(this.baseSize.width, this.baseSize.height))
                }
                getBaseHeight() {
                    return this.baseHeight
                }
                setBaseHeight(e) {
                    this.baseHeight = e
                }
                setBaseSize(e, t) {
                    this.baseSize.width === e && this.baseSize.height === t || (this.baseSize.set(e, t), this.dispatchEvent({
                        type: "change"
                    }), this.resizable.setSize(this.baseSize.width, this.baseSize.height))
                }
                get preferredWidth() {
                    return this.preferredSize.width
                }
                set preferredWidth(e) {
                    this.preferredSize.width !== e && (this.preferredSize.width = e, this.dispatchEvent({
                        type: "change"
                    }), this.resizable.setSize(this.baseSize.width, this.baseSize.height))
                }
                getPreferredWidth() {
                    return this.preferredWidth
                }
                setPreferredWidth(e) {
                    this.preferredWidth = e
                }
                get preferredHeight() {
                    return this.preferredSize.height
                }
                set preferredHeight(e) {
                    this.preferredSize.height !== e && (this.preferredSize.height = e, this.dispatchEvent({
                        type: "change"
                    }), this.resizable.setSize(this.baseSize.width, this.baseSize.height))
                }
                getPreferredHeight() {
                    return this.preferredHeight
                }
                setPreferredHeight(e) {
                    this.preferredHeight = e
                }
                setPreferredSize(e, t) {
                    this.preferredSize.width === e && this.preferredSize.height === t || (this.preferredSize.set(e, t), this.dispatchEvent({
                        type: "change"
                    }), this.resizable.setSize(this.baseSize.width, this.baseSize.height))
                }
                copy(e) {
                    this.s = e.scale, this.baseSize.set(e.baseWidth, e.baseHeight), this.preferredSize.set(e.preferredWidth, e.preferredHeight), this.dispatchEvent({
                        type: "change"
                    }), this.resizable.setSize(this.baseSize.width, this.baseSize.height)
                }
                static get AUTO_SIZE() {
                    return mx
                }
            },
            Cx = class extends Set {
                constructor(e, t = 10) {
                    super(), this.l = t, this.exclusive = !1, void 0 !== e && this.set(e)
                }
                get layer() {
                    return this.l
                }
                set layer(e) {
                    const t = this.l;
                    for (const n of this) n.layers.disable(t), n.layers.enable(e);
                    this.l = e
                }
                getLayer() {
                    return this.layer
                }
                setLayer(e) {
                    this.layer = e
                }
                isExclusive() {
                    return this.exclusive
                }
                setExclusive(e) {
                    this.exclusive = e
                }
                clear() {
                    const e = this.layer;
                    for (const t of this) t.layers.disable(e);
                    return super.clear()
                }
                set(e) {
                    this.clear();
                    for (const t of e) this.add(t);
                    return this
                }
                indexOf(e) {
                    return this.has(e) ? 0 : -1
                }
                add(e) {
                    return this.exclusive ? e.layers.set(this.layer) : e.layers.enable(this.layer), super.add(e)
                }
                delete(e) {
                    return this.has(e) && e.layers.disable(this.layer), super.delete(e)
                }
                toggle(e) {
                    let t;
                    return this.has(e) ? (this.delete(e), t = !1) : (this.add(e), t = !0), t
                }
                setVisible(e) {
                    for (const t of this) e ? t.layers.enable(0) : t.layers.disable(0);
                    return this
                }
            },
            Ix = 1,
            Sx = 9,
            vx = 21,
            Bx = 23,
            xx = 24,
            yx = 28,
            wx = 30,
            bx = new Map([
                [0, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y,opacity);}"],
                [Ix, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,min(y.a,opacity));}"],
                [2, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y)*0.5,opacity);}"],
                [3, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.rg,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}"],
                [4, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(step(0.0,y)*(1.0-min(vec4(1.0),(1.0-x)/y)),vec4(1.0),step(1.0,x));return mix(x,z,opacity);}"],
                [5, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=step(0.0,x)*mix(min(vec4(1.0),x/max(1.0-y,1e-9)),vec4(1.0),step(1.0,y));return mix(x,z,opacity);}"],
                [6, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x,y),opacity);}"],
                [7, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,abs(x-y),opacity);}"],
                [8, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x/max(y,1e-12),opacity);}"],
                [Sx, null],
                [10, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y-2.0*x*y),opacity);}"],
                [11, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 a=min(x,1.0),b=min(y,1.0);vec4 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,y));return mix(x,z,opacity);}"],
                [12, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,step(1.0,x+y),opacity);}"],
                [13, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.r,xHSL.gb));return vec4(mix(x.rgb,z,opacity),y.a);}"],
                [14, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-y,opacity);}"],
                [15, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y*(1.0-x),opacity);}"],
                [16, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x,y),opacity);}"],
                [17, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(y+x-1.0,0.0,1.0),opacity);}"],
                [18, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x+y,1.0),opacity);}"],
                [19, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(2.0*y+x-1.0,0.0,1.0),opacity);}"],
                [20, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.rg,yHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}"],
                [vx, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x*y,opacity);}"],
                [22, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-abs(1.0-x-y),opacity);}"],
                [Bx, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}"],
                [xx, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(2.0*y*x,1.0-2.0*(1.0-y)*(1.0-x),step(0.5,x));return mix(x,z,opacity);}"],
                [25, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 z=mix(mix(y2,x,step(0.5*x,y)),max(vec4(0.0),y2-1.0),step(x,(y2-1.0)));return mix(x,z,opacity);}"],
                [26, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(min(x*x/max(1.0-y,1e-12),1.0),y,step(1.0,y));return mix(x,z,opacity);}"],
                [27, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.r,yHSL.g,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}"],
                [yx, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y-min(x*y,1.0),opacity);}"],
                [29, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 w=step(0.5,y);vec4 z=mix(x-(1.0-y2)*x*(1.0-x),mix(x+(y2-1.0)*(sqrt(x)-x),x+(y2-1.0)*x*((16.0*x-12.0)*x+3.0),w*(1.0-step(0.25,x))),w);return mix(x,z,opacity);}"],
                [wx, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}"],
                [31, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x+y-1.0,0.0),opacity);}"],
                [32, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(max(1.0-min((1.0-x)/(2.0*y),1.0),0.0),min(x/(2.0*(1.0-y)),1.0),step(0.5,y));return mix(x,z,opacity);}"]
            ]),
            Qx = class extends en {
                constructor(e, t = 1) {
                    super(), this._blendFunction = e, this.opacity = new jA(t)
                }
                getOpacity() {
                    return this.opacity.value
                }
                setOpacity(e) {
                    this.opacity.value = e
                }
                get blendFunction() {
                    return this._blendFunction
                }
                set blendFunction(e) {
                    this._blendFunction = e, this.dispatchEvent({
                        type: "change"
                    })
                }
                getBlendFunction() {
                    return this.blendFunction
                }
                setBlendFunction(e) {
                    this.blendFunction = e
                }
                getShaderCode() {
                    return bx.get(this.blendFunction)
                }
            },
            Ux = 2,
            Mx = 3,
            Rx = [new Float32Array([0, 0]), new Float32Array([0, 1, 1]), new Float32Array([0, 1, 1, 2]), new Float32Array([0, 1, 2, 2, 3]), new Float32Array([0, 1, 2, 3, 4, 4, 5]), new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10])],
            Tx = class extends eo {
                constructor(e = new kn) {
                    super({
                        name: "KawaseBlurMaterial",
                        uniforms: {
                            inputBuffer: new jA(null),
                            texelSize: new jA(new kn),
                            scale: new jA(1),
                            kernel: new jA(0)
                        },
                        blending: 0,
                        toneMapped: !1,
                        depthWrite: !1,
                        depthTest: !1,
                        fragmentShader: "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nvarying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;\n#include <colorspace_fragment>\n}",
                        vertexShader: "uniform vec4 texelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}"
                    }), this.fragmentShader = rx(this.fragmentShader), this.setTexelSize(e.x, e.y), this.kernelSize = Ux
                }
                set inputBuffer(e) {
                    this.uniforms.inputBuffer.value = e
                }
                setInputBuffer(e) {
                    this.inputBuffer = e
                }
                get kernelSequence() {
                    return Rx[this.kernelSize]
                }
                get scale() {
                    return this.uniforms.scale.value
                }
                set scale(e) {
                    this.uniforms.scale.value = e
                }
                getScale() {
                    return this.uniforms.scale.value
                }
                setScale(e) {
                    this.uniforms.scale.value = e
                }
                getKernel() {
                    return null
                }
                get kernel() {
                    return this.uniforms.kernel.value
                }
                set kernel(e) {
                    this.uniforms.kernel.value = e
                }
                setKernel(e) {
                    this.kernel = e
                }
                setTexelSize(e, t) {
                    this.uniforms.texelSize.value.set(e, t, .5 * e, .5 * t)
                }
                setSize(e, t) {
                    const n = 1 / e,
                        i = 1 / t;
                    this.uniforms.texelSize.value.set(n, i, .5 * n, .5 * i)
                }
            },
            Fx = class extends tx {
                constructor({
                    kernelSize: e = Ux,
                    resolutionScale: t = .5,
                    width: n = Ex.AUTO_SIZE,
                    height: i = Ex.AUTO_SIZE,
                    resolutionX: r = n,
                    resolutionY: o = i
                } = {}) {
                    super("KawaseBlurPass"), this.renderTargetA = new Kn(1, 1, {
                        depthBuffer: !1
                    }), this.renderTargetA.texture.name = "Blur.Target.A", this.renderTargetB = this.renderTargetA.clone(), this.renderTargetB.texture.name = "Blur.Target.B";
                    const s = this.resolution = new Ex(this, r, o, t);
                    s.addEventListener("change", (e => this.setSize(s.baseWidth, s.baseHeight))), this._blurMaterial = new Tx, this._blurMaterial.kernelSize = e, this.copyMaterial = new sx
                }
                getResolution() {
                    return this.resolution
                }
                get blurMaterial() {
                    return this._blurMaterial
                }
                set blurMaterial(e) {
                    this._blurMaterial = e
                }
                get dithering() {
                    return this.copyMaterial.dithering
                }
                set dithering(e) {
                    this.copyMaterial.dithering = e
                }
                get kernelSize() {
                    return this.blurMaterial.kernelSize
                }
                set kernelSize(e) {
                    this.blurMaterial.kernelSize = e
                }
                get width() {
                    return this.resolution.width
                }
                set width(e) {
                    this.resolution.preferredWidth = e
                }
                get height() {
                    return this.resolution.height
                }
                set height(e) {
                    this.resolution.preferredHeight = e
                }
                get scale() {
                    return this.blurMaterial.scale
                }
                set scale(e) {
                    this.blurMaterial.scale = e
                }
                getScale() {
                    return this.blurMaterial.scale
                }
                setScale(e) {
                    this.blurMaterial.scale = e
                }
                getKernelSize() {
                    return this.kernelSize
                }
                setKernelSize(e) {
                    this.kernelSize = e
                }
                getResolutionScale() {
                    return this.resolution.scale
                }
                setResolutionScale(e) {
                    this.resolution.scale = e
                }
                render(e, t, n, i, r) {
                    const o = this.scene,
                        s = this.camera,
                        a = this.renderTargetA,
                        l = this.renderTargetB,
                        c = this.blurMaterial,
                        A = c.kernelSequence;
                    let h = t;
                    this.fullscreenMaterial = c;
                    for (let t = 0, n = A.length; t < n; ++t) {
                        const n = 1 & t ? l : a;
                        c.kernel = A[t], c.inputBuffer = h.texture, e.setRenderTarget(n), e.render(o, s), h = n
                    }
                    this.fullscreenMaterial = this.copyMaterial, this.copyMaterial.inputBuffer = h.texture, e.setRenderTarget(this.renderToScreen ? null : n), e.render(o, s)
                }
                setSize(e, t) {
                    const n = this.resolution;
                    n.setBaseSize(e, t);
                    const i = n.width,
                        r = n.height;
                    this.renderTargetA.setSize(i, r), this.renderTargetB.setSize(i, r), this.blurMaterial.setSize(e, t)
                }
                initialize(e, t, n) {
                    void 0 !== n && (this.renderTargetA.texture.type = n, this.renderTargetB.texture.type = n, n !== ot ? (this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1", this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1") : null !== e && e.outputColorSpace === Ot && (this.renderTargetA.texture.colorSpace = Ot, this.renderTargetB.texture.colorSpace = Ot))
                }
                static get AUTO_SIZE() {
                    return Ex.AUTO_SIZE
                }
            },
            Dx = class extends eo {
                constructor(e = !1, t = null) {
                    super({
                        name: "LuminanceMaterial",
                        defines: {
                            THREE_REVISION: ye.replace(/\D+/g, "")
                        },
                        uniforms: {
                            inputBuffer: new jA(null),
                            threshold: new jA(0),
                            smoothing: new jA(1),
                            range: new jA(null)
                        },
                        blending: 0,
                        toneMapped: !1,
                        depthWrite: !1,
                        depthTest: !1,
                        fragmentShader: "#include <common>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#ifdef RANGE\nuniform vec2 range;\n#elif defined(THRESHOLD)\nuniform float threshold;uniform float smoothing;\n#endif\nvarying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);\n#ifdef RANGE\nfloat low=step(range.x,l);float high=step(l,range.y);l*=low*high;\n#elif defined(THRESHOLD)\nl=smoothstep(threshold,threshold+smoothing,l)*l;\n#endif\n#ifdef COLOR\ngl_FragColor=vec4(texel.rgb*clamp(l,0.0,1.0),l);\n#else\ngl_FragColor=vec4(l);\n#endif\n}",
                        vertexShader: ox
                    }), this.colorOutput = e, this.luminanceRange = t
                }
                set inputBuffer(e) {
                    this.uniforms.inputBuffer.value = e
                }
                setInputBuffer(e) {
                    this.uniforms.inputBuffer.value = e
                }
                get threshold() {
                    return this.uniforms.threshold.value
                }
                set threshold(e) {
                    this.smoothing > 0 || e > 0 ? this.defines.THRESHOLD = "1" : delete this.defines.THRESHOLD, this.uniforms.threshold.value = e
                }
                getThreshold() {
                    return this.threshold
                }
                setThreshold(e) {
                    this.threshold = e
                }
                get smoothing() {
                    return this.uniforms.smoothing.value
                }
                set smoothing(e) {
                    this.threshold > 0 || e > 0 ? this.defines.THRESHOLD = "1" : delete this.defines.THRESHOLD, this.uniforms.smoothing.value = e
                }
                getSmoothingFactor() {
                    return this.smoothing
                }
                setSmoothingFactor(e) {
                    this.smoothing = e
                }
                get useThreshold() {
                    return this.threshold > 0 || this.smoothing > 0
                }
                set useThreshold(e) {}
                get colorOutput() {
                    return void 0 !== this.defines.COLOR
                }
                set colorOutput(e) {
                    e ? this.defines.COLOR = "1" : delete this.defines.COLOR, this.needsUpdate = !0
                }
                isColorOutputEnabled(e) {
                    return this.colorOutput
                }
                setColorOutputEnabled(e) {
                    this.colorOutput = e
                }
                get useRange() {
                    return null !== this.luminanceRange
                }
                set useRange(e) {
                    this.luminanceRange = null
                }
                get luminanceRange() {
                    return this.uniforms.range.value
                }
                set luminanceRange(e) {
                    null !== e ? this.defines.RANGE = "1" : delete this.defines.RANGE, this.uniforms.range.value = e, this.needsUpdate = !0
                }
                getLuminanceRange() {
                    return this.luminanceRange
                }
                setLuminanceRange(e) {
                    this.luminanceRange = e
                }
            },
            kx = class extends tx {
                constructor({
                    renderTarget: e,
                    luminanceRange: t,
                    colorOutput: n,
                    resolutionScale: i = 1,
                    width: r = Ex.AUTO_SIZE,
                    height: o = Ex.AUTO_SIZE,
                    resolutionX: s = r,
                    resolutionY: a = o
                } = {}) {
                    super("LuminancePass"), this.fullscreenMaterial = new Dx(n, t), this.needsSwap = !1, this.renderTarget = e, void 0 === this.renderTarget && (this.renderTarget = new Kn(1, 1, {
                        depthBuffer: !1
                    }), this.renderTarget.texture.name = "LuminancePass.Target");
                    const l = this.resolution = new Ex(this, s, a, i);
                    l.addEventListener("change", (e => this.setSize(l.baseWidth, l.baseHeight)))
                }
                get texture() {
                    return this.renderTarget.texture
                }
                getTexture() {
                    return this.renderTarget.texture
                }
                getResolution() {
                    return this.resolution
                }
                render(e, t, n, i, r) {
                    this.fullscreenMaterial.inputBuffer = t.texture, e.setRenderTarget(this.renderToScreen ? null : this.renderTarget), e.render(this.scene, this.camera)
                }
                setSize(e, t) {
                    const n = this.resolution;
                    n.setBaseSize(e, t), this.renderTarget.setSize(n.width, n.height)
                }
                initialize(e, t, n) {
                    void 0 !== n && n !== ot && (this.renderTarget.texture.type = n, this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1")
                }
            },
            Lx = class extends eo {
                constructor() {
                    super({
                        name: "DownsamplingMaterial",
                        uniforms: {
                            inputBuffer: new jA(null),
                            texelSize: new jA(new dn)
                        },
                        blending: 0,
                        toneMapped: !1,
                        depthWrite: !1,
                        depthTest: !1,
                        fragmentShader: "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#define WEIGHT_INNER 0.125\n#define WEIGHT_OUTER 0.0555555\nvarying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;float clampToBorder(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void main(){vec4 c=vec4(0.0);vec4 w=WEIGHT_INNER*vec4(clampToBorder(vUv00),clampToBorder(vUv01),clampToBorder(vUv02),clampToBorder(vUv03));c+=w.x*texture2D(inputBuffer,vUv00);c+=w.y*texture2D(inputBuffer,vUv01);c+=w.z*texture2D(inputBuffer,vUv02);c+=w.w*texture2D(inputBuffer,vUv03);w=WEIGHT_OUTER*vec4(clampToBorder(vUv04),clampToBorder(vUv05),clampToBorder(vUv06),clampToBorder(vUv07));c+=w.x*texture2D(inputBuffer,vUv04);c+=w.y*texture2D(inputBuffer,vUv05);c+=w.z*texture2D(inputBuffer,vUv06);c+=w.w*texture2D(inputBuffer,vUv07);w=WEIGHT_OUTER*vec4(clampToBorder(vUv08),clampToBorder(vUv09),clampToBorder(vUv10),clampToBorder(vUv11));c+=w.x*texture2D(inputBuffer,vUv08);c+=w.y*texture2D(inputBuffer,vUv09);c+=w.z*texture2D(inputBuffer,vUv10);c+=w.w*texture2D(inputBuffer,vUv11);c+=WEIGHT_OUTER*texture2D(inputBuffer,vUv);gl_FragColor=c;\n#include <colorspace_fragment>\n}",
                        vertexShader: "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;void main(){vUv=position.xy*0.5+0.5;vUv00=vUv+texelSize*vec2(-1.0,1.0);vUv01=vUv+texelSize*vec2(1.0,1.0);vUv02=vUv+texelSize*vec2(-1.0,-1.0);vUv03=vUv+texelSize*vec2(1.0,-1.0);vUv04=vUv+texelSize*vec2(-2.0,2.0);vUv05=vUv+texelSize*vec2(0.0,2.0);vUv06=vUv+texelSize*vec2(2.0,2.0);vUv07=vUv+texelSize*vec2(-2.0,0.0);vUv08=vUv+texelSize*vec2(2.0,0.0);vUv09=vUv+texelSize*vec2(-2.0,-2.0);vUv10=vUv+texelSize*vec2(0.0,-2.0);vUv11=vUv+texelSize*vec2(2.0,-2.0);gl_Position=vec4(position.xy,1.0,1.0);}"
                    }), this.fragmentShader = rx(this.fragmentShader)
                }
                set inputBuffer(e) {
                    this.uniforms.inputBuffer.value = e
                }
                setSize(e, t) {
                    this.uniforms.texelSize.value.set(1 / e, 1 / t)
                }
            },
            Kx = class extends eo {
                constructor() {
                    super({
                        name: "UpsamplingMaterial",
                        uniforms: {
                            inputBuffer: new jA(null),
                            supportBuffer: new jA(null),
                            texelSize: new jA(new dn),
                            radius: new jA(.85)
                        },
                        blending: 0,
                        toneMapped: !1,
                        depthWrite: !1,
                        depthTest: !1,
                        fragmentShader: "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;uniform mediump sampler2D supportBuffer;\n#else\nuniform lowp sampler2D inputBuffer;uniform lowp sampler2D supportBuffer;\n#endif\nuniform float radius;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vec4 c=vec4(0.0);c+=texture2D(inputBuffer,vUv0)*0.0625;c+=texture2D(inputBuffer,vUv1)*0.125;c+=texture2D(inputBuffer,vUv2)*0.0625;c+=texture2D(inputBuffer,vUv3)*0.125;c+=texture2D(inputBuffer,vUv)*0.25;c+=texture2D(inputBuffer,vUv4)*0.125;c+=texture2D(inputBuffer,vUv5)*0.0625;c+=texture2D(inputBuffer,vUv6)*0.125;c+=texture2D(inputBuffer,vUv7)*0.0625;vec4 baseColor=texture2D(supportBuffer,vUv);gl_FragColor=mix(baseColor,c,radius);\n#include <colorspace_fragment>\n}",
                        vertexShader: "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,1.0);vUv1=vUv+texelSize*vec2(0.0,1.0);vUv2=vUv+texelSize*vec2(1.0,1.0);vUv3=vUv+texelSize*vec2(-1.0,0.0);vUv4=vUv+texelSize*vec2(1.0,0.0);vUv5=vUv+texelSize*vec2(-1.0,-1.0);vUv6=vUv+texelSize*vec2(0.0,-1.0);vUv7=vUv+texelSize*vec2(1.0,-1.0);gl_Position=vec4(position.xy,1.0,1.0);}"
                    }), this.fragmentShader = rx(this.fragmentShader)
                }
                set inputBuffer(e) {
                    this.uniforms.inputBuffer.value = e
                }
                set supportBuffer(e) {
                    this.uniforms.supportBuffer.value = e
                }
                get radius() {
                    return this.uniforms.radius.value
                }
                set radius(e) {
                    this.uniforms.radius.value = e
                }
                setSize(e, t) {
                    this.uniforms.texelSize.value.set(1 / e, 1 / t)
                }
            },
            Px = class extends tx {
                constructor() {
                    super("MipmapBlurPass"), this.needsSwap = !1, this.renderTarget = new Kn(1, 1, {
                        depthBuffer: !1
                    }), this.renderTarget.texture.name = "Upsampling.Mipmap0", this.downsamplingMipmaps = [], this.upsamplingMipmaps = [], this.downsamplingMaterial = new Lx, this.upsamplingMaterial = new Kx, this.resolution = new dn
                }
                get texture() {
                    return this.renderTarget.texture
                }
                get levels() {
                    return this.downsamplingMipmaps.length
                }
                set levels(e) {
                    if (this.levels !== e) {
                        const t = this.renderTarget;
                        this.dispose(), this.downsamplingMipmaps = [], this.upsamplingMipmaps = [];
                        for (let n = 0; n < e; ++n) {
                            const e = t.clone();
                            e.texture.name = "Downsampling.Mipmap" + n, this.downsamplingMipmaps.push(e)
                        }
                        this.upsamplingMipmaps.push(t);
                        for (let n = 1, i = e - 1; n < i; ++n) {
                            const e = t.clone();
                            e.texture.name = "Upsampling.Mipmap" + n, this.upsamplingMipmaps.push(e)
                        }
                        this.setSize(this.resolution.x, this.resolution.y)
                    }
                }
                get radius() {
                    return this.upsamplingMaterial.radius
                }
                set radius(e) {
                    this.upsamplingMaterial.radius = e
                }
                render(e, t, n, i, r) {
                    const {
                        scene: o,
                        camera: s
                    } = this, {
                        downsamplingMaterial: a,
                        upsamplingMaterial: l
                    } = this, {
                        downsamplingMipmaps: c,
                        upsamplingMipmaps: A
                    } = this;
                    let h = t;
                    this.fullscreenMaterial = a;
                    for (let t = 0, n = c.length; t < n; ++t) {
                        const n = c[t];
                        a.setSize(h.width, h.height), a.inputBuffer = h.texture, e.setRenderTarget(n), e.render(o, s), h = n
                    }
                    this.fullscreenMaterial = l;
                    for (let t = A.length - 1; t >= 0; --t) {
                        const n = A[t];
                        l.setSize(h.width, h.height), l.inputBuffer = h.texture, l.supportBuffer = c[t].texture, e.setRenderTarget(n), e.render(o, s), h = n
                    }
                }
                setSize(e, t) {
                    const n = this.resolution;
                    n.set(e, t);
                    let i = n.width,
                        r = n.height;
                    for (let e = 0, t = this.downsamplingMipmaps.length; e < t; ++e) i = Math.round(.5 * i), r = Math.round(.5 * r), this.downsamplingMipmaps[e].setSize(i, r), e < this.upsamplingMipmaps.length && this.upsamplingMipmaps[e].setSize(i, r)
                }
                initialize(e, t, n) {
                    if (void 0 !== n) {
                        const t = this.downsamplingMipmaps.concat(this.upsamplingMipmaps);
                        for (const e of t) e.texture.type = n;
                        if (n !== ot) this.downsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1", this.upsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
                        else if (null !== e && e.outputColorSpace === Ot)
                            for (const e of t) e.texture.colorSpace = Ot
                    }
                }
                dispose() {
                    super.dispose();
                    for (const e of this.downsamplingMipmaps.concat(this.upsamplingMipmaps)) e.dispose()
                }
            },
            Gx = class extends en {
                constructor(e, t, {
                    attributes: n = ux.NONE,
                    blendFunction: i = Bx,
                    defines: r = new Map,
                    uniforms: o = new Map,
                    extensions: s = null,
                    vertexShader: a = null
                } = {}) {
                    super(), this.name = e, this.renderer = null, this.attributes = n, this.fragmentShader = t, this.vertexShader = a, this.defines = r, this.uniforms = o, this.extensions = s, this.blendMode = new Qx(i), this.blendMode.addEventListener("change", (e => this.setChanged())), this._inputColorSpace = Nt, this._outputColorSpace = Vt
                }
                get inputColorSpace() {
                    return this._inputColorSpace
                }
                set inputColorSpace(e) {
                    this._inputColorSpace = e, this.setChanged()
                }
                get outputColorSpace() {
                    return this._outputColorSpace
                }
                set outputColorSpace(e) {
                    this._outputColorSpace = e, this.setChanged()
                }
                set mainScene(e) {}
                set mainCamera(e) {}
                getName() {
                    return this.name
                }
                setRenderer(e) {
                    this.renderer = e
                }
                getDefines() {
                    return this.defines
                }
                getUniforms() {
                    return this.uniforms
                }
                getExtensions() {
                    return this.extensions
                }
                getBlendMode() {
                    return this.blendMode
                }
                getAttributes() {
                    return this.attributes
                }
                setAttributes(e) {
                    this.attributes = e, this.setChanged()
                }
                getFragmentShader() {
                    return this.fragmentShader
                }
                setFragmentShader(e) {
                    this.fragmentShader = e, this.setChanged()
                }
                getVertexShader() {
                    return this.vertexShader
                }
                setVertexShader(e) {
                    this.vertexShader = e, this.setChanged()
                }
                setChanged() {
                    this.dispatchEvent({
                        type: "change"
                    })
                }
                setDepthTexture(e, t = 3200) {}
                update(e, t, n) {}
                setSize(e, t) {}
                initialize(e, t, n) {}
                dispose() {
                    for (const e of Object.keys(this)) {
                        const t = this[e];
                        (t instanceof Kn || t instanceof cr || t instanceof Dn || t instanceof tx) && this[e].dispose()
                    }
                }
            },
            Vx = class extends Gx {
                constructor({
                    blendFunction: e = yx,
                    luminanceThreshold: t = .9,
                    luminanceSmoothing: n = .025,
                    mipmapBlur: i = !1,
                    intensity: r = 1,
                    radius: o = .85,
                    levels: s = 8,
                    kernelSize: a = Mx,
                    resolutionScale: l = .5,
                    width: c = Ex.AUTO_SIZE,
                    height: A = Ex.AUTO_SIZE,
                    resolutionX: h = c,
                    resolutionY: u = A
                } = {}) {
                    super("BloomEffect", "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D map;\n#else\nuniform lowp sampler2D map;\n#endif\nuniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 texel=texture2D(map,uv);outputColor=vec4(texel.rgb*intensity,texel.a);}", {
                        blendFunction: e,
                        uniforms: new Map([
                            ["map", new jA(null)],
                            ["intensity", new jA(r)]
                        ])
                    }), this.renderTarget = new Kn(1, 1, {
                        depthBuffer: !1
                    }), this.renderTarget.texture.name = "Bloom.Target", this.blurPass = new Fx({
                        kernelSize: a
                    }), this.luminancePass = new kx({
                        colorOutput: !0
                    }), this.luminanceMaterial.threshold = t, this.luminanceMaterial.smoothing = n, this.mipmapBlurPass = new Px, this.mipmapBlurPass.enabled = i, this.mipmapBlurPass.radius = o, this.mipmapBlurPass.levels = s, this.uniforms.get("map").value = i ? this.mipmapBlurPass.texture : this.renderTarget.texture;
                    const d = this.resolution = new Ex(this, h, u, l);
                    d.addEventListener("change", (e => this.setSize(d.baseWidth, d.baseHeight)))
                }
                get texture() {
                    return this.mipmapBlurPass.enabled ? this.mipmapBlurPass.texture : this.renderTarget.texture
                }
                getTexture() {
                    return this.texture
                }
                getResolution() {
                    return this.resolution
                }
                getBlurPass() {
                    return this.blurPass
                }
                getLuminancePass() {
                    return this.luminancePass
                }
                get luminanceMaterial() {
                    return this.luminancePass.fullscreenMaterial
                }
                getLuminanceMaterial() {
                    return this.luminancePass.fullscreenMaterial
                }
                get width() {
                    return this.resolution.width
                }
                set width(e) {
                    this.resolution.preferredWidth = e
                }
                get height() {
                    return this.resolution.height
                }
                set height(e) {
                    this.resolution.preferredHeight = e
                }
                get dithering() {
                    return this.blurPass.dithering
                }
                set dithering(e) {
                    this.blurPass.dithering = e
                }
                get kernelSize() {
                    return this.blurPass.kernelSize
                }
                set kernelSize(e) {
                    this.blurPass.kernelSize = e
                }
                get distinction() {
                    return console.warn(this.name, "distinction was removed"), 1
                }
                set distinction(e) {
                    console.warn(this.name, "distinction was removed")
                }
                get intensity() {
                    return this.uniforms.get("intensity").value
                }
                set intensity(e) {
                    this.uniforms.get("intensity").value = e
                }
                getIntensity() {
                    return this.intensity
                }
                setIntensity(e) {
                    this.intensity = e
                }
                getResolutionScale() {
                    return this.resolution.scale
                }
                setResolutionScale(e) {
                    this.resolution.scale = e
                }
                update(e, t, n) {
                    const i = this.renderTarget,
                        r = this.luminancePass;
                    r.enabled ? (r.render(e, t), this.mipmapBlurPass.enabled ? this.mipmapBlurPass.render(e, r.renderTarget) : this.blurPass.render(e, r.renderTarget, i)) : this.mipmapBlurPass.enabled ? this.mipmapBlurPass.render(e, t) : this.blurPass.render(e, t, i)
                }
                setSize(e, t) {
                    const n = this.resolution;
                    n.setBaseSize(e, t), this.renderTarget.setSize(n.width, n.height), this.blurPass.resolution.copy(n), this.luminancePass.setSize(e, t), this.mipmapBlurPass.setSize(e, t)
                }
                initialize(e, t, n) {
                    this.blurPass.initialize(e, t, n), this.luminancePass.initialize(e, t, n), this.mipmapBlurPass.initialize(e, t, n), void 0 !== n && (this.renderTarget.texture.type = n, null !== e && e.outputColorSpace === Ot && (this.renderTarget.texture.colorSpace = Ot))
                }
            },
            Ox = class extends Gx {
                constructor({
                    blendFunction: e = wx,
                    brightness: t = 0,
                    contrast: n = 0
                } = {}) {
                    super("BrightnessContrastEffect", "uniform float brightness;uniform float contrast;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=inputColor.rgb+vec3(brightness-0.5);if(contrast>0.0){color/=vec3(1.0-contrast);}else{color*=vec3(1.0+contrast);}outputColor=vec4(color+vec3(0.5),inputColor.a);}", {
                        blendFunction: e,
                        uniforms: new Map([
                            ["brightness", new jA(t)],
                            ["contrast", new jA(n)]
                        ])
                    }), this.inputColorSpace = Ot
                }
                get brightness() {
                    return this.uniforms.get("brightness").value
                }
                set brightness(e) {
                    this.uniforms.get("brightness").value = e
                }
                getBrightness() {
                    return this.brightness
                }
                setBrightness(e) {
                    this.brightness = e
                }
                get contrast() {
                    return this.uniforms.get("contrast").value
                }
                set contrast(e) {
                    this.uniforms.get("contrast").value = e
                }
                getContrast() {
                    return this.contrast
                }
                setContrast(e) {
                    this.contrast = e
                }
            },
            Nx = class extends Gx {
                constructor({
                    blendFunction: e,
                    bits: t = 16
                } = {}) {
                    super("ColorDepthEffect", "uniform float factor;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=vec4(floor(inputColor.rgb*factor+0.5)/factor,inputColor.a);}", {
                        blendFunction: e,
                        uniforms: new Map([
                            ["factor", new jA(1)]
                        ])
                    }), this.bits = 0, this.bitDepth = t
                }
                get bitDepth() {
                    return this.bits
                }
                set bitDepth(e) {
                    this.bits = e, this.uniforms.get("factor").value = Math.pow(2, e / 3)
                }
                getBitDepth() {
                    return this.bitDepth
                }
                setBitDepth(e) {
                    this.bitDepth = e
                }
            },
            Hx = 0,
            qx = 1,
            jx = 0,
            Yx = 3,
            Jx = class extends eo {
                constructor(e = !1, t = !1) {
                    super({
                        name: "BokehMaterial",
                        defines: {
                            PASS: e ? "2" : "1"
                        },
                        uniforms: {
                            inputBuffer: new jA(null),
                            cocBuffer: new jA(null),
                            texelSize: new jA(new dn),
                            kernel64: new jA(null),
                            kernel16: new jA(null),
                            scale: new jA(1)
                        },
                        blending: 0,
                        toneMapped: !1,
                        depthWrite: !1,
                        depthTest: !1,
                        fragmentShader: "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#if PASS == 1\nuniform vec4 kernel64[32];\n#else\nuniform vec4 kernel16[8];\n#endif\nuniform lowp sampler2D cocBuffer;uniform vec2 texelSize;uniform float scale;varying vec2 vUv;void main(){\n#ifdef FOREGROUND\nvec2 cocNearFar=texture2D(cocBuffer,vUv).rg*scale;float coc=cocNearFar.x;\n#else\nfloat coc=texture2D(cocBuffer,vUv).g*scale;\n#endif\nif(coc==0.0){gl_FragColor=texture2D(inputBuffer,vUv);}else{\n#ifdef FOREGROUND\nvec2 step=texelSize*max(cocNearFar.x,cocNearFar.y);\n#else\nvec2 step=texelSize*coc;\n#endif\n#if PASS == 1\nvec4 acc=vec4(0.0);for(int i=0;i<32;++i){vec4 kernel=kernel64[i];vec2 uv=step*kernel.xy+vUv;acc+=texture2D(inputBuffer,uv);uv=step*kernel.zw+vUv;acc+=texture2D(inputBuffer,uv);}gl_FragColor=acc/64.0;\n#else\nvec4 maxValue=texture2D(inputBuffer,vUv);for(int i=0;i<8;++i){vec4 kernel=kernel16[i];vec2 uv=step*kernel.xy+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);uv=step*kernel.zw+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);}gl_FragColor=maxValue;\n#endif\n}}",
                        vertexShader: ox
                    }), t && (this.defines.FOREGROUND = "1"), this.generateKernel()
                }
                set inputBuffer(e) {
                    this.uniforms.inputBuffer.value = e
                }
                setInputBuffer(e) {
                    this.uniforms.inputBuffer.value = e
                }
                set cocBuffer(e) {
                    this.uniforms.cocBuffer.value = e
                }
                setCoCBuffer(e) {
                    this.uniforms.cocBuffer.value = e
                }
                get scale() {
                    return this.uniforms.scale.value
                }
                set scale(e) {
                    this.uniforms.scale.value = e
                }
                getScale(e) {
                    return this.scale
                }
                setScale(e) {
                    this.scale = e
                }
                generateKernel() {
                    const e = new Float64Array(128),
                        t = new Float64Array(32);
                    let n = 0,
                        i = 0;
                    for (let r = 0, o = Math.sqrt(80); r < 80; ++r) {
                        const s = 2.39996323 * r,
                            a = Math.sqrt(r) / o,
                            l = a * Math.cos(s),
                            c = a * Math.sin(s);
                        r % 5 == 0 ? (t[i++] = l, t[i++] = c) : (e[n++] = l, e[n++] = c)
                    }
                    this.uniforms.kernel64.value = e, this.uniforms.kernel16.value = t
                }
                setTexelSize(e, t) {
                    this.uniforms.texelSize.value.set(e, t)
                }
                setSize(e, t) {
                    this.uniforms.texelSize.value.set(1 / e, 1 / t)
                }
            };

        function Wx(e, t, n) {
            return e * (t - n) - t
        }

        function zx(e, t, n) {
            return Math.min(Math.max((e + t) / (t - n), 0), 1)
        }
        var Xx = class extends eo {
                constructor(e) {
                    super({
                        name: "CircleOfConfusionMaterial",
                        defines: {
                            DEPTH_PACKING: "0"
                        },
                        uniforms: {
                            depthBuffer: new jA(null),
                            focusDistance: new jA(0),
                            focusRange: new jA(0),
                            cameraNear: new jA(.3),
                            cameraFar: new jA(1e3)
                        },
                        blending: 0,
                        toneMapped: !1,
                        depthWrite: !1,
                        depthTest: !1,
                        fragmentShader: "#include <common>\n#include <packing>\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform float focusDistance;uniform float focusRange;uniform float cameraNear;uniform float cameraFar;varying vec2 vUv;float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nfloat depth=unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nfloat depth=texture2D(depthBuffer,uv).r;\n#endif\n#ifdef LOG_DEPTH\nfloat d=pow(2.0,depth*log2(cameraFar+1.0))-1.0;float a=cameraFar/(cameraFar-cameraNear);float b=cameraFar*cameraNear/(cameraNear-cameraFar);depth=a+b/d;\n#endif\nreturn depth;}void main(){float depth=readDepth(vUv);\n#ifdef PERSPECTIVE_CAMERA\nfloat viewZ=perspectiveDepthToViewZ(depth,cameraNear,cameraFar);float linearDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);\n#else\nfloat linearDepth=depth;\n#endif\nfloat signedDistance=linearDepth-focusDistance;float magnitude=smoothstep(0.0,focusRange,abs(signedDistance));gl_FragColor.rg=magnitude*vec2(step(signedDistance,0.0),step(0.0,signedDistance));}",
                        vertexShader: ox
                    }), this.uniforms.focalLength = this.uniforms.focusRange, this.copyCameraSettings(e)
                }
                get near() {
                    return this.uniforms.cameraNear.value
                }
                get far() {
                    return this.uniforms.cameraFar.value
                }
                set depthBuffer(e) {
                    this.uniforms.depthBuffer.value = e
                }
                set depthPacking(e) {
                    this.defines.DEPTH_PACKING = e.toFixed(0), this.needsUpdate = !0
                }
                setDepthBuffer(e, t = 3200) {
                    this.depthBuffer = e, this.depthPacking = t
                }
                get focusDistance() {
                    return this.uniforms.focusDistance.value
                }
                set focusDistance(e) {
                    this.uniforms.focusDistance.value = e
                }
                get worldFocusDistance() {
                    return -Wx(this.focusDistance, this.near, this.far)
                }
                set worldFocusDistance(e) {
                    this.focusDistance = zx(-e, this.near, this.far)
                }
                getFocusDistance(e) {
                    this.uniforms.focusDistance.value = e
                }
                setFocusDistance(e) {
                    this.uniforms.focusDistance.value = e
                }
                get focalLength() {
                    return this.focusRange
                }
                set focalLength(e) {
                    this.focusRange = e
                }
                get focusRange() {
                    return this.uniforms.focusRange.value
                }
                set focusRange(e) {
                    this.uniforms.focusRange.value = e
                }
                get worldFocusRange() {
                    return -Wx(this.focusRange, this.near, this.far)
                }
                set worldFocusRange(e) {
                    this.focusRange = zx(-e, this.near, this.far)
                }
                getFocalLength(e) {
                    return this.focusRange
                }
                setFocalLength(e) {
                    this.focusRange = e
                }
                adoptCameraSettings(e) {
                    this.copyCameraSettings(e)
                }
                copyCameraSettings(e) {
                    e && (this.uniforms.cameraNear.value = e.near, this.uniforms.cameraFar.value = e.far, e instanceof oo ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0)
                }
            },
            Zx = class extends eo {
                constructor(e = null) {
                    super({
                        name: "MaskMaterial",
                        uniforms: {
                            maskTexture: new jA(e),
                            inputBuffer: new jA(null),
                            strength: new jA(1)
                        },
                        blending: 0,
                        toneMapped: !1,
                        depthWrite: !1,
                        depthTest: !1,
                        fragmentShader: "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#ifdef MASK_PRECISION_HIGH\nuniform mediump sampler2D maskTexture;\n#else\nuniform lowp sampler2D maskTexture;\n#endif\n#if MASK_FUNCTION != 0\nuniform float strength;\n#endif\nvarying vec2 vUv;void main(){\n#if COLOR_CHANNEL == 0\nfloat mask=texture2D(maskTexture,vUv).r;\n#elif COLOR_CHANNEL == 1\nfloat mask=texture2D(maskTexture,vUv).g;\n#elif COLOR_CHANNEL == 2\nfloat mask=texture2D(maskTexture,vUv).b;\n#else\nfloat mask=texture2D(maskTexture,vUv).a;\n#endif\n#if MASK_FUNCTION == 0\n#ifdef INVERTED\nmask=step(mask,0.0);\n#else\nmask=1.0-step(mask,0.0);\n#endif\n#else\nmask=clamp(mask*strength,0.0,1.0);\n#ifdef INVERTED\nmask=1.0-mask;\n#endif\n#endif\n#if MASK_FUNCTION == 3\nvec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=vec4(mask*texel.rgb,texel.a);\n#elif MASK_FUNCTION == 2\ngl_FragColor=vec4(mask*texture2D(inputBuffer,vUv).rgb,mask);\n#else\ngl_FragColor=mask*texture2D(inputBuffer,vUv);\n#endif\n}",
                        vertexShader: ox
                    }), this.colorChannel = Hx, this.maskFunction = jx
                }
                set inputBuffer(e) {
                    this.uniforms.inputBuffer.value = e
                }
                setInputBuffer(e) {
                    this.uniforms.inputBuffer.value = e
                }
                set maskTexture(e) {
                    this.uniforms.maskTexture.value = e, delete this.defines.MASK_PRECISION_HIGH, e.type !== ot && (this.defines.MASK_PRECISION_HIGH = "1"), this.needsUpdate = !0
                }
                setMaskTexture(e) {
                    this.maskTexture = e
                }
                set colorChannel(e) {
                    this.defines.COLOR_CHANNEL = e.toFixed(0), this.needsUpdate = !0
                }
                setColorChannel(e) {
                    this.colorChannel = e
                }
                set maskFunction(e) {
                    this.defines.MASK_FUNCTION = e.toFixed(0), this.needsUpdate = !0
                }
                setMaskFunction(e) {
                    this.maskFunction = e
                }
                get inverted() {
                    return void 0 !== this.defines.INVERTED
                }
                set inverted(e) {
                    this.inverted && !e ? delete this.defines.INVERTED : e && (this.defines.INVERTED = "1"), this.needsUpdate = !0
                }
                isInverted() {
                    return this.inverted
                }
                setInverted(e) {
                    this.inverted = e
                }
                get strength() {
                    return this.uniforms.strength.value
                }
                set strength(e) {
                    this.uniforms.strength.value = e
                }
                getStrength() {
                    return this.strength
                }
                setStrength(e) {
                    this.strength = e
                }
            },
            _x = class extends tx {
                constructor(e, t = "inputBuffer") {
                    super("ShaderPass"), this.fullscreenMaterial = e, this.input = t
                }
                setInput(e) {
                    this.input = e
                }
                render(e, t, n, i, r) {
                    const o = this.fullscreenMaterial.uniforms;
                    null !== t && void 0 !== o && void 0 !== o[this.input] && (o[this.input].value = t.texture), e.setRenderTarget(this.renderToScreen ? null : n), e.render(this.scene, this.camera)
                }
                initialize(e, t, n) {
                    void 0 !== n && n !== ot && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1")
                }
            },
            $x = class extends Gx {
                constructor(e, {
                    blendFunction: t,
                    worldFocusDistance: n,
                    worldFocusRange: i,
                    focusDistance: r = 0,
                    focalLength: o = .1,
                    focusRange: s = o,
                    bokehScale: a = 1,
                    resolutionScale: l = 1,
                    width: c = Ex.AUTO_SIZE,
                    height: A = Ex.AUTO_SIZE,
                    resolutionX: h = c,
                    resolutionY: u = A
                } = {}) {
                    super("DepthOfFieldEffect", "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D nearColorBuffer;uniform mediump sampler2D farColorBuffer;\n#else\nuniform lowp sampler2D nearColorBuffer;uniform lowp sampler2D farColorBuffer;\n#endif\nuniform lowp sampler2D nearCoCBuffer;uniform lowp sampler2D farCoCBuffer;uniform float scale;void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){vec4 colorNear=texture2D(nearColorBuffer,uv);vec4 colorFar=texture2D(farColorBuffer,uv);\n#if MASK_FUNCTION == 1\nvec2 cocNearFar=vec2(texture2D(nearCoCBuffer,uv).r,colorFar.a);cocNearFar.x=min(cocNearFar.x*scale,1.0);\n#else\nvec2 cocNearFar=vec2(texture2D(nearCoCBuffer,uv).r,texture2D(farCoCBuffer,uv).g);cocNearFar=min(cocNearFar*scale,1.0);\n#endif\nvec4 result=inputColor*(1.0-cocNearFar.y)+colorFar;result=mix(result,colorNear,cocNearFar.x);outputColor=result;}", {
                        blendFunction: t,
                        attributes: ux.DEPTH,
                        uniforms: new Map([
                            ["nearColorBuffer", new jA(null)],
                            ["farColorBuffer", new jA(null)],
                            ["nearCoCBuffer", new jA(null)],
                            ["farCoCBuffer", new jA(null)],
                            ["scale", new jA(1)]
                        ])
                    }), this.camera = e, this.renderTarget = new Kn(1, 1, {
                        depthBuffer: !1
                    }), this.renderTarget.texture.name = "DoF.Intermediate", this.renderTargetMasked = this.renderTarget.clone(), this.renderTargetMasked.texture.name = "DoF.Masked.Far", this.renderTargetNear = this.renderTarget.clone(), this.renderTargetNear.texture.name = "DoF.Bokeh.Near", this.uniforms.get("nearColorBuffer").value = this.renderTargetNear.texture, this.renderTargetFar = this.renderTarget.clone(), this.renderTargetFar.texture.name = "DoF.Bokeh.Far", this.uniforms.get("farColorBuffer").value = this.renderTargetFar.texture, this.renderTargetCoC = this.renderTarget.clone(), this.renderTargetCoC.texture.name = "DoF.CoC", this.uniforms.get("farCoCBuffer").value = this.renderTargetCoC.texture, this.renderTargetCoCBlurred = this.renderTargetCoC.clone(), this.renderTargetCoCBlurred.texture.name = "DoF.CoC.Blurred", this.uniforms.get("nearCoCBuffer").value = this.renderTargetCoCBlurred.texture, this.cocPass = new _x(new Xx(e));
                    const d = this.cocMaterial;
                    d.focusDistance = r, d.focusRange = s, void 0 !== n && (d.worldFocusDistance = n), void 0 !== i && (d.worldFocusRange = i), this.blurPass = new Fx({
                        resolutionScale: l,
                        resolutionX: h,
                        resolutionY: u,
                        kernelSize: Ux
                    }), this.maskPass = new _x(new Zx(this.renderTargetCoC.texture));
                    this.maskPass.fullscreenMaterial.colorChannel = qx, this.maskFunction = Yx, this.bokehNearBasePass = new _x(new Jx(!1, !0)), this.bokehNearBasePass.fullscreenMaterial.cocBuffer = this.renderTargetCoCBlurred.texture, this.bokehNearFillPass = new _x(new Jx(!0, !0)), this.bokehNearFillPass.fullscreenMaterial.cocBuffer = this.renderTargetCoCBlurred.texture, this.bokehFarBasePass = new _x(new Jx(!1, !1)), this.bokehFarBasePass.fullscreenMaterial.cocBuffer = this.renderTargetCoC.texture, this.bokehFarFillPass = new _x(new Jx(!0, !1)), this.bokehFarFillPass.fullscreenMaterial.cocBuffer = this.renderTargetCoC.texture, this.target = null;
                    const p = this.resolution = new Ex(this, h, u, l);
                    p.addEventListener("change", (e => this.setSize(p.baseWidth, p.baseHeight))), this.bokehScale = a
                }
                set mainCamera(e) {
                    this.camera = e, this.cocMaterial.copyCameraSettings(e)
                }
                get cocTexture() {
                    return this.renderTargetCoC.texture
                }
                get maskFunction() {
                    return this.maskPass.fullscreenMaterial.maskFunction
                }
                set maskFunction(e) {
                    this.maskFunction !== e && (this.defines.set("MASK_FUNCTION", e.toFixed(0)), this.maskPass.fullscreenMaterial.maskFunction = e, this.setChanged())
                }
                get cocMaterial() {
                    return this.cocPass.fullscreenMaterial
                }
                get circleOfConfusionMaterial() {
                    return this.cocMaterial
                }
                getCircleOfConfusionMaterial() {
                    return this.cocMaterial
                }
                getBlurPass() {
                    return this.blurPass
                }
                getResolution() {
                    return this.resolution
                }
                get bokehScale() {
                    return this.uniforms.get("scale").value
                }
                set bokehScale(e) {
                    this.bokehNearBasePass.fullscreenMaterial.scale = e, this.bokehNearFillPass.fullscreenMaterial.scale = e, this.bokehFarBasePass.fullscreenMaterial.scale = e, this.bokehFarFillPass.fullscreenMaterial.scale = e, this.maskPass.fullscreenMaterial.strength = e, this.uniforms.get("scale").value = e
                }
                getBokehScale() {
                    return this.bokehScale
                }
                setBokehScale(e) {
                    this.bokehScale = e
                }
                getTarget() {
                    return this.target
                }
                setTarget(e) {
                    this.target = e
                }
                calculateFocusDistance(e) {
                    const t = this.camera;
                    return zx(-t.position.distanceTo(e), t.near, t.far)
                }
                setDepthTexture(e, t = 3200) {
                    this.cocMaterial.depthBuffer = e, this.cocMaterial.depthPacking = t
                }
                update(e, t, n) {
                    const i = this.renderTarget,
                        r = this.renderTargetCoC,
                        o = this.renderTargetCoCBlurred,
                        s = this.renderTargetMasked;
                    if (null !== this.target) {
                        const e = this.calculateFocusDistance(this.target);
                        this.cocMaterial.focusDistance = e
                    }
                    this.cocPass.render(e, null, r), this.blurPass.render(e, r, o), this.maskPass.render(e, t, s), this.bokehFarBasePass.render(e, s, i), this.bokehFarFillPass.render(e, i, this.renderTargetFar), this.bokehNearBasePass.render(e, t, i), this.bokehNearFillPass.render(e, i, this.renderTargetNear)
                }
                setSize(e, t) {
                    const n = this.resolution;
                    n.setBaseSize(e, t);
                    const i = n.width,
                        r = n.height;
                    this.cocPass.setSize(e, t), this.blurPass.setSize(e, t), this.maskPass.setSize(e, t), this.renderTargetFar.setSize(e, t), this.renderTargetCoC.setSize(e, t), this.renderTargetMasked.setSize(e, t), this.renderTarget.setSize(i, r), this.renderTargetNear.setSize(i, r), this.renderTargetCoCBlurred.setSize(i, r), this.bokehNearBasePass.fullscreenMaterial.setSize(e, t), this.bokehNearFillPass.fullscreenMaterial.setSize(e, t), this.bokehFarBasePass.fullscreenMaterial.setSize(e, t), this.bokehFarFillPass.fullscreenMaterial.setSize(e, t)
                }
                initialize(e, t, n) {
                    this.cocPass.initialize(e, t, n), this.maskPass.initialize(e, t, n), this.bokehNearBasePass.initialize(e, t, n), this.bokehNearFillPass.initialize(e, t, n), this.bokehFarBasePass.initialize(e, t, n), this.bokehFarFillPass.initialize(e, t, n), this.blurPass.initialize(e, t, ot), e.capabilities.logarithmicDepthBuffer && (this.cocPass.fullscreenMaterial.defines.LOG_DEPTH = "1"), void 0 !== n && (this.renderTarget.texture.type = n, this.renderTargetNear.texture.type = n, this.renderTargetFar.texture.type = n, this.renderTargetMasked.texture.type = n, null !== e && e.outputColorSpace === Ot && (this.renderTarget.texture.colorSpace = Ot, this.renderTargetNear.texture.colorSpace = Ot, this.renderTargetFar.texture.colorSpace = Ot, this.renderTargetMasked.texture.colorSpace = Ot))
                }
            };
        var ey = class extends tx {
                constructor(e, t, n = null) {
                    super("RenderPass", e, t), this.needsSwap = !1, this.clearPass = new cx, this.overrideMaterialManager = null === n ? null : new fx(n), this.ignoreBackground = !1, this.skipShadowMapUpdate = !1, this.selection = null
                }
                set mainScene(e) {
                    this.scene = e
                }
                set mainCamera(e) {
                    this.camera = e
                }
                get renderToScreen() {
                    return super.renderToScreen
                }
                set renderToScreen(e) {
                    super.renderToScreen = e, this.clearPass.renderToScreen = e
                }
                get overrideMaterial() {
                    const e = this.overrideMaterialManager;
                    return null !== e ? e.material : null
                }
                set overrideMaterial(e) {
                    const t = this.overrideMaterialManager;
                    null !== e ? null !== t ? t.setMaterial(e) : this.overrideMaterialManager = new fx(e) : null !== t && (t.dispose(), this.overrideMaterialManager = null)
                }
                getOverrideMaterial() {
                    return this.overrideMaterial
                }
                setOverrideMaterial(e) {
                    this.overrideMaterial = e
                }
                get clear() {
                    return this.clearPass.enabled
                }
                set clear(e) {
                    this.clearPass.enabled = e
                }
                getSelection() {
                    return this.selection
                }
                setSelection(e) {
                    this.selection = e
                }
                isBackgroundDisabled() {
                    return this.ignoreBackground
                }
                setBackgroundDisabled(e) {
                    this.ignoreBackground = e
                }
                isShadowMapDisabled() {
                    return this.skipShadowMapUpdate
                }
                setShadowMapDisabled(e) {
                    this.skipShadowMapUpdate = e
                }
                getClearPass() {
                    return this.clearPass
                }
                render(e, t, n, i, r) {
                    const o = this.scene,
                        s = this.camera,
                        a = this.selection,
                        l = s.layers.mask,
                        c = o.background,
                        A = e.shadowMap.autoUpdate,
                        h = this.renderToScreen ? null : t;
                    null !== a && s.layers.set(a.getLayer()), this.skipShadowMapUpdate && (e.shadowMap.autoUpdate = !1), (this.ignoreBackground || null !== this.clearPass.overrideClearColor) && (o.background = null), this.clearPass.enabled && this.clearPass.render(e, t), e.setRenderTarget(h), null !== this.overrideMaterialManager ? this.overrideMaterialManager.render(e, o, s) : e.render(o, s), s.layers.mask = l, o.background = c, e.shadowMap.autoUpdate = A
                }
            },
            ty = class extends Gx {
                constructor({
                    blendFunction: e = wx,
                    hue: t = 0,
                    saturation: n = 0
                } = {}) {
                    super("HueSaturationEffect", "uniform vec3 hue;uniform float saturation;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,hue.xyz),dot(inputColor.rgb,hue.zxy),dot(inputColor.rgb,hue.yzx));float average=(color.r+color.g+color.b)/3.0;vec3 diff=average-color;if(saturation>0.0){color+=diff*(1.0-1.0/(1.001-saturation));}else{color+=diff*-saturation;}outputColor=vec4(min(color,1.0),inputColor.a);}", {
                        blendFunction: e,
                        uniforms: new Map([
                            ["hue", new jA(new On)],
                            ["saturation", new jA(n)]
                        ])
                    }), this.hue = t
                }
                get saturation() {
                    return this.uniforms.get("saturation").value
                }
                set saturation(e) {
                    this.uniforms.get("saturation").value = e
                }
                getSaturation() {
                    return this.saturation
                }
                setSaturation(e) {
                    this.saturation = e
                }
                get hue() {
                    const e = this.uniforms.get("hue").value;
                    return Math.acos((3 * e.x - 1) / 2)
                }
                set hue(e) {
                    const t = Math.sin(e),
                        n = Math.cos(e);
                    this.uniforms.get("hue").value.set((2 * n + 1) / 3, (-Math.sqrt(3) * t - n + 1) / 3, (Math.sqrt(3) * t - n + 1) / 3)
                }
                getHue() {
                    return this.hue
                }
                setHue(e) {
                    this.hue = e
                }
            };
        var ny = 2,
            iy = 0,
            ry = 0,
            oy = 1,
            sy = 2,
            ay = 3,
            ly = 0,
            cy = 1,
            Ay = class extends Gx {
                constructor({
                    blendFunction: e = yx,
                    premultiply: t = !1
                } = {}) {
                    super("NoiseEffect", "void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 noise=vec3(rand(uv*(1.0+time)));\n#ifdef PREMULTIPLY\noutputColor=vec4(min(inputColor.rgb*noise,vec3(1.0)),inputColor.a);\n#else\noutputColor=vec4(noise,inputColor.a);\n#endif\n}", {
                        blendFunction: e
                    }), this.premultiply = t
                }
                get premultiply() {
                    return this.defines.has("PREMULTIPLY")
                }
                set premultiply(e) {
                    this.premultiply !== e && (e ? this.defines.set("PREMULTIPLY", "1") : this.defines.delete("PREMULTIPLY"), this.setChanged())
                }
                isPremultiplied() {
                    return this.premultiply
                }
                setPremultiplied(e) {
                    this.premultiply = e
                }
            },
            hy = class extends Gx {
                constructor(e = 30) {
                    super("PixelationEffect", "uniform bool active;uniform vec4 d;void mainUv(inout vec2 uv){if(active){uv=d.xy*(floor(uv*d.zw)+0.5);}}", {
                        uniforms: new Map([
                            ["active", new jA(!1)],
                            ["d", new jA(new kn)]
                        ])
                    }), this.resolution = new dn, this._granularity = 0, this.granularity = e
                }
                get granularity() {
                    return this._granularity
                }
                set granularity(e) {
                    let t = Math.floor(e);
                    t % 2 > 0 && (t += 1), this._granularity = t, this.uniforms.get("active").value = t > 0, this.setSize(this.resolution.width, this.resolution.height)
                }
                getGranularity() {
                    return this.granularity
                }
                setGranularity(e) {
                    this.granularity = e
                }
                setSize(e, t) {
                    const n = this.resolution;
                    n.set(e, t);
                    const i = this.granularity,
                        r = i / n.x,
                        o = i / n.y;
                    this.uniforms.get("d").value.set(r, o, 1 / r, 1 / o)
                }
            },
            uy = (Math.PI, class extends eo {
                constructor(e = new dn, t = ny) {
                    super({
                        name: "EdgeDetectionMaterial",
                        defines: {
                            THREE_REVISION: ye.replace(/\D+/g, ""),
                            LOCAL_CONTRAST_ADAPTATION_FACTOR: "2.0",
                            EDGE_THRESHOLD: "0.1",
                            DEPTH_THRESHOLD: "0.01",
                            PREDICATION_MODE: "0",
                            PREDICATION_THRESHOLD: "0.01",
                            PREDICATION_SCALE: "2.0",
                            PREDICATION_STRENGTH: "1.0",
                            DEPTH_PACKING: "0"
                        },
                        uniforms: {
                            inputBuffer: new jA(null),
                            depthBuffer: new jA(null),
                            predicationBuffer: new jA(null),
                            texelSize: new jA(e)
                        },
                        blending: 0,
                        toneMapped: !1,
                        depthWrite: !1,
                        depthTest: !1,
                        fragmentShader: "varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\n#if EDGE_DETECTION_MODE != 0\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\n#endif\n#if EDGE_DETECTION_MODE == 1\n#include <common>\n#endif\n#if EDGE_DETECTION_MODE == 0 || PREDICATION_MODE == 1\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}vec3 gatherNeighbors(){float p=readDepth(vUv);float pLeft=readDepth(vUv0);float pTop=readDepth(vUv1);return vec3(p,pLeft,pTop);}\n#elif PREDICATION_MODE == 2\nuniform sampler2D predicationBuffer;vec3 gatherNeighbors(){float p=texture2D(predicationBuffer,vUv).r;float pLeft=texture2D(predicationBuffer,vUv0).r;float pTop=texture2D(predicationBuffer,vUv1).r;return vec3(p,pLeft,pTop);}\n#endif\n#if PREDICATION_MODE != 0\nvec2 calculatePredicatedThreshold(){vec3 neighbours=gatherNeighbors();vec2 delta=abs(neighbours.xx-neighbours.yz);vec2 edges=step(PREDICATION_THRESHOLD,delta);return PREDICATION_SCALE*EDGE_THRESHOLD*(1.0-PREDICATION_STRENGTH*edges);}\n#endif\n#if EDGE_DETECTION_MODE != 0\nuniform sampler2D inputBuffer;\n#endif\nvoid main(){\n#if EDGE_DETECTION_MODE == 0\nconst vec2 threshold=vec2(DEPTH_THRESHOLD);\n#elif PREDICATION_MODE != 0\nvec2 threshold=calculatePredicatedThreshold();\n#else\nconst vec2 threshold=vec2(EDGE_THRESHOLD);\n#endif\n#if EDGE_DETECTION_MODE == 0\nvec3 neighbors=gatherNeighbors();vec2 delta=abs(neighbors.xx-vec2(neighbors.y,neighbors.z));vec2 edges=step(threshold,delta);if(dot(edges,vec2(1.0))==0.0){discard;}gl_FragColor=vec4(edges,0.0,1.0);\n#elif EDGE_DETECTION_MODE == 1\nfloat l=luminance(texture2D(inputBuffer,vUv).rgb);float lLeft=luminance(texture2D(inputBuffer,vUv0).rgb);float lTop=luminance(texture2D(inputBuffer,vUv1).rgb);vec4 delta;delta.xy=abs(l-vec2(lLeft,lTop));vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}float lRight=luminance(texture2D(inputBuffer,vUv2).rgb);float lBottom=luminance(texture2D(inputBuffer,vUv3).rgb);delta.zw=abs(l-vec2(lRight,lBottom));vec2 maxDelta=max(delta.xy,delta.zw);float lLeftLeft=luminance(texture2D(inputBuffer,vUv4).rgb);float lTopTop=luminance(texture2D(inputBuffer,vUv5).rgb);delta.zw=abs(vec2(lLeft,lTop)-vec2(lLeftLeft,lTopTop));maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges.xy*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\n#elif EDGE_DETECTION_MODE == 2\nvec4 delta;vec3 c=texture2D(inputBuffer,vUv).rgb;vec3 cLeft=texture2D(inputBuffer,vUv0).rgb;vec3 t=abs(c-cLeft);delta.x=max(max(t.r,t.g),t.b);vec3 cTop=texture2D(inputBuffer,vUv1).rgb;t=abs(c-cTop);delta.y=max(max(t.r,t.g),t.b);vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}vec3 cRight=texture2D(inputBuffer,vUv2).rgb;t=abs(c-cRight);delta.z=max(max(t.r,t.g),t.b);vec3 cBottom=texture2D(inputBuffer,vUv3).rgb;t=abs(c-cBottom);delta.w=max(max(t.r,t.g),t.b);vec2 maxDelta=max(delta.xy,delta.zw);vec3 cLeftLeft=texture2D(inputBuffer,vUv4).rgb;t=abs(c-cLeftLeft);delta.z=max(max(t.r,t.g),t.b);vec3 cTopTop=texture2D(inputBuffer,vUv5).rgb;t=abs(c-cTopTop);delta.w=max(max(t.r,t.g),t.b);maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\n#endif\n}",
                        vertexShader: "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\n#if EDGE_DETECTION_MODE != 0\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\n#endif\nvoid main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,0.0);vUv1=vUv+texelSize*vec2(0.0,-1.0);\n#if EDGE_DETECTION_MODE != 0\nvUv2=vUv+texelSize*vec2(1.0,0.0);vUv3=vUv+texelSize*vec2(0.0,1.0);vUv4=vUv+texelSize*vec2(-2.0,0.0);vUv5=vUv+texelSize*vec2(0.0,-2.0);\n#endif\ngl_Position=vec4(position.xy,1.0,1.0);}"
                    }), this.edgeDetectionMode = t
                }
                set depthBuffer(e) {
                    this.uniforms.depthBuffer.value = e
                }
                set depthPacking(e) {
                    this.defines.DEPTH_PACKING = e.toFixed(0), this.needsUpdate = !0
                }
                setDepthBuffer(e, t = 3200) {
                    this.depthBuffer = e, this.depthPacking = t
                }
                get edgeDetectionMode() {
                    return Number(this.defines.EDGE_DETECTION_MODE)
                }
                set edgeDetectionMode(e) {
                    this.defines.EDGE_DETECTION_MODE = e.toFixed(0), this.needsUpdate = !0
                }
                getEdgeDetectionMode() {
                    return this.edgeDetectionMode
                }
                setEdgeDetectionMode(e) {
                    this.edgeDetectionMode = e
                }
                get localContrastAdaptationFactor() {
                    return Number(this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR)
                }
                set localContrastAdaptationFactor(e) {
                    this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR = e.toFixed("6"), this.needsUpdate = !0
                }
                getLocalContrastAdaptationFactor() {
                    return this.localContrastAdaptationFactor
                }
                setLocalContrastAdaptationFactor(e) {
                    this.localContrastAdaptationFactor = e
                }
                get edgeDetectionThreshold() {
                    return Number(this.defines.EDGE_THRESHOLD)
                }
                set edgeDetectionThreshold(e) {
                    this.defines.EDGE_THRESHOLD = e.toFixed("6"), this.defines.DEPTH_THRESHOLD = (.1 * e).toFixed("6"), this.needsUpdate = !0
                }
                getEdgeDetectionThreshold() {
                    return this.edgeDetectionThreshold
                }
                setEdgeDetectionThreshold(e) {
                    this.edgeDetectionThreshold = e
                }
                get predicationMode() {
                    return Number(this.defines.PREDICATION_MODE)
                }
                set predicationMode(e) {
                    this.defines.PREDICATION_MODE = e.toFixed(0), this.needsUpdate = !0
                }
                getPredicationMode() {
                    return this.predicationMode
                }
                setPredicationMode(e) {
                    this.predicationMode = e
                }
                set predicationBuffer(e) {
                    this.uniforms.predicationBuffer.value = e
                }
                setPredicationBuffer(e) {
                    this.uniforms.predicationBuffer.value = e
                }
                get predicationThreshold() {
                    return Number(this.defines.PREDICATION_THRESHOLD)
                }
                set predicationThreshold(e) {
                    this.defines.PREDICATION_THRESHOLD = e.toFixed("6"), this.needsUpdate = !0
                }
                getPredicationThreshold() {
                    return this.predicationThreshold
                }
                setPredicationThreshold(e) {
                    this.predicationThreshold = e
                }
                get predicationScale() {
                    return Number(this.defines.PREDICATION_SCALE)
                }
                set predicationScale(e) {
                    this.defines.PREDICATION_SCALE = e.toFixed("6"), this.needsUpdate = !0
                }
                getPredicationScale() {
                    return this.predicationScale
                }
                setPredicationScale(e) {
                    this.predicationScale = e
                }
                get predicationStrength() {
                    return Number(this.defines.PREDICATION_STRENGTH)
                }
                set predicationStrength(e) {
                    this.defines.PREDICATION_STRENGTH = e.toFixed("6"), this.needsUpdate = !0
                }
                getPredicationStrength() {
                    return this.predicationStrength
                }
                setPredicationStrength(e) {
                    this.predicationStrength = e
                }
                setSize(e, t) {
                    this.uniforms.texelSize.value.set(1 / e, 1 / t)
                }
            }),
            dy = class extends eo {
                constructor(e = new dn, t = new dn) {
                    super({
                        name: "SMAAWeightsMaterial",
                        defines: {
                            MAX_SEARCH_STEPS_INT: "16",
                            MAX_SEARCH_STEPS_FLOAT: "16.0",
                            MAX_SEARCH_STEPS_DIAG_INT: "8",
                            MAX_SEARCH_STEPS_DIAG_FLOAT: "8.0",
                            CORNER_ROUNDING: "25",
                            CORNER_ROUNDING_NORM: "0.25",
                            AREATEX_MAX_DISTANCE: "16.0",
                            AREATEX_MAX_DISTANCE_DIAG: "20.0",
                            AREATEX_PIXEL_SIZE: "(1.0 / vec2(160.0, 560.0))",
                            AREATEX_SUBTEX_SIZE: "(1.0 / 7.0)",
                            SEARCHTEX_SIZE: "vec2(66.0, 33.0)",
                            SEARCHTEX_PACKED_SIZE: "vec2(64.0, 16.0)"
                        },
                        uniforms: {
                            inputBuffer: new jA(null),
                            searchTexture: new jA(null),
                            areaTexture: new jA(null),
                            resolution: new jA(t),
                            texelSize: new jA(e)
                        },
                        blending: 0,
                        toneMapped: !1,
                        depthWrite: !1,
                        depthTest: !1,
                        fragmentShader: "#define sampleLevelZeroOffset(t, coord, offset) texture2D(t, coord + offset * texelSize)\n#if __VERSION__ < 300\n#define round(v) floor(v + 0.5)\n#endif\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform lowp sampler2D areaTexture;uniform lowp sampler2D searchTexture;uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}vec2 decodeDiagBilinearAccess(in vec2 e){e.r=e.r*abs(5.0*e.r-5.0*0.75);return round(e);}vec4 decodeDiagBilinearAccess(in vec4 e){e.rb=e.rb*abs(5.0*e.rb-5.0*0.75);return round(e);}vec2 searchDiag1(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 searchDiag2(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);coord.x+=0.25*texelSize.x;vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;e=decodeDiagBilinearAccess(e);coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 areaDiag(const in vec2 dist,const in vec2 e,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE_DIAG,AREATEX_MAX_DISTANCE_DIAG)*e+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.x+=0.5;texCoord.y+=AREATEX_SUBTEX_SIZE*offset;return texture2D(areaTexture,texCoord).rg;}vec2 calculateDiagWeights(const in vec2 texCoord,const in vec2 e,const in vec4 subsampleIndices){vec2 weights=vec2(0.0);vec4 d;vec2 end;if(e.r>0.0){d.xz=searchDiag1(texCoord,vec2(-1.0,1.0),end);d.x+=float(end.y>0.9);}else{d.xz=vec2(0.0);}d.yw=searchDiag1(texCoord,vec2(1.0,-1.0),end);if(d.x+d.y>2.0){vec4 coords=vec4(-d.x+0.25,d.x,d.y,-d.y-0.25)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.xy=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).rg;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).rg;c.yxwz=decodeDiagBilinearAccess(c.xyzw);vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.z);}d.xz=searchDiag2(texCoord,vec2(-1.0,-1.0),end);if(sampleLevelZeroOffset(inputBuffer,texCoord,vec2(1,0)).r>0.0){d.yw=searchDiag2(texCoord,vec2(1.0),end);d.y+=float(end.y>0.9);}else{d.yw=vec2(0.0);}if(d.x+d.y>2.0){vec4 coords=vec4(-d.x,-d.x,d.y,d.y)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.x=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).g;c.y=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(0,-1)).r;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).gr;vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.w).gr;}return weights;}float searchLength(const in vec2 e,const in float offset){vec2 scale=SEARCHTEX_SIZE*vec2(0.5,-1.0);vec2 bias=SEARCHTEX_SIZE*vec2(offset,1.0);scale+=vec2(-1.0,1.0);bias+=vec2(0.5,-0.5);scale*=1.0/SEARCHTEX_PACKED_SIZE;bias*=1.0/SEARCHTEX_PACKED_SIZE;return texture2D(searchTexture,scale*e+bias).r;}float searchXLeft(in vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x>end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(-2.0,0.0)*texelSize+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.0)+3.25;return texelSize.x*offset+texCoord.x;}float searchXRight(vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x<end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(2.0,0.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.5)+3.25;return-texelSize.x*offset+texCoord.x;}float searchYUp(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.y>end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=-vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.0)+3.25;return texelSize.y*offset+texCoord.y;}float searchYDown(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;i++){if(!(texCoord.y<end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.5)+3.25;return-texelSize.y*offset+texCoord.y;}vec2 area(const in vec2 dist,const in float e1,const in float e2,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE)*round(4.0*vec2(e1,e2))+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.y=AREATEX_SUBTEX_SIZE*offset+texCoord.y;return texture2D(areaTexture,texCoord).rg;}void detectHorizontalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\n#if !defined(DISABLE_CORNER_DETECTION)\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,1)).r;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).r;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,-2)).r;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,-2)).r;weights*=clamp(factor,0.0,1.0);\n#endif\n}void detectVerticalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\n#if !defined(DISABLE_CORNER_DETECTION)\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(1,0)).g;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).g;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(-2,0)).g;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(-2,1)).g;weights*=clamp(factor,0.0,1.0);\n#endif\n}void main(){vec4 weights=vec4(0.0);vec4 subsampleIndices=vec4(0.0);vec2 e=texture2D(inputBuffer,vUv).rg;if(e.g>0.0){\n#if !defined(DISABLE_DIAG_DETECTION)\nweights.rg=calculateDiagWeights(vUv,e,subsampleIndices);if(weights.r==-weights.g){\n#endif\nvec2 d;vec3 coords;coords.x=searchXLeft(vOffset[0].xy,vOffset[2].x);coords.y=vOffset[1].y;d.x=coords.x;float e1=texture2D(inputBuffer,coords.xy).r;coords.z=searchXRight(vOffset[0].zw,vOffset[2].y);d.y=coords.z;d=round(resolution.xx*d+-vPixCoord.xx);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.zy,vec2(1,0)).r;weights.rg=area(sqrtD,e1,e2,subsampleIndices.y);coords.y=vUv.y;detectHorizontalCornerPattern(weights.rg,coords.xyzy,d);\n#if !defined(DISABLE_DIAG_DETECTION)\n}else{e.r=0.0;}\n#endif\n}if(e.r>0.0){vec2 d;vec3 coords;coords.y=searchYUp(vOffset[1].xy,vOffset[2].z);coords.x=vOffset[0].x;d.x=coords.y;float e1=texture2D(inputBuffer,coords.xy).g;coords.z=searchYDown(vOffset[1].zw,vOffset[2].w);d.y=coords.z;d=round(resolution.yy*d-vPixCoord.yy);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.xz,vec2(0,1)).g;weights.ba=area(sqrtD,e1,e2,subsampleIndices.x);coords.x=vUv.x;detectVerticalCornerPattern(weights.ba,coords.xyxz,d);}gl_FragColor=weights;}",
                        vertexShader: "uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void main(){vUv=position.xy*0.5+0.5;vPixCoord=vUv*resolution;vOffset[0]=vUv.xyxy+texelSize.xyxy*vec4(-0.25,-0.125,1.25,-0.125);vOffset[1]=vUv.xyxy+texelSize.xyxy*vec4(-0.125,-0.25,-0.125,1.25);vOffset[2]=vec4(vOffset[0].xz,vOffset[1].yw)+vec4(-2.0,2.0,-2.0,2.0)*texelSize.xxyy*MAX_SEARCH_STEPS_FLOAT;gl_Position=vec4(position.xy,1.0,1.0);}"
                    })
                }
                set inputBuffer(e) {
                    this.uniforms.inputBuffer.value = e
                }
                setInputBuffer(e) {
                    this.uniforms.inputBuffer.value = e
                }
                get searchTexture() {
                    return this.uniforms.searchTexture.value
                }
                set searchTexture(e) {
                    this.uniforms.searchTexture.value = e
                }
                get areaTexture() {
                    return this.uniforms.areaTexture.value
                }
                set areaTexture(e) {
                    this.uniforms.areaTexture.value = e
                }
                setLookupTextures(e, t) {
                    this.searchTexture = e, this.areaTexture = t
                }
                get orthogonalSearchSteps() {
                    return Number(this.defines.MAX_SEARCH_STEPS_INT)
                }
                set orthogonalSearchSteps(e) {
                    const t = Math.min(Math.max(e, 0), 112);
                    this.defines.MAX_SEARCH_STEPS_INT = t.toFixed("0"), this.defines.MAX_SEARCH_STEPS_FLOAT = t.toFixed("1"), this.needsUpdate = !0
                }
                setOrthogonalSearchSteps(e) {
                    this.orthogonalSearchSteps = e
                }
                get diagonalSearchSteps() {
                    return Number(this.defines.MAX_SEARCH_STEPS_DIAG_INT)
                }
                set diagonalSearchSteps(e) {
                    const t = Math.min(Math.max(e, 0), 20);
                    this.defines.MAX_SEARCH_STEPS_DIAG_INT = t.toFixed("0"), this.defines.MAX_SEARCH_STEPS_DIAG_FLOAT = t.toFixed("1"), this.needsUpdate = !0
                }
                setDiagonalSearchSteps(e) {
                    this.diagonalSearchSteps = e
                }
                get diagonalDetection() {
                    return void 0 === this.defines.DISABLE_DIAG_DETECTION
                }
                set diagonalDetection(e) {
                    e ? delete this.defines.DISABLE_DIAG_DETECTION : this.defines.DISABLE_DIAG_DETECTION = "1", this.needsUpdate = !0
                }
                isDiagonalDetectionEnabled() {
                    return this.diagonalDetection
                }
                setDiagonalDetectionEnabled(e) {
                    this.diagonalDetection = e
                }
                get cornerRounding() {
                    return Number(this.defines.CORNER_ROUNDING)
                }
                set cornerRounding(e) {
                    const t = Math.min(Math.max(e, 0), 100);
                    this.defines.CORNER_ROUNDING = t.toFixed("4"), this.defines.CORNER_ROUNDING_NORM = (t / 100).toFixed("4"), this.needsUpdate = !0
                }
                setCornerRounding(e) {
                    this.cornerRounding = e
                }
                get cornerDetection() {
                    return void 0 === this.defines.DISABLE_CORNER_DETECTION
                }
                set cornerDetection(e) {
                    e ? delete this.defines.DISABLE_CORNER_DETECTION : this.defines.DISABLE_CORNER_DETECTION = "1", this.needsUpdate = !0
                }
                isCornerRoundingEnabled() {
                    return this.cornerDetection
                }
                setCornerRoundingEnabled(e) {
                    this.cornerDetection = e
                }
                setSize(e, t) {
                    const n = this.uniforms;
                    n.texelSize.value.set(1 / e, 1 / t), n.resolution.value.set(e, t)
                }
            },
            py = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAeElEQVRYR+2XSwqAMAxEJ168ePEqwRSKhIIiuHjJqiU0gWE+1CQdApcVAMUAuARaMGCX1MIL/Ow13++9lW2s3mW9MWvsnWc/2fvGygwPAN4E8QzAA4CXAB6AHjG4JTHYI1ey3pcx6FHnEfhLDOIBKAmUBK6/ANUDTlROXAHd9EC1AAAAAElFTkSuQmCC",
            gy = "data:image/png;base64,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",
            fy = class extends Gx {
                constructor({
                    blendFunction: e = wx,
                    preset: t = oy,
                    edgeDetectionMode: n = ny,
                    predicationMode: i = iy
                } = {}) {
                    let r, o;
                    super("SMAAEffect", "uniform sampler2D weightMap;varying vec2 vOffset0;varying vec2 vOffset1;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 a;a.x=texture2D(weightMap,vOffset0).a;a.y=texture2D(weightMap,vOffset1).g;a.wz=texture2D(weightMap,uv).rb;vec4 color=inputColor;if(dot(a,vec4(1.0))>=1e-5){bool h=max(a.x,a.z)>max(a.y,a.w);vec4 blendingOffset=vec4(0.0,a.y,0.0,a.w);vec2 blendingWeight=a.yw;movec(bvec4(h),blendingOffset,vec4(a.x,0.0,a.z,0.0));movec(bvec2(h),blendingWeight,a.xz);blendingWeight/=dot(blendingWeight,vec2(1.0));vec4 blendingCoord=blendingOffset*vec4(texelSize,-texelSize)+uv.xyxy;color=blendingWeight.x*texture2D(inputBuffer,blendingCoord.xy);color+=blendingWeight.y*texture2D(inputBuffer,blendingCoord.zw);}outputColor=color;}", {
                        vertexShader: "varying vec2 vOffset0;varying vec2 vOffset1;void mainSupport(const in vec2 uv){vOffset0=uv+texelSize*vec2(1.0,0.0);vOffset1=uv+texelSize*vec2(0.0,1.0);}",
                        blendFunction: e,
                        attributes: ux.CONVOLUTION | ux.DEPTH,
                        uniforms: new Map([
                            ["weightMap", new jA(null)]
                        ])
                    }), arguments.length > 1 && (r = arguments[0], o = arguments[1], arguments.length > 2 && (t = arguments[2]), arguments.length > 3 && (n = arguments[3])), this.renderTargetEdges = new Kn(1, 1, {
                        depthBuffer: !1
                    }), this.renderTargetEdges.texture.name = "SMAA.Edges", this.renderTargetWeights = this.renderTargetEdges.clone(), this.renderTargetWeights.texture.name = "SMAA.Weights", this.uniforms.get("weightMap").value = this.renderTargetWeights.texture, this.clearPass = new cx(!0, !1, !1), this.clearPass.overrideClearColor = new sr(0), this.clearPass.overrideClearAlpha = 1, this.edgeDetectionPass = new _x(new uy), this.edgeDetectionMaterial.edgeDetectionMode = n, this.edgeDetectionMaterial.predicationMode = i, this.weightsPass = new _x(new dy);
                    const s = new sA;
                    s.onLoad = () => {
                        const e = new Dn(r);
                        e.name = "SMAA.Search", e.magFilter = $e, e.minFilter = $e, e.generateMipmaps = !1, e.needsUpdate = !0, e.flipY = !0, this.weightsMaterial.searchTexture = e;
                        const t = new Dn(o);
                        t.name = "SMAA.Area", t.magFilter = nt, t.minFilter = nt, t.generateMipmaps = !1, t.needsUpdate = !0, t.flipY = !1, this.weightsMaterial.areaTexture = t, this.dispatchEvent({
                            type: "load"
                        })
                    }, s.itemStart("search"), s.itemStart("area"), void 0 !== r && void 0 !== o ? (s.itemEnd("search"), s.itemEnd("area")) : "undefined" != typeof Image && (r = new Image, o = new Image, r.addEventListener("load", (() => s.itemEnd("search"))), o.addEventListener("load", (() => s.itemEnd("area"))), r.src = py, o.src = gy), this.applyPreset(t)
                }
                get edgesTexture() {
                    return this.renderTargetEdges.texture
                }
                getEdgesTexture() {
                    return this.edgesTexture
                }
                get weightsTexture() {
                    return this.renderTargetWeights.texture
                }
                getWeightsTexture() {
                    return this.weightsTexture
                }
                get edgeDetectionMaterial() {
                    return this.edgeDetectionPass.fullscreenMaterial
                }
                get colorEdgesMaterial() {
                    return this.edgeDetectionMaterial
                }
                getEdgeDetectionMaterial() {
                    return this.edgeDetectionMaterial
                }
                get weightsMaterial() {
                    return this.weightsPass.fullscreenMaterial
                }
                getWeightsMaterial() {
                    return this.weightsMaterial
                }
                setEdgeDetectionThreshold(e) {
                    this.edgeDetectionMaterial.edgeDetectionThreshold = e
                }
                setOrthogonalSearchSteps(e) {
                    this.weightsMaterial.orthogonalSearchSteps = e
                }
                applyPreset(e) {
                    const t = this.edgeDetectionMaterial,
                        n = this.weightsMaterial;
                    switch (e) {
                        case ry:
                            t.edgeDetectionThreshold = .15, n.orthogonalSearchSteps = 4, n.diagonalDetection = !1, n.cornerDetection = !1;
                            break;
                        case oy:
                            t.edgeDetectionThreshold = .1, n.orthogonalSearchSteps = 8, n.diagonalDetection = !1, n.cornerDetection = !1;
                            break;
                        case sy:
                            t.edgeDetectionThreshold = .1, n.orthogonalSearchSteps = 16, n.diagonalSearchSteps = 8, n.cornerRounding = 25, n.diagonalDetection = !0, n.cornerDetection = !0;
                            break;
                        case ay:
                            t.edgeDetectionThreshold = .05, n.orthogonalSearchSteps = 32, n.diagonalSearchSteps = 16, n.cornerRounding = 25, n.diagonalDetection = !0, n.cornerDetection = !0
                    }
                }
                setDepthTexture(e, t = 3200) {
                    this.edgeDetectionMaterial.depthBuffer = e, this.edgeDetectionMaterial.depthPacking = t
                }
                update(e, t, n) {
                    this.clearPass.render(e, this.renderTargetEdges), this.edgeDetectionPass.render(e, t, this.renderTargetEdges), this.weightsPass.render(e, this.renderTargetEdges, this.renderTargetWeights)
                }
                setSize(e, t) {
                    this.edgeDetectionMaterial.setSize(e, t), this.weightsMaterial.setSize(e, t), this.renderTargetEdges.setSize(e, t), this.renderTargetWeights.setSize(e, t)
                }
                dispose() {
                    const {
                        searchTexture: e,
                        areaTexture: t
                    } = this.weightsMaterial;
                    null !== e && null !== t && (e.dispose(), t.dispose()), super.dispose()
                }
                static get searchImageDataURL() {
                    return py
                }
                static get areaImageDataURL() {
                    return gy
                }
            },
            my = class extends Gx {
                constructor({
                    blendFunction: e,
                    eskil: t = !1,
                    technique: n = (t ? cy : ly),
                    offset: i = .5,
                    darkness: r = .5
                } = {}) {
                    super("VignetteEffect", "uniform float offset;uniform float darkness;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){const vec2 center=vec2(0.5);vec3 color=inputColor.rgb;\n#if VIGNETTE_TECHNIQUE == 0\nfloat d=distance(uv,center);color*=smoothstep(0.8,offset*0.799,d*(darkness+offset));\n#else\nvec2 coord=(uv-center)*vec2(offset);color=mix(color,vec3(1.0-darkness),dot(coord,coord));\n#endif\noutputColor=vec4(color,inputColor.a);}", {
                        blendFunction: e,
                        defines: new Map([
                            ["VIGNETTE_TECHNIQUE", n.toFixed(0)]
                        ]),
                        uniforms: new Map([
                            ["offset", new jA(i)],
                            ["darkness", new jA(r)]
                        ])
                    })
                }
                get technique() {
                    return Number(this.defines.get("VIGNETTE_TECHNIQUE"))
                }
                set technique(e) {
                    this.technique !== e && (this.defines.set("VIGNETTE_TECHNIQUE", e.toFixed(0)), this.setChanged())
                }
                get eskil() {
                    return this.technique === cy
                }
                set eskil(e) {
                    this.technique = e ? cy : ly
                }
                getTechnique() {
                    return this.technique
                }
                setTechnique(e) {
                    this.technique = e
                }
                get offset() {
                    return this.uniforms.get("offset").value
                }
                set offset(e) {
                    this.uniforms.get("offset").value = e
                }
                getOffset() {
                    return this.offset
                }
                setOffset(e) {
                    this.offset = e
                }
                get darkness() {
                    return this.uniforms.get("darkness").value
                }
                set darkness(e) {
                    this.uniforms.get("darkness").value = e
                }
                getDarkness() {
                    return this.darkness
                }
                setDarkness(e) {
                    this.darkness = e
                }
            },
            Ey = class extends eo {
                constructor(e, t, n, i, r = !1) {
                    super({
                        name: "EffectMaterial",
                        defines: {
                            THREE_REVISION: ye.replace(/\D+/g, ""),
                            DEPTH_PACKING: "0",
                            ENCODE_OUTPUT: "1"
                        },
                        uniforms: {
                            inputBuffer: new jA(null),
                            depthBuffer: new jA(null),
                            resolution: new jA(new dn),
                            texelSize: new jA(new dn),
                            cameraNear: new jA(.3),
                            cameraFar: new jA(1e3),
                            aspect: new jA(1),
                            time: new jA(0)
                        },
                        blending: 0,
                        toneMapped: !1,
                        depthWrite: !1,
                        depthTest: !1,
                        dithering: r
                    }), e && this.setShaderParts(e), t && this.setDefines(t), n && this.setUniforms(n), this.copyCameraSettings(i)
                }
                set inputBuffer(e) {
                    this.uniforms.inputBuffer.value = e
                }
                setInputBuffer(e) {
                    this.uniforms.inputBuffer.value = e
                }
                get depthBuffer() {
                    return this.uniforms.depthBuffer.value
                }
                set depthBuffer(e) {
                    this.uniforms.depthBuffer.value = e
                }
                get depthPacking() {
                    return Number(this.defines.DEPTH_PACKING)
                }
                set depthPacking(e) {
                    this.defines.DEPTH_PACKING = e.toFixed(0), this.needsUpdate = !0
                }
                setDepthBuffer(e, t = 3200) {
                    this.depthBuffer = e, this.depthPacking = t
                }
                setShaderData(e) {
                    this.setShaderParts(e.shaderParts), this.setDefines(e.defines), this.setUniforms(e.uniforms), this.setExtensions(e.extensions)
                }
                setShaderParts(e) {
                    return this.fragmentShader = "#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#define packFloatToRGBA(v) packDepthToRGBA(v)\n#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#if DEPTH_PACKING == 3201\nuniform lowp sampler2D depthBuffer;\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;\n#if THREE_REVISION < 143\n#define luminance(v) linearToRelativeLuminance(v)\n#endif\n#if THREE_REVISION >= 137\nvec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}\n#endif\nfloat readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNear,cameraFar);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNear,cameraFar);\n#endif\n}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEAD void main(){FRAGMENT_MAIN_UV vec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGE color0.a=clamp(color0.a,0.0,1.0);gl_FragColor=color0;\n#ifdef ENCODE_OUTPUT\n#include <colorspace_fragment>\n#endif\n#include <dithering_fragment>\n}".replace(dx.FRAGMENT_HEAD, e.get(dx.FRAGMENT_HEAD) || "").replace(dx.FRAGMENT_MAIN_UV, e.get(dx.FRAGMENT_MAIN_UV) || "").replace(dx.FRAGMENT_MAIN_IMAGE, e.get(dx.FRAGMENT_MAIN_IMAGE) || ""), this.vertexShader = "uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEAD void main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORT gl_Position=vec4(position.xy,1.0,1.0);}".replace(dx.VERTEX_HEAD, e.get(dx.VERTEX_HEAD) || "").replace(dx.VERTEX_MAIN_SUPPORT, e.get(dx.VERTEX_MAIN_SUPPORT) || ""), this.fragmentShader = rx(this.fragmentShader), this.needsUpdate = !0, this
                }
                setDefines(e) {
                    for (const t of e.entries()) this.defines[t[0]] = t[1];
                    return this.needsUpdate = !0, this
                }
                setUniforms(e) {
                    for (const t of e.entries()) this.uniforms[t[0]] = t[1];
                    return this
                }
                setExtensions(e) {
                    this.extensions = {};
                    for (const t of e) this.extensions[t] = !0;
                    return this
                }
                get encodeOutput() {
                    return void 0 !== this.defines.ENCODE_OUTPUT
                }
                set encodeOutput(e) {
                    this.encodeOutput !== e && (e ? this.defines.ENCODE_OUTPUT = "1" : delete this.defines.ENCODE_OUTPUT, this.needsUpdate = !0)
                }
                isOutputEncodingEnabled(e) {
                    return this.encodeOutput
                }
                setOutputEncodingEnabled(e) {
                    this.encodeOutput = e
                }
                get time() {
                    return this.uniforms.time.value
                }
                set time(e) {
                    this.uniforms.time.value = e
                }
                setDeltaTime(e) {
                    this.uniforms.time.value += e
                }
                adoptCameraSettings(e) {
                    this.copyCameraSettings(e)
                }
                copyCameraSettings(e) {
                    e && (this.uniforms.cameraNear.value = e.near, this.uniforms.cameraFar.value = e.far, e instanceof oo ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0)
                }
                setSize(e, t) {
                    const n = this.uniforms;
                    n.resolution.value.set(e, t), n.texelSize.value.set(1 / e, 1 / t), n.aspect.value = e / t
                }
                static get Section() {
                    return dx
                }
            };
        new Float32Array([255 / 256 / 256 ** 3, 255 / 256 / 65536, 255 / 256 / 256, 255 / 256]);

        function Cy(e, t, n) {
            for (const i of t) {
                const t = "$1" + e + i.charAt(0).toUpperCase() + i.slice(1),
                    r = new RegExp("([^\\.])(\\b" + i + "\\b)", "g");
                for (const e of n.entries()) null !== e[1] && n.set(e[0], e[1].replace(r, t))
            }
        }

        function Iy(e, t, n) {
            let i = t.getFragmentShader(),
                r = t.getVertexShader();
            const o = void 0 !== i && /mainImage/.test(i),
                s = void 0 !== i && /mainUv/.test(i);
            if (n.attributes |= t.getAttributes(), void 0 === i) throw new Error(`Missing fragment shader (${t.name})`);
            if (s && n.attributes & ux.CONVOLUTION) throw new Error(`Effects that transform UVs are incompatible with convolution effects (${t.name})`);
            if (!o && !s) throw new Error(`Could not find mainImage or mainUv function (${t.name})`); {
                const a = /\w+\s+(\w+)\([\w\s,]*\)\s*{/g,
                    l = n.shaderParts;
                let c = l.get(dx.FRAGMENT_HEAD) || "",
                    A = l.get(dx.FRAGMENT_MAIN_UV) || "",
                    h = l.get(dx.FRAGMENT_MAIN_IMAGE) || "",
                    u = l.get(dx.VERTEX_HEAD) || "",
                    d = l.get(dx.VERTEX_MAIN_SUPPORT) || "";
                const p = new Set,
                    g = new Set;
                if (s && (A += `\t${e}MainUv(UV);\n`, n.uvTransformation = !0), null !== r && /mainSupport/.test(r)) {
                    const t = /mainSupport *\([\w\s]*?uv\s*?\)/.test(r);
                    d += `\t${e}MainSupport(`, d += t ? "vUv);\n" : ");\n";
                    for (const e of r.matchAll(/(?:varying\s+\w+\s+([\S\s]*?);)/g))
                        for (const t of e[1].split(/\s*,\s*/)) n.varyings.add(t), p.add(t), g.add(t);
                    for (const e of r.matchAll(a)) g.add(e[1])
                }
                for (const e of i.matchAll(a)) g.add(e[1]);
                for (const e of t.defines.keys()) g.add(e.replace(/\([\w\s,]*\)/g, ""));
                for (const e of t.uniforms.keys()) g.add(e);
                g.delete("while"), g.delete("for"), g.delete("if"), t.uniforms.forEach(((t, i) => n.uniforms.set(e + i.charAt(0).toUpperCase() + i.slice(1), t))), t.defines.forEach(((t, i) => n.defines.set(e + i.charAt(0).toUpperCase() + i.slice(1), t)));
                const f = new Map([
                    ["fragment", i],
                    ["vertex", r]
                ]);
                Cy(e, g, n.defines), Cy(e, g, f), i = f.get("fragment"), r = f.get("vertex");
                const m = t.blendMode;
                if (n.blendModes.set(m.blendFunction, m), o) {
                    null !== t.inputColorSpace && t.inputColorSpace !== n.colorSpace && (h += t.inputColorSpace === Ot ? "color0 = LinearTosRGB(color0);\n\t" : "color0 = sRGBToLinear(color0);\n\t"), t.outputColorSpace !== Vt ? n.colorSpace = t.outputColorSpace : null !== t.inputColorSpace && (n.colorSpace = t.inputColorSpace);
                    const r = /MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;
                    h += `${e}MainImage(color0, UV, `, n.attributes & ux.DEPTH && r.test(i) && (h += "depth, ", n.readDepth = !0), h += "color1);\n\t";
                    const o = e + "BlendOpacity";
                    n.uniforms.set(o, m.opacity), h += `color0 = blend${m.blendFunction}(color0, color1, ${o});\n\n\t`, c += `uniform float ${o};\n\n`
                }
                if (c += i + "\n", null !== r && (u += r + "\n"), l.set(dx.FRAGMENT_HEAD, c), l.set(dx.FRAGMENT_MAIN_UV, A), l.set(dx.FRAGMENT_MAIN_IMAGE, h), l.set(dx.VERTEX_HEAD, u), l.set(dx.VERTEX_MAIN_SUPPORT, d), null !== t.extensions)
                    for (const e of t.extensions) n.extensions.add(e)
            }
        }
        var Sy = class extends tx {
            constructor(e, ...t) {
                super("EffectPass"), this.fullscreenMaterial = new Ey(null, null, null, e), this.listener = e => this.handleEvent(e), this.effects = [], this.setEffects(t), this.skipRendering = !1, this.minTime = 1, this.maxTime = Number.POSITIVE_INFINITY, this.timeScale = 1
            }
            set mainScene(e) {
                for (const t of this.effects) t.mainScene = e
            }
            set mainCamera(e) {
                this.fullscreenMaterial.copyCameraSettings(e);
                for (const t of this.effects) t.mainCamera = e
            }
            get encodeOutput() {
                return this.fullscreenMaterial.encodeOutput
            }
            set encodeOutput(e) {
                this.fullscreenMaterial.encodeOutput = e
            }
            get dithering() {
                return this.fullscreenMaterial.dithering
            }
            set dithering(e) {
                const t = this.fullscreenMaterial;
                t.dithering = e, t.needsUpdate = !0
            }
            setEffects(e) {
                for (const e of this.effects) e.removeEventListener("change", this.listener);
                this.effects = e.sort(((e, t) => t.attributes - e.attributes));
                for (const e of this.effects) e.addEventListener("change", this.listener)
            }
            updateMaterial() {
                const e = new px;
                let t = 0;
                for (const n of this.effects)
                    if (n.blendMode.blendFunction === Sx) e.attributes |= n.getAttributes() & ux.DEPTH;
                    else {
                        if (e.attributes & n.getAttributes() & ux.CONVOLUTION) throw new Error(`Convolution effects cannot be merged (${n.name})`);
                        Iy("e" + t++, n, e)
                    }
                let n = e.shaderParts.get(dx.FRAGMENT_HEAD),
                    i = e.shaderParts.get(dx.FRAGMENT_MAIN_IMAGE),
                    r = e.shaderParts.get(dx.FRAGMENT_MAIN_UV);
                const o = /\bblend\b/g;
                for (const t of e.blendModes.values()) n += t.getShaderCode().replace(o, `blend${t.blendFunction}`) + "\n";
                e.attributes & ux.DEPTH ? (e.readDepth && (i = "float depth = readDepth(UV);\n\n\t" + i), this.needsDepthTexture = null === this.getDepthTexture()) : this.needsDepthTexture = !1, e.colorSpace === Ot && (i += "color0 = sRGBToLinear(color0);\n\t"), e.uvTransformation ? (r = "vec2 transformedUv = vUv;\n" + r, e.defines.set("UV", "transformedUv")) : e.defines.set("UV", "vUv"), e.shaderParts.set(dx.FRAGMENT_HEAD, n), e.shaderParts.set(dx.FRAGMENT_MAIN_IMAGE, i), e.shaderParts.set(dx.FRAGMENT_MAIN_UV, r);
                for (const [t, n] of e.shaderParts) null !== n && e.shaderParts.set(t, n.trim().replace(/^#/, "\n#"));
                this.skipRendering = 0 === t, this.needsSwap = !this.skipRendering, this.fullscreenMaterial.setShaderData(e)
            }
            recompile() {
                this.updateMaterial()
            }
            getDepthTexture() {
                return this.fullscreenMaterial.depthBuffer
            }
            setDepthTexture(e, t = 3200) {
                this.fullscreenMaterial.depthBuffer = e, this.fullscreenMaterial.depthPacking = t;
                for (const n of this.effects) n.setDepthTexture(e, t)
            }
            render(e, t, n, i, r) {
                for (const n of this.effects) n.update(e, t, i);
                if (!this.skipRendering || this.renderToScreen) {
                    const r = this.fullscreenMaterial;
                    r.inputBuffer = t.texture, r.time += i * this.timeScale, e.setRenderTarget(this.renderToScreen ? null : n), e.render(this.scene, this.camera)
                }
            }
            setSize(e, t) {
                this.fullscreenMaterial.setSize(e, t);
                for (const n of this.effects) n.setSize(e, t)
            }
            initialize(e, t, n) {
                this.renderer = e;
                for (const i of this.effects) i.initialize(e, t, n);
                this.updateMaterial(), void 0 !== n && n !== ot && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1")
            }
            dispose() {
                super.dispose();
                for (const e of this.effects) e.removeEventListener("change", this.listener), e.dispose()
            }
            handleEvent(e) {
                if ("change" === e.type) this.recompile()
            }
        };
        new Float32Array(3), new Float32Array(3), new Float32Array(3), new Float32Array(3), new Float32Array(3), new Float32Array(3), new Float32Array([0, 0, 0]), new Float32Array([1, 0, 0]), new Float32Array([1, 1, 0]), new Float32Array([1, 1, 1]), new Float32Array([0, 0, 0]), new Float32Array([1, 0, 0]), new Float32Array([1, 0, 1]), new Float32Array([1, 1, 1]), new Float32Array([0, 0, 0]), new Float32Array([0, 0, 1]), new Float32Array([1, 0, 1]), new Float32Array([1, 1, 1]), new Float32Array([0, 0, 0]), new Float32Array([0, 1, 0]), new Float32Array([1, 1, 0]), new Float32Array([1, 1, 1]), new Float32Array([0, 0, 0]), new Float32Array([0, 1, 0]), new Float32Array([0, 1, 1]), new Float32Array([1, 1, 1]), new Float32Array([0, 0, 0]), new Float32Array([0, 0, 1]), new Float32Array([0, 1, 1]), new Float32Array([1, 1, 1]);
        new Float32Array(2), new Float32Array(2), new Float32Array([0, -.25, .25, -.125, .125, -.375, .375]), new Float32Array([0, 0]), new Float32Array([.25, -.25]), new Float32Array([-.25, .25]), new Float32Array([.125, -.125]), new Float32Array([-.125, .125]), new Uint8Array([0, 0]), new Uint8Array([3, 0]), new Uint8Array([0, 3]), new Uint8Array([3, 3]), new Uint8Array([1, 0]), new Uint8Array([4, 0]), new Uint8Array([1, 3]), new Uint8Array([4, 3]), new Uint8Array([0, 1]), new Uint8Array([3, 1]), new Uint8Array([0, 4]), new Uint8Array([3, 4]), new Uint8Array([1, 1]), new Uint8Array([4, 1]), new Uint8Array([1, 4]), new Uint8Array([4, 4]), new Uint8Array([0, 0]), new Uint8Array([1, 0]), new Uint8Array([0, 2]), new Uint8Array([1, 2]), new Uint8Array([2, 0]), new Uint8Array([3, 0]), new Uint8Array([2, 2]), new Uint8Array([3, 2]), new Uint8Array([0, 1]), new Uint8Array([1, 1]), new Uint8Array([0, 3]), new Uint8Array([1, 3]), new Uint8Array([2, 1]), new Uint8Array([3, 1]), new Uint8Array([2, 3]), new Uint8Array([3, 3]);
        By(0, 0, 0, 0), new Float32Array([0, 0, 0, 0]), By(0, 0, 0, 1), new Float32Array([0, 0, 0, 1]), By(0, 0, 1, 0), new Float32Array([0, 0, 1, 0]), By(0, 0, 1, 1), new Float32Array([0, 0, 1, 1]), By(0, 1, 0, 0), new Float32Array([0, 1, 0, 0]), By(0, 1, 0, 1), new Float32Array([0, 1, 0, 1]), By(0, 1, 1, 0), new Float32Array([0, 1, 1, 0]), By(0, 1, 1, 1), new Float32Array([0, 1, 1, 1]), By(1, 0, 0, 0), new Float32Array([1, 0, 0, 0]), By(1, 0, 0, 1), new Float32Array([1, 0, 0, 1]), By(1, 0, 1, 0), new Float32Array([1, 0, 1, 0]), By(1, 0, 1, 1), new Float32Array([1, 0, 1, 1]), By(1, 1, 0, 0), new Float32Array([1, 1, 0, 0]), By(1, 1, 0, 1), new Float32Array([1, 1, 0, 1]), By(1, 1, 1, 0), new Float32Array([1, 1, 1, 0]), By(1, 1, 1, 1), new Float32Array([1, 1, 1, 1]);

        function vy(e, t, n) {
            return e + (t - e) * n
        }

        function By(e, t, n, i) {
            const r = vy(e, t, .75),
                o = vy(n, i, .75);
            return vy(r, o, .875)
        }
        var xy;

        function yy(e) {
            function t(e, t) {
                const {
                    blendFunction: n,
                    opacity: i,
                    bits: r
                } = t;
                e.bitDepth = r, e.blendMode.blendFunction = n, e.blendMode.setOpacity(i)
            }
            return {
                updateEffect: function(n) {
                    var i;
                    const {
                        type: r
                    } = n, o = null === (i = e.get(r)) || void 0 === i ? void 0 : i.effect;
                    if (!o) throw new Error("Effect that you are trying to update doesn't exist!");
                    ie(n) && function(e, t) {
                        const {
                            blendFunction: n,
                            filter: i,
                            intensity: r,
                            luminanceSmoothing: o,
                            luminanceThreshold: s,
                            opacity: a,
                            radius: l
                        } = t;
                        e.luminanceMaterial.threshold = s, e.luminanceMaterial.smoothing = o, e.blendMode.blendFunction = n, e.blendMode.setOpacity(a), e.blurPass.kernelSize = Math.round(l), e.intensity = r, e.luminancePass.enabled = i, e.luminanceMaterial.needsUpdate = !0
                    }(o, n), re(n) && function(e, t) {
                        const {
                            blendFunction: n,
                            technique: i,
                            offset: r,
                            opacity: o,
                            darkness: s
                        } = t;
                        e.darkness = s, e.offset = r, e.technique = i, e.blendMode.blendFunction = n, e.blendMode.setOpacity(o)
                    }(o, n), ae(n) && function(e, t) {
                        const {
                            bokehScale: n,
                            focusRange: i,
                            focusDistance: r,
                            resolutionScale: o,
                            blendFunction: s,
                            opacity: a
                        } = t;
                        e.bokehScale = n, e.resolution.scale = o, e.cocMaterial.focusDistance = r, e.cocMaterial.focusRange = i, e.cocMaterial.needsUpdate = !0, e.blendMode.blendFunction = s, e.blendMode.setOpacity(a)
                    }(o, n), le(n) && function(e, t) {
                        const {
                            granularity: n
                        } = t;
                        e.granularity = n
                    }(o, n), ce(n) && function(e, t) {
                        const {
                            blendFunction: n,
                            opacity: i,
                            hue: r,
                            saturation: o
                        } = t;
                        e.hue = r, e.saturation = o, e.blendMode.blendFunction = n, e.blendMode.setOpacity(i)
                    }(o, n), Ae(n) && t(o, n), he(n) && function(e, t) {
                        const {
                            blendFunction: n,
                            opacity: i,
                            contrast: r,
                            brightness: o
                        } = t;
                        e.contrast = r, e.brightness = o, e.blendMode.blendFunction = n, e.blendMode.setOpacity(i)
                    }(o, n), oe(n) && function(e, t) {
                        const {
                            blendFunction: n,
                            opacity: i
                        } = t;
                        e.blendMode.blendFunction = n, e.blendMode.setOpacity(i)
                    }(o, n), Ae(n) && t(o, n), se(n) && function(e, t) {
                        const {
                            edgeContrastFactor: n,
                            edgeMode: i,
                            edgeThreshold: r,
                            predicationMode: o,
                            predicationScale: s,
                            predicationStrength: a,
                            predicationThreshold: l,
                            preset: c
                        } = t;
                        e.applyPreset(c);
                        const A = e.edgeDetectionMaterial;
                        A.edgeDetectionMode = Number(i), A.predicationMode = Number(o), A.predicationScale = s, A.predicationStrength = a, A.predicationThreshold = l, A.edgeDetectionThreshold = r, A.localContrastAdaptationFactor = n, A.needsUpdate = !0
                    }(o, n)
                }
            }
        }

        function wy(e, t, n) {
            const {
                updateEffect: i
            } = yy(e);
            return {
                updateEffect: i,
                createEffect: function(r) {
                    var o;
                    const {
                        type: s,
                        opacity: a
                    } = r;
                    if (null === (o = e.get(s)) || void 0 === o ? void 0 : o.effect) throw Error(`Trying to create an effect that's already added ${s}`);
                    let l;
                    if (ie(r) && (l = function(e) {
                            const {
                                filter: t,
                                intensity: n,
                                luminanceSmoothing: i,
                                luminanceThreshold: r,
                                radius: o,
                                blendFunction: s
                            } = e, a = new Vx({
                                luminanceSmoothing: i,
                                luminanceThreshold: r,
                                intensity: n,
                                blendFunction: s,
                                radius: o
                            });
                            return a.luminancePass.enabled = !!t, a
                        }(r)), re(r) && (l = function(e) {
                            const {
                                offset: t,
                                darkness: n,
                                technique: i,
                                blendFunction: r
                            } = e;
                            return new my({
                                offset: t,
                                darkness: n,
                                technique: i,
                                blendFunction: r
                            })
                        }(r)), oe(r) && (l = function(e) {
                            const {
                                blendFunction: t
                            } = e;
                            return new Ay({
                                blendFunction: t
                            })
                        }(r)), ae(r) && (l = function(e) {
                            const {
                                bokehScale: t,
                                focusRange: n,
                                focusDistance: i,
                                resolutionScale: r,
                                blendFunction: o
                            } = e;
                            return new $x(void 0, {
                                bokehScale: t,
                                focusRange: n,
                                focusDistance: i,
                                resolutionScale: r,
                                blendFunction: o
                            })
                        }(r)), le(r) && (l = function(e) {
                            const {
                                granularity: t
                            } = e;
                            return new hy(t)
                        }(r)), ce(r) && (l = function(e) {
                            const {
                                hue: t,
                                saturation: n,
                                blendFunction: i
                            } = e;
                            return new ty({
                                blendFunction: i,
                                hue: t,
                                saturation: n
                            })
                        }(r)), Ae(r) && (l = function(e) {
                            const {
                                bits: t,
                                blendFunction: n
                            } = e;
                            return new Nx({
                                blendFunction: n,
                                bits: t
                            })
                        }(r)), he(r) && (l = function(e) {
                            const {
                                brightness: t,
                                contrast: n,
                                blendFunction: i
                            } = e;
                            return new Ox({
                                blendFunction: i,
                                brightness: t,
                                contrast: n
                            })
                        }(r)), se(r) && (l = function(e) {
                            const {
                                edgeMode: t,
                                predicationMode: n,
                                preset: i
                            } = e;
                            return new fy({
                                edgeDetectionMode: Number(t),
                                predicationMode: Number(n),
                                preset: i
                            })
                        }(r)), !l) throw new Error(`Object type <${s}> is not supported!`);
                    l.blendMode.setOpacity(a), l.initialize(t.getRenderer(), !0, ct), e.set(s, {
                        order: C.get(s),
                        effect: l
                    }), i(r), n()
                },
                deleteEffect: function(t) {
                    var i;
                    const r = null === (i = e.get(t)) || void 0 === i ? void 0 : i.effect;
                    if (!r) throw Error(`Trying to delete an effect that doesn't exist ${t}`);
                    e.delete(t), r.dispose(), n()
                }
            }
        }
        class by extends Sy {
            disposeWithoutDisposingEffects() {
                for (const e of Object.keys(this)) {
                    const t = this[e];
                    (t instanceof Kn || t instanceof cr || t instanceof Dn || t instanceof tx) && this[e].dispose()
                }
                this.setEffects([])
            }
        }! function(e) {
            e[e.PWObjects = 0] = "PWObjects", e[e.Effects = 1] = "Effects", e[e.Copy = 2] = "Copy", e[e.Helpers = 3] = "Helpers"
        }(xy || (xy = {}));
        const Qy = function() {
                const e = [xy.PWObjects, xy.Effects, xy.Copy, xy.Helpers],
                    t = new Map;
                return e.forEach(((e, n) => {
                    t.set(e, n)
                })), t
            }(),
            Uy = [m.SMAA];

        function My(e, t, n, i, o) {
            let s = !1;
            const a = new hx(e, {
                    alpha: !0,
                    depthBuffer: !0,
                    frameBufferType: ct
                }),
                l = new ey;
            let c = [];
            const A = e => Qy.get(e) > Qy.get(xy.Effects) ? Qy.get(e) + c.length - 1 : Qy.get(e),
                h = (e, t) => {
                    a.addPass(e, A(t))
                };
            if (h(l, xy.PWObjects), GQ) {
                const e = new ey;
                e.selection = new Cx(void 0, r.Helpers), e.clearPass.enabled = !1, e.ignoreBackground = !0, e.skipShadowMapUpdate = !0;
                const t = new ax;
                l.renderToScreen = !1, c.forEach((e => e.renderToScreen = !1)), t.renderToScreen = !0, e.renderToScreen = !0, h(e, xy.Helpers), h(t, xy.Copy)
            }
            const u = new Map,
                {
                    createEffect: d,
                    updateEffect: p,
                    deleteEffect: g
                } = wy(u, a, f);

            function f() {
                c.forEach((e => {
                    a.removePass(e), e.disposeWithoutDisposingEffects()
                }));
                const t = s ? [...u.entries()] : [...u.entries()].filter((e => Uy.includes(e[0]))),
                    r = t.sort(((e, t) => e[1].order - t[1].order)).map((e => e[1].effect));
                if (0 === r.length || !e.getContext().getContextAttributes()) return void(c = []);
                const o = [
                    []
                ];
                let l = !1,
                    A = !1;
                r.forEach((e => {
                    const t = e.getFragmentShader(),
                        n = void 0 !== t && /mainUv/.test(t),
                        i = !!(e.getAttributes() & ux.CONVOLUTION);
                    (A || l) && i ? (o.push([e]), l = !1) : A && n ? (o.push([e]), A = !1) : o[o.length - 1].push(e), l = l || n, A = A || i
                })), c = [], o.forEach((e => {
                    const t = new by(void 0, ...e);
                    GQ && (t.renderToScreen = !1), t.mainCamera = n(), t.mainScene = i(), h(t, xy.Effects), c.push(t)
                }))
            }
            const m = new mi,
                E = new mi;

            function C() {
                const e = o(),
                    i = n();
                (null == e ? void 0 : e.camera) && e.camera instanceof oo && (e.camera.aspect = e.htmlElement.clientWidth / e.htmlElement.clientHeight, e.camera.updateProjectionMatrix(), E.copy(e.camera.projectionMatrix)), i && i instanceof oo && (i.aspect = t.x / t.y, i.updateProjectionMatrix(), m.copy(i.projectionMatrix))
            }
            return {
                createEffect: d,
                deleteEffect: g,
                updateEffect: p,
                setMainCamera: function(e) {
                    a.setMainCamera(e)
                },
                setMainScene: function(e) {
                    a.setMainScene(e)
                },
                setUsePostProcessing: function(e) {
                    s = e, s || Uy.find((e => u.has(e))) ? f() : c.forEach((e => a.removePass(e)))
                },
                render: function(i) {
                    const r = o(),
                        s = n(),
                        c = e.domElement.parentElement;
                    if (!c) throw new Error("Canvas parent element is not found! Cannot update canvas size");
                    var h, u;
                    if (h = c.clientWidth, u = c.clientHeight, h === t.x && u === t.y || (a.setSize(h, u, !1), t.set(h, u), C()), r) {
                        const t = r.htmlElement.getBoundingClientRect(),
                            n = c.getBoundingClientRect();
                        a.render(i);
                        const {
                            width: o,
                            height: h
                        } = t, u = t.x - n.x, d = n.height - (t.y - n.y) - h;
                        e.setViewport(u, d, o, h), e.setScissorTest(!0), e.setScissor(u, d, o, h), l.clearPass.setClearFlags(!1, !0, !0), s === r.camera && s instanceof oo && s.projectionMatrix.copy(E), a.setMainCamera(r.camera), a.passes[A(xy.Helpers)].enabled = !1, a.render(i), e.setViewport(0, 0, n.width, n.height), e.setScissorTest(!1), l.clearPass.setClearFlags(!0, !0, !0), s === r.camera && s instanceof oo && s.projectionMatrix.copy(m), a.passes[A(xy.Helpers)].enabled = !0, a.setMainCamera(s)
                    } else a.render(i)
                },
                effects: u,
                dispose: function() {
                    u.clear(), a.dispose(), c.forEach((e => e.dispose()))
                },
                updateCameraProjectionMatrix: C,
                setMultiSampling: function(t) {
                    a.multisampling = Math.min(t, e.capabilities.maxSamples)
                }
            }
        }
        var Ry = n(52),
            Ty = n.n(Ry);

        function Fy(e) {
            let t, n = !1;
            const i = new dn(e.clientWidth, e.clientHeight),
                r = function(e) {
                    const t = new ol({
                        canvas: e,
                        powerPreference: "high-performance",
                        antialias: !0,
                        depth: !0
                    });
                    return t.setSize(e.clientWidth, e.clientHeight, !1), t.shadowMap.enabled = !0, t.shadowMap.type = be, t
                }(e),
                o = new Map,
                s = new Map;
            let a, l, c = !1;
            const A = new en;
            let h;
            const {
                effects: u,
                render: p,
                setMainCamera: g,
                setMainScene: f,
                createEffect: m,
                updateEffect: E,
                deleteEffect: C,
                setUsePostProcessing: I,
                setMultiSampling: S,
                updateCameraProjectionMatrix: v
            } = My(r, i, D, F, (function() {
                return h
            }));
            const B = function(e) {
                    const t = new pA,
                        n = new av,
                        i = new Vv,
                        r = new XB,
                        o = `https://unpkg.com/three@0.${ye}.x`,
                        s = (new sS).setDecoderPath(`${o}/examples/jsm/libs/draco/gltf/`),
                        a = (new qB).setTranscoderPath(`${o}/examples/jsm/libs/basis/`);
                    a.detectSupport(e);
                    const l = (new cS).setCrossOrigin("anonymous").setDRACOLoader(s).setKTX2Loader(a).setMeshoptDecoder(zB),
                        c = new $v,
                        A = new lB,
                        h = {
                            [d.Gltf]: l,
                            [d.Texture]: t,
                            [d.HDRTexture]: n,
                            [d.EXRTexture]: i,
                            [d.Obj]: c,
                            [d.FBX]: A,
                            [d.VideoTexture]: r
                        };
                    return {
                        load: function(e, t, n = (() => {})) {
                            const i = h[e];
                            if (!i) throw new Error(`No loader for this asset type ${e}`);
                            return i.load(t, n)
                        },
                        loadAsync: (e, t) => {
                            const n = h[e];
                            if (!n) throw new Error(`No loader for this asset type ${e}`);
                            return n.loadAsync(t)
                        },
                        dispose: function() {
                            s.dispose(), a.dispose()
                        }
                    }
                }(r),
                {
                    load: x,
                    loadAsync: y
                } = B,
                w = rS(B, A),
                b = new Set,
                Q = new Set,
                U = new TA;

            function M() {
                if (!a || !l || !r) return void console.error("Trying to render with uninitalized objects", {
                    activeScene: a,
                    activeCamera: l,
                    renderer: r
                });
                n && (null == t || t.update());
                const e = U.getDelta();
                b.forEach((t => t(a, l, e))), p(e), Q.forEach((t => t(a, l, e)))
            }

            function R() {
                if (!r) throw Error("Renderer is undefined");
                r.setAnimationLoop(null)
            }

            function T(e) {
                b.delete(e)
            }

            function F() {
                return a
            }

            function D() {
                return l
            }
            const k = ["SpotLightHelper", "PointLightHelper", "DirectionalLightHelper", "CameraHelper"];

            function L(e) {
                e.traverse((e => {
                    if (!k.includes(e.type) && e instanceof Jr) {
                        const t = e;
                        t.material.wireframe = c, t.material.transparent = !c && t.material.userData.isTransparent
                    }
                }))
            }
            return {
                objects: o,
                materials: s,
                renderer: r,
                canvas: e,
                canvasSize: i,
                effects: u,
                eventDispatcher: A,
                load: x,
                loadAsync: y,
                getActiveScene: F,
                setActiveScene: function(e) {
                    a = e, f(e)
                },
                getActiveCamera: D,
                setActiveCamera: function(e) {
                    l = e, g(e), l && l instanceof oo && v()
                },
                setCameraPreview: function(e) {
                    h = e, h && h.camera instanceof oo && v()
                },
                resourceManager: w,
                getResource: w.getResource,
                addOnRenderCallback: function(e) {
                    return b.add(e), () => T(e)
                },
                removeOnRenderCallback: T,
                addAfterRenderCallback: function(e) {
                    return Q.add(e), () => function(e) {
                        Q.delete(e)
                    }(e)
                },
                createEffect: m,
                deleteEffect: C,
                updateEffect: E,
                start: function() {
                    if (!r) throw Error("Renderer is undefined");
                    A.dispatchEvent({
                        type: OI.Loaded
                    }), r.setAnimationLoop(M)
                },
                stop: R,
                render: M,
                dispose: function() {
                    B.dispose(), w.dispose(), o.forEach((e => {
                        e.isMesh && e.geometry.dispose()
                    })), R()
                },
                setWireframe: function(e) {
                    c = e, o.forEach((e => {
                        L(e)
                    }))
                },
                setUsePostProcessing: I,
                setWireframeOnObject: L,
                showStatsPanel: function(e) {
                    n = !0, t || (t = new(Ty()), t.dom.style.position = "fixed"), t.begin(), t.showPanel(0), e.appendChild(t.dom)
                },
                hideStatsPanel: function() {
                    var e;
                    n = !1, t && (t.end(), null === (e = t.dom.parentElement) || void 0 === e || e.removeChild(t.dom))
                },
                setMultiSampling: S,
                attachToDOM: function(e) {
                    e.appendChild(r.domElement), i.set(0, 0)
                }
            }
        }

        function Dy(e, t, n) {
            return null === e ? null : (e.point.applyMatrix4(t.matrixWorld), e.distance = e.point.distanceTo(n.ray.origin), e.object = t, e.distance < n.near || e.distance > n.far ? null : e)
        }
        const ky = 0,
            Ly = 1,
            Ky = 2,
            Py = 2,
            Gy = 1.25,
            Vy = 1,
            Oy = 32,
            Ny = 65535,
            Hy = Math.pow(2, -24),
            qy = Symbol("SKIP_GENERATION");

        function jy(e) {
            return function(e) {
                return e.index ? e.index.count : e.attributes.position.count
            }(e) / 3
        }

        function Yy(e, t) {
            if (!e.index) {
                const n = e.attributes.position.count,
                    i = function(e, t = ArrayBuffer) {
                        return e > 65535 ? new Uint32Array(new t(4 * e)) : new Uint16Array(new t(2 * e))
                    }(n, t.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer);
                e.setIndex(new Er(i, 1));
                for (let e = 0; e < n; e++) i[e] = e
            }
        }

        function Jy(e) {
            const t = jy(e),
                n = e.drawRange,
                i = n.start / 3,
                r = (n.start + n.count) / 3,
                o = Math.max(0, i),
                s = Math.min(t, r) - o;
            return [{
                offset: Math.floor(o),
                count: Math.floor(s)
            }]
        }

        function Wy(e) {
            if (!e.groups || !e.groups.length) return Jy(e);
            const t = [],
                n = new Set,
                i = e.drawRange,
                r = i.start / 3,
                o = (i.start + i.count) / 3;
            for (const t of e.groups) {
                const e = t.start / 3,
                    i = (t.start + t.count) / 3;
                n.add(Math.max(r, e)), n.add(Math.min(o, i))
            }
            const s = Array.from(n.values()).sort(((e, t) => e - t));
            for (let e = 0; e < s.length - 1; e++) {
                const n = s[e],
                    i = s[e + 1];
                t.push({
                    offset: Math.floor(n),
                    count: Math.floor(i - n)
                })
            }
            return t
        }

        function zy(e, t, n, i, r) {
            let o = 1 / 0,
                s = 1 / 0,
                a = 1 / 0,
                l = -1 / 0,
                c = -1 / 0,
                A = -1 / 0,
                h = 1 / 0,
                u = 1 / 0,
                d = 1 / 0,
                p = -1 / 0,
                g = -1 / 0,
                f = -1 / 0;
            for (let i = 6 * t, r = 6 * (t + n); i < r; i += 6) {
                const t = e[i + 0],
                    n = e[i + 1],
                    r = t - n,
                    m = t + n;
                r < o && (o = r), m > l && (l = m), t < h && (h = t), t > p && (p = t);
                const E = e[i + 2],
                    C = e[i + 3],
                    I = E - C,
                    S = E + C;
                I < s && (s = I), S > c && (c = S), E < u && (u = E), E > g && (g = E);
                const v = e[i + 4],
                    B = e[i + 5],
                    x = v - B,
                    y = v + B;
                x < a && (a = x), y > A && (A = y), v < d && (d = v), v > f && (f = v)
            }
            i[0] = o, i[1] = s, i[2] = a, i[3] = l, i[4] = c, i[5] = A, r[0] = h, r[1] = u, r[2] = d, r[3] = p, r[4] = g, r[5] = f
        }

        function Xy(e, t, n) {
            return n.min.x = t[e], n.min.y = t[e + 1], n.min.z = t[e + 2], n.max.x = t[e + 3], n.max.y = t[e + 4], n.max.z = t[e + 5], n
        }

        function Zy(e) {
            let t = -1,
                n = -1 / 0;
            for (let i = 0; i < 3; i++) {
                const r = e[i + 3] - e[i];
                r > n && (n = r, t = i)
            }
            return t
        }

        function _y(e, t) {
            t.set(e)
        }

        function $y(e, t, n) {
            let i, r;
            for (let o = 0; o < 3; o++) {
                const s = o + 3;
                i = e[o], r = t[o], n[o] = i < r ? i : r, i = e[s], r = t[s], n[s] = i > r ? i : r
            }
        }

        function ew(e, t, n) {
            for (let i = 0; i < 3; i++) {
                const r = t[e + 2 * i],
                    o = t[e + 2 * i + 1],
                    s = r - o,
                    a = r + o;
                s < n[i] && (n[i] = s), a > n[i + 3] && (n[i + 3] = a)
            }
        }

        function tw(e) {
            const t = e[3] - e[0],
                n = e[4] - e[1],
                i = e[5] - e[2];
            return 2 * (t * n + n * i + i * t)
        }
        const nw = 32,
            iw = (e, t) => e.candidate - t.candidate,
            rw = new Array(nw).fill().map((() => ({
                count: 0,
                bounds: new Float32Array(6),
                rightCacheBounds: new Float32Array(6),
                leftCacheBounds: new Float32Array(6),
                candidate: 0
            }))),
            ow = new Float32Array(6);
        class sw {
            constructor() {
                this.boundingData = new Float32Array(6)
            }
        }

        function aw(e, t, n, i, r, o) {
            let s = i,
                a = i + r - 1;
            const l = o.pos,
                c = 2 * o.axis;
            for (;;) {
                for (; s <= a && n[6 * s + c] < l;) s++;
                for (; s <= a && n[6 * a + c] >= l;) a--;
                if (!(s < a)) return s;
                for (let e = 0; e < 3; e++) {
                    let n = t[3 * s + e];
                    t[3 * s + e] = t[3 * a + e], t[3 * a + e] = n
                }
                for (let e = 0; e < 6; e++) {
                    let t = n[6 * s + e];
                    n[6 * s + e] = n[6 * a + e], n[6 * a + e] = t
                }
                s++, a--
            }
        }

        function lw(e, t, n, i, r, o) {
            let s = i,
                a = i + r - 1;
            const l = o.pos,
                c = 2 * o.axis;
            for (;;) {
                for (; s <= a && n[6 * s + c] < l;) s++;
                for (; s <= a && n[6 * a + c] >= l;) a--;
                if (!(s < a)) return s; {
                    let t = e[s];
                    e[s] = e[a], e[a] = t;
                    for (let e = 0; e < 6; e++) {
                        let t = n[6 * s + e];
                        n[6 * s + e] = n[6 * a + e], n[6 * a + e] = t
                    }
                    s++, a--
                }
            }
        }

        function cw(e, t) {
            return 65535 === t[e + 15]
        }

        function Aw(e, t) {
            return t[e + 6]
        }

        function hw(e, t) {
            return t[e + 14]
        }

        function uw(e) {
            return e + 8
        }

        function dw(e, t) {
            return t[e + 6]
        }

        function pw(e, t) {
            return t[e + 7]
        }
        let gw, fw, mw, Ew;
        const Cw = Math.pow(2, 32);

        function Iw(e) {
            return "count" in e ? 1 : 1 + Iw(e.left) + Iw(e.right)
        }

        function Sw(e, t, n) {
            return gw = new Float32Array(n), fw = new Uint32Array(n), mw = new Uint16Array(n), Ew = new Uint8Array(n), vw(e, t)
        }

        function vw(e, t) {
            const n = e / 4,
                i = e / 2,
                r = "count" in t,
                o = t.boundingData;
            for (let e = 0; e < 6; e++) gw[n + e] = o[e];
            if (r) {
                if (t.buffer) {
                    const i = t.buffer;
                    Ew.set(new Uint8Array(i), e);
                    for (let t = e, r = e + i.byteLength; t < r; t += Oy) {
                        cw(t / 2, mw) || (fw[t / 4 + 6] += n)
                    }
                    return e + i.byteLength
                } {
                    const r = t.offset,
                        o = t.count;
                    return fw[n + 6] = r, mw[i + 14] = o, mw[i + 15] = Ny, e + Oy
                }
            } {
                const i = t.left,
                    r = t.right,
                    o = t.splitAxis;
                let s;
                if (s = vw(e + Oy, i), s / 4 > Cw) throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");
                return fw[n + 6] = s / 4, s = vw(s, r), fw[n + 7] = o, s
            }
        }

        function Bw(e, t, n, i, r) {
            const {
                maxDepth: o,
                verbose: s,
                maxLeafTris: a,
                strategy: l,
                onProgress: c,
                indirect: A
            } = r, h = e._indirectBuffer, u = e.geometry, d = u.index ? u.index.array : null, p = A ? lw : aw, g = jy(u), f = new Float32Array(6);
            let m = !1;
            const E = new sw;
            return zy(t, n, i, E.boundingData, f),
                function e(n, i, r, c = null, A = 0) {
                    !m && A >= o && (m = !0, s && (console.warn(`MeshBVH: Max depth of ${o} reached when generating BVH. Consider increasing maxDepth.`), console.warn(u)));
                    if (r <= a || A >= o) return C(i + r), n.offset = i, n.count = r, n;
                    const g = function(e, t, n, i, r, o) {
                        let s = -1,
                            a = 0;
                        if (o === ky) s = Zy(t), -1 !== s && (a = (t[s] + t[s + 3]) / 2);
                        else if (o === Ly) s = Zy(e), -1 !== s && (a = function(e, t, n, i) {
                            let r = 0;
                            for (let o = t, s = t + n; o < s; o++) r += e[6 * o + 2 * i];
                            return r / n
                        }(n, i, r, s));
                        else if (o === Ky) {
                            const o = tw(e);
                            let l = Gy * r;
                            const c = 6 * i,
                                A = 6 * (i + r);
                            for (let e = 0; e < 3; e++) {
                                const i = t[e],
                                    h = (t[e + 3] - i) / nw;
                                if (r < nw / 4) {
                                    const t = [...rw];
                                    t.length = r;
                                    let i = 0;
                                    for (let r = c; r < A; r += 6, i++) {
                                        const o = t[i];
                                        o.candidate = n[r + 2 * e], o.count = 0;
                                        const {
                                            bounds: s,
                                            leftCacheBounds: a,
                                            rightCacheBounds: l
                                        } = o;
                                        for (let e = 0; e < 3; e++) l[e] = 1 / 0, l[e + 3] = -1 / 0, a[e] = 1 / 0, a[e + 3] = -1 / 0, s[e] = 1 / 0, s[e + 3] = -1 / 0;
                                        ew(r, n, s)
                                    }
                                    t.sort(iw);
                                    let h = r;
                                    for (let e = 0; e < h; e++) {
                                        const n = t[e];
                                        for (; e + 1 < h && t[e + 1].candidate === n.candidate;) t.splice(e + 1, 1), h--
                                    }
                                    for (let i = c; i < A; i += 6) {
                                        const r = n[i + 2 * e];
                                        for (let e = 0; e < h; e++) {
                                            const o = t[e];
                                            r >= o.candidate ? ew(i, n, o.rightCacheBounds) : (ew(i, n, o.leftCacheBounds), o.count++)
                                        }
                                    }
                                    for (let n = 0; n < h; n++) {
                                        const i = t[n],
                                            c = i.count,
                                            A = r - i.count,
                                            h = i.leftCacheBounds,
                                            u = i.rightCacheBounds;
                                        let d = 0;
                                        0 !== c && (d = tw(h) / o);
                                        let p = 0;
                                        0 !== A && (p = tw(u) / o);
                                        const g = Vy + Gy * (d * c + p * A);
                                        g < l && (s = e, l = g, a = i.candidate)
                                    }
                                } else {
                                    for (let e = 0; e < nw; e++) {
                                        const t = rw[e];
                                        t.count = 0, t.candidate = i + h + e * h;
                                        const n = t.bounds;
                                        for (let e = 0; e < 3; e++) n[e] = 1 / 0, n[e + 3] = -1 / 0
                                    }
                                    for (let t = c; t < A; t += 6) {
                                        let r = ~~((n[t + 2 * e] - i) / h);
                                        r >= nw && (r = nw - 1);
                                        const o = rw[r];
                                        o.count++, ew(t, n, o.bounds)
                                    }
                                    const t = rw[nw - 1];
                                    _y(t.bounds, t.rightCacheBounds);
                                    for (let e = nw - 2; e >= 0; e--) {
                                        const t = rw[e],
                                            n = rw[e + 1];
                                        $y(t.bounds, n.rightCacheBounds, t.rightCacheBounds)
                                    }
                                    let u = 0;
                                    for (let t = 0; t < nw - 1; t++) {
                                        const n = rw[t],
                                            i = n.count,
                                            c = n.bounds,
                                            A = rw[t + 1].rightCacheBounds;
                                        0 !== i && (0 === u ? _y(c, ow) : $y(c, ow, ow)), u += i;
                                        let h = 0,
                                            d = 0;
                                        0 !== u && (h = tw(ow) / o);
                                        const p = r - u;
                                        0 !== p && (d = tw(A) / o);
                                        const g = Vy + Gy * (h * u + d * p);
                                        g < l && (s = e, l = g, a = n.candidate)
                                    }
                                }
                            }
                        } else console.warn(`MeshBVH: Invalid build strategy value ${o} used.`);
                        return {
                            axis: s,
                            pos: a
                        }
                    }(n.boundingData, c, t, i, r, l);
                    if (-1 === g.axis) return C(i + r), n.offset = i, n.count = r, n;
                    const E = p(h, d, t, i, r, g);
                    if (E === i || E === i + r) C(i + r), n.offset = i, n.count = r;
                    else {
                        n.splitAxis = g.axis;
                        const o = new sw,
                            s = i,
                            a = E - i;
                        n.left = o, zy(t, s, a, o.boundingData, f), e(o, s, a, f, A + 1);
                        const l = new sw,
                            c = E,
                            h = r - a;
                        n.right = l, zy(t, c, h, l.boundingData, f), e(l, c, h, f, A + 1)
                    }
                    return n
                }(E, n, i, f), E;

            function C(e) {
                c && c(e / g)
            }
        }

        function xw(e, t) {
            const n = e.geometry;
            t.indirect && (e._indirectBuffer = function(e, t) {
                const n = (e.index ? e.index.count : e.attributes.position.count) / 3,
                    i = n > 65536,
                    r = i ? 4 : 2,
                    o = t ? new SharedArrayBuffer(n * r) : new ArrayBuffer(n * r),
                    s = i ? new Uint32Array(o) : new Uint16Array(o);
                for (let e = 0, t = s.length; e < t; e++) s[e] = e;
                return s
            }(n, t.useSharedArrayBuffer), function(e) {
                if (0 === e.groups.length) return !1;
                const t = jy(e),
                    n = Wy(e).sort(((e, t) => e.offset - t.offset)),
                    i = n[n.length - 1];
                i.count = Math.min(t - i.offset, i.count);
                let r = 0;
                return n.forEach((({
                    count: e
                }) => r += e)), t !== r
            }(n) && !t.verbose && console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')), e._indirectBuffer || Yy(n, t);
            const i = t.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer,
                r = function(e, t = null, n = null, i = null) {
                    const r = e.attributes.position,
                        o = e.index ? e.index.array : null,
                        s = jy(e),
                        a = r.normalized;
                    let l;
                    null === t ? (l = new Float32Array(6 * s * 4), n = 0, i = s) : (l = t, n = n || 0, i = i || s);
                    const c = r.array,
                        A = r.offset || 0;
                    let h = 3;
                    r.isInterleavedBufferAttribute && (h = r.data.stride);
                    const u = ["getX", "getY", "getZ"];
                    for (let e = n; e < n + i; e++) {
                        const t = 3 * e,
                            n = 6 * e;
                        let i = t + 0,
                            s = t + 1,
                            d = t + 2;
                        o && (i = o[i], s = o[s], d = o[d]), a || (i = i * h + A, s = s * h + A, d = d * h + A);
                        for (let e = 0; e < 3; e++) {
                            let t, o, A;
                            a ? (t = r[u[e]](i), o = r[u[e]](s), A = r[u[e]](d)) : (t = c[i + e], o = c[s + e], A = c[d + e]);
                            let h = t;
                            o < h && (h = o), A < h && (h = A);
                            let p = t;
                            o > p && (p = o), A > p && (p = A);
                            const g = (p - h) / 2,
                                f = 2 * e;
                            l[n + f + 0] = h + g, l[n + f + 1] = g + (Math.abs(h) + g) * Hy
                        }
                    }
                    return l
                }(n),
                o = t.indirect ? Jy(n) : Wy(n);
            e._roots = o.map((n => {
                const o = Bw(e, r, n.offset, n.count, t),
                    s = Iw(o),
                    a = new i(Oy * s);
                return Sw(0, o, a), a
            }))
        }
        class yw {
            constructor() {
                this.min = 1 / 0, this.max = -1 / 0
            }
            setFromPointsField(e, t) {
                let n = 1 / 0,
                    i = -1 / 0;
                for (let r = 0, o = e.length; r < o; r++) {
                    const o = e[r][t];
                    n = o < n ? o : n, i = o > i ? o : i
                }
                this.min = n, this.max = i
            }
            setFromPoints(e, t) {
                let n = 1 / 0,
                    i = -1 / 0;
                for (let r = 0, o = t.length; r < o; r++) {
                    const o = t[r],
                        s = e.dot(o);
                    n = s < n ? s : n, i = s > i ? s : i
                }
                this.min = n, this.max = i
            }
            isSeparated(e) {
                return this.min > e.max || e.min > this.max
            }
        }
        yw.prototype.setFromBox = function() {
            const e = new On;
            return function(t, n) {
                const i = n.min,
                    r = n.max;
                let o = 1 / 0,
                    s = -1 / 0;
                for (let n = 0; n <= 1; n++)
                    for (let a = 0; a <= 1; a++)
                        for (let l = 0; l <= 1; l++) {
                            e.x = i.x * n + r.x * (1 - n), e.y = i.y * a + r.y * (1 - a), e.z = i.z * l + r.z * (1 - l);
                            const c = t.dot(e);
                            o = Math.min(c, o), s = Math.max(c, s)
                        }
                this.min = o, this.max = s
            }
        }();
        ! function() {
            const e = new yw
        }();
        const ww = function() {
                const e = new On,
                    t = new On,
                    n = new On;
                return function(i, r, o) {
                    const s = i.start,
                        a = e,
                        l = r.start,
                        c = t;
                    n.subVectors(s, l), e.subVectors(i.end, i.start), t.subVectors(r.end, r.start);
                    const A = n.dot(c),
                        h = c.dot(a),
                        u = c.dot(c),
                        d = n.dot(a),
                        p = a.dot(a) * u - h * h;
                    let g, f;
                    g = 0 !== p ? (A * h - d * u) / p : 0, f = (A + g * h) / u, o.x = g, o.y = f
                }
            }(),
            bw = function() {
                const e = new dn,
                    t = new On,
                    n = new On;
                return function(i, r, o, s) {
                    ww(i, r, e);
                    let a = e.x,
                        l = e.y;
                    if (a >= 0 && a <= 1 && l >= 0 && l <= 1) return i.at(a, o), void r.at(l, s);
                    if (a >= 0 && a <= 1) return l < 0 ? r.at(0, s) : r.at(1, s), void i.closestPointToPoint(s, !0, o);
                    if (l >= 0 && l <= 1) return a < 0 ? i.at(0, o) : i.at(1, o), void r.closestPointToPoint(o, !0, s); {
                        let e, c;
                        e = a < 0 ? i.start : i.end, c = l < 0 ? r.start : r.end;
                        const A = t,
                            h = n;
                        return i.closestPointToPoint(c, !0, t), r.closestPointToPoint(e, !0, n), A.distanceToSquared(c) <= h.distanceToSquared(e) ? (o.copy(A), void s.copy(c)) : (o.copy(e), void s.copy(h))
                    }
                }
            }(),
            Qw = function() {
                const e = new On,
                    t = new On,
                    n = new po,
                    i = new _A;
                return function(r, o) {
                    const {
                        radius: s,
                        center: a
                    } = r, {
                        a: l,
                        b: c,
                        c: A
                    } = o;
                    i.start = l, i.end = c;
                    if (i.closestPointToPoint(a, !0, e).distanceTo(a) <= s) return !0;
                    i.start = l, i.end = A;
                    if (i.closestPointToPoint(a, !0, e).distanceTo(a) <= s) return !0;
                    i.start = c, i.end = A;
                    if (i.closestPointToPoint(a, !0, e).distanceTo(a) <= s) return !0;
                    const h = o.getPlane(n);
                    if (Math.abs(h.distanceToPoint(a)) <= s) {
                        const e = h.projectPoint(a, t);
                        if (o.containsPoint(e)) return !0
                    }
                    return !1
                }
            }();

        function Uw(e) {
            return Math.abs(e) < 1e-15
        }
        class Mw extends tr {
            constructor(...e) {
                super(...e), this.isExtendedTriangle = !0, this.satAxes = new Array(4).fill().map((() => new On)), this.satBounds = new Array(4).fill().map((() => new yw)), this.points = [this.a, this.b, this.c], this.sphere = new li, this.plane = new po, this.needsUpdate = !0
            }
            intersectsSphere(e) {
                return Qw(e, this)
            }
            update() {
                const e = this.a,
                    t = this.b,
                    n = this.c,
                    i = this.points,
                    r = this.satAxes,
                    o = this.satBounds,
                    s = r[0],
                    a = o[0];
                this.getNormal(s), a.setFromPoints(s, i);
                const l = r[1],
                    c = o[1];
                l.subVectors(e, t), c.setFromPoints(l, i);
                const A = r[2],
                    h = o[2];
                A.subVectors(t, n), h.setFromPoints(A, i);
                const u = r[3],
                    d = o[3];
                u.subVectors(n, e), d.setFromPoints(u, i), this.sphere.setFromPoints(this.points), this.plane.setFromNormalAndCoplanarPoint(s, e), this.needsUpdate = !1
            }
        }
        Mw.prototype.closestPointToSegment = function() {
            const e = new On,
                t = new On,
                n = new _A;
            return function(i, r = null, o = null) {
                const {
                    start: s,
                    end: a
                } = i, l = this.points;
                let c, A = 1 / 0;
                for (let s = 0; s < 3; s++) {
                    const a = (s + 1) % 3;
                    n.start.copy(l[s]), n.end.copy(l[a]), bw(n, i, e, t), c = e.distanceToSquared(t), c < A && (A = c, r && r.copy(e), o && o.copy(t))
                }
                return this.closestPointToPoint(s, e), c = s.distanceToSquared(e), c < A && (A = c, r && r.copy(e), o && o.copy(s)), this.closestPointToPoint(a, e), c = a.distanceToSquared(e), c < A && (A = c, r && r.copy(e), o && o.copy(a)), Math.sqrt(A)
            }
        }(), Mw.prototype.intersectsTriangle = function() {
            const e = new Mw,
                t = new Array(3),
                n = new Array(3),
                i = new yw,
                r = new yw,
                o = new On,
                s = new On,
                a = new On,
                l = new On,
                c = new On,
                A = new _A,
                h = new _A,
                u = new _A,
                d = new On;

            function p(e, t, n) {
                const i = e.points;
                let r = 0,
                    o = -1;
                for (let e = 0; e < 3; e++) {
                    const {
                        start: a,
                        end: l
                    } = A;
                    a.copy(i[e]), l.copy(i[(e + 1) % 3]), A.delta(s);
                    const c = Uw(t.distanceToPoint(a));
                    if (Uw(t.normal.dot(s)) && c) {
                        n.copy(A), r = 2;
                        break
                    }
                    const h = t.intersectLine(A, d);
                    if (!h && c && d.copy(a), (h || c) && !Uw(d.distanceTo(l))) {
                        if (r <= 1) {
                            (1 === r ? n.start : n.end).copy(d), c && (o = r)
                        } else if (r >= 2) {
                            (1 === o ? n.start : n.end).copy(d), r = 2;
                            break
                        }
                        if (r++, 2 === r && -1 === o) break
                    }
                }
                return r
            }
            return function(s, A = null, d = !1) {
                this.needsUpdate && this.update(), s.isExtendedTriangle ? s.needsUpdate && s.update() : (e.copy(s), e.update(), s = e);
                const g = this.plane,
                    f = s.plane;
                if (Math.abs(g.normal.dot(f.normal)) > 1 - 1e-10) {
                    const e = this.satBounds,
                        a = this.satAxes;
                    n[0] = s.a, n[1] = s.b, n[2] = s.c;
                    for (let t = 0; t < 4; t++) {
                        const r = e[t],
                            o = a[t];
                        if (i.setFromPoints(o, n), r.isSeparated(i)) return !1
                    }
                    const l = s.satBounds,
                        c = s.satAxes;
                    t[0] = this.a, t[1] = this.b, t[2] = this.c;
                    for (let e = 0; e < 4; e++) {
                        const n = l[e],
                            r = c[e];
                        if (i.setFromPoints(r, t), n.isSeparated(i)) return !1
                    }
                    for (let e = 0; e < 4; e++) {
                        const s = a[e];
                        for (let e = 0; e < 4; e++) {
                            const a = c[e];
                            if (o.crossVectors(s, a), i.setFromPoints(o, t), r.setFromPoints(o, n), i.isSeparated(r)) return !1
                        }
                    }
                    return A && (d || console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."), A.start.set(0, 0, 0), A.end.set(0, 0, 0)), !0
                } {
                    const e = p(this, f, h);
                    if (1 === e && s.containsPoint(h.end)) return A && (A.start.copy(h.end), A.end.copy(h.end)), !0;
                    if (2 !== e) return !1;
                    const t = p(s, g, u);
                    if (1 === t && this.containsPoint(u.end)) return A && (A.start.copy(u.end), A.end.copy(u.end)), !0;
                    if (2 !== t) return !1;
                    if (h.delta(a), u.delta(l), a.dot(l) < 0) {
                        let e = u.start;
                        u.start = u.end, u.end = e
                    }
                    const n = h.start.dot(a),
                        i = h.end.dot(a),
                        r = u.start.dot(a),
                        o = u.end.dot(a);
                    return (n === o || r === i || i < r !== n < o) && (A && (c.subVectors(h.start, u.start), c.dot(a) > 0 ? A.start.copy(h.start) : A.start.copy(u.start), c.subVectors(h.end, u.end), c.dot(a) < 0 ? A.end.copy(h.end) : A.end.copy(u.end)), !0)
                }
            }
        }(), Mw.prototype.distanceToPoint = function() {
            const e = new On;
            return function(t) {
                return this.closestPointToPoint(t, e), t.distanceTo(e)
            }
        }(), Mw.prototype.distanceToTriangle = function() {
            const e = new On,
                t = new On,
                n = ["a", "b", "c"],
                i = new _A,
                r = new _A;
            return function(o, s = null, a = null) {
                const l = s || a ? i : null;
                if (this.intersectsTriangle(o, l)) return (s || a) && (s && l.getCenter(s), a && l.getCenter(a)), 0;
                let c = 1 / 0;
                for (let t = 0; t < 3; t++) {
                    let i;
                    const r = n[t],
                        l = o[r];
                    this.closestPointToPoint(l, e), i = l.distanceToSquared(e), i < c && (c = i, s && s.copy(e), a && a.copy(l));
                    const A = this[r];
                    o.closestPointToPoint(A, e), i = A.distanceToSquared(e), i < c && (c = i, s && s.copy(A), a && a.copy(e))
                }
                for (let l = 0; l < 3; l++) {
                    const A = n[l],
                        h = n[(l + 1) % 3];
                    i.set(this[A], this[h]);
                    for (let l = 0; l < 3; l++) {
                        const A = n[l],
                            h = n[(l + 1) % 3];
                        r.set(o[A], o[h]), bw(i, r, e, t);
                        const u = e.distanceToSquared(t);
                        u < c && (c = u, s && s.copy(e), a && a.copy(t))
                    }
                }
                return Math.sqrt(c)
            }
        }();
        class Rw {
            constructor(e, t, n) {
                this.isOrientedBox = !0, this.min = new On, this.max = new On, this.matrix = new mi, this.invMatrix = new mi, this.points = new Array(8).fill().map((() => new On)), this.satAxes = new Array(3).fill().map((() => new On)), this.satBounds = new Array(3).fill().map((() => new yw)), this.alignedSatBounds = new Array(3).fill().map((() => new yw)), this.needsUpdate = !1, e && this.min.copy(e), t && this.max.copy(t), n && this.matrix.copy(n)
            }
            set(e, t, n) {
                this.min.copy(e), this.max.copy(t), this.matrix.copy(n), this.needsUpdate = !0
            }
            copy(e) {
                this.min.copy(e.min), this.max.copy(e.max), this.matrix.copy(e.matrix), this.needsUpdate = !0
            }
        }
        Rw.prototype.update = function() {
            const e = this.matrix,
                t = this.min,
                n = this.max,
                i = this.points;
            for (let r = 0; r <= 1; r++)
                for (let o = 0; o <= 1; o++)
                    for (let s = 0; s <= 1; s++) {
                        const a = i[1 * r | 2 * o | 4 * s];
                        a.x = r ? n.x : t.x, a.y = o ? n.y : t.y, a.z = s ? n.z : t.z, a.applyMatrix4(e)
                    }
            const r = this.satBounds,
                o = this.satAxes,
                s = i[0];
            for (let e = 0; e < 3; e++) {
                const t = o[e],
                    n = r[e],
                    a = i[1 << e];
                t.subVectors(s, a), n.setFromPoints(t, i)
            }
            const a = this.alignedSatBounds;
            a[0].setFromPointsField(i, "x"), a[1].setFromPointsField(i, "y"), a[2].setFromPointsField(i, "z"), this.invMatrix.copy(this.matrix).invert(), this.needsUpdate = !1
        }, Rw.prototype.intersectsBox = function() {
            const e = new yw;
            return function(t) {
                this.needsUpdate && this.update();
                const n = t.min,
                    i = t.max,
                    r = this.satBounds,
                    o = this.satAxes,
                    s = this.alignedSatBounds;
                if (e.min = n.x, e.max = i.x, s[0].isSeparated(e)) return !1;
                if (e.min = n.y, e.max = i.y, s[1].isSeparated(e)) return !1;
                if (e.min = n.z, e.max = i.z, s[2].isSeparated(e)) return !1;
                for (let n = 0; n < 3; n++) {
                    const i = o[n],
                        s = r[n];
                    if (e.setFromBox(i, t), s.isSeparated(e)) return !1
                }
                return !0
            }
        }(), Rw.prototype.intersectsTriangle = function() {
            const e = new Mw,
                t = new Array(3),
                n = new yw,
                i = new yw,
                r = new On;
            return function(o) {
                this.needsUpdate && this.update(), o.isExtendedTriangle ? o.needsUpdate && o.update() : (e.copy(o), e.update(), o = e);
                const s = this.satBounds,
                    a = this.satAxes;
                t[0] = o.a, t[1] = o.b, t[2] = o.c;
                for (let e = 0; e < 3; e++) {
                    const i = s[e],
                        r = a[e];
                    if (n.setFromPoints(r, t), i.isSeparated(n)) return !1
                }
                const l = o.satBounds,
                    c = o.satAxes,
                    A = this.points;
                for (let e = 0; e < 3; e++) {
                    const t = l[e],
                        i = c[e];
                    if (n.setFromPoints(i, A), t.isSeparated(n)) return !1
                }
                for (let e = 0; e < 3; e++) {
                    const o = a[e];
                    for (let e = 0; e < 4; e++) {
                        const s = c[e];
                        if (r.crossVectors(o, s), n.setFromPoints(r, t), i.setFromPoints(r, A), n.isSeparated(i)) return !1
                    }
                }
                return !0
            }
        }(), Rw.prototype.closestPointToPoint = function(e, t) {
            return this.needsUpdate && this.update(), t.copy(e).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix), t
        }, Rw.prototype.distanceToPoint = function() {
            const e = new On;
            return function(t) {
                return this.closestPointToPoint(t, e), t.distanceTo(e)
            }
        }(), Rw.prototype.distanceToBox = function() {
            const e = ["x", "y", "z"],
                t = new Array(12).fill().map((() => new _A)),
                n = new Array(12).fill().map((() => new _A)),
                i = new On,
                r = new On;
            return function(o, s = 0, a = null, l = null) {
                if (this.needsUpdate && this.update(), this.intersectsBox(o)) return (a || l) && (o.getCenter(r), this.closestPointToPoint(r, i), o.closestPointToPoint(i, r), a && a.copy(i), l && l.copy(r)), 0;
                const c = s * s,
                    A = o.min,
                    h = o.max,
                    u = this.points;
                let d = 1 / 0;
                for (let e = 0; e < 8; e++) {
                    const t = u[e];
                    r.copy(t).clamp(A, h);
                    const n = t.distanceToSquared(r);
                    if (n < d && (d = n, a && a.copy(t), l && l.copy(r), n < c)) return Math.sqrt(n)
                }
                let p = 0;
                for (let i = 0; i < 3; i++)
                    for (let r = 0; r <= 1; r++)
                        for (let o = 0; o <= 1; o++) {
                            const s = (i + 1) % 3,
                                a = (i + 2) % 3,
                                l = 1 << i | r << s | o << a,
                                c = u[r << s | o << a],
                                d = u[l];
                            t[p].set(c, d);
                            const g = e[i],
                                f = e[s],
                                m = e[a],
                                E = n[p],
                                C = E.start,
                                I = E.end;
                            C[g] = A[g], C[f] = r ? A[f] : h[f], C[m] = o ? A[m] : h[f], I[g] = h[g], I[f] = r ? A[f] : h[f], I[m] = o ? A[m] : h[f], p++
                        }
                for (let e = 0; e <= 1; e++)
                    for (let t = 0; t <= 1; t++)
                        for (let n = 0; n <= 1; n++) {
                            r.x = e ? h.x : A.x, r.y = t ? h.y : A.y, r.z = n ? h.z : A.z, this.closestPointToPoint(r, i);
                            const o = r.distanceToSquared(i);
                            if (o < d && (d = o, a && a.copy(i), l && l.copy(r), o < c)) return Math.sqrt(o)
                        }
                for (let e = 0; e < 12; e++) {
                    const o = t[e];
                    for (let e = 0; e < 12; e++) {
                        const t = n[e];
                        bw(o, t, i, r);
                        const s = i.distanceToSquared(r);
                        if (s < d && (d = s, a && a.copy(i), l && l.copy(r), s < c)) return Math.sqrt(s)
                    }
                }
                return Math.sqrt(d)
            }
        }();
        class Tw {
            constructor(e) {
                this._getNewPrimitive = e, this._primitives = []
            }
            getPrimitive() {
                const e = this._primitives;
                return 0 === e.length ? this._getNewPrimitive() : e.pop()
            }
            releasePrimitive(e) {
                this._primitives.push(e)
            }
        }
        class Fw extends Tw {
            constructor() {
                super((() => new Mw))
            }
        }
        const Dw = new Fw;
        const kw = new class {
            constructor() {
                this.float32Array = null, this.uint16Array = null, this.uint32Array = null;
                const e = [];
                let t = null;
                this.setBuffer = n => {
                    t && e.push(t), t = n, this.float32Array = new Float32Array(n), this.uint16Array = new Uint16Array(n), this.uint32Array = new Uint32Array(n)
                }, this.clearBuffer = () => {
                    t = null, this.float32Array = null, this.uint16Array = null, this.uint32Array = null, 0 !== e.length && this.setBuffer(e.pop())
                }
            }
        };
        let Lw, Kw;
        const Pw = [],
            Gw = new Tw((() => new qn));

        function Vw(e, t, n, i, r, o) {
            Lw = Gw.getPrimitive(), Kw = Gw.getPrimitive(), Pw.push(Lw, Kw), kw.setBuffer(e._roots[t]);
            const s = Ow(0, e.geometry, n, i, r, o);
            kw.clearBuffer(), Gw.releasePrimitive(Lw), Gw.releasePrimitive(Kw), Pw.pop(), Pw.pop();
            const a = Pw.length;
            return a > 0 && (Kw = Pw[a - 1], Lw = Pw[a - 2]), s
        }

        function Ow(e, t, n, i, r = null, o = 0, s = 0) {
            const {
                float32Array: a,
                uint16Array: l,
                uint32Array: c
            } = kw;
            let A = 2 * e;
            if (cw(A, l)) {
                const h = Aw(e, c),
                    u = hw(A, l);
                return Xy(e, a, Lw), i(h, u, !1, s, o + e, Lw)
            } {
                const d = uw(e),
                    p = dw(e, c);
                let g, f, m, E, C = d,
                    I = p;
                if (r && (m = Lw, E = Kw, Xy(C, a, m), Xy(I, a, E), g = r(m), f = r(E), f < g)) {
                    C = p, I = d;
                    const b = g;
                    g = f, f = b, m = E
                }
                m || (m = Lw, Xy(C, a, m));
                const S = n(m, cw(2 * C, l), g, s + 1, o + C);
                let v;
                if (S === Py) {
                    const Q = y(C);
                    v = i(Q, w(C) - Q, !0, s + 1, o + C, m)
                } else v = S && Ow(C, t, n, i, r, o, s + 1);
                if (v) return !0;
                E = Kw, Xy(I, a, E);
                const B = n(E, cw(2 * I, l), f, s + 1, o + I);
                let x;
                if (B === Py) {
                    const U = y(I);
                    x = i(U, w(I) - U, !0, s + 1, o + I, E)
                } else x = B && Ow(I, t, n, i, r, o, s + 1);
                return !!x;

                function y(e) {
                    const {
                        uint16Array: t,
                        uint32Array: n
                    } = kw;
                    let i = 2 * e;
                    for (; !cw(i, t);) i = 2 * (e = uw(e));
                    return Aw(e, n)
                }

                function w(e) {
                    const {
                        uint16Array: t,
                        uint32Array: n
                    } = kw;
                    let i = 2 * e;
                    for (; !cw(i, t);) i = 2 * (e = dw(e, n));
                    return Aw(e, n) + hw(i, t)
                }
            }
        }
        const Nw = new On,
            Hw = new On;
        const qw = new On,
            jw = new On,
            Yw = new On,
            Jw = new dn,
            Ww = new dn,
            zw = new dn,
            Xw = new On,
            Zw = new On,
            _w = new On,
            $w = new On;

        function eb(e, t, n, i, r, o, s, a, l) {
            qw.fromBufferAttribute(t, o), jw.fromBufferAttribute(t, s), Yw.fromBufferAttribute(t, a);
            const c = function(e, t, n, i, r, o) {
                let s;
                return s = o === Me ? e.intersectTriangle(i, n, t, !0, r) : e.intersectTriangle(t, n, i, o !== Re, r), null === s ? null : {
                    distance: e.origin.distanceTo(r),
                    point: r.clone()
                }
            }(e, qw, jw, Yw, $w, l);
            if (c) {
                i && (Jw.fromBufferAttribute(i, o), Ww.fromBufferAttribute(i, s), zw.fromBufferAttribute(i, a), c.uv = tr.getInterpolation($w, qw, jw, Yw, Jw, Ww, zw, new dn)), r && (Jw.fromBufferAttribute(r, o), Ww.fromBufferAttribute(r, s), zw.fromBufferAttribute(r, a), c.uv1 = tr.getInterpolation($w, qw, jw, Yw, Jw, Ww, zw, new dn)), n && (Xw.fromBufferAttribute(n, o), Zw.fromBufferAttribute(n, s), _w.fromBufferAttribute(n, a), c.normal = tr.getInterpolation($w, qw, jw, Yw, Xw, Zw, _w, new On), c.normal.dot(e.direction) > 0 && c.normal.multiplyScalar(-1));
                const t = {
                    a: o,
                    b: s,
                    c: a,
                    normal: new On,
                    materialIndex: 0
                };
                tr.getNormal(qw, jw, Yw, t.normal), c.face = t, c.faceIndex = o
            }
            return c
        }

        function tb(e, t, n, i, r) {
            const o = 3 * i;
            let s = o + 0,
                a = o + 1,
                l = o + 2;
            const c = e.index;
            e.index && (s = c.getX(s), a = c.getX(a), l = c.getX(l));
            const {
                position: A,
                normal: h,
                uv: u,
                uv1: d
            } = e.attributes, p = eb(n, A, h, u, d, s, a, l, t);
            return p ? (p.faceIndex = i, r && r.push(p), p) : null
        }

        function nb(e, t, n, i) {
            const r = e.a,
                o = e.b,
                s = e.c;
            let a = t,
                l = t + 1,
                c = t + 2;
            n && (a = n.getX(a), l = n.getX(l), c = n.getX(c)), r.x = i.getX(a), r.y = i.getY(a), r.z = i.getZ(a), o.x = i.getX(l), o.y = i.getY(l), o.z = i.getZ(l), s.x = i.getX(c), s.y = i.getY(c), s.z = i.getZ(c)
        }

        function ib(e, t, n, i, r, o, s) {
            const {
                geometry: a
            } = n, {
                index: l
            } = a, c = a.attributes.position;
            for (let n = e, a = t + e; n < a; n++) {
                let e;
                if (e = n, nb(s, 3 * e, l, c), s.needsUpdate = !0, i(s, e, r, o)) return !0
            }
            return !1
        }

        function rb(e, t = null) {
            t && Array.isArray(t) && (t = new Set(t));
            const n = e.geometry,
                i = n.index ? n.index.array : null,
                r = n.attributes.position;
            let o, s, a, l, c = 0;
            const A = e._roots;
            for (let e = 0, t = A.length; e < t; e++) o = A[e], s = new Uint32Array(o), a = new Uint16Array(o), l = new Float32Array(o), h(0, c), c += o.byteLength;

            function h(e, n, o = !1) {
                const c = 2 * e;
                if (a[c + 15] === Ny) {
                    const t = s[e + 6];
                    let n = 1 / 0,
                        o = 1 / 0,
                        A = 1 / 0,
                        h = -1 / 0,
                        u = -1 / 0,
                        d = -1 / 0;
                    for (let e = 3 * t, s = 3 * (t + a[c + 14]); e < s; e++) {
                        let t = i[e];
                        const s = r.getX(t),
                            a = r.getY(t),
                            l = r.getZ(t);
                        s < n && (n = s), s > h && (h = s), a < o && (o = a), a > u && (u = a), l < A && (A = l), l > d && (d = l)
                    }
                    return (l[e + 0] !== n || l[e + 1] !== o || l[e + 2] !== A || l[e + 3] !== h || l[e + 4] !== u || l[e + 5] !== d) && (l[e + 0] = n, l[e + 1] = o, l[e + 2] = A, l[e + 3] = h, l[e + 4] = u, l[e + 5] = d, !0)
                } {
                    const i = e + 8,
                        r = s[e + 6],
                        a = i + n,
                        c = r + n;
                    let A = o,
                        u = !1,
                        d = !1;
                    t ? A || (u = t.has(a), d = t.has(c), A = !u && !d) : (u = !0, d = !0);
                    const p = A || d;
                    let g = !1;
                    (A || u) && (g = h(i, n, A));
                    let f = !1;
                    p && (f = h(r, n, A));
                    const m = g || f;
                    if (m)
                        for (let t = 0; t < 3; t++) {
                            const n = i + t,
                                o = r + t,
                                s = l[n],
                                a = l[n + 3],
                                c = l[o],
                                A = l[o + 3];
                            l[e + t] = s < c ? s : c, l[e + t + 3] = a > A ? a : A
                        }
                    return m
                }
            }
        }
        const ob = new qn;

        function sb(e, t, n, i) {
            return Xy(e, t, ob), n.intersectBox(ob, i)
        }
        const ab = new On;

        function lb(e, t, n, i, r) {
            kw.setBuffer(e._roots[t]), cb(0, e, n, i, r), kw.clearBuffer()
        }

        function cb(e, t, n, i, r) {
            const {
                float32Array: o,
                uint16Array: s,
                uint32Array: a
            } = kw, l = 2 * e;
            if (cw(l, s)) {
                ! function(e, t, n, i, r, o) {
                    const {
                        geometry: s,
                        _indirectBuffer: a
                    } = e;
                    for (let e = i, a = i + r; e < a; e++) tb(s, t, n, e, o)
                }(t, n, i, Aw(e, a), hw(l, s), r)
            } else {
                const s = uw(e);
                sb(s, o, i, ab) && cb(s, t, n, i, r);
                const l = dw(e, a);
                sb(l, o, i, ab) && cb(l, t, n, i, r)
            }
        }
        const Ab = new On,
            hb = ["x", "y", "z"];

        function ub(e, t, n, i) {
            kw.setBuffer(e._roots[t]);
            const r = db(0, e, n, i);
            return kw.clearBuffer(), r
        }

        function db(e, t, n, i) {
            const {
                float32Array: r,
                uint16Array: o,
                uint32Array: s
            } = kw;
            let a = 2 * e;
            if (cw(a, o)) {
                return function(e, t, n, i, r) {
                    const {
                        geometry: o,
                        _indirectBuffer: s
                    } = e;
                    let a = 1 / 0,
                        l = null;
                    for (let e = i, s = i + r; e < s; e++) {
                        let i;
                        i = tb(o, t, n, e), i && i.distance < a && (l = i, a = i.distance)
                    }
                    return l
                }(t, n, i, Aw(e, s), hw(a, o))
            } {
                const o = pw(e, s),
                    a = hb[o],
                    l = i.direction[a] >= 0;
                let c, A;
                l ? (c = uw(e), A = dw(e, s)) : (c = dw(e, s), A = uw(e));
                const h = sb(c, r, i, Ab) ? db(c, t, n, i) : null;
                if (h) {
                    const e = h.point[a];
                    if (l ? e <= r[A + o] : e >= r[A + o + 3]) return h
                }
                const u = sb(A, r, i, Ab) ? db(A, t, n, i) : null;
                return h && u ? h.distance <= u.distance ? h : u : h || u || null
            }
        }
        const pb = new qn,
            gb = new Mw,
            fb = new Mw,
            mb = new mi,
            Eb = new Rw,
            Cb = new Rw;

        function Ib(e, t, n, i) {
            kw.setBuffer(e._roots[t]);
            const r = Sb(0, e, n, i);
            return kw.clearBuffer(), r
        }

        function Sb(e, t, n, i, r = null) {
            const {
                float32Array: o,
                uint16Array: s,
                uint32Array: a
            } = kw;
            let l = 2 * e;
            null === r && (n.boundingBox || n.computeBoundingBox(), Eb.set(n.boundingBox.min, n.boundingBox.max, i), r = Eb);
            if (!cw(l, s)) {
                const s = e + 8,
                    l = a[e + 6];
                Xy(s, o, pb);
                if (r.intersectsBox(pb) && Sb(s, t, n, i, r)) return !0;
                Xy(l, o, pb);
                return !!(r.intersectsBox(pb) && Sb(l, t, n, i, r))
            } {
                const r = t.geometry,
                    c = r.index,
                    A = r.attributes.position,
                    h = n.index,
                    u = n.attributes.position,
                    d = Aw(e, a),
                    p = hw(l, s);
                if (mb.copy(i).invert(), n.boundsTree) {
                    Xy(e, o, Cb), Cb.matrix.copy(mb), Cb.needsUpdate = !0;
                    const t = n.boundsTree.shapecast({
                        intersectsBounds: e => Cb.intersectsBox(e),
                        intersectsTriangle: e => {
                            e.a.applyMatrix4(i), e.b.applyMatrix4(i), e.c.applyMatrix4(i), e.needsUpdate = !0;
                            for (let t = 3 * d, n = 3 * (p + d); t < n; t += 3)
                                if (nb(fb, t, c, A), fb.needsUpdate = !0, e.intersectsTriangle(fb)) return !0;
                            return !1
                        }
                    });
                    return t
                }
                for (let e = 3 * d, t = 3 * (p + d); e < t; e += 3) {
                    nb(gb, e, c, A), gb.a.applyMatrix4(mb), gb.b.applyMatrix4(mb), gb.c.applyMatrix4(mb), gb.needsUpdate = !0;
                    for (let e = 0, t = h.count; e < t; e += 3)
                        if (nb(fb, e, h, u), fb.needsUpdate = !0, gb.intersectsTriangle(fb)) return !0
                }
            }
        }
        const vb = new mi,
            Bb = new Rw,
            xb = new Rw,
            yb = new On,
            wb = new On,
            bb = new On,
            Qb = new On;

        function Ub(e, t, n, i = {}, r = {}, o = 0, s = 1 / 0) {
            t.boundingBox || t.computeBoundingBox(), Bb.set(t.boundingBox.min, t.boundingBox.max, n), Bb.needsUpdate = !0;
            const a = e.geometry,
                l = a.attributes.position,
                c = a.index,
                A = t.attributes.position,
                h = t.index,
                u = Dw.getPrimitive(),
                d = Dw.getPrimitive();
            let p = yb,
                g = wb,
                f = null,
                m = null;
            r && (f = bb, m = Qb);
            let E = 1 / 0,
                C = null,
                I = null;
            return vb.copy(n).invert(), xb.matrix.copy(vb), e.shapecast({
                boundsTraverseOrder: e => Bb.distanceToBox(e),
                intersectsBounds: (e, t, n) => n < E && n < s && (t && (xb.min.copy(e.min), xb.max.copy(e.max), xb.needsUpdate = !0), !0),
                intersectsRange: (e, i) => {
                    if (t.boundsTree) {
                        return t.boundsTree.shapecast({
                            boundsTraverseOrder: e => xb.distanceToBox(e),
                            intersectsBounds: (e, t, n) => n < E && n < s,
                            intersectsRange: (t, r) => {
                                for (let s = t, a = t + r; s < a; s++) {
                                    nb(d, 3 * s, h, A), d.a.applyMatrix4(n), d.b.applyMatrix4(n), d.c.applyMatrix4(n), d.needsUpdate = !0;
                                    for (let t = e, n = e + i; t < n; t++) {
                                        nb(u, 3 * t, c, l), u.needsUpdate = !0;
                                        const e = u.distanceToTriangle(d, p, f);
                                        if (e < E && (g.copy(p), m && m.copy(f), E = e, C = t, I = s), e < o) return !0
                                    }
                                }
                            }
                        })
                    }
                    for (let r = 0, s = jy(t); r < s; r++) {
                        nb(d, 3 * r, h, A), d.a.applyMatrix4(n), d.b.applyMatrix4(n), d.c.applyMatrix4(n), d.needsUpdate = !0;
                        for (let t = e, n = e + i; t < n; t++) {
                            nb(u, 3 * t, c, l), u.needsUpdate = !0;
                            const e = u.distanceToTriangle(d, p, f);
                            if (e < E && (g.copy(p), m && m.copy(f), E = e, C = t, I = r), e < o) return !0
                        }
                    }
                }
            }), Dw.releasePrimitive(u), Dw.releasePrimitive(d), E === 1 / 0 ? null : (i.point ? i.point.copy(g) : i.point = g.clone(), i.distance = E, i.faceIndex = C, r && (r.point ? r.point.copy(m) : r.point = m.clone(), r.point.applyMatrix4(vb), g.applyMatrix4(vb), r.distance = g.sub(r.point).length(), r.faceIndex = I), i)
        }

        function Mb(e, t, n, i, r, o, s) {
            const {
                geometry: a
            } = n, {
                index: l
            } = a, c = a.attributes.position;
            for (let a = e, A = t + e; a < A; a++) {
                let e;
                if (e = n.resolveTriangleIndex(a), nb(s, 3 * e, l, c), s.needsUpdate = !0, i(s, e, r, o)) return !0
            }
            return !1
        }

        function Rb(e, t = null) {
            t && Array.isArray(t) && (t = new Set(t));
            const n = e.geometry,
                i = n.index ? n.index.array : null,
                r = n.attributes.position;
            let o, s, a, l, c = 0;
            const A = e._roots;
            for (let e = 0, t = A.length; e < t; e++) o = A[e], s = new Uint32Array(o), a = new Uint16Array(o), l = new Float32Array(o), h(0, c), c += o.byteLength;

            function h(n, o, c = !1) {
                const A = 2 * n;
                if (a[A + 15] === Ny) {
                    const t = s[n + 6];
                    let o = 1 / 0,
                        c = 1 / 0,
                        h = 1 / 0,
                        u = -1 / 0,
                        d = -1 / 0,
                        p = -1 / 0;
                    for (let n = t, s = t + a[A + 14]; n < s; n++) {
                        const t = 3 * e.resolveTriangleIndex(n);
                        for (let e = 0; e < 3; e++) {
                            let n = t + e;
                            n = i ? i[n] : n;
                            const s = r.getX(n),
                                a = r.getY(n),
                                l = r.getZ(n);
                            s < o && (o = s), s > u && (u = s), a < c && (c = a), a > d && (d = a), l < h && (h = l), l > p && (p = l)
                        }
                    }
                    return (l[n + 0] !== o || l[n + 1] !== c || l[n + 2] !== h || l[n + 3] !== u || l[n + 4] !== d || l[n + 5] !== p) && (l[n + 0] = o, l[n + 1] = c, l[n + 2] = h, l[n + 3] = u, l[n + 4] = d, l[n + 5] = p, !0)
                } {
                    const e = n + 8,
                        i = s[n + 6],
                        r = e + o,
                        a = i + o;
                    let A = c,
                        u = !1,
                        d = !1;
                    t ? A || (u = t.has(r), d = t.has(a), A = !u && !d) : (u = !0, d = !0);
                    const p = A || d;
                    let g = !1;
                    (A || u) && (g = h(e, o, A));
                    let f = !1;
                    p && (f = h(i, o, A));
                    const m = g || f;
                    if (m)
                        for (let t = 0; t < 3; t++) {
                            const r = e + t,
                                o = i + t,
                                s = l[r],
                                a = l[r + 3],
                                c = l[o],
                                A = l[o + 3];
                            l[n + t] = s < c ? s : c, l[n + t + 3] = a > A ? a : A
                        }
                    return m
                }
            }
        }
        const Tb = new On;

        function Fb(e, t, n, i, r) {
            kw.setBuffer(e._roots[t]), Db(0, e, n, i, r), kw.clearBuffer()
        }

        function Db(e, t, n, i, r) {
            const {
                float32Array: o,
                uint16Array: s,
                uint32Array: a
            } = kw, l = 2 * e;
            if (cw(l, s)) {
                ! function(e, t, n, i, r, o) {
                    const {
                        geometry: s,
                        _indirectBuffer: a
                    } = e;
                    for (let e = i, l = i + r; e < l; e++) tb(s, t, n, a ? a[e] : e, o)
                }(t, n, i, Aw(e, a), hw(l, s), r)
            } else {
                const s = uw(e);
                sb(s, o, i, Tb) && Db(s, t, n, i, r);
                const l = dw(e, a);
                sb(l, o, i, Tb) && Db(l, t, n, i, r)
            }
        }
        const kb = new On,
            Lb = ["x", "y", "z"];

        function Kb(e, t, n, i) {
            kw.setBuffer(e._roots[t]);
            const r = Pb(0, e, n, i);
            return kw.clearBuffer(), r
        }

        function Pb(e, t, n, i) {
            const {
                float32Array: r,
                uint16Array: o,
                uint32Array: s
            } = kw;
            let a = 2 * e;
            if (cw(a, o)) {
                return function(e, t, n, i, r) {
                    const {
                        geometry: o,
                        _indirectBuffer: s
                    } = e;
                    let a = 1 / 0,
                        l = null;
                    for (let e = i, c = i + r; e < c; e++) {
                        let i;
                        i = tb(o, t, n, s ? s[e] : e), i && i.distance < a && (l = i, a = i.distance)
                    }
                    return l
                }(t, n, i, Aw(e, s), hw(a, o))
            } {
                const o = pw(e, s),
                    a = Lb[o],
                    l = i.direction[a] >= 0;
                let c, A;
                l ? (c = uw(e), A = dw(e, s)) : (c = dw(e, s), A = uw(e));
                const h = sb(c, r, i, kb) ? Pb(c, t, n, i) : null;
                if (h) {
                    const e = h.point[a];
                    if (l ? e <= r[A + o] : e >= r[A + o + 3]) return h
                }
                const u = sb(A, r, i, kb) ? Pb(A, t, n, i) : null;
                return h && u ? h.distance <= u.distance ? h : u : h || u || null
            }
        }
        const Gb = new qn,
            Vb = new Mw,
            Ob = new Mw,
            Nb = new mi,
            Hb = new Rw,
            qb = new Rw;

        function jb(e, t, n, i) {
            kw.setBuffer(e._roots[t]);
            const r = Yb(0, e, n, i);
            return kw.clearBuffer(), r
        }

        function Yb(e, t, n, i, r = null) {
            const {
                float32Array: o,
                uint16Array: s,
                uint32Array: a
            } = kw;
            let l = 2 * e;
            null === r && (n.boundingBox || n.computeBoundingBox(), Hb.set(n.boundingBox.min, n.boundingBox.max, i), r = Hb);
            if (!cw(l, s)) {
                const s = e + 8,
                    l = a[e + 6];
                Xy(s, o, Gb);
                if (r.intersectsBox(Gb) && Yb(s, t, n, i, r)) return !0;
                Xy(l, o, Gb);
                return !!(r.intersectsBox(Gb) && Yb(l, t, n, i, r))
            } {
                const r = t.geometry,
                    c = r.index,
                    A = r.attributes.position,
                    h = n.index,
                    u = n.attributes.position,
                    d = Aw(e, a),
                    p = hw(l, s);
                if (Nb.copy(i).invert(), n.boundsTree) {
                    Xy(e, o, qb), qb.matrix.copy(Nb), qb.needsUpdate = !0;
                    const r = n.boundsTree.shapecast({
                        intersectsBounds: e => qb.intersectsBox(e),
                        intersectsTriangle: e => {
                            e.a.applyMatrix4(i), e.b.applyMatrix4(i), e.c.applyMatrix4(i), e.needsUpdate = !0;
                            for (let n = d, i = p + d; n < i; n++)
                                if (nb(Ob, 3 * t.resolveTriangleIndex(n), c, A), Ob.needsUpdate = !0, e.intersectsTriangle(Ob)) return !0;
                            return !1
                        }
                    });
                    return r
                }
                for (let e = d, n = p + d; e < n; e++) {
                    const n = t.resolveTriangleIndex(e);
                    nb(Vb, 3 * n, c, A), Vb.a.applyMatrix4(Nb), Vb.b.applyMatrix4(Nb), Vb.c.applyMatrix4(Nb), Vb.needsUpdate = !0;
                    for (let e = 0, t = h.count; e < t; e += 3)
                        if (nb(Ob, e, h, u), Ob.needsUpdate = !0, Vb.intersectsTriangle(Ob)) return !0
                }
            }
        }
        const Jb = new mi,
            Wb = new Rw,
            zb = new Rw,
            Xb = new On,
            Zb = new On,
            _b = new On,
            $b = new On;

        function eQ(e, t, n, i = {}, r = {}, o = 0, s = 1 / 0) {
            t.boundingBox || t.computeBoundingBox(), Wb.set(t.boundingBox.min, t.boundingBox.max, n), Wb.needsUpdate = !0;
            const a = e.geometry,
                l = a.attributes.position,
                c = a.index,
                A = t.attributes.position,
                h = t.index,
                u = Dw.getPrimitive(),
                d = Dw.getPrimitive();
            let p = Xb,
                g = Zb,
                f = null,
                m = null;
            r && (f = _b, m = $b);
            let E = 1 / 0,
                C = null,
                I = null;
            return Jb.copy(n).invert(), zb.matrix.copy(Jb), e.shapecast({
                boundsTraverseOrder: e => Wb.distanceToBox(e),
                intersectsBounds: (e, t, n) => n < E && n < s && (t && (zb.min.copy(e.min), zb.max.copy(e.max), zb.needsUpdate = !0), !0),
                intersectsRange: (i, r) => {
                    if (t.boundsTree) {
                        const a = t.boundsTree;
                        return a.shapecast({
                            boundsTraverseOrder: e => zb.distanceToBox(e),
                            intersectsBounds: (e, t, n) => n < E && n < s,
                            intersectsRange: (t, s) => {
                                for (let S = t, v = t + s; S < v; S++) {
                                    const t = a.resolveTriangleIndex(S);
                                    nb(d, 3 * t, h, A), d.a.applyMatrix4(n), d.b.applyMatrix4(n), d.c.applyMatrix4(n), d.needsUpdate = !0;
                                    for (let t = i, n = i + r; t < n; t++) {
                                        const n = e.resolveTriangleIndex(t);
                                        nb(u, 3 * n, c, l), u.needsUpdate = !0;
                                        const i = u.distanceToTriangle(d, p, f);
                                        if (i < E && (g.copy(p), m && m.copy(f), E = i, C = t, I = S), i < o) return !0
                                    }
                                }
                            }
                        })
                    }
                    for (let s = 0, a = jy(t); s < a; s++) {
                        nb(d, 3 * s, h, A), d.a.applyMatrix4(n), d.b.applyMatrix4(n), d.c.applyMatrix4(n), d.needsUpdate = !0;
                        for (let t = i, n = i + r; t < n; t++) {
                            const n = e.resolveTriangleIndex(t);
                            nb(u, 3 * n, c, l), u.needsUpdate = !0;
                            const i = u.distanceToTriangle(d, p, f);
                            if (i < E && (g.copy(p), m && m.copy(f), E = i, C = t, I = s), i < o) return !0
                        }
                    }
                }
            }), Dw.releasePrimitive(u), Dw.releasePrimitive(d), E === 1 / 0 ? null : (i.point ? i.point.copy(g) : i.point = g.clone(), i.distance = E, i.faceIndex = C, r && (r.point ? r.point.copy(m) : r.point = m.clone(), r.point.applyMatrix4(Jb), g.applyMatrix4(Jb), r.distance = g.sub(r.point).length(), r.faceIndex = I), i)
        }
        const tQ = new kw.constructor,
            nQ = new kw.constructor,
            iQ = new Tw((() => new qn)),
            rQ = new qn,
            oQ = new qn,
            sQ = new qn,
            aQ = new qn;
        let lQ = !1;

        function cQ(e, t, n, i, r, o = 0, s = 0, a = 0, l = 0, c = null, A = !1) {
            let h, u;
            A ? (h = nQ, u = tQ) : (h = tQ, u = nQ);
            const d = h.float32Array,
                p = h.uint32Array,
                g = h.uint16Array,
                f = u.float32Array,
                m = u.uint32Array,
                E = u.uint16Array,
                C = 2 * t,
                I = cw(2 * e, g),
                S = cw(C, E);
            let v = !1;
            if (S && I) v = A ? r(Aw(t, m), hw(2 * t, E), Aw(e, p), hw(2 * e, g), l, s + t, a, o + e) : r(Aw(e, p), hw(2 * e, g), Aw(t, m), hw(2 * t, E), a, o + e, l, s + t);
            else if (S) {
                const c = iQ.getPrimitive();
                Xy(t, f, c), c.applyMatrix4(n);
                const h = uw(e),
                    u = dw(e, p);
                Xy(h, d, rQ), Xy(u, d, oQ);
                const g = c.intersectsBox(rQ),
                    m = c.intersectsBox(oQ);
                v = g && cQ(t, h, i, n, r, s, o, l, a + 1, c, !A) || m && cQ(t, u, i, n, r, s, o, l, a + 1, c, !A), iQ.releasePrimitive(c)
            } else {
                const h = uw(t),
                    u = dw(t, m);
                Xy(h, f, sQ), Xy(u, f, aQ);
                const g = c.intersectsBox(sQ),
                    E = c.intersectsBox(aQ);
                if (g && E) v = cQ(e, h, n, i, r, o, s, a, l + 1, c, A) || cQ(e, u, n, i, r, o, s, a, l + 1, c, A);
                else if (g)
                    if (I) v = cQ(e, h, n, i, r, o, s, a, l + 1, c, A);
                    else {
                        const t = iQ.getPrimitive();
                        t.copy(sQ).applyMatrix4(n);
                        const c = uw(e),
                            u = dw(e, p);
                        Xy(c, d, rQ), Xy(u, d, oQ);
                        const g = t.intersectsBox(rQ),
                            f = t.intersectsBox(oQ);
                        v = g && cQ(h, c, i, n, r, s, o, l, a + 1, t, !A) || f && cQ(h, u, i, n, r, s, o, l, a + 1, t, !A), iQ.releasePrimitive(t)
                    }
                else if (E)
                    if (I) v = cQ(e, u, n, i, r, o, s, a, l + 1, c, A);
                    else {
                        const t = iQ.getPrimitive();
                        t.copy(aQ).applyMatrix4(n);
                        const c = uw(e),
                            h = dw(e, p);
                        Xy(c, d, rQ), Xy(h, d, oQ);
                        const g = t.intersectsBox(rQ),
                            f = t.intersectsBox(oQ);
                        v = g && cQ(u, c, i, n, r, s, o, l, a + 1, t, !A) || f && cQ(u, h, i, n, r, s, o, l, a + 1, t, !A), iQ.releasePrimitive(t)
                    }
            }
            return v
        }
        const AQ = new Rw,
            hQ = new qn,
            uQ = {
                strategy: ky,
                maxDepth: 40,
                maxLeafTris: 10,
                useSharedArrayBuffer: !1,
                setBoundingBox: !0,
                onProgress: null,
                indirect: !1,
                verbose: !0
            };
        class dQ {
            static serialize(e, t = {}) {
                t = {
                    cloneBuffers: !0,
                    ...t
                };
                const n = e.geometry,
                    i = e._roots,
                    r = e._indirectBuffer,
                    o = n.getIndex();
                let s;
                return s = t.cloneBuffers ? {
                    roots: i.map((e => e.slice())),
                    index: o.array.slice(),
                    indirectBuffer: r ? r.slice() : null
                } : {
                    roots: i,
                    index: o.array,
                    indirectBuffer: r
                }, s
            }
            static deserialize(e, t, n = {}) {
                n = {
                    setIndex: !0,
                    indirect: Boolean(e.indirectBuffer),
                    ...n
                };
                const {
                    index: i,
                    roots: r,
                    indirectBuffer: o
                } = e, s = new dQ(t, { ...n,
                    [qy]: !0
                });
                if (s._roots = r, s._indirectBuffer = o || null, n.setIndex) {
                    const n = t.getIndex();
                    if (null === n) {
                        const n = new Er(e.index, 1, !1);
                        t.setIndex(n)
                    } else n.array !== i && (n.array.set(i), n.needsUpdate = !0)
                }
                return s
            }
            get indirect() {
                return !!this._indirectBuffer
            }
            constructor(e, t = {}) {
                if (!e.isBufferGeometry) throw new Error("MeshBVH: Only BufferGeometries are supported.");
                if (e.index && e.index.isInterleavedBufferAttribute) throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");
                if ((t = Object.assign({ ...uQ,
                        [qy]: !1
                    }, t)).useSharedArrayBuffer && "undefined" == typeof SharedArrayBuffer) throw new Error("MeshBVH: SharedArrayBuffer is not available.");
                this.geometry = e, this._roots = null, this._indirectBuffer = null, t[qy] || (xw(this, t), !e.boundingBox && t.setBoundingBox && (e.boundingBox = this.getBoundingBox(new qn)));
                const {
                    _indirectBuffer: n
                } = this;
                this.resolveTriangleIndex = t.indirect ? e => n[e] : e => e
            }
            refit(e = null) {
                return (this.indirect ? Rb : rb)(this, e)
            }
            traverse(e, t = 0) {
                const n = this._roots[t],
                    i = new Uint32Array(n),
                    r = new Uint16Array(n);
                ! function t(o, s = 0) {
                    const a = 2 * o,
                        l = r[a + 15] === Ny;
                    if (l) {
                        const t = i[o + 6],
                            c = r[a + 14];
                        e(s, l, new Float32Array(n, 4 * o, 6), t, c)
                    } else {
                        const r = o + Oy / 4,
                            a = i[o + 6],
                            c = i[o + 7];
                        e(s, l, new Float32Array(n, 4 * o, 6), c) || (t(r, s + 1), t(a, s + 1))
                    }
                }(0)
            }
            raycast(e, t = Ue) {
                const n = this._roots,
                    i = this.geometry,
                    r = [],
                    o = t.isMaterial,
                    s = Array.isArray(t),
                    a = i.groups,
                    l = o ? t.side : t,
                    c = this.indirect ? Fb : lb;
                for (let i = 0, o = n.length; i < o; i++) {
                    const n = s ? t[a[i].materialIndex].side : l,
                        o = r.length;
                    if (c(this, i, n, e, r), s) {
                        const e = a[i].materialIndex;
                        for (let t = o, n = r.length; t < n; t++) r[t].face.materialIndex = e
                    }
                }
                return r
            }
            raycastFirst(e, t = Ue) {
                const n = this._roots,
                    i = this.geometry,
                    r = t.isMaterial,
                    o = Array.isArray(t);
                let s = null;
                const a = i.groups,
                    l = r ? t.side : t,
                    c = this.indirect ? Kb : ub;
                for (let i = 0, r = n.length; i < r; i++) {
                    const n = c(this, i, o ? t[a[i].materialIndex].side : l, e);
                    null != n && (null == s || n.distance < s.distance) && (s = n, o && (n.face.materialIndex = a[i].materialIndex))
                }
                return s
            }
            intersectsGeometry(e, t) {
                let n = !1;
                const i = this._roots,
                    r = this.indirect ? jb : Ib;
                for (let o = 0, s = i.length; o < s && (n = r(this, o, e, t), !n); o++);
                return n
            }
            shapecast(e) {
                const t = Dw.getPrimitive(),
                    n = this.indirect ? Mb : ib;
                let {
                    boundsTraverseOrder: i,
                    intersectsBounds: r,
                    intersectsRange: o,
                    intersectsTriangle: s
                } = e;
                if (o && s) {
                    const e = o;
                    o = (i, r, o, a, l) => !!e(i, r, o, a, l) || n(i, r, this, s, o, a, t)
                } else o || (o = s ? (e, i, r, o) => n(e, i, this, s, r, o, t) : (e, t, n) => n);
                let a = !1,
                    l = 0;
                const c = this._roots;
                for (let e = 0, t = c.length; e < t; e++) {
                    const t = c[e];
                    if (a = Vw(this, e, r, o, i, l), a) break;
                    l += t.byteLength
                }
                return Dw.releasePrimitive(t), a
            }
            bvhcast(e, t, n) {
                let {
                    intersectsRanges: i,
                    intersectsTriangles: r
                } = n;
                const o = Dw.getPrimitive(),
                    s = this.geometry.index,
                    a = this.geometry.attributes.position,
                    l = this.indirect ? e => {
                        const t = this.resolveTriangleIndex(e);
                        nb(o, 3 * t, s, a)
                    } : e => {
                        nb(o, 3 * e, s, a)
                    },
                    c = Dw.getPrimitive(),
                    A = e.geometry.index,
                    h = e.geometry.attributes.position,
                    u = e.indirect ? t => {
                        const n = e.resolveTriangleIndex(t);
                        nb(c, 3 * n, A, h)
                    } : e => {
                        nb(c, 3 * e, A, h)
                    };
                if (r) {
                    const e = (e, n, i, s, a, A, h, d) => {
                        for (let p = i, g = i + s; p < g; p++) {
                            u(p), c.a.applyMatrix4(t), c.b.applyMatrix4(t), c.c.applyMatrix4(t), c.needsUpdate = !0;
                            for (let t = e, i = e + n; t < i; t++)
                                if (l(t), o.needsUpdate = !0, r(o, c, t, p, a, A, h, d)) return !0
                        }
                        return !1
                    };
                    if (i) {
                        const t = i;
                        i = function(n, i, r, o, s, a, l, c) {
                            return !!t(n, i, r, o, s, a, l, c) || e(n, i, r, o, s, a, l, c)
                        }
                    } else i = e
                }
                return function(e, t, n, i) {
                    if (lQ) throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");
                    lQ = !0;
                    const r = e._roots,
                        o = t._roots;
                    let s, a = 0,
                        l = 0;
                    const c = (new mi).copy(n).invert();
                    for (let e = 0, t = r.length; e < t; e++) {
                        tQ.setBuffer(r[e]), l = 0;
                        const t = iQ.getPrimitive();
                        Xy(0, tQ.float32Array, t), t.applyMatrix4(c);
                        for (let r = 0, A = o.length; r < A && (nQ.setBuffer(o[e]), s = cQ(0, 0, n, c, i, a, l, 0, 0, t), nQ.clearBuffer(), l += o[r].length, !s); r++);
                        if (iQ.releasePrimitive(t), tQ.clearBuffer(), a += r[e].length, s) break
                    }
                    return lQ = !1, s
                }(this, e, t, i)
            }
            intersectsBox(e, t) {
                return AQ.set(e.min, e.max, t), AQ.needsUpdate = !0, this.shapecast({
                    intersectsBounds: e => AQ.intersectsBox(e),
                    intersectsTriangle: e => AQ.intersectsTriangle(e)
                })
            }
            intersectsSphere(e) {
                return this.shapecast({
                    intersectsBounds: t => e.intersectsBox(t),
                    intersectsTriangle: t => t.intersectsSphere(e)
                })
            }
            closestPointToGeometry(e, t, n = {}, i = {}, r = 0, o = 1 / 0) {
                return (this.indirect ? eQ : Ub)(this, e, t, n, i, r, o)
            }
            closestPointToPoint(e, t = {}, n = 0, i = 1 / 0) {
                return function(e, t, n = {}, i = 0, r = 1 / 0) {
                    const o = i * i,
                        s = r * r;
                    let a = 1 / 0,
                        l = null;
                    if (e.shapecast({
                            boundsTraverseOrder: e => (Nw.copy(t).clamp(e.min, e.max), Nw.distanceToSquared(t)),
                            intersectsBounds: (e, t, n) => n < a && n < s,
                            intersectsTriangle: (e, n) => {
                                e.closestPointToPoint(t, Nw);
                                const i = t.distanceToSquared(Nw);
                                return i < a && (Hw.copy(Nw), a = i, l = n), i < o
                            }
                        }), a === 1 / 0) return null;
                    const c = Math.sqrt(a);
                    return n.point ? n.point.copy(Hw) : n.point = Hw.clone(), n.distance = c, n.faceIndex = l, n
                }(this, e, t, n, i)
            }
            getBoundingBox(e) {
                e.makeEmpty();
                return this._roots.forEach((t => {
                    Xy(0, new Float32Array(t), hQ), e.union(hQ)
                })), e
            }
        }
        const pQ = new fi,
            gQ = new mi,
            fQ = Jr.prototype.raycast;

        function mQ(e, t) {
            if (this.geometry.boundsTree) {
                if (void 0 === this.material) return;
                gQ.copy(this.matrixWorld).invert(), pQ.copy(e.ray).applyMatrix4(gQ);
                const n = this.geometry.boundsTree;
                if (!0 === e.firstHitOnly) {
                    const i = Dy(n.raycastFirst(pQ, this.material), this, e);
                    i && t.push(i)
                } else {
                    const i = n.raycast(pQ, this.material);
                    for (let n = 0, r = i.length; n < r; n++) {
                        const r = Dy(i[n], this, e);
                        r && t.push(r)
                    }
                }
            } else fQ.call(this, e, t)
        }
        const EQ = 30;

        function CQ(e) {
            const {
                canvas: t,
                eventDispatcher: n,
                getActiveCamera: i,
                getActiveScene: o
            } = e, s = t.parentElement, a = new JA;
            a.layers.set(r.Raycast), a.firstHitOnly = !0;
            const l = Im((function(e) {
                const t = {
                    type: OI.MouseMove,
                    data: h(e),
                    mouseEvent: e
                };
                n.dispatchEvent(t)
            }), EQ, {
                maxWait: EQ,
                leading: !0
            });

            function c(e) {
                if (4 === (void 0 !== e.buttons ? e.buttons : e.which)) return;
                const t = {
                    type: OI.MouseDown,
                    data: h(e),
                    mouseEvent: e
                };
                n.dispatchEvent(t)
            }
            t.addEventListener("mousedown", c), t.addEventListener("mouseup", (function(e) {
                const t = {
                    type: OI.MouseUp,
                    data: h(e),
                    mouseEvent: e
                };
                n.dispatchEvent(t)
            })), t.addEventListener("mousemove", l);
            const A = new dn;

            function h(e) {
                const n = i(),
                    l = o();
                if (!l || !n) return {
                    distance: 0,
                    object: null,
                    x: 0,
                    y: 0,
                    point: null,
                    ray: a.ray
                };
                const c = s.getBoundingClientRect();
                A.x = (e.clientX - c.left) / t.clientWidth * 2 - 1, A.y = -(e.clientY - c.top) / t.clientHeight * 2 + 1, a.setFromCamera(A, n);
                let h = [];
                if (GQ ? (a.layers.set(r.HelpersRaycast), h = a.intersectObject(l), h.length || (a.layers.set(r.Raycast), h = a.intersectObject(l))) : (a.layers.set(r.Raycast), h = a.intersectObject(l)), !h.length) return {
                    distance: 0,
                    object: null,
                    x: A.x,
                    y: A.y,
                    point: null,
                    ray: a.ray
                };
                const u = h[0];
                return {
                    distance: u.distance,
                    object: u.object,
                    point: u.point,
                    ray: a.ray,
                    x: A.x,
                    y: A.y
                }
            }
            const u = new mi,
                d = new mo,
                p = new Set,
                g = new qn;
            return {
                dispose: function() {
                    t.removeEventListener("mousedown", c), t.removeEventListener("mousemove", l)
                },
                getObjectPositionOnScreen: function(e) {
                    const t = i(),
                        n = new On;
                    return e.getWorldPosition(n), n.project(t)
                },
                getObjectIntersectionAtPointer: function(e, t, n, r) {
                    r ? a.layers.set(r) : a.layers.enableAll();
                    const o = i();
                    if (a.setFromCamera(t, o), a.intersectObject(e, n).length > 0) return a.intersectObject(e)[0]
                },
                getObjectsInScreenView: function(e, t) {
                    const n = i(),
                        s = o();
                    return n instanceof oo && function(n) {
                        const {
                            near: i,
                            far: r,
                            fov: o,
                            aspect: s,
                            zoom: a
                        } = n;
                        let l = i * Math.tan(.5 * un.DEG2RAD * o) / a,
                            c = 2 * l,
                            A = s * c,
                            h = -.5 * A;
                        l = -(e.y - .5) * c, c *= t.y - e.y, h = (e.x - .5) * A, A *= t.x - e.x, u.makePerspective(h, h + A, l, l - c, i, r)
                    }(n), n instanceof Fo && function(n) {
                        const {
                            near: i,
                            far: r,
                            left: o,
                            right: s,
                            top: a,
                            bottom: l,
                            zoom: c
                        } = n, A = (s - o) / (2 * c), h = (a - l) / (2 * c), d = (s + o) / 2, p = (a + l) / 2;
                        let g = d - A,
                            f = d + A,
                            m = p + h,
                            E = p - h;
                        const C = m - E,
                            I = f - g;
                        m -= e.y * C, E += (1 - t.y) * C, g += e.x * I, f -= (1 - t.x) * I, u.makeOrthographic(g, f, m, E, i, r)
                    }(n), u.multiply(n.matrixWorldInverse), d.setFromProjectionMatrix(u), p.clear(), s.traverseVisible((e => {
                        if (!e.userData.isCollider) return;
                        if (!e.layers.isEnabled(r.Raycast)) return;
                        const t = e;
                        if (null === t.geometry.boundingBox && t.geometry.computeBoundingBox(), g.copy(t.geometry.boundingBox).applyMatrix4(t.matrixWorld), d.intersectsBox(g)) {
                            const t = JI(e);
                            if (!t) return;
                            p.has(t.uuid) || p.add(t.uuid)
                        }
                    })), [...p]
                }
            }
        }
        Jr.prototype.raycast = mQ, Il.prototype.raycast = mQ, Dl.prototype.raycast = mQ, Ur.prototype.computeBoundsTree = function(e) {
            return this.boundsTree = new dQ(this, e), this.boundsTree
        }, Ur.prototype.disposeBoundsTree = function() {
            this.boundsTree = null
        };
        const IQ = function(e, t) {
                return OC(e, t)
            },
            SQ = {
                [u.Front]: Ue,
                [u.Back]: Me,
                [u.Double]: Re
            },
            vQ = {
                [h.Lit]: Lc,
                [h.Unlit]: Ar
            };

        function BQ(e) {
            const {
                resourceManager: t,
                materials: n,
                objects: i,
                getActiveScene: r
            } = e;

            function o(e) {
                return n.get(e)
            }

            function s(e) {
                const t = vQ[e.type];
                if (!t) throw Error("Material type not supported");
                const i = function(e) {
                    const t = e,
                        n = new Proxy(e, qI(["color", "metalness", "reflectivity", "opacity", "roughness", "displacementScale", "emissive", "emissiveIntensity"], (e => t.dispatchEvent({
                            type: HI.Update,
                            property: e,
                            target: t
                        }))));
                    return n
                }(new t);
                i.uuid = e.uuid, n.set(e.uuid, i), a(e)
            }

            function a(t, i, o = !1) {
                var s, a, c, A;
                const {
                    name: u,
                    side: d,
                    color: p,
                    metalness: g,
                    opacity: f,
                    transparent: m,
                    alphaTest: E
                } = t, C = n.get(t.uuid);
                if (!C) throw Error(`Material with ${t.uuid} does not exist`);
                if (o || (C.color.set(p), C.opacity = f), C.name = u || "", C.side = SQ[d], C.transparent = m, C.userData.isTransparent = m, C.alphaTest = E, l(t, "map", null == i ? void 0 : i.map), l(t, "alphaMap", null == i ? void 0 : i.alphaMap), t.type === h.Unlit) {
                    if (!(C instanceof Ar)) throw Error("Material type mismatch");
                    o || (C.reflectivity = g), l(t, "metalnessMap", null == i ? void 0 : i.metalnessMap);
                    const n = null === (c = null === (a = null === (s = r()) || void 0 === s ? void 0 : s.environment) || void 0 === a ? void 0 : a.userData) || void 0 === c ? void 0 : c.originalTextureUuid;
                    n && (null === (A = e.resourceManager.getResource(n)) || void 0 === A || A.assetInstance.then((e => {
                        const t = e;
                        C.envMap = t
                    })))
                }
                if (t.type === h.Lit) {
                    if (!(C instanceof Lc)) throw Error("Material type mismatch");
                    const {
                        flatShading: e,
                        roughness: n,
                        displacementScale: r,
                        emissive: s,
                        emissiveIntensity: a
                    } = t;
                    o || (C.metalness = g, C.roughness = n, C.emissiveIntensity = a, C.displacementScale = r, C.emissive.set(s)), C.flatShading = e, l(t, "metalnessMap", null == i ? void 0 : i.metalnessMap), l(t, "emissiveMap", null == i ? void 0 : i.emissiveMap), l(t, "normalMap", null == i ? void 0 : i.normalMap), l(t, "roughnessMap", null == i ? void 0 : i.roughnessMap), l(t, "displacementMap", null == i ? void 0 : i.displacementMap)
                }
                C.needsUpdate = !0
            }

            function l(e, r, o) {
                var s, a;
                const l = e[r],
                    c = n.get(e.uuid);
                if (!c) throw new Error(`Material with ${e.uuid} does not exist`);
                if (o && o.uuid !== (null == l ? void 0 : l.uuid) && t.deleteResource(o.uuid), IQ(l, o)) return;
                const A = e.type === h.Unlit && "metalnessMap" === r ? "specularMap" : r;
                if (!l) return void(c[A] = null);
                const u = e => {
                    e ? (c[A] = e, e.wrapS = xQ[l.wrapS], e.wrapT = xQ[l.wrapT], e.repeat.set(l.repeat.x, l.repeat.y), e.offset.set(l.offset.x, l.offset.y), e.center.set(l.center.x, l.center.y), e.image && (e.needsUpdate = !0), c.needsUpdate = !0, me(l) && (o && me(o) && o.loop === l.loop || e.source.data.play(), e.source.data.loop = l.loop)) : c[A] = null
                };
                if (l)
                    if (l.assetUrl === eh) {
                        const t = null === (s = i.get(e.overrideObjectId)) || void 0 === s ? void 0 : s.userData;
                        if (!t) return;
                        u(t.originalMaps[e.overrideMaterialIndex][r])
                    } else null === (a = t.getResource(l.uuid) || t.createResource(l)) || void 0 === a || a.assetInstance.then((e => {
                        u(e)
                    }))
            }
            return {
                dispose: function() {
                    n.forEach((e => YI(e)))
                },
                createMaterial: s,
                updateMaterial: a,
                getMaterial: o,
                deleteMaterial: function(e) {
                    const t = n.get(e);
                    if (!t) throw new Error(`Cannot delete material that does not exist! ${e}`);
                    t.dispose(), n.delete(e)
                },
                replaceMaterial: function(e, t) {
                    const i = n.get(t.uuid);
                    if (!i) return;
                    i.uuid = ih();
                    const a = r();
                    s(e), a.traverse((t => {
                        "Mesh" === t.type && t.material.uuid === i.uuid && (t.material = o(e.uuid))
                    })), i.dispose()
                }
            }
        }
        const xQ = {
            [g.Clamp]: Ze,
            [g.Repeat]: Xe,
            [g.MirroredRepeat]: _e
        };
        const yQ = 10;

        function wQ(e, t) {
            const n = function(e) {
                const t = new jo(e);
                t.compileCubemapShader();
                const n = new al,
                    i = new UA,
                    r = new Jr(new kc(1).scale(1, 1, -1), new Gc({
                        transparent: !0,
                        depthTest: !1
                    })),
                    o = new Jr(new kc(1).scale(1, 1, -1), new Gc({
                        depthTest: !1
                    }));
                return n.add(o), n.add(r), n.add(i), {
                    generateEnvironment: function(e, s, a, l, c) {
                        return o.material.color.set(a), i.intensity = c, r.material.map = e, r.material.opacity = l, r.rotation.y = s, t.fromScene(n).texture
                    }
                }
            }(e.renderer);

            function i(e, t) {
                var n;
                const {
                    intensity: i,
                    color: r,
                    castShadow: o,
                    shadowQuality: s
                } = t;
                if (e.intensity = i, e.color.set(r), o && (e.shadow && (e.shadow.mapSize.width = Number(s), e.shadow.mapSize.height = Number(s), null === (n = e.shadow.map) || void 0 === n || n.dispose(), e.shadow.map = null, e.shadow.normalBias = .03, e.shadow.isDirectionalLightShadow && (e.shadow.camera.top = yQ, e.shadow.camera.right = yQ, e.shadow.camera.left = -yQ, e.shadow.camera.bottom = -yQ), e.shadow.needsUpdate = !0), Be(t) && (e.castShadow = !1)), Se(t)) {
                    const n = e,
                        {
                            decay: i,
                            distance: r
                        } = t;
                    void 0 !== i && (n.decay = i), void 0 !== r && (n.distance = r)
                }
                if (xe(t)) {
                    const n = e,
                        {
                            decay: i,
                            distance: r,
                            penumbra: o,
                            angle: s
                        } = t;
                    void 0 !== i && (n.decay = i), void 0 !== r && (n.distance = r), void 0 !== o && (n.penumbra = o), void 0 !== s && (n.angle = s)
                }
                if (ve(t)) {
                    const n = e,
                        {
                            target: i
                        } = t;
                    i && WI(n.target.position, i)
                }
            }

            function r(e, t) {
                var n, i;
                WI(e.position, t.position), WI(e.scale, t.scale), n = e.rotation, i = t.rotation, n.setFromVector3(WI(zI, i))
            }
            return {
                updateObject: function(o, s, a = !1) {
                    const l = e.objects.get(o.uuid);
                    if (!l) throw new Error("Objects that you are trying to update doesn't exist!");
                    l.name = o.name, l.visible = o.visible, l.castShadow = o.castShadow, l.receiveShadow = o.receiveShadow, a || r(l, o), ge(o) && function(n, i, r) {
                        var o;
                        const {
                            uuid: s,
                            object: a,
                            animation: l,
                            castShadow: c,
                            receiveShadow: A
                        } = i;
                        if (r && r.castShadow === c && r.receiveShadow === A || n.traverse((e => {
                                e.castShadow = i.castShadow, e.receiveShadow = i.receiveShadow
                            })), IQ(null == r ? void 0 : r.animation, l)) return;
                        const {
                            clipName: h
                        } = l;
                        h ? null === (o = e.getResource(a.uuid)) || void 0 === o || o.assetInstance.then((e => {
                            var i;
                            if (a.assetType !== d.Gltf) return;
                            const o = e.animations;
                            (null == r ? void 0 : r.animation.clipName) && r.animation.clipName !== h && t.removeAnimation(r.uuid, r.animation.clipName);
                            const c = t.getAnimation(s, h);
                            if (c) t.updateAnimation(s, l), c.play();
                            else {
                                const e = o.find((e => e.name === h)),
                                    r = null === (i = n.children.find((e => !!e.userData.isGLTF))) || void 0 === i ? void 0 : i.children[0];
                                if (!e || !r) throw Error(`No animation clip with this name ${h} or root ${n}`);
                                t.createAnimation(r, s, e, l).play()
                            }
                        })) : (null == r ? void 0 : r.animation.clipName) && t.removeAnimation(r.uuid, r.animation.clipName)
                    }(l, o, s), ue(o) && i(l, o), fe(o) && function(e, t, n) {
                        const {
                            flowDirectionX: i,
                            flowDirectionY: r,
                            flowSpeed: o,
                            color: s,
                            quality: a,
                            useRefraction: l,
                            waveScale: c,
                            reflectivity: A
                        } = t;
                        n && l !== n.useRefraction && e.setUseRefraction(l), n && a !== n.quality && e.setResolution(t.quality), n && s !== n.color && e.material.uniforms.color.value.set(s), e.material.uniforms.flowDirection.value.x = i, e.material.uniforms.flowDirection.value.y = r, e.material.uniforms.flowDirection.value.normalize(), e.material.uniforms.reflectivity.value = A, e.material.uniforms.config.value.w = c, e.flowSpeed = o, e.material.needsUpdate = !0
                    }(l, o, s), pe(o) && function(t, r, o) {
                        var s;
                        const {
                            background: a,
                            environment: l,
                            ambientLight: c,
                            fog: A,
                            useEnvironmentAsBackground: h,
                            backgroundBlurriness: u,
                            multisampling: d
                        } = r;
                        if (t.backgroundBlurriness = u, (null == o ? void 0 : o.environment) && o.environment.uuid !== (null == l ? void 0 : l.uuid) && e.resourceManager.deleteResource(o.environment.uuid), l ? (e.resourceManager.getResource(l.uuid) || e.resourceManager.createResource(l)).assetInstance.then((i => {
                                var r;
                                const o = i,
                                    {
                                        intensity: s,
                                        rotation: c,
                                        opacity: A
                                    } = l;
                                null === (r = t.environment) || void 0 === r || r.dispose();
                                const u = n.generateEnvironment(o, c, "string" == typeof a ? a : "white", A, s);
                                t.environment = u, u.userData.originalTextureUuid = l.uuid, h && (t.background = u), e.materials.forEach((e => {
                                    e instanceof Ar && (e.envMap = o)
                                }))
                            })) : t.environment = null, (null == o ? void 0 : o.background) && "string" != typeof o.background && o.background.uuid !== a.uuid && e.resourceManager.deleteResource(o.background.uuid), !h || !l)
                            if (a)
                                if ("string" == typeof a) {
                                    const e = t.background;
                                    (null == e ? void 0 : e.isColor) ? e.set(a): t.background = new sr(a)
                                } else null === (s = e.resourceManager.getResource(a.uuid) || e.resourceManager.createResource(a)) || void 0 === s || s.assetInstance.then((e => {
                                    t.background = e
                                }));
                        else t.background = null;
                        const p = e.objects.get(c.uuid);
                        p && (p.visible = c.visible, i(p, c)), (null == d ? void 0 : d.enabled) ? e.setMultiSampling(d.samples) : e.setMultiSampling(0), (null == A ? void 0 : A.enabled) ? t.fog = new sl(A.useBackgroundColor ? "string" == typeof r.background ? r.background : "#FFFFFF" : A.color, A.near, A.far) : (null == A ? void 0 : A.enabled) || (t.fog = null)
                    }(l, o, s), de(o) && function(t, n, i) {
                        const {
                            geometry: r
                        } = n;
                        if ((null == i ? void 0 : i.geometry) && r !== (null == i ? void 0 : i.geometry) && $A && console.warn("Geometry object of the pwMesh has changed! Updating the THREE.geometry at run time is not supported yet!"), n.materialId !== (null == i ? void 0 : i.materialId)) {
                            const i = e.materials.get(n.materialId);
                            if (!i) throw Error(`Material with ${n.materialId} does not exist!`);
                            t.material = i
                        }
                    }(l, o, s), Ee(o) && function(e, t) {
                        if (Ce(t)) {
                            const {
                                zoom: n,
                                near: i,
                                far: r,
                                fov: o
                            } = t, s = e;
                            s.zoom = n, s.near = i, s.far = r, s.fov = o, s.updateProjectionMatrix()
                        }
                        if (Ie(t)) {
                            const {
                                zoom: n,
                                near: i,
                                far: r,
                                top: o,
                                left: s,
                                right: a,
                                bottom: l
                            } = t, c = e;
                            c.zoom = n, c.near = i, c.far = r, c.top = o, c.bottom = l, c.right = a, c.left = s, c.updateProjectionMatrix()
                        }
                    }(l, o)
                }
            }
        }
        const bQ = "data:image/jpeg;base64,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";
        class QQ extends Jr {
            constructor(e, t = {}) {
                super(e), this.isRefractor = !0, this.type = "Refractor", this.camera = new oo;
                const n = this,
                    i = void 0 !== t.color ? new sr(t.color) : new sr(8355711),
                    r = t.textureWidth || 512,
                    o = t.textureHeight || 512,
                    s = t.clipBias || 0,
                    a = t.shader || QQ.RefractorShader,
                    l = void 0 !== t.multisample ? t.multisample : 4,
                    c = this.camera;
                c.matrixAutoUpdate = !1, c.userData.refractor = !0;
                const A = new po,
                    h = new mi,
                    u = new Kn(r, o, {
                        samples: l,
                        type: ct
                    });
                this.material = new eo({
                    name: void 0 !== a.name ? a.name : "unspecified",
                    uniforms: $r.clone(a.uniforms),
                    vertexShader: a.vertexShader,
                    fragmentShader: a.fragmentShader,
                    transparent: !0
                }), this.material.uniforms.color.value = i, this.material.uniforms.tDiffuse.value = u.texture, this.material.uniforms.textureMatrix.value = h;
                const d = function() {
                        const e = new On,
                            t = new On,
                            i = new mi,
                            r = new On,
                            o = new On;
                        return function(s) {
                            return e.setFromMatrixPosition(n.matrixWorld), t.setFromMatrixPosition(s.matrixWorld), r.subVectors(e, t), i.extractRotation(n.matrixWorld), o.set(0, 0, 1), o.applyMatrix4(i), r.dot(o) < 0
                        }
                    }(),
                    p = function() {
                        const e = new On,
                            t = new On,
                            i = new Vn,
                            r = new On;
                        return function() {
                            n.matrixWorld.decompose(t, i, r), e.set(0, 0, 1).applyQuaternion(i).normalize(), e.negate(), A.setFromNormalAndCoplanarPoint(e, t)
                        }
                    }(),
                    g = function() {
                        const e = new po,
                            t = new kn,
                            n = new kn;
                        return function(i) {
                            c.matrixWorld.copy(i.matrixWorld), c.matrixWorldInverse.copy(c.matrixWorld).invert(), c.projectionMatrix.copy(i.projectionMatrix), c.far = i.far, e.copy(A), e.applyMatrix4(c.matrixWorldInverse), t.set(e.normal.x, e.normal.y, e.normal.z, e.constant);
                            const r = c.projectionMatrix;
                            n.x = (Math.sign(t.x) + r.elements[8]) / r.elements[0], n.y = (Math.sign(t.y) + r.elements[9]) / r.elements[5], n.z = -1, n.w = (1 + r.elements[10]) / r.elements[14], t.multiplyScalar(2 / t.dot(n)), r.elements[2] = t.x, r.elements[6] = t.y, r.elements[10] = t.z + 1 - s, r.elements[14] = t.w
                        }
                    }();
                this.onBeforeRender = function(e, t, i) {
                    !0 !== i.userData.refractor && !0 != !d(i) && (p(), function(e) {
                        h.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), h.multiply(e.projectionMatrix), h.multiply(e.matrixWorldInverse), h.multiply(n.matrixWorld)
                    }(i), g(i), function(e, t, i) {
                        n.visible = !1;
                        const r = e.getRenderTarget(),
                            o = e.xr.enabled,
                            s = e.shadowMap.autoUpdate;
                        e.xr.enabled = !1, e.shadowMap.autoUpdate = !1, e.setRenderTarget(u), !1 === e.autoClear && e.clear(), e.render(t, c), e.xr.enabled = o, e.shadowMap.autoUpdate = s, e.setRenderTarget(r);
                        const a = i.viewport;
                        void 0 !== a && e.state.viewport(a), n.visible = !0
                    }(e, t, i))
                }, this.getRenderTarget = function() {
                    return u
                }, this.dispose = function() {
                    u.dispose(), n.material.dispose()
                }
            }
        }
        QQ.RefractorShader = {
            name: "RefractorShader",
            uniforms: {
                color: {
                    value: null
                },
                tDiffuse: {
                    value: null
                },
                textureMatrix: {
                    value: null
                }
            },
            vertexShader: "\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
            fragmentShader: "\n\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec4 vUv;\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\n\t\t}"
        };
        class UQ extends Jr {
            constructor(e, t = {}) {
                super(e), this.isReflector = !0, this.type = "Reflector", this.camera = new oo;
                const n = this,
                    i = void 0 !== t.color ? new sr(t.color) : new sr(8355711),
                    r = t.textureWidth || 512,
                    o = t.textureHeight || 512,
                    s = t.clipBias || 0,
                    a = t.shader || UQ.ReflectorShader,
                    l = void 0 !== t.multisample ? t.multisample : 4,
                    c = new po,
                    A = new On,
                    h = new On,
                    u = new On,
                    d = new mi,
                    p = new On(0, 0, -1),
                    g = new kn,
                    f = new On,
                    m = new On,
                    E = new kn,
                    C = new mi,
                    I = this.camera,
                    S = new Kn(r, o, {
                        samples: l,
                        type: ct
                    }),
                    v = new eo({
                        name: void 0 !== a.name ? a.name : "unspecified",
                        uniforms: $r.clone(a.uniforms),
                        fragmentShader: a.fragmentShader,
                        vertexShader: a.vertexShader
                    });
                v.uniforms.tDiffuse.value = S.texture, v.uniforms.color.value = i, v.uniforms.textureMatrix.value = C, this.material = v, this.onBeforeRender = function(e, t, i) {
                    if (h.setFromMatrixPosition(n.matrixWorld), u.setFromMatrixPosition(i.matrixWorld), d.extractRotation(n.matrixWorld), A.set(0, 0, 1), A.applyMatrix4(d), f.subVectors(h, u), f.dot(A) > 0) return;
                    f.reflect(A).negate(), f.add(h), d.extractRotation(i.matrixWorld), p.set(0, 0, -1), p.applyMatrix4(d), p.add(u), m.subVectors(h, p), m.reflect(A).negate(), m.add(h), I.position.copy(f), I.up.set(0, 1, 0), I.up.applyMatrix4(d), I.up.reflect(A), I.lookAt(m), I.far = i.far, I.updateMatrixWorld(), I.projectionMatrix.copy(i.projectionMatrix), C.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), C.multiply(I.projectionMatrix), C.multiply(I.matrixWorldInverse), C.multiply(n.matrixWorld), c.setFromNormalAndCoplanarPoint(A, h), c.applyMatrix4(I.matrixWorldInverse), g.set(c.normal.x, c.normal.y, c.normal.z, c.constant);
                    const r = I.projectionMatrix;
                    E.x = (Math.sign(g.x) + r.elements[8]) / r.elements[0], E.y = (Math.sign(g.y) + r.elements[9]) / r.elements[5], E.z = -1, E.w = (1 + r.elements[10]) / r.elements[14], g.multiplyScalar(2 / g.dot(E)), r.elements[2] = g.x, r.elements[6] = g.y, r.elements[10] = g.z + 1 - s, r.elements[14] = g.w, n.visible = !1;
                    const o = e.getRenderTarget(),
                        a = e.xr.enabled,
                        l = e.shadowMap.autoUpdate;
                    e.xr.enabled = !1, e.shadowMap.autoUpdate = !1, e.setRenderTarget(S), e.state.buffers.depth.setMask(!0), !1 === e.autoClear && e.clear(), e.render(t, I), e.xr.enabled = a, e.shadowMap.autoUpdate = l, e.setRenderTarget(o);
                    const v = i.viewport;
                    void 0 !== v && e.state.viewport(v), n.visible = !0
                }, this.getRenderTarget = function() {
                    return S
                }, this.dispose = function() {
                    S.dispose(), n.material.dispose()
                }
            }
        }
        UQ.ReflectorShader = {
            name: "ReflectorShader",
            uniforms: {
                color: {
                    value: null
                },
                tDiffuse: {
                    value: null
                },
                textureMatrix: {
                    value: null
                }
            },
            vertexShader: "\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\t#include <common>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t#include <logdepthbuf_vertex>\n\n\t\t}",
            fragmentShader: "\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec4 vUv;\n\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\n\t\t}"
        };
        const MQ = .15,
            RQ = .075;
        class TQ extends Jr {
            constructor(e, t) {
                var n;
                super(e), this.isWater = !0, this.textureMatrix = new mi, this.clock = new TA, this.useRefraction = !1, this.clipBias = 0, this.textureHeight = 512, this.textureWidth = 512, this.isWater = !0;
                const {
                    flowSpeed: i = .03,
                    textureHeight: r = 512,
                    textureWidth: o = 512,
                    clipBias: s = 0,
                    flowDirection: a = new dn(1, 0),
                    reflectivity: l = .02,
                    scale: c = 1,
                    flowMap: A,
                    normalMap0: h,
                    normalMap1: u,
                    useRefraction: d = !1
                } = t;
                this.flowSpeed = i, this.useRefraction = d;
                const p = new sr(t.color),
                    g = FQ;
                this.clipBias = s, this.textureWidth = o, this.textureHeight = r, this.reflector = new UQ(e, {
                    textureWidth: o,
                    textureHeight: r,
                    clipBias: s
                }), this.reflector.matrixAutoUpdate = !1, this.useRefraction && (this.refractor = new QQ(e, {
                    textureWidth: o,
                    textureHeight: r,
                    clipBias: s
                }), this.refractor.matrixAutoUpdate = !1), this.material = new eo({
                    uniforms: $r.merge([vo.fog, g.uniforms]),
                    vertexShader: g.vertexShader,
                    fragmentShader: g.fragmentShader,
                    transparent: !0,
                    fog: !0
                }), void 0 !== A ? (this.material.defines.USE_FLOWMAP = "", this.material.uniforms.tFlowMap = new jA(A)) : this.material.uniforms.flowDirection = new jA(a), this.useRefraction && (this.material.defines.USE_REFRACTION = "", this.material.uniforms.tRefractionMap.value = null === (n = this.refractor) || void 0 === n ? void 0 : n.getRenderTarget().texture), h.wrapS = h.wrapT = Xe, u.wrapS = u.wrapT = Xe, this.material.uniforms.tReflectionMap.value = this.reflector.getRenderTarget().texture, this.material.uniforms.tNormalMap0.value = h, this.material.uniforms.tNormalMap1.value = u, this.material.uniforms.color.value = p, this.material.uniforms.reflectivity.value = l, this.material.uniforms.textureMatrix.value = this.textureMatrix, this.material.uniforms.config.value.x = 0, this.material.uniforms.config.value.y = RQ, this.material.uniforms.config.value.z = RQ, this.material.uniforms.config.value.w = c, this.onBeforeRender = function(e, t, n, i, r, o) {
                    var s, a;
                    this.updateTextureMatrix(n), this.updateFlow(), this.visible = !1, this.reflector.matrixWorld.copy(this.matrixWorld), this.reflector.onBeforeRender(e, t, n, i, r, o), this.useRefraction && (null === (s = this.refractor) || void 0 === s || s.onBeforeRender(e, t, n, i, r, o), null === (a = this.refractor) || void 0 === a || a.matrixWorld.copy(this.matrixWorld)), this.visible = !0
                }
            }
            updateTextureMatrix(e) {
                this.textureMatrix.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), this.textureMatrix.multiply(e.projectionMatrix), this.textureMatrix.multiply(e.matrixWorldInverse), this.textureMatrix.multiply(this.matrixWorld)
            }
            setUseRefraction(e) {
                var t, n;
                this.useRefraction !== e && (this.useRefraction ? (this.material.defines.USE_REFRACTION = !1, null === (t = this.refractor) || void 0 === t || t.dispose()) : (this.refractor = new QQ(this.geometry, {
                    textureWidth: this.textureWidth,
                    textureHeight: this.textureHeight,
                    clipBias: this.clipBias
                }), this.refractor.matrixAutoUpdate = !1, this.material.defines.USE_REFRACTION = "", this.material.uniforms.tRefractionMap.value = null === (n = this.refractor) || void 0 === n ? void 0 : n.getRenderTarget().texture), this.useRefraction = e)
            }
            updateFlow() {
                const e = this.clock.getDelta(),
                    t = this.material.uniforms.config;
                t.value.x += this.flowSpeed * e, t.value.y = t.value.x + RQ, t.value.x >= MQ ? (t.value.x = 0, t.value.y = RQ) : t.value.y >= MQ && (t.value.y = t.value.y - MQ)
            }
            setResolution(e) {
                var t;
                this.reflector.getRenderTarget().setSize(e, e), null === (t = this.refractor) || void 0 === t || t.getRenderTarget().setSize(e, e)
            }
            dispose() {
                var e, t, n, i, r, o, s;
                this.reflector.dispose(), null === (e = this.refractor) || void 0 === e || e.dispose(), null === (n = null === (t = this.material.uniforms.tNormalMap0) || void 0 === t ? void 0 : t.value) || void 0 === n || n.dispose(), null === (r = null === (i = this.material.uniforms.tNormalMap1) || void 0 === i ? void 0 : i.value) || void 0 === r || r.dispose(), this.material.dispose(), null === (s = (o = this.geometry).disposeBoundsTree) || void 0 === s || s.call(o), this.geometry.dispose()
            }
        }
        const FQ = {
            uniforms: {
                color: {
                    type: "c",
                    value: null
                },
                reflectivity: {
                    type: "f",
                    value: 0
                },
                tReflectionMap: {
                    type: "t",
                    value: null
                },
                tRefractionMap: {
                    type: "t",
                    value: null
                },
                tNormalMap0: {
                    type: "t",
                    value: null
                },
                tNormalMap1: {
                    type: "t",
                    value: null
                },
                textureMatrix: {
                    type: "m4",
                    value: null
                },
                config: {
                    type: "v4",
                    value: new kn
                }
            },
            vertexShader: "#define GLSLIFY 1\n#include <common>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n\nuniform mat4 textureMatrix;\n\nvarying vec4 vCoord;\nvarying vec2 vUv;\nvarying vec3 vToEye;\n\nvoid main() {\n    vUv = uv;\n    vCoord = textureMatrix * vec4(position, 1.0);\n\n    vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n    vToEye = cameraPosition - worldPosition.xyz;\n\n    vec4 mvPosition = viewMatrix * worldPosition; // used in fog_vertex\n    gl_Position = projectionMatrix * mvPosition;\n\n    #include <logdepthbuf_vertex>\n    #include <fog_vertex>\n\n}",
            fragmentShader: "#define GLSLIFY 1\n#include <common>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n\nuniform sampler2D tReflectionMap;\n    #ifdef USE_REFRACTION\nuniform sampler2D tRefractionMap;\n    #endif\nuniform sampler2D tNormalMap0;\nuniform sampler2D tNormalMap1;\n\n\t\t#ifdef USE_FLOWMAP\nuniform sampler2D tFlowMap;\n\t\t#else\nuniform vec2 flowDirection;\n\t\t#endif\n\nuniform vec3 color;\nuniform float reflectivity;\nuniform vec4 config;\n\nvarying vec4 vCoord;\nvarying vec2 vUv;\nvarying vec3 vToEye;\n\nvoid main() {\n\n  #include <logdepthbuf_fragment>\n\n  float flowMapOffset0 = config.x;\n  float flowMapOffset1 = config.y;\n  float halfCycle = config.z;\n  float scale = config.w;\n\n  vec3 toEye = normalize(vToEye);\n\n\t\t\t// determine flow direction\n  vec2 flow;\n\t\t\t#ifdef USE_FLOWMAP\n  flow = texture2D(tFlowMap, vUv).rg * 2.0 - 1.0;\n\t\t\t#else\n  flow = flowDirection;\n\t\t\t#endif\n  flow.x *= -1.0;\n\n\t\t\t// sample normal maps (distort uvs with flowdata)\n  vec4 normalColor0 = texture2D(tNormalMap0, (vUv * scale) + flow * flowMapOffset0);\n  vec4 normalColor1 = texture2D(tNormalMap1, (vUv * scale) + flow * flowMapOffset1);\n\n\t\t\t// linear interpolate to get the final normal color\n  float flowLerp = abs(halfCycle - flowMapOffset0) / halfCycle;\n  vec4 normalColor = mix(normalColor0, normalColor1, flowLerp);\n\n\t\t\t// calculate normal vector\n  vec3 normal = normalize(vec3(normalColor.r * 2.0 - 1.0, normalColor.b, normalColor.g * 2.0 - 1.0));\n\n\t\t\t// calculate the fresnel term to blend reflection and refraction maps\n  float theta = max(dot(toEye, normal), 0.0);\n  float reflectance = reflectivity + (1.0 - reflectivity) * pow((1.0 - theta), 5.0);     \n\n\t\t\t// calculate final uv coords\n  vec3 coord = vCoord.xyz / vCoord.w;\n  vec2 uv = coord.xy + coord.z * normal.xz * 0.05;\n\n  vec4 reflectColor = texture2D(tReflectionMap, vec2(1.0 - uv.x, uv.y));\n      #ifdef USE_REFRACTION\n  vec4 refractColor = texture2D(tRefractionMap, uv);\n      #endif\n\n\t\t\t// multiply water color with the mix of both textures\n      #ifdef USE_REFRACTION\n  gl_FragColor = vec4(color, 1.0) * mix(refractColor, reflectColor, reflectance);\n      #else\n  gl_FragColor = vec4(color, reflectance) * reflectColor;\n      #endif\n\n  #include <tonemapping_fragment>\n  #include <tonemapping_fragment>\n  #include <fog_fragment>\n}\n"
        };

        function DQ(e, t) {
            const {
                updateObject: n
            } = wQ(e, t), {
                materials: i,
                objects: o
            } = e;

            function s(e) {
                const {
                    geometry: t,
                    materialId: n
                } = e;
                let o = null;
                if (t.type === l.Plane) {
                    const {
                        width: e,
                        height: n
                    } = t;
                    o = new Io(e, n, 4, 4)
                }
                if (function(e) {
                        return e.type === l.Box
                    }(t)) {
                    const {
                        width: e,
                        height: n,
                        depth: i
                    } = t;
                    o = new zr(e, n, i, 4, 4)
                }
                if (!o) throw new Error("Geometry type is not supported!");
                o.computeBoundsTree({
                    maxLeafTris: 5,
                    maxDepth: 10,
                    strategy: ky
                }), o.uuid = t.uuid;
                const s = new Jr;
                if (!i.has(n)) throw new Error(`Material with uuid ${n} doesn't exist`);
                return s.material = i.get(n), s.geometry = o, s.userData = {
                    isCollider: !0
                }, s.layers.enable(r.Raycast), s
            }

            function c(e, t) {
                var n;
                const i = o.get(e),
                    r = o.get(t);
                if (!i) throw new Error("Cannot set parent relationship!");
                r ? r.add(i) : null === (n = i.parent) || void 0 === n || n.remove(i)
            }
            return {
                updateObject: n,
                createObject: function t(i, l) {
                    let A = null;
                    if (!i.uuid) throw new Error("Object must have a uuid!");
                    if (o.has(i.uuid)) throw new Error("Object already exists!");
                    if (function(e) {
                            return e.type === a.Group
                        }(i) && (A = new Xa), fe(i) && (A = function(t) {
                            const {
                                flowDirectionX: n,
                                flowDirectionY: i,
                                flowSpeed: o,
                                color: s,
                                waveScale: a,
                                quality: l
                            } = t, c = new Io(1, 1), A = new TQ(c, {
                                normalMap0: e.load(d.Texture, bQ),
                                normalMap1: e.load(d.Texture, bQ),
                                scale: a,
                                flowDirection: new dn(n, i),
                                flowSpeed: o,
                                textureHeight: l,
                                textureWidth: l,
                                color: s
                            });
                            return A.userData = {
                                isCollider: !0
                            }, A.layers.enable(r.Raycast), A
                        }(i)), ue(i) && (A = function(e) {
                            if (Se(e)) return new wA;
                            if (ve(e)) return new QA;
                            if (Be(e)) return new UA;
                            if (xe(e)) {
                                const e = new qi,
                                    t = new SA;
                                return t.add(e), e.position.set(0, -1, 0), t.target = e, t
                            }
                            throw new Error("Light type is not supported!")
                        }(i)), de(i) && (A = s(i)), ge(i) && (A = function(t) {
                            const {
                                object: i
                            } = t, o = e.resourceManager.createResource(i);
                            switch (i.assetType) {
                                case d.Gltf:
                                case d.Obj:
                                case d.FBX:
                                    {
                                        const e = new Xa;
                                        return o.assetInstance.then((i => {
                                            const {
                                                model: o,
                                                materials: s
                                            } = i;
                                            e.userData.originalMaps = s.map((e => {
                                                const t = e;
                                                return {
                                                    alphaMap: t.alphaMap,
                                                    metalnessMap: t.metalnessMap,
                                                    map: t.map,
                                                    emissiveMap: t.emissiveMap,
                                                    normalMap: t.normalMap,
                                                    roughnessMap: t.roughnessMap,
                                                    displacementMap: t.displacementMap
                                                }
                                            })), o.traverse((e => {
                                                if (e instanceof Jr) {
                                                    e.updateMatrixWorld(!0), e.geometry.computeBoundsTree({
                                                        maxLeafTris: 5,
                                                        strategy: ky
                                                    }), e.layers.enable(r.Raycast);
                                                    const t = {
                                                        isCollider: !0
                                                    };
                                                    e.userData = Object.assign(Object.assign({}, e.userData), t)
                                                }
                                            })), e.add(o), o.getObjectsByProperty("isLight", !0).forEach((e => {
                                                e.removeFromParent()
                                            })), n(t)
                                        })),
                                        e
                                    }
                                default:
                                    throw Error(`No imported object of this type ${i.assetType}`)
                            }
                        }(i)), pe(i) && (A = new al), Ee(i) && (A = function(t) {
                            let n;
                            if (Ce(t) && (n = new oo, n.aspect = e.canvasSize.x / e.canvasSize.y, n.updateProjectionMatrix()), Ie(t) && (n = new Fo, n.updateProjectionMatrix()), !n) throw new Error("Camera type is not supported!");
                            return n
                        }(i)), !A) throw new Error(`Object type <${i.type}> is not supported!`);
                    const {
                        name: h,
                        uuid: u,
                        visible: p = !0
                    } = i;
                    A.uuid = u, A.visible = p, A.userData = Object.assign(Object.assign({}, A.userData), {
                        name: h,
                        isPwObject: !0
                    });
                    const g = jI(A);
                    o.set(i.uuid, g), n(i), l && c(i.uuid, l), pe(i) && t(i.ambientLight, i.uuid), e.setWireframeOnObject(A)
                },
                setParentRelationship: c,
                deleteObject: function(e) {
                    var n, i;
                    const r = o.get(e);
                    if (!r) throw new Error(`Cannot delete object that does not exist! ${e}`);
                    null === (n = r.parent) || void 0 === n || n.remove(r), r.dispose && r.dispose(), r instanceof al && (null === (i = r.environment) || void 0 === i || i.dispose()), t.removeObjectAnimations(r.uuid), o.delete(e)
                },
                getObject: function(e) {
                    return o.get(e)
                }
            }
        }

        function kQ(e, t, n, i) {
            var r;
            const o = function(e, t) {
                    var n, i;
                    const r = {};
                    if (!e || !t) return r;
                    const o = Object.values(O);
                    for (const s of o) {
                        const o = null === (i = null === (n = e.devices[s]) || void 0 === n ? void 0 : n.canvases) || void 0 === i ? void 0 : i[t];
                        o && (r[s] = o.cameraId)
                    }
                    return r
                }(e, null === (r = t.parentElement) || void 0 === r ? void 0 : r.id),
                s = n.find((e => e === o.desktop)) || i,
                a = n.find((e => e === o.tablet)) || s;
            return {
                desktop: s,
                tablet: a,
                mobile: n.find((e => e === o.mobile)) || a
            }
        }

        function LQ() {
            const e = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
            return e < th ? O.Mobile : e < nh ? O.Tablet : O.Desktop
        }

        function KQ(e, t, n, i, r) {
            const {
                pwObjects: o,
                defaultCameraId: s
            } = t, l = kQ(n, e, function(e) {
                return e.filter((e => Ee(e))).map((e => e.uuid))
            }(Array.from(o.values())), s);
            let c, A = i(s);
            A || o.forEach((e => {
                A || e.type !== a.Camera || (A = i(e.uuid))
            }));
            const h = {
                    desktop: i(l.desktop) || A,
                    tablet: i(l.tablet) || A,
                    mobile: i(l.mobile) || A
                },
                u = () => {
                    const e = LQ();
                    if (c === e) return;
                    c = e;
                    const t = h[e];
                    r.getActiveCamera() !== t && r.setActiveCamera(t)
                };
            u(), window.addEventListener("resize", u);
            return {
                dispose: () => {
                    window.removeEventListener("resize", u)
                },
                updateResponsiveCanvasCamera: u
            }
        }
        const PQ = "RESOLUTION_FACTOR";
        let GQ = !1;

        function VQ(e, t, n = !1) {
            GQ = n;
            const i = Fy(e),
                r = CQ(i),
                o = function(e) {
                    const {
                        getActiveScene: t
                    } = e, n = new qA(t()), i = new Map;

                    function r(e, t) {
                        var n;
                        const {
                            clipName: r,
                            loop: o,
                            speed: s
                        } = t;
                        if (!r) return;
                        const a = null === (n = i.get(e)) || void 0 === n ? void 0 : n.get(r);
                        if (!a) throw Error(`Animation with name ${r} and object id ${e} does not exist`);
                        a.setLoop(o ? Mt : Ut, 1 / 0), a.reset(), a.timeScale = s
                    }

                    function o(e, t) {
                        var r, o;
                        const s = null === (r = i.get(e)) || void 0 === r ? void 0 : r.get(t);
                        s && (s.enabled = !1, s.stop(), s.reset(), n.uncacheRoot(s.getRoot()), n.uncacheClip(s.getClip()), null === (o = i.get(e)) || void 0 === o || o.delete(t))
                    }
                    return {
                        createAnimation: function(e, t, o, s) {
                            const a = n.clipAction(o, e);
                            return a.clampWhenFinished = !0, a.blendMode = Kt, i.has(t) || i.set(t, new Map), i.get(t).set(o.name, a), r(t, s), a
                        },
                        removeAnimation: o,
                        removeObjectAnimations: function(e) {
                            var t;
                            null === (t = i.get(e)) || void 0 === t || t.forEach(((t, n) => o(e, n)))
                        },
                        updateAnimation: r,
                        getAnimation: function(e, t) {
                            var n;
                            return null === (n = i.get(e)) || void 0 === n ? void 0 : n.get(t)
                        },
                        update: function(e) {
                            n.update(e)
                        },
                        dispose: function() {
                            n.stopAllAction(), n.getRoot() && n.uncacheRoot(n.getRoot())
                        }
                    }
                }(i),
                s = BQ(i);
            let l;
            if (!n && (null == t ? void 0 : t.isReductionEnabled)) {
                const {
                    fpsThresholdMode: e,
                    fpsThresholdAbsolute: n,
                    fpsThresholdRelative: r,
                    minResolution: o
                } = t;
                let s;
                if (e === f.Absolute) s = e => [Math.min(n || 60, e - 20), Math.min(n || 60, e)];
                else {
                    const e = .01 * (r || 100);
                    s = t => [t * e, t * e + 20]
                }
                const a = window.location !== window.parent.location;
                l = function(e, {
                    iterations: t = 10,
                    ms: n = 250,
                    threshold: i = .75,
                    step: r = .1,
                    factor: o = .5,
                    flipflops: s = 1 / 0,
                    bounds: a = (e => e > 100 ? [60, 100] : [40, 60]),
                    resolutionStepMultiplier: l = .25,
                    minResolutionFactor: c = .2,
                    memoizeResolutionFactor: A = !0
                }) {
                    const h = Math.pow(10, 0),
                        u = {
                            fps: 0,
                            index: 0,
                            factor: o,
                            flipped: 0,
                            refreshrate: 0,
                            fallback: !1,
                            frames: [],
                            averages: [],
                            subscriptions: new Map,
                            subscribe: e => {
                                const t = Symbol();
                                return u.subscriptions.set(t, e.current), () => {
                                    u.subscriptions.delete(t)
                                }
                            }
                        };
                    if (A) {
                        const t = Number(window.localStorage.getItem(PQ));
                        !Number.isNaN(t) && t > c && e.renderer.setPixelRatio(t)
                    }

                    function d(t) {
                        e.renderer.setPixelRatio(t), A && window.localStorage.setItem(PQ, t.toString())
                    }

                    function p() {
                        d(Math.min(window.devicePixelRatio, e.renderer.getPixelRatio() * (1 + l)))
                    }

                    function g() {
                        d(Math.max(c, e.renderer.getPixelRatio() * (1 - l)))
                    }
                    let f = 0;

                    function m() {
                        const {
                            frames: e,
                            averages: o
                        } = u;
                        if (!u.fallback && o.length < t) {
                            e.push(performance.now());
                            const l = e[e.length - 1] - e[0];
                            if (l >= n) {
                                if (u.fps = Math.round(e.length / l * 1e3 * h) / h, u.refreshrate = Math.max(u.refreshrate, u.fps), o[u.index++ % t] = u.fps, o.length === t) {
                                    const [e, n] = a(u.refreshrate), l = o.filter((e => e >= n)), c = o.filter((t => t < e));
                                    l.length > t * i && (u.factor = Math.min(1, u.factor + r), u.flipped++, p && p(), u.subscriptions.forEach((e => e.onIncline && e.onIncline(u)))), c.length > t * i && (u.factor = Math.max(0, u.factor - r), u.flipped++, g && g(), u.subscriptions.forEach((e => e.onDecline && e.onDecline(u)))), f !== u.factor && (f = u.factor, u.subscriptions.forEach((e => e.onChange && e.onChange(u)))), u.flipped > s && !u.fallback && (u.fallback = !0, u.subscriptions.forEach((e => e.onFallback && e.onFallback(u)))), u.averages = []
                                }
                                u.frames = []
                            }
                        }
                    }
                    return e.addOnRenderCallback(m), {
                        api: u,
                        dispose: function() {
                            e.removeOnRenderCallback(m)
                        }
                    }
                }(i, {
                    memoizeResolutionFactor: !a,
                    minResolutionFactor: .01 * (o || 100),
                    bounds: s
                })
            }
            const {
                start: c,
                stop: A,
                eventDispatcher: h,
                addOnRenderCallback: u,
                removeOnRenderCallback: d,
                renderer: p,
                effects: g,
                setActiveCamera: m,
                setActiveScene: E,
                setCameraPreview: C,
                setWireframe: I,
                setUsePostProcessing: S,
                createEffect: v,
                updateEffect: B,
                deleteEffect: x,
                getResource: y,
                resourceManager: w,
                showStatsPanel: b,
                hideStatsPanel: Q,
                addAfterRenderCallback: U,
                attachToDOM: M
            } = i, {
                getMaterial: R,
                updateMaterial: T,
                createMaterial: F,
                deleteMaterial: D,
                replaceMaterial: k
            } = s;
            u(((e, t, n) => o.update(n)));
            const {
                updateObject: L,
                createObject: K,
                getObject: P,
                deleteObject: G,
                setParentRelationship: V
            } = DQ(i, o), {
                getObjectIntersectionAtPointer: O,
                getObjectPositionOnScreen: N,
                getObjectsInScreenView: H
            } = r, {
                getAnimation: q
            } = o;

            function j(e, t, n) {
                const i = P(e);
                n.forEach((e => T(e, void 0, !0)));
                const r = i => {
                    if (!i.userData.isPwObject || i.uuid === e) {
                        if (i instanceof Jr || i instanceof Dl) {
                            const e = t.findIndex((e => i.material.uuid === e)); - 1 !== e && (i.material = R(n[e].uuid))
                        }
                        i.children.forEach(r)
                    }
                };
                i && r(i)
            }
            const Y = (e, t) => (h.addEventListener(e, t), () => h.removeEventListener(e, t));
            return {
                renderer: p,
                effects: g,
                setActiveCamera: m,
                setActiveScene: E,
                setCameraPreview: C,
                initializeClient: function(t, n) {
                    const {
                        pwObjects: r,
                        pwMaterials: o,
                        parents: s,
                        usePostProcessing: l,
                        effects: c
                    } = t;
                    o.forEach((e => F(e))), r.forEach((e => K(e))), Array.from(s.entries()).forEach((([e, t]) => {
                        V(e, t)
                    })), KQ(e, t, n, P, i), r.forEach((e => {
                        i.getActiveScene() || e.type !== a.Scene || i.setActiveScene(P(e.uuid))
                    })), r.forEach((e => {
                        ge(e) && e.materials && y(e.object.uuid).assetInstance.then((t => {
                            var n;
                            e.materials && j(e.uuid, t.materials.map((e => e.uuid)), null === (n = e.materials) || void 0 === n ? void 0 : n.map((e => o.get(e))))
                        }))
                    }));
                    let A = !1;
                    c.forEach((e => {
                        e.enabled && (A = A || e.enabled, v(e))
                    })), S(A && l), Y(OI.ResourcesLoaded, (() => {
                        const e = Number.MAX_VALUE / 2,
                            t = new Fo(-e, e, e, -e, 0, Number.MAX_VALUE);
                        t.position.set(0, 0, -e);
                        const n = i.getActiveCamera();
                        i.setActiveCamera(t), i.start(), document.location.search.includes("debug") && b(document.body), p.compileAsync(i.getActiveScene(), t).then((() => {
                            i.setActiveCamera(n), h.dispatchEvent({
                                type: OI.SceneReady
                            })
                        }))
                    })), w.checkIfResourceLoadingFinished()
                },
                listenTo: Y,
                start: c,
                stop: A,
                dispose: function() {
                    i.dispose(), r.dispose(), o.dispose(), s.dispose(), null == l || l.dispose()
                },
                updateObject: L,
                getObject: P,
                getResource: y,
                createEffect: v,
                updateEffect: B,
                deleteEffect: x,
                createObject: K,
                deleteObject: G,
                createMaterial: F,
                updateMaterial: T,
                deleteMaterial: D,
                replaceMaterial: k,
                replaceImportedMaterials: j,
                getImportedAnimation: q,
                setParentRelationship: V,
                addOnRenderCallback: u,
                removeOnRenderCallback: d,
                getObjectIntersectionAtPointer: O,
                getObjectPositionOnScreen: N,
                setWireframe: I,
                setUsePostProcessing: S,
                getMaterial: R,
                showStatsPanel: b,
                hideStatsPanel: Q,
                addAfterRenderCallback: U,
                getObjectsInScreenView: H,
                attachToDOM: M
            }
        }
        const OQ = {
            disposePageCallbacks: []
        };

        function NQ(e) {
            OQ.disposePageCallbacks.push(e)
        }

        function HQ() {
            const e = OQ.disposePageCallbacks;
            for (OQ.disposePageCallbacks = []; e.length > 0;) {
                const t = e.pop();
                if (t) try {
                    t()
                } catch (e) {
                    console.error("Router page dispose callback error:", e)
                }
            }
        }

        function qQ(e, t, n) {
            return Math.max(e, Math.min(t, n))
        }
        class jQ {
            advance(e) {
                if (!this.isRunning) return;
                let t = !1;
                if (this.lerp) this.value = (n = this.value, i = this.to, r = 60 * this.lerp, o = e, function(e, t, n) {
                    return (1 - n) * e + n * t
                }(n, i, 1 - Math.exp(-r * o))), Math.round(this.value) === this.to && (this.value = this.to, t = !0);
                else {
                    this.currentTime += e;
                    const n = qQ(0, this.currentTime / this.duration, 1);
                    t = n >= 1;
                    const i = t ? 1 : this.easing(n);
                    this.value = this.from + (this.to - this.from) * i
                }
                var n, i, r, o;
                this.onUpdate ? .(this.value, t), t && this.stop()
            }
            stop() {
                this.isRunning = !1
            }
            fromTo(e, t, {
                lerp: n = .1,
                duration: i = 1,
                easing: r = (e => e),
                onStart: o,
                onUpdate: s
            }) {
                this.from = this.value = e, this.to = t, this.lerp = n, this.duration = i, this.easing = r, this.currentTime = 0, this.isRunning = !0, o ? .(), this.onUpdate = s
            }
        }
        class YQ {
            constructor({
                wrapper: e,
                content: t,
                autoResize: n = !0
            } = {}) {
                if (this.wrapper = e, this.content = t, n) {
                    const e = function(e, t) {
                        let n;
                        return function() {
                            let t = arguments,
                                i = this;
                            clearTimeout(n), n = setTimeout((function() {
                                e.apply(i, t)
                            }), 250)
                        }
                    }(this.resize);
                    this.wrapper !== window && (this.wrapperResizeObserver = new ResizeObserver(e), this.wrapperResizeObserver.observe(this.wrapper)), this.contentResizeObserver = new ResizeObserver(e), this.contentResizeObserver.observe(this.content)
                }
                this.resize()
            }
            destroy() {
                this.wrapperResizeObserver ? .disconnect(), this.contentResizeObserver ? .disconnect()
            }
            resize = () => {
                this.onWrapperResize(), this.onContentResize()
            };
            onWrapperResize = () => {
                this.wrapper === window ? (this.width = window.innerWidth, this.height = window.innerHeight) : (this.width = this.wrapper.clientWidth, this.height = this.wrapper.clientHeight)
            };
            onContentResize = () => {
                this.scrollHeight = this.content.scrollHeight, this.scrollWidth = this.content.scrollWidth
            };
            get limit() {
                return {
                    x: this.scrollWidth - this.width,
                    y: this.scrollHeight - this.height
                }
            }
        }
        class JQ {
            constructor() {
                this.events = {}
            }
            emit(e, ...t) {
                let n = this.events[e] || [];
                for (let e = 0, i = n.length; e < i; e++) n[e](...t)
            }
            on(e, t) {
                return this.events[e] ? .push(t) || (this.events[e] = [t]), () => {
                    this.events[e] = this.events[e] ? .filter((e => t !== e))
                }
            }
            off(e, t) {
                this.events[e] = this.events[e] ? .filter((e => t !== e))
            }
            destroy() {
                this.events = {}
            }
        }
        class WQ {
            constructor(e, {
                wheelMultiplier: t = 1,
                touchMultiplier: n = 2,
                normalizeWheel: i = !1
            }) {
                this.element = e, this.wheelMultiplier = t, this.touchMultiplier = n, this.normalizeWheel = i, this.touchStart = {
                    x: null,
                    y: null
                }, this.emitter = new JQ, this.element.addEventListener("wheel", this.onWheel, {
                    passive: !1
                }), this.element.addEventListener("touchstart", this.onTouchStart, {
                    passive: !1
                }), this.element.addEventListener("touchmove", this.onTouchMove, {
                    passive: !1
                }), this.element.addEventListener("touchend", this.onTouchEnd, {
                    passive: !1
                })
            }
            on(e, t) {
                return this.emitter.on(e, t)
            }
            destroy() {
                this.emitter.destroy(), this.element.removeEventListener("wheel", this.onWheel, {
                    passive: !1
                }), this.element.removeEventListener("touchstart", this.onTouchStart, {
                    passive: !1
                }), this.element.removeEventListener("touchmove", this.onTouchMove, {
                    passive: !1
                }), this.element.removeEventListener("touchend", this.onTouchEnd, {
                    passive: !1
                })
            }
            onTouchStart = e => {
                const {
                    clientX: t,
                    clientY: n
                } = e.targetTouches ? e.targetTouches[0] : e;
                this.touchStart.x = t, this.touchStart.y = n, this.lastDelta = {
                    x: 0,
                    y: 0
                }, this.emitter.emit("scroll", {
                    deltaX: 0,
                    deltaY: 0,
                    event: e
                })
            };
            onTouchMove = e => {
                const {
                    clientX: t,
                    clientY: n
                } = e.targetTouches ? e.targetTouches[0] : e, i = -(t - this.touchStart.x) * this.touchMultiplier, r = -(n - this.touchStart.y) * this.touchMultiplier;
                this.touchStart.x = t, this.touchStart.y = n, this.lastDelta = {
                    x: i,
                    y: r
                }, this.emitter.emit("scroll", {
                    deltaX: i,
                    deltaY: r,
                    event: e
                })
            };
            onTouchEnd = e => {
                this.emitter.emit("scroll", {
                    deltaX: this.lastDelta.x,
                    deltaY: this.lastDelta.y,
                    event: e
                })
            };
            onWheel = e => {
                let {
                    deltaX: t,
                    deltaY: n
                } = e;
                this.normalizeWheel && (t = qQ(-100, t, 100), n = qQ(-100, n, 100)), t *= this.wheelMultiplier, n *= this.wheelMultiplier, this.emitter.emit("scroll", {
                    deltaX: t,
                    deltaY: n,
                    event: e
                })
            }
        }
        class zQ {
            constructor({
                wrapper: e = window,
                content: t = document.documentElement,
                wheelEventsTarget: n = e,
                eventsTarget: i = n,
                smoothWheel: r = !0,
                smoothTouch: o = !1,
                syncTouch: s = !1,
                syncTouchLerp: a = .075,
                touchInertiaMultiplier: l = 35,
                duration: c,
                easing: A = (e => Math.min(1, 1.001 - Math.pow(2, -10 * e))),
                lerp: h = !c && .1,
                infinite: u = !1,
                orientation: d = "vertical",
                gestureOrientation: p = "vertical",
                touchMultiplier: g = 1,
                wheelMultiplier: f = 1,
                normalizeWheel: m = !1,
                autoResize: E = !0
            } = {}) {
                window.lenisVersion = "1.0.33", e !== document.documentElement && e !== document.body || (e = window), this.options = {
                    wrapper: e,
                    content: t,
                    wheelEventsTarget: n,
                    eventsTarget: i,
                    smoothWheel: r,
                    smoothTouch: o,
                    syncTouch: s,
                    syncTouchLerp: a,
                    touchInertiaMultiplier: l,
                    duration: c,
                    easing: A,
                    lerp: h,
                    infinite: u,
                    gestureOrientation: p,
                    orientation: d,
                    touchMultiplier: g,
                    wheelMultiplier: f,
                    normalizeWheel: m,
                    autoResize: E
                }, this.animate = new jQ, this.emitter = new JQ, this.dimensions = new YQ({
                    wrapper: e,
                    content: t,
                    autoResize: E
                }), this.toggleClass("lenis", !0), this.velocity = 0, this.isLocked = !1, this.isStopped = !1, this.isSmooth = s || r || o, this.isScrolling = !1, this.targetScroll = this.animatedScroll = this.actualScroll, this.options.wrapper.addEventListener("scroll", this.onNativeScroll, {
                    passive: !1
                }), this.virtualScroll = new WQ(i, {
                    touchMultiplier: g,
                    wheelMultiplier: f,
                    normalizeWheel: m
                }), this.virtualScroll.on("scroll", this.onVirtualScroll)
            }
            destroy() {
                this.emitter.destroy(), this.options.wrapper.removeEventListener("scroll", this.onNativeScroll, {
                    passive: !1
                }), this.virtualScroll.destroy(), this.dimensions.destroy(), this.toggleClass("lenis", !1), this.toggleClass("lenis-smooth", !1), this.toggleClass("lenis-scrolling", !1), this.toggleClass("lenis-stopped", !1), this.toggleClass("lenis-locked", !1)
            }
            on(e, t) {
                return this.emitter.on(e, t)
            }
            off(e, t) {
                return this.emitter.off(e, t)
            }
            setScroll(e) {
                this.isHorizontal ? this.rootElement.scrollLeft = e : this.rootElement.scrollTop = e
            }
            onVirtualScroll = ({
                deltaX: e,
                deltaY: t,
                event: n
            }) => {
                if (n.ctrlKey) return;
                const i = n.type.includes("touch"),
                    r = n.type.includes("wheel");
                if ((this.options.smoothTouch || this.options.syncTouch) && i && "touchstart" === n.type) return void this.reset();
                const o = 0 === e && 0 === t,
                    s = "vertical" === this.options.gestureOrientation && 0 === t || "horizontal" === this.options.gestureOrientation && 0 === e;
                if (o || s) return;
                let a = n.composedPath();
                if (a = a.slice(0, a.indexOf(this.rootElement)), a.find((e => e.hasAttribute ? .("data-lenis-prevent") || i && e.hasAttribute ? .("data-lenis-prevent-touch") || r && e.hasAttribute ? .("data-lenis-prevent-wheel") || e.classList ? .contains("lenis")))) return;
                if (this.isStopped || this.isLocked) return void n.preventDefault();
                if (this.isSmooth = (this.options.smoothTouch || this.options.syncTouch) && i || this.options.smoothWheel && r, !this.isSmooth) return this.isScrolling = !1, void this.animate.stop();
                n.preventDefault();
                let l = t;
                "both" === this.options.gestureOrientation ? l = Math.abs(t) > Math.abs(e) ? t : e : "horizontal" === this.options.gestureOrientation && (l = e);
                const c = i && this.options.syncTouch,
                    A = i && "touchend" === n.type && Math.abs(l) > 5;
                A && (l = this.velocity * this.options.touchInertiaMultiplier), this.scrollTo(this.targetScroll + l, {
                    programmatic: !1,
                    ...c ? {
                        lerp: A ? this.options.syncTouchLerp : 1
                    } : {
                        lerp: this.options.lerp,
                        duration: this.options.duration,
                        easing: this.options.easing
                    }
                })
            };
            resize() {
                this.dimensions.resize()
            }
            emit() {
                this.emitter.emit("scroll", this)
            }
            onNativeScroll = () => {
                if (!this.__preventNextScrollEvent && !this.isScrolling) {
                    const e = this.animatedScroll;
                    this.animatedScroll = this.targetScroll = this.actualScroll, this.velocity = 0, this.direction = Math.sign(this.animatedScroll - e), this.emit()
                }
            };
            reset() {
                this.isLocked = !1, this.isScrolling = !1, this.animatedScroll = this.targetScroll = this.actualScroll, this.velocity = 0, this.animate.stop()
            }
            start() {
                this.isStopped = !1, this.reset()
            }
            stop() {
                this.isStopped = !0, this.animate.stop(), this.reset()
            }
            raf(e) {
                const t = e - (this.time || e);
                this.time = e, this.animate.advance(.001 * t)
            }
            scrollTo(e, {
                offset: t = 0,
                immediate: n = !1,
                lock: i = !1,
                duration: r = this.options.duration,
                easing: o = this.options.easing,
                lerp: s = !r && this.options.lerp,
                onComplete: a = null,
                force: l = !1,
                programmatic: c = !0
            } = {}) {
                if (!this.isStopped && !this.isLocked || l) {
                    if (["top", "left", "start"].includes(e)) e = 0;
                    else if (["bottom", "right", "end"].includes(e)) e = this.limit;
                    else {
                        let n;
                        if ("string" == typeof e ? n = document.querySelector(e) : e ? .nodeType && (n = e), n) {
                            if (this.options.wrapper !== window) {
                                const e = this.options.wrapper.getBoundingClientRect();
                                t -= this.isHorizontal ? e.left : e.top
                            }
                            const i = n.getBoundingClientRect();
                            e = (this.isHorizontal ? i.left : i.top) + this.animatedScroll
                        }
                    }
                    if ("number" == typeof e) {
                        if (e += t, e = Math.round(e), this.options.infinite ? c && (this.targetScroll = this.animatedScroll = this.scroll) : e = qQ(0, e, this.limit), n) return this.animatedScroll = this.targetScroll = e, this.setScroll(this.scroll), this.reset(), void a ? .(this);
                        if (!c) {
                            if (e === this.targetScroll) return;
                            this.targetScroll = e
                        }
                        this.animate.fromTo(this.animatedScroll, e, {
                            duration: r,
                            easing: o,
                            lerp: s,
                            onStart: () => {
                                i && (this.isLocked = !0), this.isScrolling = !0
                            },
                            onUpdate: (e, t) => {
                                this.isScrolling = !0, this.velocity = e - this.animatedScroll, this.direction = Math.sign(this.velocity), this.animatedScroll = e, this.setScroll(this.scroll), c && (this.targetScroll = e), t || this.emit(), t && (this.reset(), this.emit(), a ? .(this), this.__preventNextScrollEvent = !0, requestAnimationFrame((() => {
                                    delete this.__preventNextScrollEvent
                                })))
                            }
                        })
                    }
                }
            }
            get rootElement() {
                return this.options.wrapper === window ? document.documentElement : this.options.wrapper
            }
            get limit() {
                return this.dimensions.limit[this.isHorizontal ? "x" : "y"]
            }
            get isHorizontal() {
                return "horizontal" === this.options.orientation
            }
            get actualScroll() {
                return this.isHorizontal ? this.rootElement.scrollLeft : this.rootElement.scrollTop
            }
            get scroll() {
                return this.options.infinite ? (this.animatedScroll % (e = this.limit) + e) % e : this.animatedScroll;
                var e
            }
            get progress() {
                return 0 === this.limit ? 1 : this.scroll / this.limit
            }
            get isSmooth() {
                return this.__isSmooth
            }
            set isSmooth(e) {
                this.__isSmooth !== e && (this.__isSmooth = e, this.toggleClass("lenis-smooth", e))
            }
            get isScrolling() {
                return this.__isScrolling
            }
            set isScrolling(e) {
                this.__isScrolling !== e && (this.__isScrolling = e, this.toggleClass("lenis-scrolling", e))
            }
            get isStopped() {
                return this.__isStopped
            }
            set isStopped(e) {
                this.__isStopped !== e && (this.__isStopped = e, this.toggleClass("lenis-stopped", e))
            }
            get isLocked() {
                return this.__isLocked
            }
            set isLocked(e) {
                this.__isLocked !== e && (this.__isLocked = e, this.toggleClass("lenis-locked", e))
            }
            get className() {
                let e = "lenis";
                return this.isStopped && (e += " lenis-stopped"), this.isLocked && (e += " lenis-locked"), this.isScrolling && (e += " lenis-scrolling"), this.isSmooth && (e += " lenis-smooth"), e
            }
            toggleClass(e, t) {
                this.rootElement.classList.toggle(e, t), this.emitter.emit("className change", this)
            }
        }
        const XQ = {
            listeners: new Set
        };

        function ZQ() {
            return {
                smoothTouch: !0,
                duration: 1.2,
                easing: Gh.lenisDefault
            }
        }

        function _Q() {
            if ("smooth" !== document.body.getAttribute("data-scroll-type")) return {
                isSmooth: !1,
                config: {
                    smoothTouch: !0,
                    duration: .2,
                    touchInertiaMultiplier: 3
                }
            };
            const e = document.body,
                t = ZQ(),
                n = e.getAttribute("data-scroll-easing");
            n in Gh && (t.easing = Gh[n]);
            const i = e.getAttribute("data-scroll-duration"),
                r = ch(parseInt(i) / 1e3, 3);
            !isNaN(r) && r >= 0 && (t.duration = r);
            const o = e.getAttribute("data-scroll-speed"),
                s = ch(parseInt(o) / 100, 2);
            !isNaN(s) && s > 0 && (t.wheelMultiplier = s, t.touchMultiplier = s);
            return "yes" === e.getAttribute("data-scroll-infinite") && (t.infinite = !0), {
                isSmooth: !0,
                config: t
            }
        }

        function $Q() {
            var e;
            XQ.val && XQ.val.destroy(), window.scrollTo(0, 0), XQ.config = _Q(), XQ.val = new zQ(XQ.config.config), (e = XQ.val).setScroll = t => {
                const n = e.velocity,
                    i = e.rootElement,
                    r = n > 0 ? Math.ceil(t) : n < 0 ? Math.floor(t) : Math.round(t);
                e.isHorizontal ? i.scrollLeft = Math.round(r) : i.scrollTop = Math.round(r)
            }, XQ.val.on("scroll", (e => {
                const t = XQ.listeners;
                for (const n of t) try {
                    n(e)
                } catch (e) {
                    console.error("Smooth scroll listener callback error:", e)
                }
            }))
        }
        var eU = function(e, t, n, i) {
            return new(n || (n = Promise))((function(r, o) {
                function s(e) {
                    try {
                        l(i.next(e))
                    } catch (e) {
                        o(e)
                    }
                }

                function a(e) {
                    try {
                        l(i.throw(e))
                    } catch (e) {
                        o(e)
                    }
                }

                function l(e) {
                    var t;
                    e.done ? r(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(s, a)
                }
                l((i = i.apply(e, t || [])).next())
            }))
        };
        const tU = {};

        function nU(e, t) {
            return eU(this, void 0, void 0, (function*() {
                if (!e) return;
                const n = document.getElementsByClassName("pwb-scene")[0];
                if (!n) return;
                const i = document.createElement("canvas");
                n.appendChild(i);
                const r = VQ(i, e.autoResolutionSettings);
                tU.builder = r;
                const {
                    pwObjects: o,
                    pwMaterials: s,
                    parents: a,
                    children: l,
                    effects: c,
                    pwObjectsUsingPwMaterial: A,
                    sharedMaterials: h
                } = e, u = Object.assign(Object.assign({}, e), {
                    pwObjects: new Map(Object.entries(o)),
                    pwMaterials: new Map(Object.entries(s)),
                    parents: new Map(Object.entries(a)),
                    children: new Map(Object.entries(l)),
                    effects: new Map(Object.entries(c || {})),
                    pwObjectsUsingPwMaterial: new Map(Object.entries(A || {})),
                    sharedMaterials: new Set(h)
                });
                let d;
                const p = new Promise((e => {
                    d = e
                }));
                r.listenTo(OI.SceneReady, (() => {
                    null == d || d(void 0)
                })), r.initializeClient(u, t), yield p, Cu && r.showStatsPanel(document.body), NQ((() => {
                    var e;
                    null === (e = tU.builder) || void 0 === e || e.dispose(), tU.builder = void 0
                }))
            }))
        }

        function iU(e) {
            return eU(this, void 0, void 0, (function*() {
                if (!e) return;
                const {
                    builder: t
                } = tU;
                if (!t) return;
                window.scrollTo(0, 0);
                const n = VI("default project");
                n.setState(e.sheetsById);
                const i = n.getAnimation(LI),
                    r = e.sheetsById[LI].sequence;
                if (!r) return void console.error("No animation sheet state found!");
                const {
                    tracksByObject: o = {},
                    unitType: s,
                    lengthInUnits: a
                } = r;
                Object.keys(o).forEach((e => {
                    const n = t.getMaterial(e);
                    if (n) return void i.animateMaterial(n);
                    const r = t.getObject(e);
                    r && i.animateObject3D(r)
                }));
                const l = e => {
                    const t = function(e) {
                        const {
                            height: t,
                            scrollHeight: n
                        } = e.dimensions, i = e.scroll;
                        return "percentage" === s ? i / (n - t) * 100 : "dynamicViewPort" === s ? i / t * 100 : (console.error(`Animation unit type: <${s}> not supported.`), 0)
                    }(e);
                    i.setPosition(t / a)
                };
                var c;
                c = l, XQ.listeners.add(c), NQ((() => {
                    ! function(e) {
                        XQ.listeners.delete(e)
                    }(l)
                }))
            }))
        }
        const rU = {
            listeners: {
                [D.UIOverlay]: new Set,
                [D.UIAudio]: new Set
            }
        };

        function oU(e, t) {
            rU.listeners[e].add(t)
        }

        function sU(e, t) {
            rU.listeners[e].delete(t)
        }

        function aU(e, t) {
            ! function(e, t, n) {
                const i = rU.listeners[e];
                for (const e of i) try {
                    e((r = t, JSON.parse(JSON.stringify(r))), n)
                } catch (e) {
                    console.error("Interaction error:", e)
                }
                var r
            }(e.type, e, t)
        }

        function lU(e) {
            return [D.UIAudio, D.UIOverlay].includes(e.type) && !!e.id
        }

        function cU(e) {
            return `pwb-ignore-click-ui-overlay-interaction-${e}`
        }
        const AU = {
            [K.MouseClick]: function(t) {
                const {
                    el: n
                } = t, {
                    actions: i,
                    mouseCursor: r
                } = t.interaction;
                ! function(e) {
                    const {
                        el: t
                    } = e, {
                        actions: n
                    } = e.interaction, i = new Set;
                    for (const e of n) {
                        if (e.type !== D.UIOverlay) return;
                        if (!e.id) return;
                        i.add(cU(e.id))
                    }
                    for (const e of i) t.classList.add(e)
                }(t), r === e.Pointer && (n.style.cursor = "pointer"), n.addEventListener("click", (e => {
                    ph(e), gh(e);
                    for (const e of i) aU(e, K.MouseClick)
                }))
            },
            [K.MouseEnter]: function(e) {
                const {
                    el: t
                } = e, {
                    actions: n
                } = e.interaction;
                t.addEventListener("mouseenter", (() => {
                    for (const e of n) aU(e, K.MouseEnter)
                }))
            },
            [K.MouseLeave]: function(e) {
                const {
                    el: t
                } = e, {
                    actions: n
                } = e.interaction;
                t.addEventListener("mouseleave", (() => {
                    for (const e of n) aU(e, K.MouseLeave)
                }))
            }
        };

        function hU(e) {
            const t = function(e) {
                const t = [];
                if (!e) return t;
                const n = e[V.Interactions] || {};
                return Object.entries(n).forEach((([e, n]) => {
                    if (!n) return;
                    const i = document.getElementById(e);
                    if (i)
                        for (const e of n) {
                            const n = e.actions.filter((e => lU(e)));
                            n.length <= 0 || t.push({
                                el: i,
                                interaction: {
                                    triggerType: e.triggerType,
                                    mouseCursor: e.mouseCursor,
                                    actions: n
                                }
                            })
                        }
                })), t
            }(e);
            for (const e of t) AU[e.interaction.triggerType](e)
        }
        const uU = {};

        function dU() {
            if (uU.scrollSections) return uU.scrollSections;
            throw new Error("ScrollSectionsModule needs to be initialized before the findAllScrollSections function can be called.")
        }

        function pU(e) {
            uU.scrollSections = function(e) {
                const t = new Map;
                if (!e) return t;
                const n = e.sections || {};
                return Object.entries(n).forEach((([e, n]) => {
                    if (!(null == n ? void 0 : n.hash)) return;
                    const i = document.getElementById(e);
                    if (!i) return;
                    const {
                        hash: r,
                        offsetY: o
                    } = n;
                    t.set(e, {
                        id: e,
                        hash: r,
                        offsetY: o || 0,
                        el: i
                    })
                })), t
            }(e)
        }

        function gU(e, t) {
            const n = new Map;
            if (!e) return n;
            const i = e.links || {};
            return Object.entries(i).forEach((([e, i]) => {
                if (!i) return;
                const r = function(e, t) {
                    if (e.type === P.External) {
                        if ("string" != typeof e.url) return;
                        const t = e.url.trim();
                        if (!t) return;
                        return {
                            type: P.External,
                            url: ah(t),
                            newTab: !!e.newTab
                        }
                    }
                    if (e.type === P.Internal) {
                        if (!e.pageId) return;
                        if (!e.pagePath) return;
                        const n = !!e.newTab,
                            i = e.sectionId ? t.get(e.sectionId) : void 0;
                        return {
                            type: P.Internal,
                            pageId: e.pageId,
                            pagePath: e.pagePath,
                            sectionId: e.sectionId,
                            sectionHash: e.sectionHash,
                            sectionEl: null == i ? void 0 : i.el,
                            sectionOffsetY: (null == i ? void 0 : i.offsetY) || 0,
                            newTab: n,
                            smoothScroll: !n && !!e.smoothScroll
                        }
                    }
                }(i, t);
                r && n.set(e, r)
            })), n
        }

        function fU(e) {
            const t = window;
            return n => {
                ph(n), gh(n);
                const i = e.url;
                n.ctrlKey || n.metaKey || e.newTab || Eu ? t.open(i, "_blank") : n.shiftKey ? t.open(i) : t.location.href = i
            }
        }

        function mU(e) {
            const t = window;
            return n => {
                ph(n), gh(n);
                const i = e.newTab && Eu;
                if (e.newTab && !i) {
                    const n = function(e, t, n) {
                        const i = t || "/",
                            r = n ? `#${n}` : "";
                        try {
                            const t = new URL(ah(e));
                            return t.hash = r, t.pathname = i, t.toString()
                        } catch (e) {
                            return `${i}${r}`
                        }
                    }(window.location.href, e.pagePath, e.sectionHash);
                    return void t.open(n, "_blank")
                }
                if (function() {
                        const {
                            isInitialized: e,
                            isNavigating: t
                        } = Ek;
                        return !e || t ? void 0 : Ek.currentPath
                    }() !== e.pagePath) return void Sk(e.pagePath, e.sectionHash);
                if (!XQ.val) return;
                const r = e.sectionEl ? e.sectionEl : "top",
                    o = {
                        offset: e.sectionOffsetY,
                        immediate: !e.smoothScroll && !i
                    };
                if (!(o.immediate || XQ.config && XQ.config.isSmooth)) {
                    const e = ZQ();
                    o.duration = e.duration, o.easing = e.easing
                }
                XQ.val.scrollTo(r, o)
            }
        }

        function EU(e) {
            if (!XQ.val) return;
            const t = Ek.currentSectionHash;
            if (!t) return;
            const n = Array.from(e.values()).find((e => e.hash === t));
            n && XQ.val.scrollTo(n.el, {
                offset: n.offsetY,
                immediate: !0
            })
        }
        const CU = e => e;
        let IU = CU,
            SU = CU;

        function vU(e, t, n) {
            var i;
            if ("string" == typeof e) {
                let r = document;
                t && (SU(Boolean(t.current), "Scope provided, but no element detected."), r = t.current), n ? (null !== (i = n[e]) && void 0 !== i || (n[e] = r.querySelectorAll(e)), e = n[e]) : e = r.querySelectorAll(e)
            } else e instanceof Element && (e = [e]);
            return Array.from(e || [])
        }
        const BU = new WeakMap,
            xU = !1,
            yU = !1;
        class wU {
            constructor() {
                this.order = [], this.scheduled = new Set
            }
            add(e) {
                if (!this.scheduled.has(e)) return this.scheduled.add(e), this.order.push(e), !0
            }
            remove(e) {
                const t = this.order.indexOf(e); - 1 !== t && (this.order.splice(t, 1), this.scheduled.delete(e))
            }
            clear() {
                this.order.length = 0, this.scheduled.clear()
            }
        }
        const bU = ["read", "resolveKeyframes", "update", "preRender", "render", "postRender"];
        const {
            schedule: QU,
            cancel: UU,
            state: MU,
            steps: RU
        } = function(e, t) {
            let n = !1,
                i = !0;
            const r = {
                    delta: 0,
                    timestamp: 0,
                    isProcessing: !1
                },
                o = bU.reduce(((e, t) => (e[t] = function(e) {
                    let t = new wU,
                        n = new wU,
                        i = 0,
                        r = !1,
                        o = !1;
                    const s = new WeakSet,
                        a = {
                            schedule: (e, o = !1, a = !1) => {
                                const l = a && r,
                                    c = l ? t : n;
                                return o && s.add(e), c.add(e) && l && r && (i = t.order.length), e
                            },
                            cancel: e => {
                                n.remove(e), s.delete(e)
                            },
                            process: l => {
                                if (r) o = !0;
                                else {
                                    if (r = !0, [t, n] = [n, t], n.clear(), i = t.order.length, i)
                                        for (let n = 0; n < i; n++) {
                                            const i = t.order[n];
                                            s.has(i) && (a.schedule(i), e()), i(l)
                                        }
                                    r = !1, o && (o = !1, a.process(l))
                                }
                            }
                        };
                    return a
                }((() => n = !0)), e)), {}),
                s = e => {
                    o[e].process(r)
                },
                a = () => {
                    const o = yU ? r.timestamp : performance.now();
                    n = !1, r.delta = i ? 1e3 / 60 : Math.max(Math.min(o - r.timestamp, 40), 1), r.timestamp = o, r.isProcessing = !0, bU.forEach(s), r.isProcessing = !1, n && t && (i = !1, e(a))
                };
            return {
                schedule: bU.reduce(((t, s) => {
                    const l = o[s];
                    return t[s] = (t, o = !1, s = !1) => (n || (n = !0, i = !0, r.isProcessing || e(a)), l.schedule(t, o, s)), t
                }), {}),
                cancel: e => bU.forEach((t => o[t].cancel(e))),
                state: r,
                steps: o
            }
        }("undefined" != typeof requestAnimationFrame ? requestAnimationFrame : CU, !0);

        function TU(e, t) {
            let n;
            const i = () => {
                const {
                    currentTime: i
                } = t, r = (null === i ? 0 : i.value) / 100;
                n !== r && e(r), n = r
            };
            return QU.update(i, !0), () => UU(i)
        }

        function FU(e) {
            let t;
            return () => (void 0 === t && (t = e()), t)
        }
        const DU = FU((() => void 0 !== window.ScrollTimeline));
        class kU {
            constructor(e) {
                this.animations = e.filter(Boolean)
            }
            then(e, t) {
                return Promise.all(this.animations).then(e).catch(t)
            }
            getAll(e) {
                return this.animations[0][e]
            }
            setAll(e, t) {
                for (let n = 0; n < this.animations.length; n++) this.animations[n][e] = t
            }
            attachTimeline(e) {
                const t = this.animations.map((t => {
                    if (!DU() || !t.attachTimeline) return t.pause(), TU((e => {
                        t.time = t.duration * e
                    }), e);
                    t.attachTimeline(e)
                }));
                return () => {
                    t.forEach(((e, t) => {
                        e && e(), this.animations[t].stop()
                    }))
                }
            }
            get time() {
                return this.getAll("time")
            }
            set time(e) {
                this.setAll("time", e)
            }
            get speed() {
                return this.getAll("speed")
            }
            set speed(e) {
                this.setAll("speed", e)
            }
            get duration() {
                let e = 0;
                for (let t = 0; t < this.animations.length; t++) e = Math.max(e, this.animations[t].duration);
                return e
            }
            runAll(e) {
                this.animations.forEach((t => t[e]()))
            }
            play() {
                this.runAll("play")
            }
            pause() {
                this.runAll("pause")
            }
            stop() {
                this.runAll("stop")
            }
            cancel() {
                this.runAll("cancel")
            }
            complete() {
                this.runAll("complete")
            }
        }
        const LU = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"],
            KU = new Set(LU),
            PU = e => e.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(),
            GU = "data-" + PU("framerAppearId"),
            VU = e => 1e3 * e,
            OU = e => e / 1e3,
            NU = {
                type: "spring",
                stiffness: 500,
                damping: 25,
                restSpeed: 10
            },
            HU = {
                type: "keyframes",
                duration: .8
            },
            qU = {
                type: "keyframes",
                ease: [.25, .1, .35, 1],
                duration: .3
            },
            jU = (e, {
                keyframes: t
            }) => t.length > 2 ? HU : KU.has(e) ? e.startsWith("scale") ? {
                type: "spring",
                stiffness: 550,
                damping: 0 === t[1] ? 2 * Math.sqrt(550) : 30,
                restSpeed: 10
            } : NU : qU;

        function YU(e, t) {
            return e[t] || e.default || e
        }
        const JU = !1,
            WU = e => null !== e;

        function zU(e, {
            repeat: t,
            repeatType: n = "loop"
        }) {
            const i = e.filter(WU);
            return i[t && "loop" !== n && t % 2 == 1 ? 0 : i.length - 1]
        }
        let XU;

        function ZU() {
            XU = void 0
        }
        const _U = {
                now: () => (void 0 === XU && _U.set(MU.isProcessing || yU ? MU.timestamp : performance.now()), XU),
                set: e => {
                    XU = e, queueMicrotask(ZU)
                }
            },
            $U = e => /^0[^.\s]+$/u.test(e);
        const eM = e => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e),
            tM = e => t => "string" == typeof t && t.startsWith(e),
            nM = tM("--"),
            iM = tM("var(--"),
            rM = e => !!iM(e) && oM.test(e.split("/*")[0].trim()),
            oM = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu,
            sM = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;

        function aM(e, t, n = 1) {
            SU(n <= 4, `Max CSS variable fallback depth detected in property "${e}". This may indicate a circular fallback dependency.`);
            const [i, r] = function(e) {
                const t = sM.exec(e);
                if (!t) return [, ];
                const [, n, i, r] = t;
                return [`--${null!=n?n:i}`, r]
            }(e);
            if (!i) return;
            const o = window.getComputedStyle(t).getPropertyValue(i);
            if (o) {
                const e = o.trim();
                return eM(e) ? parseFloat(e) : e
            }
            return rM(r) ? aM(r, t, n + 1) : r
        }
        const lM = (e, t, n) => n > t ? t : n < e ? e : n,
            cM = {
                test: e => "number" == typeof e,
                parse: parseFloat,
                transform: e => e
            },
            AM = { ...cM,
                transform: e => lM(0, 1, e)
            },
            hM = { ...cM,
                default: 1
            },
            uM = e => Math.round(1e5 * e) / 1e5,
            dM = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu,
            pM = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu,
            gM = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu;

        function fM(e) {
            return "string" == typeof e
        }
        const mM = e => ({
                test: t => fM(t) && t.endsWith(e) && 1 === t.split(" ").length,
                parse: parseFloat,
                transform: t => `${t}${e}`
            }),
            EM = mM("deg"),
            CM = mM("%"),
            IM = mM("px"),
            SM = mM("vh"),
            vM = mM("vw"),
            BM = { ...CM,
                parse: e => CM.parse(e) / 100,
                transform: e => CM.transform(100 * e)
            },
            xM = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y", "translateX", "translateY"]),
            yM = e => e === cM || e === IM,
            wM = (e, t) => parseFloat(e.split(", ")[t]),
            bM = (e, t) => (n, {
                transform: i
            }) => {
                if ("none" === i || !i) return 0;
                const r = i.match(/^matrix3d\((.+)\)$/u);
                if (r) return wM(r[1], t); {
                    const t = i.match(/^matrix\((.+)\)$/u);
                    return t ? wM(t[1], e) : 0
                }
            },
            QM = new Set(["x", "y", "z"]),
            UM = LU.filter((e => !QM.has(e)));
        const MM = {
            width: ({
                x: e
            }, {
                paddingLeft: t = "0",
                paddingRight: n = "0"
            }) => e.max - e.min - parseFloat(t) - parseFloat(n),
            height: ({
                y: e
            }, {
                paddingTop: t = "0",
                paddingBottom: n = "0"
            }) => e.max - e.min - parseFloat(t) - parseFloat(n),
            top: (e, {
                top: t
            }) => parseFloat(t),
            left: (e, {
                left: t
            }) => parseFloat(t),
            bottom: ({
                y: e
            }, {
                top: t
            }) => parseFloat(t) + (e.max - e.min),
            right: ({
                x: e
            }, {
                left: t
            }) => parseFloat(t) + (e.max - e.min),
            x: bM(4, 13),
            y: bM(5, 14)
        };
        MM.translateX = MM.x, MM.translateY = MM.y;
        const RM = e => t => t.test(e),
            TM = [cM, IM, CM, EM, vM, SM, {
                test: e => "auto" === e,
                parse: e => e
            }],
            FM = e => TM.find(RM(e)),
            DM = new Set;
        let kM = !1,
            LM = !1;

        function KM() {
            LM && (DM.forEach((e => {
                e.needsMeasurement && e.unsetTransforms()
            })), DM.forEach((e => {
                e.needsMeasurement && e.measureInitialState()
            })), DM.forEach((e => {
                e.needsMeasurement && e.renderEndStyles()
            })), DM.forEach((e => {
                e.needsMeasurement && e.measureEndState()
            }))), LM = !1, kM = !1, DM.forEach((e => e.complete())), DM.clear()
        }

        function PM() {
            DM.forEach((e => {
                e.readKeyframes(), e.needsMeasurement && (LM = !0)
            })), QU.resolveKeyframes(KM)
        }
        class GM {
            constructor(e, t, n, i, r, o = !1) {
                this.isComplete = !1, this.isAsync = !1, this.needsMeasurement = !1, this.isScheduled = !1, this.unresolvedKeyframes = [...e], this.onComplete = t, this.name = n, this.motionValue = i, this.element = r, this.isAsync = o
            }
            scheduleResolve() {
                this.isScheduled = !0, this.isAsync ? (DM.add(this), kM || (kM = !0, QU.read(PM))) : (this.readKeyframes(), this.complete())
            }
            readKeyframes() {
                const {
                    unresolvedKeyframes: e,
                    name: t,
                    element: n,
                    motionValue: i
                } = this;
                for (let r = 0; r < e.length; r++)
                    if (null === e[r])
                        if (0 === r) {
                            const r = null == i ? void 0 : i.get(),
                                o = e[e.length - 1];
                            if (void 0 !== r) e[0] = r;
                            else if (n && t) {
                                const i = n.readValue(t, o);
                                null != i && (e[0] = i)
                            }
                            void 0 === e[0] && (e[0] = o), i && void 0 === r && i.set(e[0])
                        } else e[r] = e[r - 1]
            }
            unsetTransforms() {}
            measureInitialState() {}
            renderEndStyles() {}
            measureEndState() {}
            complete() {
                this.isComplete = !0, this.onComplete(this.unresolvedKeyframes), DM.delete(this)
            }
            cancel() {
                this.isComplete || (this.isScheduled = !1, DM.delete(this))
            }
            resume() {
                this.isComplete || this.scheduleResolve()
            }
        }
        const VM = (e, t) => n => Boolean(fM(n) && gM.test(n) && n.startsWith(e) || t && Object.prototype.hasOwnProperty.call(n, t)),
            OM = (e, t, n) => i => {
                if (!fM(i)) return i;
                const [r, o, s, a] = i.match(dM);
                return {
                    [e]: parseFloat(r),
                    [t]: parseFloat(o),
                    [n]: parseFloat(s),
                    alpha: void 0 !== a ? parseFloat(a) : 1
                }
            },
            NM = { ...cM,
                transform: e => Math.round((e => lM(0, 255, e))(e))
            },
            HM = {
                test: VM("rgb", "red"),
                parse: OM("red", "green", "blue"),
                transform: ({
                    red: e,
                    green: t,
                    blue: n,
                    alpha: i = 1
                }) => "rgba(" + NM.transform(e) + ", " + NM.transform(t) + ", " + NM.transform(n) + ", " + uM(AM.transform(i)) + ")"
            };
        const qM = {
                test: VM("#"),
                parse: function(e) {
                    let t = "",
                        n = "",
                        i = "",
                        r = "";
                    return e.length > 5 ? (t = e.substring(1, 3), n = e.substring(3, 5), i = e.substring(5, 7), r = e.substring(7, 9)) : (t = e.substring(1, 2), n = e.substring(2, 3), i = e.substring(3, 4), r = e.substring(4, 5), t += t, n += n, i += i, r += r), {
                        red: parseInt(t, 16),
                        green: parseInt(n, 16),
                        blue: parseInt(i, 16),
                        alpha: r ? parseInt(r, 16) / 255 : 1
                    }
                },
                transform: HM.transform
            },
            jM = {
                test: VM("hsl", "hue"),
                parse: OM("hue", "saturation", "lightness"),
                transform: ({
                    hue: e,
                    saturation: t,
                    lightness: n,
                    alpha: i = 1
                }) => "hsla(" + Math.round(e) + ", " + CM.transform(uM(t)) + ", " + CM.transform(uM(n)) + ", " + uM(AM.transform(i)) + ")"
            },
            YM = {
                test: e => HM.test(e) || qM.test(e) || jM.test(e),
                parse: e => HM.test(e) ? HM.parse(e) : jM.test(e) ? jM.parse(e) : qM.parse(e),
                transform: e => fM(e) ? e : e.hasOwnProperty("red") ? HM.transform(e) : jM.transform(e)
            };
        const JM = "number",
            WM = "color",
            zM = "var",
            XM = "var(",
            ZM = "${}",
            _M = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;

        function $M(e) {
            const t = e.toString(),
                n = [],
                i = {
                    color: [],
                    number: [],
                    var: []
                },
                r = [];
            let o = 0;
            const s = t.replace(_M, (e => (YM.test(e) ? (i.color.push(o), r.push(WM), n.push(YM.parse(e))) : e.startsWith(XM) ? (i.var.push(o), r.push(zM), n.push(e)) : (i.number.push(o), r.push(JM), n.push(parseFloat(e))), ++o, ZM))).split(ZM);
            return {
                values: n,
                split: s,
                indexes: i,
                types: r
            }
        }

        function eR(e) {
            return $M(e).values
        }

        function tR(e) {
            const {
                split: t,
                types: n
            } = $M(e), i = t.length;
            return e => {
                let r = "";
                for (let o = 0; o < i; o++)
                    if (r += t[o], void 0 !== e[o]) {
                        const t = n[o];
                        r += t === JM ? uM(e[o]) : t === WM ? YM.transform(e[o]) : e[o]
                    }
                return r
            }
        }
        const nR = e => "number" == typeof e ? 0 : e;
        const iR = {
                test: function(e) {
                    var t, n;
                    return isNaN(e) && fM(e) && ((null === (t = e.match(dM)) || void 0 === t ? void 0 : t.length) || 0) + ((null === (n = e.match(pM)) || void 0 === n ? void 0 : n.length) || 0) > 0
                },
                parse: eR,
                createTransformer: tR,
                getAnimatableNone: function(e) {
                    const t = eR(e);
                    return tR(e)(t.map(nR))
                }
            },
            rR = new Set(["brightness", "contrast", "saturate", "opacity"]);

        function oR(e) {
            const [t, n] = e.slice(0, -1).split("(");
            if ("drop-shadow" === t) return e;
            const [i] = n.match(dM) || [];
            if (!i) return e;
            const r = n.replace(i, "");
            let o = rR.has(t) ? 1 : 0;
            return i !== n && (o *= 100), t + "(" + o + r + ")"
        }
        const sR = /\b([a-z-]*)\(.*?\)/gu,
            aR = { ...iR,
                getAnimatableNone: e => {
                    const t = e.match(sR);
                    return t ? t.map(oR).join(" ") : e
                }
            },
            lR = { ...cM,
                transform: Math.round
            },
            cR = {
                borderWidth: IM,
                borderTopWidth: IM,
                borderRightWidth: IM,
                borderBottomWidth: IM,
                borderLeftWidth: IM,
                borderRadius: IM,
                radius: IM,
                borderTopLeftRadius: IM,
                borderTopRightRadius: IM,
                borderBottomRightRadius: IM,
                borderBottomLeftRadius: IM,
                width: IM,
                maxWidth: IM,
                height: IM,
                maxHeight: IM,
                size: IM,
                top: IM,
                right: IM,
                bottom: IM,
                left: IM,
                padding: IM,
                paddingTop: IM,
                paddingRight: IM,
                paddingBottom: IM,
                paddingLeft: IM,
                margin: IM,
                marginTop: IM,
                marginRight: IM,
                marginBottom: IM,
                marginLeft: IM,
                rotate: EM,
                rotateX: EM,
                rotateY: EM,
                rotateZ: EM,
                scale: hM,
                scaleX: hM,
                scaleY: hM,
                scaleZ: hM,
                skew: EM,
                skewX: EM,
                skewY: EM,
                distance: IM,
                translateX: IM,
                translateY: IM,
                translateZ: IM,
                x: IM,
                y: IM,
                z: IM,
                perspective: IM,
                transformPerspective: IM,
                opacity: AM,
                originX: BM,
                originY: BM,
                originZ: IM,
                zIndex: lR,
                fillOpacity: AM,
                strokeOpacity: AM,
                numOctaves: lR
            },
            AR = { ...cR,
                color: YM,
                backgroundColor: YM,
                outlineColor: YM,
                fill: YM,
                stroke: YM,
                borderColor: YM,
                borderTopColor: YM,
                borderRightColor: YM,
                borderBottomColor: YM,
                borderLeftColor: YM,
                filter: aR,
                WebkitFilter: aR
            },
            hR = e => AR[e];

        function uR(e, t) {
            let n = hR(e);
            return n !== aR && (n = iR), n.getAnimatableNone ? n.getAnimatableNone(t) : void 0
        }
        class dR extends GM {
            constructor(e, t, n, i) {
                super(e, t, n, i, null == i ? void 0 : i.owner, !0)
            }
            readKeyframes() {
                const {
                    unresolvedKeyframes: e,
                    element: t,
                    name: n
                } = this;
                if (!t.current) return;
                const i = [];
                super.readKeyframes();
                for (let n = 0; n < e.length; n++) {
                    const o = e[n];
                    if ("string" == typeof o && rM(o)) {
                        const i = aM(o, t.current);
                        void 0 !== i && (e[n] = i)
                    }("number" == typeof(r = e[n]) ? 0 === r : null === r || "none" === r || "0" === r || $U(r)) && i.push(n)
                }
                var r;
                if (i.length && function(e, t, n) {
                        let i, r = 0;
                        for (; r < e.length && !i;) "string" == typeof e[r] && "none" !== e[r] && "0" !== e[r] && (i = e[r]), r++;
                        if (i && n)
                            for (const r of t) e[r] = uR(n, i)
                    }(e, i, n), !xM.has(n) || 2 !== e.length) return;
                const [o, s] = e, a = FM(o), l = FM(s);
                if (a && l && a !== l)
                    if (yM(a) && yM(l))
                        for (let t = 0; t < e.length; t++) {
                            const n = e[t];
                            "string" == typeof n && (e[t] = parseFloat(n))
                        } else this.needsMeasurement = !0
            }
            unsetTransforms() {
                const {
                    element: e,
                    name: t,
                    unresolvedKeyframes: n
                } = this;
                if (!e.current) return;
                this.removedTransforms = function(e) {
                    const t = [];
                    return UM.forEach((n => {
                        const i = e.getValue(n);
                        void 0 !== i && (t.push([n, i.get()]), i.set(n.startsWith("scale") ? 1 : 0))
                    })), t.length && e.render(), t
                }(e);
                const i = n[n.length - 1];
                e.getValue(t, i).jump(i, !1)
            }
            measureInitialState() {
                const {
                    element: e,
                    unresolvedKeyframes: t,
                    name: n
                } = this;
                e.current && ("height" === n && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = MM[n](e.measureViewportBox(), window.getComputedStyle(e.current)), t[0] = this.measuredOrigin)
            }
            renderEndStyles() {
                this.element.render()
            }
            measureEndState() {
                var e;
                const {
                    element: t,
                    name: n,
                    unresolvedKeyframes: i
                } = this;
                if (!t.current) return;
                const r = t.getValue(n);
                r && r.jump(this.measuredOrigin, !1), i[i.length - 1] = MM[n](t.measureViewportBox(), window.getComputedStyle(t.current)), "height" === n && void 0 !== this.suspendedScrollY && window.scrollTo(0, this.suspendedScrollY), (null === (e = this.removedTransforms) || void 0 === e ? void 0 : e.length) && this.removedTransforms.forEach((([e, n]) => {
                    t.getValue(e).set(n)
                }))
            }
        }
        const pR = (e, t) => "zIndex" !== t && (!("number" != typeof e && !Array.isArray(e)) || !("string" != typeof e || !iR.test(e) && "0" !== e || e.startsWith("url(")));
        class gR {
            constructor({
                autoplay: e = !0,
                delay: t = 0,
                type: n = "keyframes",
                repeat: i = 0,
                repeatDelay: r = 0,
                repeatType: o = "loop",
                ...s
            }) {
                this.isStopped = !1, this.options = {
                    autoplay: e,
                    delay: t,
                    type: n,
                    repeat: i,
                    repeatDelay: r,
                    repeatType: o,
                    ...s
                }, this.updateFinishedPromise()
            }
            get resolved() {
                return this._resolved || (PM(), KM(), UU(PM), UU(KM)), this._resolved
            }
            onKeyframesResolved(e) {
                const {
                    name: t,
                    type: n,
                    velocity: i,
                    delay: r,
                    onComplete: o,
                    onUpdate: s
                } = this.options;
                if (! function(e, t, n, i) {
                        const r = e[0];
                        if (null === r) return !1;
                        const o = e[e.length - 1],
                            s = pR(r, t),
                            a = pR(o, t);
                        return IU(s === a, `You are trying to animate ${t} from "${r}" to "${o}". ${r} is not an animatable value - to enable this animation set ${r} to a value animatable to ${o} via the \`style\` property.`), !(!s || !a) && (function(e) {
                            const t = e[0];
                            if (1 === e.length) return !0;
                            for (let n = 0; n < e.length; n++)
                                if (e[n] !== t) return !0
                        }(e) || "spring" === n && i)
                    }(e, t, n, i)) {
                    if (JU || !r) {
                        const t = zU(e, this.options);
                        return null == s || s(t), null == o || o(), this.resolveFinishedPromise(), void this.updateFinishedPromise()
                    }
                    this.options.duration = 0
                }
                this._resolved = {
                    keyframes: e,
                    ...this.initPlayback(e)
                }, this.onPostResolved()
            }
            onPostResolved() {}
            then(e, t) {
                return this.currentFinishedPromise.then(e, t)
            }
            updateFinishedPromise() {
                this.currentFinishedPromise = new Promise((e => {
                    this.resolveFinishedPromise = () => {
                        e(), this.updateFinishedPromise()
                    }
                }))
            }
        }

        function fR(e, t) {
            return t ? e * (1e3 / t) : 0
        }
        const mR = 5;

        function ER(e, t, n) {
            const i = Math.max(t - mR, 0);
            return fR(n - e(i), t - i)
        }
        const CR = .001,
            IR = .01,
            SR = 10,
            vR = .05,
            BR = 1;

        function xR({
            duration: e = 800,
            bounce: t = .25,
            velocity: n = 0,
            mass: i = 1
        }) {
            let r, o;
            IU(e <= VU(SR), "Spring duration must be 10 seconds or less");
            let s = 1 - t;
            s = lM(vR, BR, s), e = lM(IR, SR, OU(e)), s < 1 ? (r = t => {
                const i = t * s,
                    r = i * e,
                    o = i - n,
                    a = wR(t, s),
                    l = Math.exp(-r);
                return CR - o / a * l
            }, o = t => {
                const i = t * s * e,
                    o = i * n + n,
                    a = Math.pow(s, 2) * Math.pow(t, 2) * e,
                    l = Math.exp(-i),
                    c = wR(Math.pow(t, 2), s);
                return (-r(t) + CR > 0 ? -1 : 1) * ((o - a) * l) / c
            }) : (r = t => Math.exp(-t * e) * ((t - n) * e + 1) - CR, o = t => Math.exp(-t * e) * (e * e * (n - t)));
            const a = function(e, t, n) {
                let i = n;
                for (let n = 1; n < yR; n++) i -= e(i) / t(i);
                return i
            }(r, o, 5 / e);
            if (e = VU(e), isNaN(a)) return {
                stiffness: 100,
                damping: 10,
                duration: e
            }; {
                const t = Math.pow(a, 2) * i;
                return {
                    stiffness: t,
                    damping: 2 * s * Math.sqrt(i * t),
                    duration: e
                }
            }
        }
        const yR = 12;

        function wR(e, t) {
            return e * Math.sqrt(1 - t * t)
        }
        const bR = ["duration", "bounce"],
            QR = ["stiffness", "damping", "mass"];

        function UR(e, t) {
            return t.some((t => void 0 !== e[t]))
        }

        function MR({
            keyframes: e,
            restDelta: t,
            restSpeed: n,
            ...i
        }) {
            const r = e[0],
                o = e[e.length - 1],
                s = {
                    done: !1,
                    value: r
                },
                {
                    stiffness: a,
                    damping: l,
                    mass: c,
                    duration: A,
                    velocity: h,
                    isResolvedFromDuration: u
                } = function(e) {
                    let t = {
                        velocity: 0,
                        stiffness: 100,
                        damping: 10,
                        mass: 1,
                        isResolvedFromDuration: !1,
                        ...e
                    };
                    if (!UR(e, QR) && UR(e, bR)) {
                        const n = xR(e);
                        t = { ...t,
                            ...n,
                            mass: 1
                        }, t.isResolvedFromDuration = !0
                    }
                    return t
                }({ ...i,
                    velocity: -OU(i.velocity || 0)
                }),
                d = h || 0,
                p = l / (2 * Math.sqrt(a * c)),
                g = o - r,
                f = OU(Math.sqrt(a / c)),
                m = Math.abs(g) < 5;
            let E;
            if (n || (n = m ? .01 : 2), t || (t = m ? .005 : .5), p < 1) {
                const e = wR(f, p);
                E = t => {
                    const n = Math.exp(-p * f * t);
                    return o - n * ((d + p * f * g) / e * Math.sin(e * t) + g * Math.cos(e * t))
                }
            } else if (1 === p) E = e => o - Math.exp(-f * e) * (g + (d + f * g) * e);
            else {
                const e = f * Math.sqrt(p * p - 1);
                E = t => {
                    const n = Math.exp(-p * f * t),
                        i = Math.min(e * t, 300);
                    return o - n * ((d + p * f * g) * Math.sinh(i) + e * g * Math.cosh(i)) / e
                }
            }
            return {
                calculatedDuration: u && A || null,
                next: e => {
                    const i = E(e);
                    if (u) s.done = e >= A;
                    else {
                        let r = d;
                        0 !== e && (r = p < 1 ? ER(E, e, i) : 0);
                        const a = Math.abs(r) <= n,
                            l = Math.abs(o - i) <= t;
                        s.done = a && l
                    }
                    return s.value = s.done ? o : i, s
                }
            }
        }

        function RR({
            keyframes: e,
            velocity: t = 0,
            power: n = .8,
            timeConstant: i = 325,
            bounceDamping: r = 10,
            bounceStiffness: o = 500,
            modifyTarget: s,
            min: a,
            max: l,
            restDelta: c = .5,
            restSpeed: A
        }) {
            const h = e[0],
                u = {
                    done: !1,
                    value: h
                },
                d = e => void 0 === a ? l : void 0 === l || Math.abs(a - e) < Math.abs(l - e) ? a : l;
            let p = n * t;
            const g = h + p,
                f = void 0 === s ? g : s(g);
            f !== g && (p = f - h);
            const m = e => -p * Math.exp(-e / i),
                E = e => f + m(e),
                C = e => {
                    const t = m(e),
                        n = E(e);
                    u.done = Math.abs(t) <= c, u.value = u.done ? f : n
                };
            let I, S;
            const v = e => {
                (e => void 0 !== a && e < a || void 0 !== l && e > l)(u.value) && (I = e, S = MR({
                    keyframes: [u.value, d(u.value)],
                    velocity: ER(E, e, u.value),
                    damping: r,
                    stiffness: o,
                    restDelta: c,
                    restSpeed: A
                }))
            };
            return v(0), {
                calculatedDuration: null,
                next: e => {
                    let t = !1;
                    return S || void 0 !== I || (t = !0, C(e), v(e)), void 0 !== I && e >= I ? S.next(e - I) : (!t && C(e), u)
                }
            }
        }
        const TR = (e, t, n) => (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e,
            FR = 1e-7,
            DR = 12;

        function kR(e, t, n, i) {
            if (e === t && n === i) return CU;
            const r = t => function(e, t, n, i, r) {
                let o, s, a = 0;
                do {
                    s = t + (n - t) / 2, o = TR(s, i, r) - e, o > 0 ? n = s : t = s
                } while (Math.abs(o) > FR && ++a < DR);
                return s
            }(t, 0, 1, e, n);
            return e => 0 === e || 1 === e ? e : TR(r(e), t, i)
        }
        const LR = kR(.42, 0, 1, 1),
            KR = kR(0, 0, .58, 1),
            PR = kR(.42, 0, .58, 1),
            GR = e => Array.isArray(e) && "number" != typeof e[0],
            VR = e => t => t <= .5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2,
            OR = e => t => 1 - e(1 - t),
            NR = e => 1 - Math.sin(Math.acos(e)),
            HR = OR(NR),
            qR = VR(NR),
            jR = kR(.33, 1.53, .69, .99),
            YR = OR(jR),
            JR = VR(YR),
            WR = {
                linear: CU,
                easeIn: LR,
                easeInOut: PR,
                easeOut: KR,
                circIn: NR,
                circInOut: qR,
                circOut: HR,
                backIn: YR,
                backInOut: JR,
                backOut: jR,
                anticipate: e => (e *= 2) < 1 ? .5 * YR(e) : .5 * (2 - Math.pow(2, -10 * (e - 1)))
            },
            zR = e => {
                if (Array.isArray(e)) {
                    SU(4 === e.length, "Cubic bezier arrays must contain four numerical values.");
                    const [t, n, i, r] = e;
                    return kR(t, n, i, r)
                }
                return "string" == typeof e ? (SU(void 0 !== WR[e], `Invalid easing type '${e}'`), WR[e]) : e
            },
            XR = (e, t) => n => t(e(n)),
            ZR = (...e) => e.reduce(XR),
            _R = (e, t, n) => {
                const i = t - e;
                return 0 === i ? 1 : (n - e) / i
            },
            $R = (e, t, n) => e + (t - e) * n;

        function eT(e, t, n) {
            return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e
        }
        const tT = (e, t, n) => {
                const i = e * e,
                    r = n * (t * t - i) + i;
                return r < 0 ? 0 : Math.sqrt(r)
            },
            nT = [qM, HM, jM];

        function iT(e) {
            const t = (e => nT.find((t => t.test(e))))(e);
            SU(Boolean(t), `'${e}' is not an animatable color. Use the equivalent color code instead.`);
            let n = t.parse(e);
            return t === jM && (n = function({
                hue: e,
                saturation: t,
                lightness: n,
                alpha: i
            }) {
                e /= 360, n /= 100;
                let r = 0,
                    o = 0,
                    s = 0;
                if (t /= 100) {
                    const i = n < .5 ? n * (1 + t) : n + t - n * t,
                        a = 2 * n - i;
                    r = eT(a, i, e + 1 / 3), o = eT(a, i, e), s = eT(a, i, e - 1 / 3)
                } else r = o = s = n;
                return {
                    red: Math.round(255 * r),
                    green: Math.round(255 * o),
                    blue: Math.round(255 * s),
                    alpha: i
                }
            }(n)), n
        }
        const rT = (e, t) => {
            const n = iT(e),
                i = iT(t),
                r = { ...n
                };
            return e => (r.red = tT(n.red, i.red, e), r.green = tT(n.green, i.green, e), r.blue = tT(n.blue, i.blue, e), r.alpha = $R(n.alpha, i.alpha, e), HM.transform(r))
        };

        function oT(e, t) {
            return n => n > 0 ? t : e
        }

        function sT(e, t) {
            return n => $R(e, t, n)
        }

        function aT(e) {
            return "number" == typeof e ? sT : "string" == typeof e ? rM(e) ? oT : YM.test(e) ? rT : AT : Array.isArray(e) ? lT : "object" == typeof e ? YM.test(e) ? rT : cT : oT
        }

        function lT(e, t) {
            const n = [...e],
                i = n.length,
                r = e.map(((e, n) => aT(e)(e, t[n])));
            return e => {
                for (let t = 0; t < i; t++) n[t] = r[t](e);
                return n
            }
        }

        function cT(e, t) {
            const n = { ...e,
                    ...t
                },
                i = {};
            for (const r in n) void 0 !== e[r] && void 0 !== t[r] && (i[r] = aT(e[r])(e[r], t[r]));
            return e => {
                for (const t in i) n[t] = i[t](e);
                return n
            }
        }
        const AT = (e, t) => {
            const n = iR.createTransformer(t),
                i = $M(e),
                r = $M(t);
            return i.indexes.var.length === r.indexes.var.length && i.indexes.color.length === r.indexes.color.length && i.indexes.number.length >= r.indexes.number.length ? ZR(lT(function(e, t) {
                var n;
                const i = [],
                    r = {
                        color: 0,
                        var: 0,
                        number: 0
                    };
                for (let o = 0; o < t.values.length; o++) {
                    const s = t.types[o],
                        a = e.indexes[s][r[s]],
                        l = null !== (n = e.values[a]) && void 0 !== n ? n : 0;
                    i[o] = l, r[s]++
                }
                return i
            }(i, r), r.values), n) : (IU(!0, `Complex values '${e}' and '${t}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`), oT(e, t))
        };

        function hT(e, t, n) {
            if ("number" == typeof e && "number" == typeof t && "number" == typeof n) return $R(e, t, n);
            return aT(e)(e, t)
        }

        function uT(e, t, {
            clamp: n = !0,
            ease: i,
            mixer: r
        } = {}) {
            const o = e.length;
            if (SU(o === t.length, "Both input and output ranges must be the same length"), 1 === o) return () => t[0];
            if (2 === o && e[0] === e[1]) return () => t[1];
            e[0] > e[o - 1] && (e = [...e].reverse(), t = [...t].reverse());
            const s = function(e, t, n) {
                    const i = [],
                        r = n || hT,
                        o = e.length - 1;
                    for (let n = 0; n < o; n++) {
                        let o = r(e[n], e[n + 1]);
                        if (t) {
                            const e = Array.isArray(t) ? t[n] || CU : t;
                            o = ZR(e, o)
                        }
                        i.push(o)
                    }
                    return i
                }(t, i, r),
                a = s.length,
                l = t => {
                    let n = 0;
                    if (a > 1)
                        for (; n < e.length - 2 && !(t < e[n + 1]); n++);
                    const i = _R(e[n], e[n + 1], t);
                    return s[n](i)
                };
            return n ? t => l(lM(e[0], e[o - 1], t)) : l
        }

        function dT(e, t) {
            const n = e[e.length - 1];
            for (let i = 1; i <= t; i++) {
                const r = _R(0, t, i);
                e.push($R(n, 1, r))
            }
        }

        function pT(e) {
            const t = [0];
            return dT(t, e.length - 1), t
        }

        function gT({
            duration: e = 300,
            keyframes: t,
            times: n,
            ease: i = "easeInOut"
        }) {
            const r = GR(i) ? i.map(zR) : zR(i),
                o = {
                    done: !1,
                    value: t[0]
                },
                s = function(e, t) {
                    return e.map((e => e * t))
                }(n && n.length === t.length ? n : pT(t), e),
                a = uT(s, t, {
                    ease: Array.isArray(r) ? r : (l = t, c = r, l.map((() => c || PR)).splice(0, l.length - 1))
                });
            var l, c;
            return {
                calculatedDuration: e,
                next: t => (o.value = a(t), o.done = t >= e, o)
            }
        }
        const fT = 2e4;

        function mT(e) {
            let t = 0;
            let n = e.next(t);
            for (; !n.done && t < fT;) t += 50, n = e.next(t);
            return t >= fT ? 1 / 0 : t
        }
        const ET = e => {
                const t = ({
                    timestamp: t
                }) => e(t);
                return {
                    start: () => QU.update(t, !0),
                    stop: () => UU(t),
                    now: () => MU.isProcessing ? MU.timestamp : _U.now()
                }
            },
            CT = {
                decay: RR,
                inertia: RR,
                tween: gT,
                keyframes: gT,
                spring: MR
            },
            IT = e => e / 100;
        class ST extends gR {
            constructor({
                KeyframeResolver: e = GM,
                ...t
            }) {
                super(t), this.holdTime = null, this.startTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.state = "idle";
                const {
                    name: n,
                    motionValue: i,
                    keyframes: r
                } = this.options, o = e => this.onKeyframesResolved(e);
                n && i && i.owner ? this.resolver = i.owner.resolveKeyframes(r, o, n, i) : this.resolver = new e(r, o, n, i), this.resolver.scheduleResolve()
            }
            initPlayback(e) {
                const {
                    type: t = "keyframes",
                    repeat: n = 0,
                    repeatDelay: i = 0,
                    repeatType: r,
                    velocity: o = 0
                } = this.options, s = CT[t] || gT;
                let a, l;
                s !== gT && "number" != typeof e[0] && (a = ZR(IT, hT(e[0], e[1])), e = [0, 100]);
                const c = s({ ...this.options,
                    keyframes: e
                });
                "mirror" === r && (l = s({ ...this.options,
                    keyframes: [...e].reverse(),
                    velocity: -o
                })), null === c.calculatedDuration && (c.calculatedDuration = mT(c));
                const {
                    calculatedDuration: A
                } = c, h = A + i;
                return {
                    generator: c,
                    mirroredGenerator: l,
                    mapPercentToKeyframes: a,
                    calculatedDuration: A,
                    resolvedDuration: h,
                    totalDuration: h * (n + 1) - i
                }
            }
            onPostResolved() {
                const {
                    autoplay: e = !0
                } = this.options;
                this.play(), "paused" !== this.pendingPlayState && e ? this.state = this.pendingPlayState : this.pause()
            }
            tick(e, t = !1) {
                const {
                    generator: n,
                    mirroredGenerator: i,
                    mapPercentToKeyframes: r,
                    keyframes: o,
                    calculatedDuration: s,
                    totalDuration: a,
                    resolvedDuration: l
                } = this.resolved;
                if (null === this.startTime) return n.next(0);
                const {
                    delay: c,
                    repeat: A,
                    repeatType: h,
                    repeatDelay: u,
                    onUpdate: d
                } = this.options;
                this.speed > 0 ? this.startTime = Math.min(this.startTime, e) : this.speed < 0 && (this.startTime = Math.min(e - a / this.speed, this.startTime)), t ? this.currentTime = e : null !== this.holdTime ? this.currentTime = this.holdTime : this.currentTime = Math.round(e - this.startTime) * this.speed;
                const p = this.currentTime - c * (this.speed >= 0 ? 1 : -1),
                    g = this.speed >= 0 ? p < 0 : p > a;
                this.currentTime = Math.max(p, 0), "finished" === this.state && null === this.holdTime && (this.currentTime = a);
                let f = this.currentTime,
                    m = n;
                if (A) {
                    const e = Math.min(this.currentTime, a) / l;
                    let t = Math.floor(e),
                        n = e % 1;
                    !n && e >= 1 && (n = 1), 1 === n && t--, t = Math.min(t, A + 1);
                    Boolean(t % 2) && ("reverse" === h ? (n = 1 - n, u && (n -= u / l)) : "mirror" === h && (m = i)), f = lM(0, 1, n) * l
                }
                const E = g ? {
                    done: !1,
                    value: o[0]
                } : m.next(f);
                r && (E.value = r(E.value));
                let {
                    done: C
                } = E;
                g || null === s || (C = this.speed >= 0 ? this.currentTime >= a : this.currentTime <= 0);
                const I = null === this.holdTime && ("finished" === this.state || "running" === this.state && C);
                return d && d(E.value), I && this.finish(), E
            }
            get duration() {
                return OU(this.resolved.calculatedDuration)
            }
            get time() {
                return OU(this.currentTime)
            }
            set time(e) {
                e = VU(e), this.currentTime = e, null !== this.holdTime || 0 === this.speed ? this.holdTime = e : this.driver && (this.startTime = this.driver.now() - e / this.speed)
            }
            get speed() {
                return this.playbackSpeed
            }
            set speed(e) {
                const t = this.playbackSpeed !== e;
                this.playbackSpeed = e, t && (this.time = OU(this.currentTime))
            }
            play() {
                if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) return void(this.pendingPlayState = "running");
                if (this.isStopped) return;
                const {
                    driver: e = ET,
                    onPlay: t
                } = this.options;
                this.driver || (this.driver = e((e => this.tick(e)))), t && t();
                const n = this.driver.now();
                null !== this.holdTime ? this.startTime = n - this.holdTime : this.startTime && "finished" !== this.state || (this.startTime = n), "finished" === this.state && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start()
            }
            pause() {
                var e;
                this._resolved ? (this.state = "paused", this.holdTime = null !== (e = this.currentTime) && void 0 !== e ? e : 0) : this.pendingPlayState = "paused"
            }
            stop() {
                if (this.isStopped = !0, "idle" === this.state) return;
                this.state = "idle";
                const {
                    onStop: e
                } = this.options;
                e && e(), this.teardown()
            }
            complete() {
                "running" !== this.state && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null
            }
            finish() {
                this.teardown(), this.state = "finished";
                const {
                    onComplete: e
                } = this.options;
                e && e()
            }
            cancel() {
                null !== this.cancelTime && this.tick(this.cancelTime), this.teardown()
            }
            teardown() {
                this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel()
            }
            stopDriver() {
                this.driver && (this.driver.stop(), this.driver = void 0)
            }
            sample(e) {
                return this.startTime = 0, this.tick(e, !0)
            }
        }
        const vT = e => Array.isArray(e) && "number" == typeof e[0];

        function BT(e) {
            return Boolean(!e || "string" == typeof e && yT[e] || vT(e) || Array.isArray(e) && e.every(BT))
        }
        const xT = ([e, t, n, i]) => `cubic-bezier(${e}, ${t}, ${n}, ${i})`,
            yT = {
                linear: "linear",
                ease: "ease",
                easeIn: "ease-in",
                easeOut: "ease-out",
                easeInOut: "ease-in-out",
                circIn: xT([0, .65, .55, 1]),
                circOut: xT([.55, 0, 1, .45]),
                backIn: xT([.31, .01, .66, -.59]),
                backOut: xT([.33, 1.53, .69, .99])
            };

        function wT(e) {
            if (e) return vT(e) ? xT(e) : Array.isArray(e) ? e.map(wT) : yT[e]
        }
        const bT = FU((() => Object.hasOwnProperty.call(Element.prototype, "animate"))),
            QT = new Set(["opacity", "clipPath", "filter", "transform"]);
        class UT extends gR {
            constructor(e) {
                super(e);
                const {
                    name: t,
                    motionValue: n,
                    keyframes: i
                } = this.options;
                this.resolver = new dR(i, (e => this.onKeyframesResolved(e)), t, n), this.resolver.scheduleResolve()
            }
            initPlayback(e) {
                let t = this.options.duration || 300;
                if ("spring" === (n = this.options).type || "backgroundColor" === n.name || !BT(n.ease)) {
                    const {
                        onComplete: n,
                        onUpdate: i,
                        motionValue: r,
                        ...o
                    } = this.options, s = function(e, t) {
                        const n = new ST({ ...t,
                            keyframes: e,
                            repeat: 0,
                            delay: 0
                        });
                        let i = {
                            done: !1,
                            value: e[0]
                        };
                        const r = [];
                        let o = 0;
                        for (; !i.done && o < 2e4;) i = n.sample(o), r.push(i.value), o += 10;
                        return {
                            times: void 0,
                            keyframes: r,
                            duration: o - 10,
                            ease: "linear"
                        }
                    }(e, o);
                    e = s.keyframes, t = s.duration, this.options.times = s.times, this.options.ease = s.ease
                }
                var n;
                const {
                    motionValue: i,
                    name: r
                } = this.options, o = function(e, t, n, {
                    delay: i = 0,
                    duration: r = 300,
                    repeat: o = 0,
                    repeatType: s = "loop",
                    ease: a,
                    times: l
                } = {}) {
                    const c = {
                        [t]: n
                    };
                    l && (c.offset = l);
                    const A = wT(a);
                    return Array.isArray(A) && (c.easing = A), e.animate(c, {
                        delay: i,
                        duration: r,
                        easing: Array.isArray(A) ? "linear" : A,
                        fill: "both",
                        iterations: o + 1,
                        direction: "reverse" === s ? "alternate" : "normal"
                    })
                }(i.owner.current, r, e, { ...this.options,
                    duration: t
                });
                return o.startTime = _U.now(), this.pendingTimeline ? (o.timeline = this.pendingTimeline, this.pendingTimeline = void 0) : o.onfinish = () => {
                    const {
                        onComplete: t
                    } = this.options;
                    i.set(zU(e, this.options)), t && t(), this.cancel(), this.resolveFinishedPromise(), this.updateFinishedPromise()
                }, {
                    animation: o,
                    duration: t,
                    keyframes: e
                }
            }
            get duration() {
                const {
                    duration: e
                } = this.resolved;
                return OU(e)
            }
            get time() {
                const {
                    animation: e
                } = this.resolved;
                return OU(e.currentTime || 0)
            }
            set time(e) {
                const {
                    animation: t
                } = this.resolved;
                t.currentTime = VU(e)
            }
            get speed() {
                const {
                    animation: e
                } = this.resolved;
                return e.playbackRate
            }
            set speed(e) {
                const {
                    animation: t
                } = this.resolved;
                t.playbackRate = e
            }
            get state() {
                const {
                    animation: e
                } = this.resolved;
                return e.playState
            }
            attachTimeline(e) {
                if (this._resolved) {
                    const {
                        animation: t
                    } = this.resolved;
                    t.timeline = e, t.onfinish = null
                } else this.pendingTimeline = e;
                return CU
            }
            play() {
                if (this.isStopped) return;
                const {
                    animation: e
                } = this.resolved;
                e.play()
            }
            pause() {
                const {
                    animation: e
                } = this.resolved;
                e.pause()
            }
            stop() {
                this.isStopped = !0;
                const {
                    animation: e,
                    keyframes: t
                } = this.resolved;
                if ("idle" !== e.playState && "finished" !== e.playState) {
                    if (this.time) {
                        const {
                            motionValue: e,
                            onUpdate: n,
                            onComplete: i,
                            ...r
                        } = this.options, o = new ST({ ...r,
                            keyframes: t
                        });
                        e.setWithVelocity(o.sample(this.time - 10).value, o.sample(this.time).value, 10)
                    }
                    this.cancel()
                }
            }
            complete() {
                this.resolved.animation.finish()
            }
            cancel() {
                this.resolved.animation.cancel()
            }
            static supports(e) {
                const {
                    motionValue: t,
                    name: n,
                    repeatDelay: i,
                    repeatType: r,
                    damping: o,
                    type: s
                } = e;
                return bT() && n && QT.has(n) && t && t.owner && t.owner.current instanceof HTMLElement && !t.owner.getProps().onUpdate && !i && "mirror" !== r && 0 !== o && "inertia" !== s
            }
        }
        const MT = (e, t, n, i = {}, r, o) => s => {
                const a = YU(i, e) || {},
                    l = a.delay || i.delay || 0;
                let {
                    elapsed: c = 0
                } = i;
                c -= VU(l);
                let A = {
                    keyframes: Array.isArray(n) ? n : [null, n],
                    ease: "easeOut",
                    velocity: t.getVelocity(),
                    ...a,
                    delay: -c,
                    onUpdate: e => {
                        t.set(e), a.onUpdate && a.onUpdate(e)
                    },
                    onComplete: () => {
                        s(), a.onComplete && a.onComplete()
                    },
                    name: e,
                    motionValue: t,
                    element: o ? void 0 : r
                };
                (function({
                    when: e,
                    delay: t,
                    delayChildren: n,
                    staggerChildren: i,
                    staggerDirection: r,
                    repeat: o,
                    repeatType: s,
                    repeatDelay: a,
                    from: l,
                    elapsed: c,
                    ...A
                }) {
                    return !!Object.keys(A).length
                })(a) || (A = { ...A,
                    ...jU(e, A)
                }), A.duration && (A.duration = VU(A.duration)), A.repeatDelay && (A.repeatDelay = VU(A.repeatDelay)), void 0 !== A.from && (A.keyframes[0] = A.from);
                let h = !1;
                if (!1 === A.type && (A.duration = 0, 0 === A.delay && (h = !0)), (JU || xU) && (h = !0, A.duration = 0, A.delay = 0), h && !o && void 0 !== t.get()) {
                    const e = zU(A.keyframes, a);
                    if (void 0 !== e) return void QU.update((() => {
                        A.onUpdate(e), A.onComplete()
                    }))
                }
                return !o && UT.supports(A) ? new UT(A) : new ST(A)
            },
            RT = e => Boolean(e && e.getVelocity);

        function TT(e) {
            return Boolean(RT(e) && e.add)
        }
        const FT = e => (e => Array.isArray(e))(e) ? e[e.length - 1] || 0 : e;

        function DT(e, t) {
            const n = e.indexOf(t);
            n > -1 && e.splice(n, 1)
        }
        class kT {
            constructor() {
                this.subscriptions = []
            }
            add(e) {
                var t, n;
                return t = this.subscriptions, n = e, -1 === t.indexOf(n) && t.push(n), () => DT(this.subscriptions, e)
            }
            notify(e, t, n) {
                const i = this.subscriptions.length;
                if (i)
                    if (1 === i) this.subscriptions[0](e, t, n);
                    else
                        for (let r = 0; r < i; r++) {
                            const i = this.subscriptions[r];
                            i && i(e, t, n)
                        }
            }
            getSize() {
                return this.subscriptions.length
            }
            clear() {
                this.subscriptions.length = 0
            }
        }
        const LT = {
            current: void 0
        };
        class KT {
            constructor(e, t = {}) {
                var n;
                this.version = "11.0.12", this.canTrackVelocity = !1, this.events = {}, this.updateAndNotify = (e, t = !0) => {
                    const n = _U.now();
                    this.updatedAt !== n && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(e), this.current !== this.prev && this.events.change && this.events.change.notify(this.current), t && this.events.renderRequest && this.events.renderRequest.notify(this.current)
                }, this.hasAnimated = !1, this.setCurrent(e), this.canTrackVelocity = (n = this.current, !isNaN(parseFloat(n))), this.owner = t.owner
            }
            setCurrent(e) {
                this.current = e, this.updatedAt = _U.now()
            }
            setPrevFrameValue(e = this.current) {
                this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt
            }
            onChange(e) {
                return this.on("change", e)
            }
            on(e, t) {
                this.events[e] || (this.events[e] = new kT);
                const n = this.events[e].add(t);
                return "change" === e ? () => {
                    n(), QU.read((() => {
                        this.events.change.getSize() || this.stop()
                    }))
                } : n
            }
            clearListeners() {
                for (const e in this.events) this.events[e].clear()
            }
            attach(e, t) {
                this.passiveEffect = e, this.stopPassiveEffect = t
            }
            set(e, t = !0) {
                t && this.passiveEffect ? this.passiveEffect(e, this.updateAndNotify) : this.updateAndNotify(e, t)
            }
            setWithVelocity(e, t, n) {
                this.set(t), this.prev = void 0, this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt - n
            }
            jump(e, t = !0) {
                this.updateAndNotify(e), this.prev = e, this.prevUpdatedAt = this.prevFrameValue = void 0, t && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect()
            }
            get() {
                return LT.current && LT.current.push(this), this.current
            }
            getPrevious() {
                return this.prev
            }
            getVelocity() {
                const e = _U.now();
                if (!this.canTrackVelocity || void 0 === this.prevFrameValue || e - this.updatedAt > 30) return 0;
                const t = Math.min(this.updatedAt - this.prevUpdatedAt, 30);
                return fR(parseFloat(this.current) - parseFloat(this.prevFrameValue), t)
            }
            start(e) {
                return this.stop(), new Promise((t => {
                    this.hasAnimated = !0, this.animation = e(t), this.events.animationStart && this.events.animationStart.notify()
                })).then((() => {
                    this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation()
                }))
            }
            stop() {
                this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation()
            }
            isAnimating() {
                return !!this.animation
            }
            clearAnimation() {
                delete this.animation
            }
            destroy() {
                this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect()
            }
        }

        function PT(e, t) {
            return new KT(e, t)
        }

        function GT(e, t, n, i = {}, r = {}) {
            return "function" == typeof t && (t = t(void 0 !== n ? n : e.custom, i, r)), "string" == typeof t && (t = e.variants && e.variants[t]), "function" == typeof t && (t = t(void 0 !== n ? n : e.custom, i, r)), t
        }

        function VT(e, t, n) {
            e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, PT(n))
        }

        function OT(e, t) {
            const n = function(e, t, n) {
                const i = e.getProps();
                return GT(i, t, void 0 !== n ? n : i.custom, function(e) {
                    const t = {};
                    return e.values.forEach(((e, n) => t[n] = e.get())), t
                }(e), function(e) {
                    const t = {};
                    return e.values.forEach(((e, n) => t[n] = e.getVelocity())), t
                }(e))
            }(e, t);
            let {
                transitionEnd: i = {},
                transition: r = {},
                ...o
            } = n || {};
            o = { ...o,
                ...i
            };
            for (const t in o) {
                VT(e, t, FT(o[t]))
            }
        }

        function NT({
            protectedKeys: e,
            needsAnimating: t
        }, n) {
            const i = e.hasOwnProperty(n) && !0 !== t[n];
            return t[n] = !1, i
        }

        function HT(e, t, {
            delay: n = 0,
            transitionOverride: i,
            type: r
        } = {}) {
            var o;
            let {
                transition: s = e.getDefaultTransition(),
                transitionEnd: a,
                ...l
            } = t;
            const c = e.getValue("willChange");
            i && (s = i);
            const A = [],
                h = r && e.animationState && e.animationState.getState()[r];
            for (const t in l) {
                const i = e.getValue(t, null !== (o = e.latestValues[t]) && void 0 !== o ? o : null),
                    r = l[t];
                if (void 0 === r || h && NT(h, t)) continue;
                const a = {
                    delay: n,
                    elapsed: 0,
                    ...YU(s || {}, t)
                };
                let u = !1;
                if (window.HandoffAppearAnimations) {
                    const n = e.getProps()[GU];
                    if (n) {
                        const e = window.HandoffAppearAnimations(n, t);
                        null !== e && (a.elapsed = e, u = !0)
                    }
                }
                i.start(MT(t, i, r, e.shouldReduceMotion && KU.has(t) ? {
                    type: !1
                } : a, e, u));
                const d = i.animation;
                d && (TT(c) && (c.add(t), d.then((() => c.remove(t)))), A.push(d))
            }
            return a && Promise.all(A).then((() => {
                QU.update((() => {
                    a && OT(e, a)
                }))
            })), A
        }
        const qT = {};

        function jT(e, {
            layout: t,
            layoutId: n
        }) {
            return KU.has(e) || e.startsWith("origin") || (t || void 0 !== n) && (!!qT[e] || "opacity" === e)
        }

        function YT(e, t) {
            const {
                style: n
            } = e, i = {};
            for (const r in n)(RT(n[r]) || t.style && RT(t.style[r]) || jT(r, e)) && (i[r] = n[r]);
            return i
        }

        function JT(e) {
            return e && "object" == typeof e && Object.prototype.hasOwnProperty.call(e, "current")
        }
        const WT = "undefined" != typeof document,
            zT = {
                current: null
            },
            XT = {
                current: !1
            };

        function ZT(e) {
            return "string" == typeof e || Array.isArray(e)
        }
        const _T = ["initial", "animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"];

        function $T(e) {
            return function(e) {
                return null !== e && "object" == typeof e && "function" == typeof e.start
            }(e.animate) || _T.some((t => ZT(e[t])))
        }
        const eF = {
                animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"],
                exit: ["exit"],
                drag: ["drag", "dragControls"],
                focus: ["whileFocus"],
                hover: ["whileHover", "onHoverStart", "onHoverEnd"],
                tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
                pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
                inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
                layout: ["layout", "layoutId"]
            },
            tF = {};
        for (const e in eF) tF[e] = {
            isEnabled: t => eF[e].some((e => !!t[e]))
        };
        const nF = [...TM, YM, iR],
            iF = Object.keys(tF),
            rF = iF.length,
            oF = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"],
            sF = _T.length;
        class aF {
            constructor({
                parent: e,
                props: t,
                presenceContext: n,
                reducedMotionConfig: i,
                blockInitialAnimation: r,
                visualState: o
            }, s = {}) {
                this.resolveKeyframes = (e, t, n, i) => new this.KeyframeResolver(e, t, n, i, this), this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.KeyframeResolver = GM, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
                    this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection))
                }, this.scheduleRender = () => QU.render(this.render, !1, !0);
                const {
                    latestValues: a,
                    renderState: l
                } = o;
                this.latestValues = a, this.baseTarget = { ...a
                }, this.initialValues = t.initial ? { ...a
                } : {}, this.renderState = l, this.parent = e, this.props = t, this.presenceContext = n, this.depth = e ? e.depth + 1 : 0, this.reducedMotionConfig = i, this.options = s, this.blockInitialAnimation = Boolean(r), this.isControllingVariants = $T(t), this.isVariantNode = function(e) {
                    return Boolean($T(e) || e.variants)
                }(t), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = Boolean(e && e.current);
                const {
                    willChange: c,
                    ...A
                } = this.scrapeMotionValuesFromProps(t, {});
                for (const e in A) {
                    const t = A[e];
                    void 0 !== a[e] && RT(t) && (t.set(a[e], !1), TT(c) && c.add(e))
                }
            }
            scrapeMotionValuesFromProps(e, t) {
                return {}
            }
            mount(e) {
                this.current = e, BU.set(e, this), this.projection && !this.projection.instance && this.projection.mount(e), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach(((e, t) => this.bindToMotionValue(t, e))), XT.current || function() {
                    if (XT.current = !0, WT)
                        if (window.matchMedia) {
                            const e = window.matchMedia("(prefers-reduced-motion)"),
                                t = () => zT.current = e.matches;
                            e.addListener(t), t()
                        } else zT.current = !1
                }(), this.shouldReduceMotion = "never" !== this.reducedMotionConfig && ("always" === this.reducedMotionConfig || zT.current), this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext)
            }
            unmount() {
                BU.delete(this.current), this.projection && this.projection.unmount(), UU(this.notifyUpdate), UU(this.render), this.valueSubscriptions.forEach((e => e())), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);
                for (const e in this.events) this.events[e].clear();
                for (const e in this.features) this.features[e].unmount();
                this.current = null
            }
            bindToMotionValue(e, t) {
                const n = KU.has(e),
                    i = t.on("change", (t => {
                        this.latestValues[e] = t, this.props.onUpdate && QU.preRender(this.notifyUpdate), n && this.projection && (this.projection.isTransformDirty = !0)
                    })),
                    r = t.on("renderRequest", this.scheduleRender);
                this.valueSubscriptions.set(e, (() => {
                    i(), r()
                }))
            }
            sortNodePosition(e) {
                return this.current && this.sortInstanceNodePosition && this.type === e.type ? this.sortInstanceNodePosition(this.current, e.current) : 0
            }
            loadFeatures({
                children: e,
                ...t
            }, n, i, r) {
                let o, s;
                for (let e = 0; e < rF; e++) {
                    const n = iF[e],
                        {
                            isEnabled: i,
                            Feature: r,
                            ProjectionNode: a,
                            MeasureLayout: l
                        } = tF[n];
                    a && (o = a), i(t) && (!this.features[n] && r && (this.features[n] = new r(this)), l && (s = l))
                }
                if (("html" === this.type || "svg" === this.type) && !this.projection && o) {
                    this.projection = new o(this.latestValues, this.parent && this.parent.projection);
                    const {
                        layoutId: e,
                        layout: n,
                        drag: i,
                        dragConstraints: s,
                        layoutScroll: a,
                        layoutRoot: l
                    } = t;
                    this.projection.setOptions({
                        layoutId: e,
                        layout: n,
                        alwaysMeasureLayout: Boolean(i) || s && JT(s),
                        visualElement: this,
                        scheduleRender: () => this.scheduleRender(),
                        animationType: "string" == typeof n ? n : "both",
                        initialPromotionConfig: r,
                        layoutScroll: a,
                        layoutRoot: l
                    })
                }
                return s
            }
            updateFeatures() {
                for (const e in this.features) {
                    const t = this.features[e];
                    t.isMounted ? t.update() : (t.mount(), t.isMounted = !0)
                }
            }
            triggerBuild() {
                this.build(this.renderState, this.latestValues, this.options, this.props)
            }
            measureViewportBox() {
                return this.current ? this.measureInstanceViewportBox(this.current, this.props) : {
                    x: {
                        min: 0,
                        max: 0
                    },
                    y: {
                        min: 0,
                        max: 0
                    }
                }
            }
            getStaticValue(e) {
                return this.latestValues[e]
            }
            setStaticValue(e, t) {
                this.latestValues[e] = t
            }
            update(e, t) {
                (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = e, this.prevPresenceContext = this.presenceContext, this.presenceContext = t;
                for (let t = 0; t < oF.length; t++) {
                    const n = oF[t];
                    this.propEventSubscriptions[n] && (this.propEventSubscriptions[n](), delete this.propEventSubscriptions[n]);
                    const i = e["on" + n];
                    i && (this.propEventSubscriptions[n] = this.on(n, i))
                }
                this.prevMotionValues = function(e, t, n) {
                    const {
                        willChange: i
                    } = t;
                    for (const r in t) {
                        const o = t[r],
                            s = n[r];
                        if (RT(o)) e.addValue(r, o), TT(i) && i.add(r);
                        else if (RT(s)) e.addValue(r, PT(o, {
                            owner: e
                        })), TT(i) && i.remove(r);
                        else if (s !== o)
                            if (e.hasValue(r)) {
                                const t = e.getValue(r);
                                !t.hasAnimated && t.set(o)
                            } else {
                                const t = e.getStaticValue(r);
                                e.addValue(r, PT(void 0 !== t ? t : o, {
                                    owner: e
                                }))
                            }
                    }
                    for (const i in n) void 0 === t[i] && e.removeValue(i);
                    return t
                }(this, this.scrapeMotionValuesFromProps(e, this.prevProps), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue()
            }
            getProps() {
                return this.props
            }
            getVariant(e) {
                return this.props.variants ? this.props.variants[e] : void 0
            }
            getDefaultTransition() {
                return this.props.transition
            }
            getTransformPagePoint() {
                return this.props.transformPagePoint
            }
            getClosestVariantNode() {
                return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0
            }
            getVariantContext(e = !1) {
                if (e) return this.parent ? this.parent.getVariantContext() : void 0;
                if (!this.isControllingVariants) {
                    const e = this.parent && this.parent.getVariantContext() || {};
                    return void 0 !== this.props.initial && (e.initial = this.props.initial), e
                }
                const t = {};
                for (let e = 0; e < sF; e++) {
                    const n = _T[e],
                        i = this.props[n];
                    (ZT(i) || !1 === i) && (t[n] = i)
                }
                return t
            }
            addVariantChild(e) {
                const t = this.getClosestVariantNode();
                if (t) return t.variantChildren && t.variantChildren.add(e), () => t.variantChildren.delete(e)
            }
            addValue(e, t) {
                t !== this.values.get(e) && (this.removeValue(e), this.bindToMotionValue(e, t)), this.values.set(e, t), this.latestValues[e] = t.get()
            }
            removeValue(e) {
                this.values.delete(e);
                const t = this.valueSubscriptions.get(e);
                t && (t(), this.valueSubscriptions.delete(e)), delete this.latestValues[e], this.removeValueFromRenderState(e, this.renderState)
            }
            hasValue(e) {
                return this.values.has(e)
            }
            getValue(e, t) {
                if (this.props.values && this.props.values[e]) return this.props.values[e];
                let n = this.values.get(e);
                return void 0 === n && void 0 !== t && (n = PT(null === t ? void 0 : t, {
                    owner: this
                }), this.addValue(e, n)), n
            }
            readValue(e, t) {
                var n;
                let i = void 0 === this.latestValues[e] && this.current ? null !== (n = this.getBaseTargetFromProps(this.props, e)) && void 0 !== n ? n : this.readValueFromInstance(this.current, e, this.options) : this.latestValues[e];
                return null != i && ("string" == typeof i && (eM(i) || $U(i)) ? i = parseFloat(i) : !(e => nF.find(RM(e)))(i) && iR.test(t) && (i = uR(e, t)), this.setBaseTarget(e, RT(i) ? i.get() : i)), RT(i) ? i.get() : i
            }
            setBaseTarget(e, t) {
                this.baseTarget[e] = t
            }
            getBaseTarget(e) {
                var t, n;
                const {
                    initial: i
                } = this.props, r = "string" == typeof i || "object" == typeof i ? null === (n = GT(this.props, i, null === (t = this.presenceContext) || void 0 === t ? void 0 : t.custom)) || void 0 === n ? void 0 : n[e] : void 0;
                if (i && void 0 !== r) return r;
                const o = this.getBaseTargetFromProps(this.props, e);
                return void 0 === o || RT(o) ? void 0 !== this.initialValues[e] && void 0 === r ? void 0 : this.baseTarget[e] : o
            }
            on(e, t) {
                return this.events[e] || (this.events[e] = new kT), this.events[e].add(t)
            }
            notify(e, ...t) {
                this.events[e] && this.events[e].notify(...t)
            }
        }
        class lF extends aF {
            constructor() {
                super(...arguments), this.KeyframeResolver = dR
            }
            sortInstanceNodePosition(e, t) {
                return 2 & e.compareDocumentPosition(t) ? 1 : -1
            }
            getBaseTargetFromProps(e, t) {
                return e.style ? e.style[t] : void 0
            }
            removeValueFromRenderState(e, {
                vars: t,
                style: n
            }) {
                delete t[e], delete n[e]
            }
        }
        const cF = {
                x: "translateX",
                y: "translateY",
                z: "translateZ",
                transformPerspective: "perspective"
            },
            AF = LU.length;
        const hF = (e, t) => t && "number" == typeof e ? t.transform(e) : e;

        function uF(e, t, n, i) {
            const {
                style: r,
                vars: o,
                transform: s,
                transformOrigin: a
            } = e;
            let l = !1,
                c = !1,
                A = !0;
            for (const e in t) {
                const n = t[e];
                if (nM(e)) {
                    o[e] = n;
                    continue
                }
                const i = cR[e],
                    h = hF(n, i);
                if (KU.has(e)) {
                    if (l = !0, s[e] = h, !A) continue;
                    n !== (i.default || 0) && (A = !1)
                } else e.startsWith("origin") ? (c = !0, a[e] = h) : r[e] = h
            }
            if (t.transform || (l || i ? r.transform = function(e, {
                    enableHardwareAcceleration: t = !0,
                    allowTransformNone: n = !0
                }, i, r) {
                    let o = "";
                    for (let t = 0; t < AF; t++) {
                        const n = LU[t];
                        void 0 !== e[n] && (o += `${cF[n]||n}(${e[n]}) `)
                    }
                    return t && !e.z && (o += "translateZ(0)"), o = o.trim(), r ? o = r(e, i ? "" : o) : n && i && (o = "none"), o
                }(e.transform, n, A, i) : r.transform && (r.transform = "none")), c) {
                const {
                    originX: e = "50%",
                    originY: t = "50%",
                    originZ: n = 0
                } = a;
                r.transformOrigin = `${e} ${t} ${n}`
            }
        }

        function dF(e, t, n) {
            return "string" == typeof e ? e : IM.transform(t + n * e)
        }
        const pF = {
                offset: "stroke-dashoffset",
                array: "stroke-dasharray"
            },
            gF = {
                offset: "strokeDashoffset",
                array: "strokeDasharray"
            };

        function fF(e, {
            attrX: t,
            attrY: n,
            attrScale: i,
            originX: r,
            originY: o,
            pathLength: s,
            pathSpacing: a = 1,
            pathOffset: l = 0,
            ...c
        }, A, h, u) {
            if (uF(e, c, A, u), h) return void(e.style.viewBox && (e.attrs.viewBox = e.style.viewBox));
            e.attrs = e.style, e.style = {};
            const {
                attrs: d,
                style: p,
                dimensions: g
            } = e;
            d.transform && (g && (p.transform = d.transform), delete d.transform), g && (void 0 !== r || void 0 !== o || p.transform) && (p.transformOrigin = function(e, t, n) {
                return `${dF(t,e.x,e.width)} ${dF(n,e.y,e.height)}`
            }(g, void 0 !== r ? r : .5, void 0 !== o ? o : .5)), void 0 !== t && (d.x = t), void 0 !== n && (d.y = n), void 0 !== i && (d.scale = i), void 0 !== s && function(e, t, n = 1, i = 0, r = !0) {
                e.pathLength = 1;
                const o = r ? pF : gF;
                e[o.offset] = IM.transform(-i);
                const s = IM.transform(t),
                    a = IM.transform(n);
                e[o.array] = `${s} ${a}`
            }(d, s, a, l, !1)
        }
        const mF = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]);

        function EF(e, {
            style: t,
            vars: n
        }, i, r) {
            Object.assign(e.style, t, r && r.getProjectionStyles(i));
            for (const t in n) e.style.setProperty(t, n[t])
        }
        class CF extends lF {
            constructor() {
                super(...arguments), this.type = "svg", this.isSVGTag = !1
            }
            getBaseTargetFromProps(e, t) {
                return e[t]
            }
            readValueFromInstance(e, t) {
                if (KU.has(t)) {
                    const e = hR(t);
                    return e && e.default || 0
                }
                return t = mF.has(t) ? t : PU(t), e.getAttribute(t)
            }
            measureInstanceViewportBox() {
                return {
                    x: {
                        min: 0,
                        max: 0
                    },
                    y: {
                        min: 0,
                        max: 0
                    }
                }
            }
            scrapeMotionValuesFromProps(e, t) {
                return function(e, t) {
                    const n = YT(e, t);
                    for (const i in e)(RT(e[i]) || RT(t[i])) && (n[-1 !== LU.indexOf(i) ? "attr" + i.charAt(0).toUpperCase() + i.substring(1) : i] = e[i]);
                    return n
                }(e, t)
            }
            build(e, t, n, i) {
                fF(e, t, n, this.isSVGTag, i.transformTemplate)
            }
            renderInstance(e, t, n, i) {
                ! function(e, t, n, i) {
                    EF(e, t, void 0, i);
                    for (const n in t.attrs) e.setAttribute(mF.has(n) ? n : PU(n), t.attrs[n])
                }(e, t, 0, i)
            }
            mount(e) {
                var t;
                this.isSVGTag = "string" == typeof(t = e.tagName) && "svg" === t.toLowerCase(), super.mount(e)
            }
        }

        function IF(e, t) {
            return function({
                top: e,
                left: t,
                right: n,
                bottom: i
            }) {
                return {
                    x: {
                        min: t,
                        max: n
                    },
                    y: {
                        min: e,
                        max: i
                    }
                }
            }(function(e, t) {
                if (!t) return e;
                const n = t({
                        x: e.left,
                        y: e.top
                    }),
                    i = t({
                        x: e.right,
                        y: e.bottom
                    });
                return {
                    top: n.y,
                    left: n.x,
                    bottom: i.y,
                    right: i.x
                }
            }(e.getBoundingClientRect(), t))
        }
        class SF extends lF {
            constructor() {
                super(...arguments), this.type = "html"
            }
            readValueFromInstance(e, t) {
                if (KU.has(t)) {
                    const e = hR(t);
                    return e && e.default || 0
                } {
                    const i = (n = e, window.getComputedStyle(n)),
                        r = (nM(t) ? i.getPropertyValue(t) : i[t]) || 0;
                    return "string" == typeof r ? r.trim() : r
                }
                var n
            }
            measureInstanceViewportBox(e, {
                transformPagePoint: t
            }) {
                return IF(e, t)
            }
            build(e, t, n, i) {
                uF(e, t, n, i.transformTemplate)
            }
            scrapeMotionValuesFromProps(e, t) {
                return YT(e, t)
            }
            handleChildMotionValue() {
                this.childSubscription && (this.childSubscription(), delete this.childSubscription);
                const {
                    children: e
                } = this.props;
                RT(e) && (this.childSubscription = e.on("change", (e => {
                    this.current && (this.current.textContent = `${e}`)
                })))
            }
            renderInstance(e, t, n, i) {
                EF(e, t, n, i)
            }
        }

        function vF(e) {
            const t = {
                    presenceContext: null,
                    props: {},
                    visualState: {
                        renderState: {
                            transform: {},
                            transformOrigin: {},
                            style: {},
                            vars: {},
                            attrs: {}
                        },
                        latestValues: {}
                    }
                },
                n = function(e) {
                    return e instanceof SVGElement && "svg" !== e.tagName
                }(e) ? new CF(t, {
                    enableHardwareAcceleration: !1
                }) : new SF(t, {
                    enableHardwareAcceleration: !0
                });
            n.mount(e), BU.set(e, n)
        }

        function BF(e, t, n) {
            const i = RT(e) ? e : PT(e);
            return i.start(MT("", i, t, n)), i.animation
        }

        function xF(e, t = 100) {
            const n = MR({
                    keyframes: [0, t],
                    ...e
                }),
                i = Math.min(mT(n), fT);
            return {
                type: "keyframes",
                ease: e => n.next(i * e).value / t,
                duration: OU(i)
            }
        }

        function yF(e, t, n, i) {
            var r;
            return "number" == typeof t ? t : t.startsWith("-") || t.startsWith("+") ? Math.max(0, e + parseFloat(t)) : "<" === t ? n : null !== (r = i.get(t)) && void 0 !== r ? r : e
        }
        const wF = (e, t, n) => {
            const i = t - e;
            return ((n - e) % i + i) % i + e
        };

        function bF(e, t) {
            return GR(e) ? e[wF(0, e.length, t)] : e
        }

        function QF(e, t, n, i, r, o) {
            ! function(e, t, n) {
                for (let i = 0; i < e.length; i++) {
                    const r = e[i];
                    r.at > t && r.at < n && (DT(e, r), i--)
                }
            }(e, r, o);
            for (let s = 0; s < t.length; s++) e.push({
                value: t[s],
                at: $R(r, o, i[s]),
                easing: bF(n, s)
            })
        }

        function UF(e, t) {
            return e.at === t.at ? null === e.value ? 1 : null === t.value ? -1 : 0 : e.at - t.at
        }
        const MF = "easeInOut";

        function RF(e, t) {
            return !t.has(e) && t.set(e, {}), t.get(e)
        }

        function TF(e, t) {
            return t[e] || (t[e] = []), t[e]
        }

        function FF(e) {
            return Array.isArray(e) ? e : [e]
        }

        function DF(e, t) {
            return e[t] ? { ...e,
                ...e[t]
            } : { ...e
            }
        }
        const kF = e => "number" == typeof e,
            LF = e => e.every(kF);

        function KF(e, t, n, i) {
            const r = vU(e, i),
                o = r.length;
            SU(Boolean(o), "No valid element provided.");
            const s = [];
            for (let e = 0; e < o; e++) {
                const i = r[e];
                BU.has(i) || vF(i);
                const a = BU.get(i),
                    l = { ...n
                    };
                "function" == typeof l.delay && (l.delay = l.delay(e, o)), s.push(...HT(a, { ...t,
                    transition: l
                }, {}))
            }
            return new kU(s)
        }

        function PF(e, t, n) {
            const i = [],
                r = function(e, {
                    defaultTransition: t = {},
                    ...n
                } = {}, i) {
                    const r = t.duration || .3,
                        o = new Map,
                        s = new Map,
                        a = {},
                        l = new Map;
                    let c = 0,
                        A = 0,
                        h = 0;
                    for (let n = 0; n < e.length; n++) {
                        const o = e[n];
                        if ("string" == typeof o) {
                            l.set(o, A);
                            continue
                        }
                        if (!Array.isArray(o)) {
                            l.set(o.name, yF(A, o.at, c, l));
                            continue
                        }
                        let [u, d, p = {}] = o;
                        void 0 !== p.at && (A = yF(A, p.at, c, l));
                        let g = 0;
                        const f = (e, n, i, o = 0, s = 0) => {
                            const a = FF(e),
                                {
                                    delay: l = 0,
                                    times: c = pT(a),
                                    type: u = "keyframes",
                                    ...d
                                } = n;
                            let {
                                ease: p = t.ease || "easeOut",
                                duration: f
                            } = n;
                            const m = "function" == typeof l ? l(o, s) : l,
                                E = a.length;
                            if (E <= 2 && "spring" === u) {
                                let e = 100;
                                if (2 === E && LF(a)) {
                                    const t = a[1] - a[0];
                                    e = Math.abs(t)
                                }
                                const t = { ...d
                                };
                                void 0 !== f && (t.duration = VU(f));
                                const n = xF(t, e);
                                p = n.ease, f = n.duration
                            }
                            null != f || (f = r);
                            const C = A + m,
                                I = C + f;
                            1 === c.length && 0 === c[0] && (c[1] = 1);
                            const S = c.length - a.length;
                            S > 0 && dT(c, S), 1 === a.length && a.unshift(null), QF(i, a, p, c, C, I), g = Math.max(m + f, g), h = Math.max(I, h)
                        };
                        if (RT(u)) f(d, p, TF("default", RF(u, s)));
                        else {
                            const e = vU(u, i, a),
                                t = e.length;
                            for (let n = 0; n < t; n++) {
                                const i = RF(e[n], s);
                                for (const e in d) f(d[e], DF(p, e), TF(e, i), n, t)
                            }
                        }
                        c = A, A += g
                    }
                    return s.forEach(((e, i) => {
                        for (const r in e) {
                            const s = e[r];
                            s.sort(UF);
                            const a = [],
                                l = [],
                                c = [];
                            for (let e = 0; e < s.length; e++) {
                                const {
                                    at: t,
                                    value: n,
                                    easing: i
                                } = s[e];
                                a.push(n), l.push(_R(0, h, t)), c.push(i || "easeOut")
                            }
                            0 !== l[0] && (l.unshift(0), a.unshift(a[0]), c.unshift(MF)), 1 !== l[l.length - 1] && (l.push(1), a.push(null)), o.has(i) || o.set(i, {
                                keyframes: {},
                                transition: {}
                            });
                            const A = o.get(i);
                            A.keyframes[r] = a, A.transition[r] = { ...t,
                                duration: h,
                                ease: c,
                                times: l,
                                ...n
                            }
                        }
                    })), o
                }(e, t, n);
            return r.forEach((({
                keyframes: e,
                transition: t
            }, n) => {
                let r;
                r = RT(n) ? BF(n, e.default, t.default) : KF(n, e, t), i.push(r)
            })), new kU(i)
        }
        const GF = (e => function(t, n, i) {
                let r;
                var o;
                return o = t, r = Array.isArray(o) && Array.isArray(o[0]) ? PF(t, n, e) : function(e) {
                    return "object" == typeof e && !Array.isArray(e)
                }(n) ? KF(t, n, i, e) : BF(t, n, i), e && e.animations.push(r), r
            })(),
            VF = {
                some: 0,
                all: 1
            };

        function OF(e, t, {
            root: n,
            margin: i,
            amount: r = "some"
        } = {}) {
            const o = vU(e),
                s = new WeakMap,
                a = new IntersectionObserver((e => {
                    e.forEach((e => {
                        const n = s.get(e.target);
                        if (e.isIntersecting !== Boolean(n))
                            if (e.isIntersecting) {
                                const n = t(e);
                                "function" == typeof n ? s.set(e.target, n) : a.unobserve(e.target)
                            } else n && (n(e), s.delete(e.target))
                    }))
                }), {
                    root: n,
                    rootMargin: i,
                    threshold: "number" == typeof r ? r : VF[r]
                });
            return o.forEach((e => a.observe(e))), () => a.disconnect()
        }
        const NF = new WeakMap;
        let HF;

        function qF({
            target: e,
            contentRect: t,
            borderBoxSize: n
        }) {
            var i;
            null === (i = NF.get(e)) || void 0 === i || i.forEach((i => {
                i({
                    target: e,
                    contentSize: t,
                    get size() {
                        return function(e, t) {
                            if (t) {
                                const {
                                    inlineSize: e,
                                    blockSize: n
                                } = t[0];
                                return {
                                    width: e,
                                    height: n
                                }
                            }
                            return e instanceof SVGElement && "getBBox" in e ? e.getBBox() : {
                                width: e.offsetWidth,
                                height: e.offsetHeight
                            }
                        }(e, n)
                    }
                })
            }))
        }

        function jF(e) {
            e.forEach(qF)
        }

        function YF(e, t) {
            HF || "undefined" != typeof ResizeObserver && (HF = new ResizeObserver(jF));
            const n = vU(e);
            return n.forEach((e => {
                let n = NF.get(e);
                n || (n = new Set, NF.set(e, n)), n.add(t), null == HF || HF.observe(e)
            })), () => {
                n.forEach((e => {
                    const n = NF.get(e);
                    null == n || n.delete(t), (null == n ? void 0 : n.size) || null == HF || HF.unobserve(e)
                }))
            }
        }
        const JF = new Set;
        let WF;

        function zF(e) {
            return JF.add(e), WF || (WF = () => {
                const e = {
                        width: window.innerWidth,
                        height: window.innerHeight
                    },
                    t = {
                        target: window,
                        size: e,
                        contentSize: e
                    };
                JF.forEach((e => e(t)))
            }, window.addEventListener("resize", WF)), () => {
                JF.delete(e), !JF.size && WF && (WF = void 0)
            }
        }
        const XF = 50,
            ZF = () => ({
                time: 0,
                x: {
                    current: 0,
                    offset: [],
                    progress: 0,
                    scrollLength: 0,
                    targetOffset: 0,
                    targetLength: 0,
                    containerLength: 0,
                    velocity: 0
                },
                y: {
                    current: 0,
                    offset: [],
                    progress: 0,
                    scrollLength: 0,
                    targetOffset: 0,
                    targetLength: 0,
                    containerLength: 0,
                    velocity: 0
                }
            }),
            _F = {
                x: {
                    length: "Width",
                    position: "Left"
                },
                y: {
                    length: "Height",
                    position: "Top"
                }
            };

        function $F(e, t, n, i) {
            const r = n[t],
                {
                    length: o,
                    position: s
                } = _F[t],
                a = r.current,
                l = n.time;
            r.current = e["scroll" + s], r.scrollLength = e["scroll" + o] - e["client" + o], r.offset.length = 0, r.offset[0] = 0, r.offset[1] = r.scrollLength, r.progress = _R(0, r.scrollLength, r.current);
            const c = i - l;
            r.velocity = c > XF ? 0 : fR(r.current - a, c)
        }
        const eD = {
                Enter: [
                    [0, 1],
                    [1, 1]
                ],
                Exit: [
                    [0, 0],
                    [1, 0]
                ],
                Any: [
                    [1, 0],
                    [0, 1]
                ],
                All: [
                    [0, 0],
                    [1, 1]
                ]
            },
            tD = {
                start: 0,
                center: .5,
                end: 1
            };

        function nD(e, t, n = 0) {
            let i = 0;
            if (void 0 !== tD[e] && (e = tD[e]), "string" == typeof e) {
                const t = parseFloat(e);
                e.endsWith("px") ? i = t : e.endsWith("%") ? e = t / 100 : e.endsWith("vw") ? i = t / 100 * document.documentElement.clientWidth : e.endsWith("vh") ? i = t / 100 * document.documentElement.clientHeight : e = t
            }
            return "number" == typeof e && (i = t * e), n + i
        }
        const iD = [0, 0];

        function rD(e, t, n, i) {
            let r = Array.isArray(e) ? e : iD,
                o = 0,
                s = 0;
            return "number" == typeof e ? r = [e, e] : "string" == typeof e && (r = (e = e.trim()).includes(" ") ? e.split(" ") : [e, tD[e] ? e : "0"]), o = nD(r[0], n, i), s = nD(r[1], t), o - s
        }
        const oD = {
            x: 0,
            y: 0
        };

        function sD(e, t, n) {
            const {
                offset: i = eD.All
            } = n, {
                target: r = e,
                axis: o = "y"
            } = n, s = "y" === o ? "height" : "width", a = r !== e ? function(e, t) {
                const n = {
                    x: 0,
                    y: 0
                };
                let i = e;
                for (; i && i !== t;)
                    if (i instanceof HTMLElement) n.x += i.offsetLeft, n.y += i.offsetTop, i = i.offsetParent;
                    else if ("svg" === i.tagName) {
                    const e = i.getBoundingClientRect();
                    i = i.parentElement;
                    const t = i.getBoundingClientRect();
                    n.x += e.left - t.left, n.y += e.top - t.top
                } else {
                    if (!(i instanceof SVGGraphicsElement)) break; {
                        const {
                            x: e,
                            y: t
                        } = i.getBBox();
                        n.x += e, n.y += t;
                        let r = null,
                            o = i.parentNode;
                        for (; !r;) "svg" === o.tagName && (r = o), o = i.parentNode;
                        i = r
                    }
                }
                return n
            }(r, e) : oD, l = r === e ? {
                width: e.scrollWidth,
                height: e.scrollHeight
            } : function(e) {
                return "getBBox" in e && "svg" !== e.tagName ? e.getBBox() : {
                    width: e.clientWidth,
                    height: e.clientHeight
                }
            }(r), c = {
                width: e.clientWidth,
                height: e.clientHeight
            };
            t[o].offset.length = 0;
            let A = !t[o].interpolate;
            const h = i.length;
            for (let e = 0; e < h; e++) {
                const n = rD(i[e], c[s], l[s], a[o]);
                A || n === t[o].interpolatorOffsets[e] || (A = !0), t[o].offset[e] = n
            }
            A && (t[o].interpolate = uT(t[o].offset, pT(i)), t[o].interpolatorOffsets = [...t[o].offset]), t[o].progress = t[o].interpolate(t[o].current)
        }

        function aD(e, t, n, i = {}) {
            return {
                measure: () => function(e, t = e, n) {
                    if (n.x.targetOffset = 0, n.y.targetOffset = 0, t !== e) {
                        let i = t;
                        for (; i && i !== e;) n.x.targetOffset += i.offsetLeft, n.y.targetOffset += i.offsetTop, i = i.offsetParent
                    }
                    n.x.targetLength = t === e ? t.scrollWidth : t.clientWidth, n.y.targetLength = t === e ? t.scrollHeight : t.clientHeight, n.x.containerLength = e.clientWidth, n.y.containerLength = e.clientHeight
                }(e, i.target, n),
                update: t => {
                    ! function(e, t, n) {
                        $F(e, "x", t, n), $F(e, "y", t, n), t.time = n
                    }(e, n, t), (i.offset || i.target) && sD(e, n, i)
                },
                notify: () => t(n)
            }
        }
        const lD = new WeakMap,
            cD = new WeakMap,
            AD = new WeakMap,
            hD = e => e === document.documentElement ? window : e;

        function uD(e, {
            container: t = document.documentElement,
            ...n
        } = {}) {
            let i = AD.get(t);
            i || (i = new Set, AD.set(t, i));
            const r = ZF(),
                o = aD(t, e, r, n);
            if (i.add(o), !lD.has(t)) {
                const e = () => {
                        for (const e of i) e.measure()
                    },
                    n = () => {
                        for (const e of i) e.update(MU.timestamp)
                    },
                    r = () => {
                        for (const e of i) e.notify()
                    },
                    o = () => {
                        QU.read(e, !1, !0), QU.read(n, !1, !0), QU.update(r, !1, !0)
                    };
                lD.set(t, o);
                const s = hD(t);
                window.addEventListener("resize", o, {
                    passive: !0
                }), t !== document.documentElement && cD.set(t, function(e, t) {
                    return "function" == typeof e ? zF(e) : YF(e, t)
                }(t, o)), s.addEventListener("scroll", o, {
                    passive: !0
                })
            }
            const s = lD.get(t);
            return QU.read(s, !1, !0), () => {
                var e;
                UU(s);
                const n = AD.get(t);
                if (!n) return;
                if (n.delete(o), n.size) return;
                const i = lD.get(t);
                lD.delete(t), i && (hD(t).removeEventListener("scroll", i), null === (e = cD.get(t)) || void 0 === e || e(), window.removeEventListener("resize", i))
            }
        }
        const dD = new Map;

        function pD({
            source: e = document.documentElement,
            axis: t = "y"
        } = {}) {
            dD.has(e) || dD.set(e, {});
            const n = dD.get(e);
            return n[t] || (n[t] = DU() ? new ScrollTimeline({
                source: e,
                axis: t
            }) : function({
                source: e,
                axis: t = "y"
            }) {
                const n = {
                        value: 0
                    },
                    i = uD((e => {
                        n.value = 100 * e[t].progress
                    }), {
                        container: e,
                        axis: t
                    });
                return {
                    currentTime: n,
                    cancel: i
                }
            }({
                source: e,
                axis: t
            })), n[t]
        }
        var gD;
        ! function(e) {
            e.Initial = "initial", e.Entered = "entered", e.Exited = "exited"
        }(gD || (gD = {}));
        const fD = Object.values(b),
            mD = {
                lastScrollDirection: void 0
            };

        function ED(e) {
            return parseFloat((e / 1e3).toFixed(3))
        }

        function CD(e) {
            if (!e) return;
            const t = fD.find((t => t === e)) || b.Custom,
                n = function(e) {
                    return {
                        keyframe: mh(e),
                        transition: fh(B.Spring, I.ScrollAnimation)
                    }
                }(t),
                i = "object" == typeof e ? {
                    keyframe: Object.assign(Object.assign({}, n.keyframe), e.keyframe),
                    transition: Object.assign(Object.assign({}, n.transition), e.transition)
                } : n;
            return {
                keyframe: (o = i.keyframe, {
                    opacity: o.opacity,
                    scale: o.scale,
                    rotateX: o.rotateX,
                    rotateY: o.rotateY,
                    rotateZ: o.rotateZ,
                    x: o.offsetX,
                    y: o.offsetY
                }),
                transition: (r = i.transition, r.type === B.Spring ? {
                    type: "spring",
                    delay: ED(r.delay),
                    stiffness: r.stiffness,
                    damping: r.damping,
                    mass: r.mass
                } : {
                    type: "tween",
                    ease: r.type,
                    delay: ED(r.delay),
                    duration: ED(r.duration)
                })
            };
            var r, o
        }

        function ID(e) {
            if (!e.type) return;
            const t = function(e) {
                    return {
                        type: e,
                        direction: y.Down,
                        start: w.Top,
                        replay: !0,
                        clickThrough: !0
                    }
                }(e.type),
                n = Object.assign(Object.assign({}, t), e),
                i = n.type;
            if (i === x.OnAppear) {
                const e = CD(n.effectA);
                if (!e) return;
                return {
                    type: x.OnAppear,
                    effectA: e,
                    clickThrough: n.clickThrough
                }
            }
            if (i === x.OnScroll) {
                const e = CD(n.effectA);
                if (!e) return;
                return {
                    type: x.OnScroll,
                    direction: n.direction,
                    replay: n.replay,
                    effectA: e,
                    clickThrough: n.clickThrough
                }
            }
            if (i === x.ElementInView) {
                const e = CD(n.effectA),
                    t = CD(n.effectB);
                if (!e && !t) return;
                return {
                    type: x.ElementInView,
                    start: n.start,
                    replay: n.replay,
                    effectA: e,
                    effectB: t,
                    clickThrough: n.clickThrough
                }
            }
            if (i === x.SectionInView) {
                const e = dU(),
                    t = n.sectionId ? e.get(n.sectionId) : void 0;
                if (!t) return;
                const i = CD(n.effectA),
                    r = CD(n.effectB);
                if (!i && !r) return;
                return {
                    type: x.SectionInView,
                    section: t,
                    start: n.start,
                    replay: n.replay,
                    effectA: i,
                    effectB: r,
                    clickThrough: n.clickThrough
                }
            }
        }

        function SD(e) {
            const t = parseFloat(window.getComputedStyle(e).getPropertyValue("opacity")),
                n = e.style.transform;
            let i = 1,
                r = 1,
                o = 0,
                s = 0,
                a = 0,
                l = 0,
                c = 0;
            isNaN(t) || (i *= t);
            const A = n.match(/(scale|rotateX|rotateY|rotateZ|translateX|translateY)\((.*?)\)/g);
            return A && A.forEach((e => {
                const [t, n] = e.split("("), i = parseFloat(n);
                switch (t) {
                    case "scale":
                        r *= i;
                        break;
                    case "rotateX":
                        o += i;
                        break;
                    case "rotateY":
                        s += i;
                        break;
                    case "rotateZ":
                        a += i;
                        break;
                    case "translateX":
                        l += i;
                        break;
                    case "translateY":
                        c += i
                }
            })), {
                opacity: i,
                scale: r,
                rotateX: o,
                rotateY: s,
                rotateZ: a,
                x: l,
                y: c
            }
        }

        function vD(e, t) {
            const {
                animation: n,
                state: i
            } = e, {
                currentState: r
            } = i;
            switch (n.type) {
                case x.OnAppear:
                    if (t === gD.Entered) return {
                        keyframe: i.defaultKeyframe,
                        transition: n.effectA.transition
                    };
                    break;
                case x.OnScroll:
                    if (t === gD.Entered) return {
                        keyframe: n.effectA.keyframe,
                        transition: n.effectA.transition
                    };
                    if (t === gD.Initial) return {
                        keyframe: i.defaultKeyframe,
                        transition: n.effectA.transition
                    };
                    break;
                case x.ElementInView:
                case x.SectionInView:
                    {
                        const e = t === gD.Exited || r === gD.Exited ? n.effectB : n.effectA;
                        if (e) {
                            return {
                                keyframe: t === gD.Entered ? i.defaultKeyframe : e.keyframe,
                                transition: e.transition
                            }
                        }
                        break
                    }
            }
        }

        function BD(e) {
            const {
                state: t
            } = e, {
                currentState: n,
                desiredState: i
            } = t;
            if (n === i) return;
            const r = function(e, t) {
                const n = [gD.Initial, gD.Entered, gD.Exited],
                    i = n.indexOf(e),
                    r = n.indexOf(t);
                return r < i ? n[i - 1] : r > i ? n[i + 1] : e
            }(n, i);
            return n !== r ? {
                nextState: r,
                effect: vD(e, r)
            } : void 0
        }
        const xD = e => (t, n, i) => {
            e && n.opacity >= Number.EPSILON && (t.style.pointerEvents = "auto");
            const r = GF(t, n, i);
            return r.then((() => {
                e && n.opacity < Number.EPSILON && (t.style.pointerEvents = "none")
            })), r
        };

        function yD(e) {
            const {
                state: t
            } = e, n = BD(e);
            if (!n) return;
            const {
                nextState: i,
                effect: r
            } = n;
            if (!r) return t.currentState = i, t.animationInProgress = !1, void yD(e);
            t.animationInProgress = !0;
            const o = t.isFirstAnimation ? Object.assign(Object.assign({}, r.transition), {
                velocity: 0
            }) : r.transition;
            t.isFirstAnimation = !1;
            const {
                el: s
            } = t, {
                keyframe: a
            } = r;
            xD(e.animation.clickThrough)(s, a, o).then((() => {
                t.currentState = i, t.animationInProgress = !1, yD(e)
            }))
        }

        function wD(e) {
            const {
                state: t
            } = e;
            t.animationInProgress || yD(e)
        }

        function bD(e) {
            const {
                animation: t,
                state: n
            } = e, {
                el: i
            } = n;
            i.style.opacity = `${t.effectA.keyframe.opacity}`, xD(t.clickThrough)(i, t.effectA.keyframe, {
                duration: 0
            }), OF(i, (() => {
                n.desiredState = gD.Entered, wD(e)
            }))
        }

        function QD(e) {
            switch (e) {
                case w.Top:
                    return 0;
                case w.Center:
                    return .5;
                case w.Bottom:
                    return 1;
                default:
                    return .5
            }
        }

        function UD(e) {
            return (e.top + e.bottom) / 2
        }

        function MD(e) {
            const {
                animation: t,
                state: n
            } = e, {
                el: i
            } = n;
            t.effectA && (i.style.opacity = `${t.effectA.keyframe.opacity}`, xD(t.clickThrough)(i, t.effectA.keyframe, {
                duration: 0
            }));
            const r = OF(i, (i => {
                const o = UD(i.boundingClientRect);
                return t.effectA && !t.replay && r(), n.desiredState = gD.Entered, wD(e), i => {
                    t.replay || r();
                    const s = UD(i.boundingClientRect) <= o;
                    n.desiredState = s ? gD.Exited : gD.Initial, wD(e)
                }
            }), {
                amount: QD(t.start)
            })
        }

        function RD(e) {
            switch (e) {
                case w.Top:
                    return "0px 0px -100% 0px";
                case w.Center:
                    return "-50% 0px -50% 0px";
                case w.Bottom:
                    return "-100% 0px 0px 0px";
                default:
                    return "-50% 0px -50% 0px"
            }
        }

        function TD(e) {
            const {
                animation: t,
                state: n
            } = e, {
                el: i
            } = n;
            t.effectA && (i.style.opacity = `${t.effectA.keyframe.opacity}`, xD(t.clickThrough)(i, t.effectA.keyframe, {
                duration: 0
            }));
            const r = OF(t.section.el, (i => {
                const o = UD(i.boundingClientRect);
                return t.effectA && !t.replay && r(), n.desiredState = gD.Entered, wD(e), i => {
                    t.replay || r();
                    const s = UD(i.boundingClientRect) <= o;
                    n.desiredState = s ? gD.Exited : gD.Initial, wD(e)
                }
            }), {
                amount: "some",
                root: document,
                margin: RD(t.start)
            })
        }

        function FD(e, t) {
            e.effectA && (e.effectA.keyframe.opacity *= t.defaultKeyframe.opacity), e.type !== x.ElementInView && e.type !== x.SectionInView || e.effectB && (e.effectB.keyframe.opacity *= t.defaultKeyframe.opacity)
        }

        function DD(e) {
            const t = function(e) {
                    const t = new Map;
                    if (!e) return t;
                    const n = e.scrollAnimations || {};
                    return Object.entries(n).forEach((([e, n]) => {
                        if (!n) return;
                        const i = ID(n);
                        i && t.set(e, i)
                    })), t
                }(e),
                n = function(e) {
                    const t = new Map;
                    for (const [n] of e) {
                        const e = document.getElementById(n);
                        if (!e) continue;
                        const i = SD(e),
                            r = {
                                isFirstAnimation: !0,
                                animationInProgress: !1,
                                desiredState: gD.Initial,
                                currentState: gD.Initial,
                                el: e,
                                defaultKeyframe: i
                            };
                        t.set(n, r)
                    }
                    return t
                }(t),
                i = new Map;
            for (const [e, r] of t) {
                const t = n.get(e);
                if (t) switch (FD(r, t), r.type) {
                    case x.OnAppear:
                        bD({
                            animation: r,
                            state: t
                        });
                        break;
                    case x.OnScroll:
                        i.set(e, {
                            animation: r,
                            state: t
                        });
                        break;
                    case x.ElementInView:
                        MD({
                            animation: r,
                            state: t
                        });
                        break;
                    case x.SectionInView:
                        TD({
                            animation: r,
                            state: t
                        })
                }
            }
            let r;
            const o = function(e, t) {
                const n = pD(t);
                return "function" == typeof e ? TU(e, n) : e.attachTimeline(n)
            }((e => {
                const t = r;
                if (r = e, void 0 === t) return;
                const n = mD.lastScrollDirection;
                e > t ? mD.lastScrollDirection = y.Down : e < t && (mD.lastScrollDirection = y.Up), mD.lastScrollDirection && mD.lastScrollDirection !== n && function(e, t) {
                    const n = [];
                    for (const [i, r] of t) {
                        const {
                            animation: t,
                            state: o
                        } = r, s = t.direction === e, a = o.desiredState === gD.Initial;
                        s && a ? (o.desiredState = gD.Entered, wD(r), t.replay || n.push(i)) : s || a || (o.desiredState = gD.Initial, wD(r))
                    }
                    for (const e of n) t.delete(e)
                }(mD.lastScrollDirection, i)
            }));
            NQ((() => {
                o(), mD.lastScrollDirection = void 0
            }))
        }
        var kD = n(683),
            LD = function(e, t, n, i) {
                return new(n || (n = Promise))((function(r, o) {
                    function s(e) {
                        try {
                            l(i.next(e))
                        } catch (e) {
                            o(e)
                        }
                    }

                    function a(e) {
                        try {
                            l(i.throw(e))
                        } catch (e) {
                            o(e)
                        }
                    }

                    function l(e) {
                        var t;
                        e.done ? r(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                            e(t)
                        }))).then(s, a)
                    }
                    l((i = i.apply(e, t || [])).next())
                }))
            };
        let KD = {
            loadPromise: void 0,
            loadingDone: !1,
            audios: void 0,
            onLeavePauseAudios: [],
            tabFocus: !0,
            documentVisibility: !0,
            audioFadeOut: !1
        };

        function PD(e, t) {
            var n;
            const i = (null === (n = null == e ? void 0 : e.audio) || void 0 === n ? void 0 : n[t]) || {},
                r = function(e) {
                    return {
                        sourceType: e,
                        src: "",
                        autoplay: !1,
                        loop: !1,
                        progress: 0,
                        volume: .25,
                        onLeave: U.Pause
                    }
                }((null == i ? void 0 : i.sourceType) || Eh);
            return Object.assign(Object.assign({}, r), i)
        }

        function GD(e, t) {
            var n;
            const i = (null === (n = null == e ? void 0 : e.audioStyle) || void 0 === n ? void 0 : n[t]) || {},
                r = {
                    playCursor: Ih,
                    playIconType: Ch,
                    playIconColor: Sh,
                    iconPlayUrl: "",
                    iconPauseUrl: ""
                };
            return Object.assign(Object.assign({}, r), i)
        }

        function VD(e) {
            var t, n;
            null === (t = e.iconDivEl) || void 0 === t || t.remove(), e.iconDivEl = void 0;
            const i = !!(null === (n = e.howl) || void 0 === n ? void 0 : n.playing());
            i && (e.playedOnce = !0);
            const r = i ? e.iconPauseBlobUrl : e.iconPlayBlobUrl;
            if (!r) return;
            const o = yh(r, e.style);
            e.el.prepend(o), e.iconDivEl = o
        }

        function OD(e) {
            var t, n;
            !!(null === (t = e.howl) || void 0 === t ? void 0 : t.playing()) || null === (n = e.howl) || void 0 === n || n.play()
        }

        function ND(e) {
            return LD(this, void 0, void 0, (function*() {
                e.iconPlayBlobUrl = yield Su(Bh(e.style))
            }))
        }

        function HD(e) {
            return LD(this, void 0, void 0, (function*() {
                e.iconPauseBlobUrl = yield Su(xh(e.style))
            }))
        }

        function qD(e) {
            return LD(this, void 0, void 0, (function*() {
                const t = function(e) {
                    const t = new Map,
                        n = document.getElementsByClassName("pwb-audio");
                    for (let i = 0; i < n.length; i++) {
                        const r = n[i].id;
                        if (!r) continue;
                        const o = document.getElementById(r);
                        o && t.set(r, {
                            el: o,
                            attrs: PD(e, r),
                            style: GD(e, r),
                            playedOnce: !1,
                            isUnlocked: !1,
                            wasFadedOut: !1,
                            wasPausedByFadeOut: !1
                        })
                    }
                    return t
                }(e);
                KD.audios = t;
                const n = [];
                Array.from(t.values()).forEach((e => {
                    n.push(function(e) {
                        return LD(this, void 0, void 0, (function*() {
                            yield Promise.all([ND(e), HD(e)])
                        }))
                    }(e))
                })), yield Promise.all(n), KD.loadingDone = !0
            }))
        }

        function jD(e) {
            return LD(this, void 0, void 0, (function*() {
                KD.loadPromise || (KD.loadPromise = qD(e)), yield KD.loadPromise
            }))
        }

        function YD(e) {
            if (!e) return;
            const t = function(e) {
                e = ah(e), e = new URL(e).pathname;
                const t = (e = (e = oh(e, "/")).substring(e.lastIndexOf("/") + 1)).lastIndexOf(".");
                return t < 0 ? "" : e.substring(t + 1)
            }(e).toLowerCase();
            return ["mp3", "opus", "ogg", "wav", "aac", "m4a", "m4b", "mp4", "webm"].includes(t) ? [t] : void 0
        }

        function JD(e) {
            var t, n;
            if (VD(e), !e.playedOnce) {
                if (e.attrs.progress > 0) {
                    const i = ((null === (t = e.howl) || void 0 === t ? void 0 : t.duration()) || 0) * e.attrs.progress;
                    null === (n = e.howl) || void 0 === n || n.seek(i)
                }
                e.attrs.autoplay && OD(e)
            }
        }

        function WD(t) {
            if (VD(t), t.attrs.src) {
                const e = new kD.Howl({
                    src: [t.attrs.src],
                    format: YD(t.attrs.src),
                    html5: !0,
                    loop: t.attrs.loop,
                    volume: t.attrs.volume,
                    onplay: () => VD(t),
                    onplayerror: () => VD(t),
                    onend: () => VD(t),
                    onpause: () => VD(t),
                    onstop: () => VD(t),
                    onload: () => {
                        JD(t)
                    },
                    onunlock: () => {
                        JD(t), t.isUnlocked = !0
                    },
                    onfade: () => {
                        var e, n, i;
                        const r = (null === (e = t.howl) || void 0 === e ? void 0 : e.volume()) || 0,
                            o = !!(null === (n = t.howl) || void 0 === n ? void 0 : n.playing());
                        r <= 0 && o && t.wasFadedOut && (t.wasPausedByFadeOut = !0, null === (i = t.howl) || void 0 === i || i.pause())
                    }
                });
                t.howl = e, t.attrs.onLeave === U.Pause && KD.onLeavePauseAudios.push(t)
            }
            const n = function(e) {
                    return t => {
                        var n, i;
                        ph(t), gh(t), (!e.attrs.autoplay || e.playedOnce) && ((null === (n = e.howl) || void 0 === n ? void 0 : n.playing()) ? null === (i = e.howl) || void 0 === i || i.pause() : OD(e))
                    }
                }(t),
                {
                    el: i
                } = t;
            t.style.playCursor === e.Pointer && (i.style.cursor = "pointer"), i.addEventListener("click", n)
        }

        function zD() {
            const e = !KD.documentVisibility;
            if (KD.audioFadeOut !== e)
                if (KD.audioFadeOut = e, KD.audioFadeOut)
                    for (const e of KD.onLeavePauseAudios) {
                        e.wasFadedOut = !1, e.wasPausedByFadeOut = !1;
                        const t = e.howl;
                        if (!t) continue;
                        t.playing() && (e.wasFadedOut = !0, t.fade(t.volume(), 0, 1e3))
                    } else
                        for (const e of KD.onLeavePauseAudios) {
                            if (!e.wasFadedOut) continue;
                            e.wasFadedOut = !1;
                            const t = e.howl;
                            t && (t.fade(t.volume(), e.attrs.volume, 1e3), e.wasPausedByFadeOut && OD(e))
                        }
        }

        function XD(e) {
            KD.tabFocus = e, zD()
        }

        function ZD(e, t) {
            if (!e.id) return;
            const {
                audios: n
            } = KD;
            if (!n) return;
            const i = n.get(e.id);
            if (!i) return;
            if (!i.howl) return;
            if (!i.isUnlocked && t !== K.MouseClick) return;
            if (e.event !== k.Pause && e.event !== k.Stop || (i.attrs.autoplay = !1), i.attrs.autoplay && !i.playedOnce) return;
            const r = !!i.howl.playing(),
                o = function(e, t) {
                    return e === k.TogglePlayPause ? t ? k.Pause : k.Play : e === k.TogglePlayStop ? t ? k.Stop : k.Play : e
                }(e.event, r);
            r ? o === k.Pause ? i.howl.pause() : o === k.Stop && i.howl.stop() : o === k.Play ? i.howl.play() : o === k.Stop && i.howl.stop()
        }

        function _D() {
            const {
                loadingDone: e,
                audios: t
            } = KD;
            if (!e || !t) throw new Error("UIAudioModule needs to be loaded before it can be initialized.");
            Array.from(t.values()).forEach((e => {
                WD(e)
            }));
            const n = () => XD(!0),
                i = () => XD(!1);
            window.addEventListener("focus", n), window.addEventListener("blur", i), XD(!!document.hasFocus());
            const r = () => {
                return e = !document.hidden, KD.documentVisibility = e, void zD();
                var e
            };
            document.addEventListener("visibilitychange", r), r(), oU(D.UIAudio, ZD);
            NQ((() => {
                var e;
                sU(D.UIAudio, ZD), document.removeEventListener("visibilitychange", r), window.removeEventListener("blur", i), window.removeEventListener("focus", n);
                const t = Array.from(KD.audios ? KD.audios.values() : []);
                for (const n of t) null === (e = n.howl) || void 0 === e || e.unload();
                KD = {
                    loadPromise: void 0,
                    loadingDone: !1,
                    audios: void 0,
                    onLeavePauseAudios: [],
                    tabFocus: !0,
                    documentVisibility: !0,
                    audioFadeOut: !1
                }
            }))
        }
        const $D = function(e, t, n) {
            var i = !0,
                r = !0;
            if ("function" != typeof e) throw new TypeError("Expected a function");
            return Du(n) && (i = "leading" in n ? !!n.leading : i, r = "trailing" in n ? !!n.trailing : r), Im(e, t, {
                leading: i,
                maxWait: t,
                trailing: r
            })
        };
        var ek, tk, nk = function(e, t, n, i) {
            return new(n || (n = Promise))((function(r, o) {
                function s(e) {
                    try {
                        l(i.next(e))
                    } catch (e) {
                        o(e)
                    }
                }

                function a(e) {
                    try {
                        l(i.throw(e))
                    } catch (e) {
                        o(e)
                    }
                }

                function l(e) {
                    var t;
                    e.done ? r(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(s, a)
                }
                l((i = i.apply(e, t || [])).next())
            }))
        };
        ! function(e) {
            e.Relative = "relative", e.Fixed = "fixed"
        }(ek || (ek = {})),
        function(e) {
            e.Closed = "closed", e.Open = "open"
        }(tk || (tk = {}));
        const ik = {
                [tk.Closed]: tk.Open,
                [tk.Open]: tk.Closed
            },
            rk = {
                overlays: new Map
            };

        function ok(e) {
            const t = [];
            if (!e) return t;
            const n = e[V.RelativeOverlays] || {};
            return Object.entries(n).forEach((([e, n]) => {
                if (!n) return;
                const i = document.getElementById(e);
                if (!i) return;
                const r = {
                        position: R.Bottom,
                        align: T.Center,
                        offsetOrthogonal: 8,
                        offsetParallel: 0,
                        dismissType: F.Auto
                    },
                    o = Object.assign(Object.assign({}, r), n);
                t.push({
                    id: e,
                    el: i,
                    type: ek.Relative,
                    desiredState: tk.Closed,
                    currentState: tk.Closed,
                    isAnimating: !1,
                    isDisposed: !1,
                    overlay: o
                })
            })), t
        }

        function sk(e) {
            return [{
                x: e.left,
                y: e.top
            }, {
                x: e.right,
                y: e.top
            }, {
                x: e.right,
                y: e.bottom
            }, {
                x: e.left,
                y: e.bottom
            }]
        }

        function ak(e) {
            const {
                el: t
            } = e, n = t.parentElement;
            if (!n) return;
            const i = $D((i => {
                    const o = function(e) {
                        if (e.length < 3) return;
                        const t = [];
                        let n = 0;
                        for (let t = 1; t < e.length; t++)(e[t].x < e[n].x || e[t].x === e[n].x && e[t].y < e[n].y) && (n = t);
                        let i, r = n;
                        do {
                            t.push(e[r]), i = (r + 1) % e.length;
                            for (let t = 0; t < e.length; t++) {
                                const n = Ah(e[r], e[t], e[i]);
                                (2 == n || 0 == n && hh(e[r], e[t]) > hh(e[r], e[i])) && (i = t)
                            }
                            r = i
                        } while (r != n);
                        return t
                    }([...sk(t.getBoundingClientRect()), ...sk(n.getBoundingClientRect())]);
                    if (!o) return;
                    dh({
                        x: i.clientX,
                        y: i.clientY
                    }, o) || (e.desiredState = tk.Closed, uk(e), r())
                }), 200, {
                    leading: !0,
                    trailing: !0
                }),
                r = () => {
                    document.removeEventListener("mousemove", i), e.disposeMouseMoveListenerCb = void 0
                };
            return document.addEventListener("mousemove", i), r
        }

        function lk(e, t) {
            return !!t && (!!t.classList.contains(e) || lk(e, t.parentElement))
        }

        function ck(e) {
            const {
                el: t
            } = e, n = t.parentElement;
            if (!n) return;
            const i = cU(e.id),
                r = () => {
                    e.desiredState = tk.Closed, uk(e), a()
                },
                o = e => {
                    const t = e.target;
                    n.contains(t) || lk(i, t) || r()
                },
                s = e => {
                    "Escape" !== e.key && "Esc" !== e.key || r()
                },
                a = () => {
                    document.removeEventListener("mousedown", o), document.removeEventListener("touchstart", o), document.removeEventListener("keydown", s), e.disposeClickAwayListenerCb = void 0
                };
            return document.addEventListener("mousedown", o), document.addEventListener("touchstart", o), document.addEventListener("keydown", s), a
        }

        function Ak(e) {
            var t, n;
            null === (t = e.disposeMouseMoveListenerCb) || void 0 === t || t.call(e), null === (n = e.disposeClickAwayListenerCb) || void 0 === n || n.call(e)
        }

        function hk(e) {
            return nk(this, void 0, void 0, (function*() {
                e.isAnimating = !0;
                const {
                    el: t,
                    desiredState: n
                } = e;
                n === tk.Open ? (t.style.display = "block", e.type === ek.Relative && function(e) {
                    var t, n;
                    e.overlay.dismissType === F.Auto && (null === (t = e.disposeMouseMoveListenerCb) || void 0 === t || t.call(e), e.disposeMouseMoveListenerCb = ak(e)), [F.Auto, F.Click].includes(e.overlay.dismissType) && (null === (n = e.disposeClickAwayListenerCb) || void 0 === n || n.call(e), e.disposeClickAwayListenerCb = ck(e))
                }(e), yield GF(t, {
                    opacity: 1
                }, {
                    type: "tween",
                    ease: v.EaseInOut,
                    delay: 0,
                    duration: .3
                }), e.currentState = tk.Open) : (e.type === ek.Relative && Ak(e), yield GF(t, {
                    opacity: 0
                }, {
                    type: "tween",
                    ease: v.EaseInOut,
                    delay: 0,
                    duration: .3
                }), t.style.display = "none", e.currentState = tk.Closed), e.isAnimating = !1, uk(e)
            }))
        }

        function uk(e) {
            e.isAnimating || e.isDisposed || e.desiredState !== e.currentState && hk(e)
        }

        function dk(e) {
            const {
                el: t,
                overlay: n
            } = e;
            t.style.display = "none", t.style.opacity = "0",
                function(e, t) {
                    const n = bh(t);
                    for (const [t, i] of Object.entries(n)) e.style[t] = i
                }(t, n);
            const i = t.parentElement;
            i && (i.style.cursor = "pointer", t.style.cursor || (t.style.cursor = "auto"), i.addEventListener("click", (t => {
                ph(t), gh(t), e.desiredState = tk.Open, uk(e)
            })), rk.overlays.set(e.id, e))
        }

        function pk(e) {
            const {
                overlays: t
            } = rk, n = t.get(e.id);
            if (n) {
                switch (e.event) {
                    case L.Open:
                        n.desiredState = tk.Open;
                        break;
                    case L.Close:
                        n.desiredState = tk.Closed;
                        break;
                    case L.ToggleOpenClose:
                        n.desiredState = ik[n.desiredState]
                }
                uk(n)
            }
        }

        function gk(e) {
            $Q(), pU(e), hU(e),
                function(e) {
                    const t = ok(e);
                    for (const e of t) dk(e);
                    oU(D.UIOverlay, pk), NQ((() => {
                        sU(D.UIOverlay, pk);
                        const e = Array.from(rk.overlays.values());
                        for (const t of e) t.isDisposed = !0, t.type === ek.Relative && Ak(t);
                        rk.overlays = new Map
                    }))
                }(e),
                function(e) {
                    const t = dU(),
                        n = gU(e, t);
                    for (const [e, t] of n) {
                        const n = document.getElementById(e);
                        if (!n) continue;
                        const i = t.type === P.External ? fU(t) : mU(t);
                        n.style.cursor = "pointer", n.addEventListener("click", i)
                    }
                    EU(t)
                }(e), DD(e), _D()
        }

        function fk(e) {
            const t = document.getElementById(jh);
            t.replaceWith(...t.childNodes);
            document.querySelector(`div#${qh}`).remove(), gk(e)
        }
        var mk = function(e, t, n, i) {
            return new(n || (n = Promise))((function(r, o) {
                function s(e) {
                    try {
                        l(i.next(e))
                    } catch (e) {
                        o(e)
                    }
                }

                function a(e) {
                    try {
                        l(i.throw(e))
                    } catch (e) {
                        o(e)
                    }
                }

                function l(e) {
                    var t;
                    e.done ? r(e.value) : (t = e.value, t instanceof n ? t : new n((function(e) {
                        e(t)
                    }))).then(s, a)
                }
                l((i = i.apply(e, t || [])).next())
            }))
        };
        const Ek = {
            isInitialized: !1,
            isNavigating: !1,
            styleLoadedPaths: new Set
        };

        function Ck(e, t, n = !1) {
            Ek.currentPath = e, Ek.currentSectionHash = t || void 0, n || Eu || history.pushState({}, "", `${e}${t?`#${t}`:""}`)
        }

        function Ik() {
            return mk(this, void 0, void 0, (function*() {
                try {
                    const [e, t] = yield Promise.all([Uu(), Mu()]), n = (new DOMParser).parseFromString(e, "text/html"), i = n.getElementById(Yh);
                    if (!i) throw new Error("Error page wrap not found.");
                    HQ(), document.body.replaceChildren(i), document.title = n.title, Array.from(document.body.attributes).forEach((e => {
                        document.body.removeAttribute(e.name)
                    }));
                    const r = document.createElement("style");
                    r.textContent = t, document.head.append(r)
                } catch (e) {
                    console.error("Load error page error:", e)
                }
            }))
        }

        function Sk(e, t, n) {
            const {
                isInitialized: i,
                isNavigating: r
            } = Ek;
            i && !r ? (Ek.isNavigating = !0, Ck(e, t, n), function() {
                return mk(this, void 0, void 0, (function*() {
                    const e = Ek.currentPath;
                    if (!e) return;
                    const [t, n, i, {
                        engineState: r,
                        animations: o
                    }] = yield Promise.all([bu(e), Qu(e), wu(e), yu()]);
                    HQ();
                    const s = (new DOMParser).parseFromString(t, "text/html"),
                        a = s.getElementById(jh);
                    if (!a) throw new Error("Failed loading a new page: page body wrap not found.");
                    const l = s.getElementById(qh);
                    if (!l) throw new Error("Failed loading a new page: page loading wrap not found.");
                    if (document.body.replaceChildren(a, l), document.title = s.title, window._pwExecLoadingPageJavascript(), Array.from(document.body.attributes).forEach((e => {
                            document.body.removeAttribute(e.name)
                        })), Array.from(s.body.attributes).forEach((e => {
                            document.body.setAttribute(e.name, e.value)
                        })), !Ek.styleLoadedPaths.has(e)) {
                        Ek.styleLoadedPaths.add(e);
                        const t = document.createElement("style");
                        t.textContent = n, document.head.append(t)
                    }
                    const c = jD(i);
                    yield nU(r, i), iU(o), yield c, fk(i)
                }))
            }().then((() => {
                Ek.isNavigating = !1, vk()
            })).catch((e => {
                console.error("Router navigation error:", e), Ik().finally((() => {
                    Ek.isNavigating = !1, vk()
                }))
            }))) : Ek.nextNavigateTo = {
                path: e,
                sectionHash: t,
                omitHistoryPush: n
            }
        }

        function vk() {
            if (!Ek.nextNavigateTo) return;
            const {
                path: e,
                sectionHash: t
            } = Ek.nextNavigateTo;
            Ek.nextNavigateTo = void 0, Sk(e, t)
        }

        function Bk() {
            const e = mu,
                t = rh(window.location.hash, "#"),
                n = document.location.search || "";
            Eu || history.replaceState({}, "", `${e}${t?`#${t}`:""}${n}`), Ck(e, t, !0),
                function() {
                    return mk(this, void 0, void 0, (function*() {
                        const e = Ek.currentPath;
                        if (!e) return;
                        Ek.styleLoadedPaths.add(e);
                        const t = yu(),
                            n = wu(e),
                            i = yield n, {
                                engineState: r,
                                animations: o
                            } = yield t, s = jD(i), a = nU(r, i);
                        yield Promise.all([s, a]), iU(o), fk(i)
                    }))
                }().then((() => {
                    Ek.isInitialized = !0, vk()
                })).catch((e => {
                    console.error("Router initialization error:", e), Ik().finally((() => {
                        Ek.isInitialized = !0, vk()
                    }))
                })), window.addEventListener("popstate", (() => {
                    Sk(window.location.pathname, rh(window.location.hash, "#"), !0)
                }))
        }
        $Q(), requestAnimationFrame((function e(t) {
            var n;
            null === (n = XQ.val) || void 0 === n || n.raf(t), requestAnimationFrame(e)
        }));
        window._pwIsInitialized ? console.warn("The client app was initialized more than once!") : (window._pwIsInitialized = !0, Eu && (() => {
            const e = n => {
                const r = n.data;
                if (r.type === i.WebsitePreviewData) {
                    const n = r.previewPages.find((e => e.path === mu));
                    if (n) {
                        const e = document.createElement("style");
                        document.head.append(e), e.textContent = n.css
                    }
                    vu(`/${t.SceneState}`, new Blob([JSON.stringify(r.previewSceneState)], {
                        type: "application/json"
                    }));
                    for (const e of r.previewPages) {
                        const n = sh(e.path);
                        vu(`${n}${t.Index}`, new Blob([e.html], {
                            type: "text/html"
                        })), vu(`${n}${t.Styles}`, new Blob([e.css], {
                            type: "text/css"
                        })), vu(`${n}${t.UIState}`, new Blob([JSON.stringify(e.uiState)], {
                            type: "application/json"
                        }))
                    }
                    window.removeEventListener("message", e)
                }
            };
            window.addEventListener("message", e)
        })(), Bk())
    })()
})();